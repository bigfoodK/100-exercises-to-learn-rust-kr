msgid ""
msgstr ""
"Project-Id-Version: 100 Exercises To Learn Rust\n"
"POT-Creation-Date: 2024-06-20T21:50:15+09:00\n"
"PO-Revision-Date: 2024-06-22 07:07+0900\n"
"Last-Translator: bigfood <satcom1600@hanmail.net>\n"
"Language-Team: Korean <translation-team-ko@googlegroups.com>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.4\n"

#: src/SUMMARY.md:1 src/02_basic_calculator/01_integers.md:44
msgid "Summary"
msgstr "ìš”ì•½"

#: src/SUMMARY.md:3 src/01_intro/00_welcome.md:1
msgid "Welcome"
msgstr "í™˜ì˜í•©ë‹ˆë‹¤"

#: src/SUMMARY.md:4 src/01_intro/01_syntax.md:1
#: src/03_ticket_v1/06_ownership.md:181
msgid "Syntax"
msgstr "ë¬¸ë²•"

#: src/SUMMARY.md:6 src/02_basic_calculator/00_intro.md:1
msgid "A Basic Calculator"
msgstr "ê°„ë‹¨í•œ ê³„ì‚°ê¸°"

#: src/SUMMARY.md:7 src/02_basic_calculator/01_integers.md:13
msgid "Integers"
msgstr "ì •ìˆ˜"

#: src/SUMMARY.md:8 src/02_basic_calculator/02_variables.md:1
msgid "Variables"
msgstr "ë³€ìˆ˜"

#: src/SUMMARY.md:9
msgid "Branching: `if`/`else`"
msgstr "ë¶„ê¸°: `if`/`else`"

#: src/SUMMARY.md:10 src/02_basic_calculator/00_intro.md:12
#: src/02_basic_calculator/04_panics.md:1
msgid "Panics"
msgstr "íŒ¨ë‹‰"

#: src/SUMMARY.md:11 src/02_basic_calculator/05_factorial.md:1
msgid "Factorial"
msgstr "íŒ©í† ë¦¬ì–¼"

#: src/SUMMARY.md:12
msgid "Loops: `while`"
msgstr "ë£¨í”„: `while`"

#: src/SUMMARY.md:13
msgid "Loops: `for`"
msgstr "ë£¨í”„: `for`"

#: src/SUMMARY.md:14
msgid "Overflow and underflow"
msgstr "ì˜¤ë²„í”Œë¡œìš°ì™€ ì–¸ë”í”Œë¡œìš°"

#: src/SUMMARY.md:15
msgid "Saturating arithmetic"
msgstr "í¬í™” ì‚°ìˆ "

#: src/SUMMARY.md:16
msgid "Conversions: `as` casting"
msgstr "ë³€í™˜: `as` ìºìŠ¤íŒ…"

#: src/SUMMARY.md:18
msgid "Ticket v1"
msgstr "Ticket v1"

#: src/SUMMARY.md:19 src/03_ticket_v1/01_struct.md:1
msgid "Structs"
msgstr "êµ¬ì¡°ì²´"

#: src/SUMMARY.md:20 src/03_ticket_v1/02_validation.md:1
msgid "Validation"
msgstr "í™•ì¸"

#: src/SUMMARY.md:21 src/03_ticket_v1/03_modules.md:1
msgid "Modules"
msgstr "ëª¨ë“ˆ"

#: src/SUMMARY.md:22 src/03_ticket_v1/04_visibility.md:1
msgid "Visibility"
msgstr "ê°€ì‹œì„±"

#: src/SUMMARY.md:23 src/03_ticket_v1/05_encapsulation.md:1
msgid "Encapsulation"
msgstr "ìº¡ìŠí™”"

#: src/SUMMARY.md:24 src/03_ticket_v1/06_ownership.md:1
msgid "Ownership"
msgstr "ì†Œìœ ê¶Œ"

#: src/SUMMARY.md:25 src/03_ticket_v1/07_setters.md:25
msgid "Setters"
msgstr "ì„¤ì •ì(Setters)"

#: src/SUMMARY.md:26 src/03_ticket_v1/08_stack.md:13
msgid "Stack"
msgstr "ìŠ¤íƒ"

#: src/SUMMARY.md:27 src/03_ticket_v1/09_heap.md:1
msgid "Heap"
msgstr "í™"

#: src/SUMMARY.md:28
msgid "References in memory"
msgstr "ë©”ëª¨ë¦¬ ì°¸ì¡°"

#: src/SUMMARY.md:29 src/03_ticket_v1/11_destructor.md:1
#: src/03_ticket_v1/11_destructor.md:39
msgid "Destructors"
msgstr "ì†Œë©¸ì(Destructors)"

#: src/SUMMARY.md:30 src/SUMMARY.md:46 src/SUMMARY.md:63 src/SUMMARY.md:107
#: src/08_futures/08_outro.md:1
msgid "Outro"
msgstr "ë§ˆë¬´ë¦¬"

#: src/SUMMARY.md:32 src/04_traits/00_intro.md:1 src/04_traits/01_trait.md:1
msgid "Traits"
msgstr "íŠ¸ë ˆì‡"

#: src/SUMMARY.md:33 src/04_traits/03_operator_overloading.md:35
msgid "Trait"
msgstr "íŠ¸ë ˆì‡"

#: src/SUMMARY.md:34 src/04_traits/02_orphan_rule.md:86
msgid "Orphan rule"
msgstr "ê³ ì•„ ê·œì¹™(Orphan rule)"

#: src/SUMMARY.md:35 src/04_traits/03_operator_overloading.md:1
msgid "Operator overloading"
msgstr "ì—°ì‚°ì ì˜¤ë²„ë¡œë”©"

#: src/SUMMARY.md:36 src/04_traits/04_derive.md:1 src/04_traits/04_derive.md:69
msgid "Derive macros"
msgstr "íŒŒìƒ(Derive) ë§¤í¬ë¡œ"

#: src/SUMMARY.md:37 src/04_traits/05_trait_bounds.md:1
#: src/04_traits/05_trait_bounds.md:81
msgid "Trait bounds"
msgstr "íŠ¸ë ˆì‡ ë°”ìš´ë“œ"

#: src/SUMMARY.md:38 src/04_traits/06_str_slice.md:1
#: src/04_traits/06_str_slice.md:67
msgid "String slices"
msgstr "ë¬¸ìì—´ ìŠ¬ë¼ì´ìŠ¤"

#: src/SUMMARY.md:39 src/04_traits/07_deref.md:1
msgid "`Deref` trait"
msgstr "`Deref` íŠ¸ë ˆì‡"

#: src/SUMMARY.md:40
msgid "`Sized` trait"
msgstr "`Sized` íŠ¸ë ˆì‡"

#: src/SUMMARY.md:41
msgid "`From` trait"
msgstr "`From` íŠ¸ë ˆì‡"

#: src/SUMMARY.md:42
msgid "Associated vs generic types"
msgstr "ì—°ê´€ vs ì œë„¤ë¦­ íƒ€ì…"

#: src/SUMMARY.md:43
msgid "`Clone` trait"
msgstr "`Clone` íŠ¸ë ˆì‡"

#: src/SUMMARY.md:44
msgid "`Copy` trait"
msgstr "`Copy` íŠ¸ë ˆì‡"

#: src/SUMMARY.md:45
msgid "`Drop` trait"
msgstr "`Drop` íŠ¸ë ˆì‡"

#: src/SUMMARY.md:48
msgid "Ticket v2"
msgstr "Ticket v2"

#: src/SUMMARY.md:49
msgid "Enums"
msgstr "ì—´ê±°í˜•(Enums)"

#: src/SUMMARY.md:50
msgid "Branching: `match`"
msgstr "ë¶„ê¸°: `match`"

#: src/SUMMARY.md:51
msgid "Variants with data"
msgstr "ë°ì´í„°ë¥¼ ê°€ì§„ ë°°ë¦¬ì–¸íŠ¸"

#: src/SUMMARY.md:52
msgid "Branching: `if let` and `let/else`"
msgstr "ë¶„ê¸°: `if let` ê³¼ `let/else`"

#: src/SUMMARY.md:53 src/05_ticket_v2/05_nullability.md:1
msgid "Nullability"
msgstr "Null ê°€ëŠ¥ì„±(Nullability)"

#: src/SUMMARY.md:54 src/05_ticket_v2/06_fallibility.md:1
msgid "Fallibility"
msgstr "ì‹¤íŒ¨ ê°€ëŠ¥ì„±(Fallibility)"

#: src/SUMMARY.md:55
msgid "Unwrap"
msgstr "Unwrap"

#: src/SUMMARY.md:56 src/05_ticket_v2/08_error_enums.md:1
msgid "Error enums"
msgstr "Error ì—´ê±°í˜•"

#: src/SUMMARY.md:57
msgid "`Error` trait"
msgstr "`Error` íŠ¸ë ˆì‡"

#: src/SUMMARY.md:58
msgid "Packages"
msgstr "íŒ¨í‚¤ì§€"

#: src/SUMMARY.md:59 src/05_ticket_v2/11_dependencies.md:1
msgid "Dependencies"
msgstr "ë””íœë˜ì‹œ"

#: src/SUMMARY.md:60 src/05_ticket_v2/12_thiserror.md:1
msgid "`thiserror`"
msgstr "`thiserror`"

#: src/SUMMARY.md:61
msgid "`TryFrom` trait"
msgstr "`TryFrom` íŠ¸ë ˆì‡"

#: src/SUMMARY.md:62 src/05_ticket_v2/14_source.md:1
msgid "`Error::source`"
msgstr "`Error::source`"

#: src/SUMMARY.md:65
msgid "Ticket Management"
msgstr "í‹°ì¼“ ê´€ë¦¬"

#: src/SUMMARY.md:66 src/06_ticket_management/01_arrays.md:1
#: src/06_ticket_management/01_arrays.md:9
msgid "Arrays"
msgstr "ë°°ì—´"

#: src/SUMMARY.md:67 src/06_ticket_management/02_vec.md:1
msgid "Vectors"
msgstr "ë²¡í„°"

#: src/SUMMARY.md:68 src/06_ticket_management/03_resizing.md:1
msgid "Resizing"
msgstr "ë¦¬ì‚¬ì´ì§•"

#: src/SUMMARY.md:69
msgid "Iterators"
msgstr "ë°˜ë³µì"

#: src/SUMMARY.md:70
msgid "Iter"
msgstr "Iter"

#: src/SUMMARY.md:71 src/06_ticket_management/06_lifetimes.md:1
msgid "Lifetimes"
msgstr "ìˆ˜ëª…"

#: src/SUMMARY.md:72 src/06_ticket_management/07_combinators.md:1
msgid "Combinators"
msgstr "ê²°í•©ì(Combinators)"

#: src/SUMMARY.md:73 src/06_ticket_management/08_impl_trait.md:1
#: src/06_ticket_management/08_impl_trait.md:35
msgid "`impl Trait`"
msgstr "`impl Trait`"

#: src/SUMMARY.md:74
msgid "`impl Trait`, pt.2"
msgstr "`impl Trait`, pt.2"

#: src/SUMMARY.md:75 src/06_ticket_management/10_slices.md:1
msgid "Slices"
msgstr "ìŠ¬ë¼ì´ìŠ¤"

#: src/SUMMARY.md:76 src/06_ticket_management/11_mutable_slices.md:1
msgid "Mutable slices"
msgstr "ë³€ê²½ ê°€ëŠ¥í•œ ìŠ¬ë¼ì´ìŠ¤"

#: src/SUMMARY.md:77
msgid "Two states"
msgstr "ë‘ ê°€ì§€ ìƒíƒœ"

#: src/SUMMARY.md:78
msgid "`Index` trait"
msgstr "`Index` íŠ¸ë ˆì‡"

#: src/SUMMARY.md:79
msgid "`IndexMut` trait"
msgstr "`IndexMut` íŠ¸ë ˆì‡"

#: src/SUMMARY.md:80 src/06_ticket_management/15_hashmap.md:1
msgid "`HashMap`"
msgstr "`HashMap`"

#: src/SUMMARY.md:81 src/06_ticket_management/16_btreemap.md:11
msgid "`BTreeMap`"
msgstr "`BTreeMap`"

#: src/SUMMARY.md:83 src/SUMMARY.md:84 src/07_threads/01_threads.md:1
msgid "Threads"
msgstr "ìŠ¤ë ˆë“œ"

#: src/SUMMARY.md:85 src/07_threads/02_static.md:54
msgid "`'static` lifetime"
msgstr "`'static` ìˆ˜ëª…"

#: src/SUMMARY.md:86
msgid "Leaking memory"
msgstr "ë©”ëª¨ë¦¬ ëˆ„ìˆ˜"

#: src/SUMMARY.md:87 src/07_threads/04_scoped_threads.md:1
msgid "Scoped threads"
msgstr "ë²”ìœ„ ìŠ¤ë ˆë“œ"

#: src/SUMMARY.md:88 src/07_threads/05_channels.md:1
#: src/07_threads/05_channels.md:31
msgid "Channels"
msgstr "ì±„ë„"

#: src/SUMMARY.md:89 src/07_threads/06_interior_mutability.md:1
msgid "Interior mutability"
msgstr "ë‚´ë¶€ ê°€ë³€ì„±(Interior mutability)"

#: src/SUMMARY.md:90
msgid "Ack pattern"
msgstr "Ack íŒ¨í„´"

#: src/SUMMARY.md:91
msgid "Client"
msgstr "í´ë¼ì´ì–¸íŠ¸"

#: src/SUMMARY.md:92 src/07_threads/09_bounded.md:13
msgid "Bounded channels"
msgstr "ì œí•œ ì±„ë„(Bounded channels)"

#: src/SUMMARY.md:93 src/07_threads/10_patch.md:19
msgid "Patching"
msgstr "íŒ¨ì¹˜"

#: src/SUMMARY.md:94
msgid "`Mutex`, `Send` and `Arc`"
msgstr "`Mutex`, `Send` ê·¸ë¦¬ê³  `Arc`"

#: src/SUMMARY.md:95
msgid "`RwLock`"
msgstr "`RwLock`"

#: src/SUMMARY.md:96
msgid "Without channels"
msgstr "ì±„ë„ ì—†ì´"

#: src/SUMMARY.md:97
msgid "`Sync` trait"
msgstr "`Sync` íŠ¸ë ˆì‡"

#: src/SUMMARY.md:99
msgid "Futures"
msgstr "Futures"

#: src/SUMMARY.md:100 src/08_futures/01_async_fn.md:1
msgid "Asynchronous functions"
msgstr "ë¹„ë™ê¸° í•¨ìˆ˜"

#: src/SUMMARY.md:101 src/08_futures/02_spawn.md:1
msgid "Spawning tasks"
msgstr "íƒœìŠ¤í¬ ë„ìš°ê¸°"

#: src/SUMMARY.md:102
msgid "Runtime"
msgstr "ëŸ°íƒ€ì„"

#: src/SUMMARY.md:103
msgid "Future trait"
msgstr "Future trait"

#: src/SUMMARY.md:104
msgid "Blocking the runtime"
msgstr "ëŸ°íƒ€ì„ ë¸”ë¡œí‚¹"

#: src/SUMMARY.md:105 src/08_futures/06_async_aware_primitives.md:1
msgid "Async-aware primitives"
msgstr "Async-aware ê¸°ë³¸ ìš”ì†Œ"

#: src/SUMMARY.md:106 src/08_futures/07_cancellation.md:1
msgid "Cancellation"
msgstr "ì·¨ì†Œ"

#: src/SUMMARY.md:109 src/going_further.md:16
msgid "Going further"
msgstr "ë” ë‚˜ì•„ê°€"

#: src/01_intro/00_welcome.md:3
msgid "Welcome to **\"100 Exercises To Learn Rust\"**!"
msgstr "**Rustë¥¼ ë°°ìš°ê¸° ìœ„í•œ 100ê°€ì§€ ì—°ìŠµ**ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!"

#: src/01_intro/00_welcome.md:5
msgid ""
"This course will teach you Rust's core concepts, one exercise at a time.  \n"
"You'll learn about Rust's syntax, its type system, its standard library, and "
"its ecosystem."
msgstr ""
"ì´ ì½”ìŠ¤ì—ì„œëŠ” Rustì˜ í•µì‹¬ ê°œë…ì„ í•œ ë²ˆì— í•˜ë‚˜ì”© ì—°ìŠµí•´ ë³¼ ê²ƒì…ë‹ˆë‹¤.  \n"
"Rustì˜ ë¬¸ë²•, Trait ì‹œìŠ¤í…œ, í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì™€ ìƒíƒœê³„ì— ëŒ€í•´ ë°°ìš°ê²Œ ë©ë‹ˆë‹¤."

#: src/01_intro/00_welcome.md:8
msgid ""
"We don't assume any prior knowledge of Rust, but we assume you know at least "
"another programming language. We also don't assume any prior knowledge of "
"systems programming or memory management. Those topics will be covered in the "
"course."
msgstr ""
"ìš°ë¦¬ëŠ” ë‹¹ì‹ ì´ Rustì— ëŒ€í•œ ì‚¬ì „ ì§€ì‹ì´ ì—†ì§€ë§Œ, ì ì–´ë„ ë‹¤ë¥¸ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ í•˜ë‚˜"
"ëŠ” ì•Œê³  ìˆë‹¤ê³  ê°€ì •í•©ë‹ˆë‹¤. ê·¸ë¦¬ê³  ì‹œìŠ¤í…œ í”„ë¡œê·¸ë˜ë°ì´ë‚˜ ë©”ëª¨ë¦¬ ê´€ë¦¬ì— ëŒ€í•œ ì‚¬"
"ì „ ì§€ì‹ì„ ê°€ì§€ê³ ìˆë‹¤ê³  ê°€ì •í•©ë‹ˆë‹¤. ì´ ì½”ìŠ¤ì—ì„œ ì•ì„  ì£¼ì œë“¤ì„ ë‹¤ë£¨ì–´ ë³¼ê²ƒì…ë‹ˆ"
"ë‹¤."

#: src/01_intro/00_welcome.md:13
msgid ""
"In other words, we'll be starting from scratch!  \n"
"You'll build up your Rust knowledge in small, manageable steps. By the end of "
"the course, you will have solved ~100 exercises, enough to feel comfortable "
"working on small to medium-sized Rust projects."
msgstr ""
"ì¦‰, ì²˜ìŒë¶€í„° ë‹¤ì‹œ ì‹œì‘í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤!  \n"
"ì‘ê³  ê´€ë¦¬ ê°€ëŠ¥í•œ ë‹¨ê³„ë¥¼ í†µí•´ Rust ì§€ì‹ì„ ìŒ“ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê³¼ì •ì´ ëë‚˜ë©´ ì¤‘ì†Œ "
"ê·œëª¨ì˜ Rust í”„ë¡œì íŠ¸ì—ì„œ í¸ì•ˆí•˜ê²Œ ì‘ì—…í•  ìˆ˜ ìˆì„ ë§Œí¼ ì•½ 100ê°œì˜ ì—°ìŠµ ë¬¸ì œë¥¼ "
"í’€ê²Œ ë©ë‹ˆë‹¤."

#: src/01_intro/00_welcome.md:18
msgid "Methodology"
msgstr "ë°©ë²•ë¡ "

#: src/01_intro/00_welcome.md:20
msgid ""
"This course is based on the \"learn by doing\" principle.  \n"
"It has been designed to be interactive and hands-on."
msgstr ""
"ì´ ê³¼ì •ì€ \"ì‹¤í–‰ì„ í†µí•´ í•™ìŠµ\" ì›ì¹™ì„ ê¸°ë°˜ìœ¼ë¡œ í•©ë‹ˆë‹¤.  \n"
"ëŒ€í™”í˜• ë° ì‹¤ìŠµí˜•ìœ¼ë¡œ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤."

#: src/01_intro/00_welcome.md:23
msgid ""
"[Mainmatter](https://mainmatter.com/rust-consulting/) developed this course "
"to be delivered in a classroom setting, over 4 days: each attendee advances "
"through the lessons at their own pace, with an experienced instructor "
"providing guidance, answering questions and diving deeper into the topics as "
"needed.  \n"
"If you're interested in attending one of our training sessions, or if you'd "
"like to bring this course to your company, please [get in touch](https://"
"mainmatter.com/contact/)."
msgstr ""
"[Mainmatter](https://mainmatter.com/rust-consulting/) ëŠ” 4ì¼ì— ê±¸ì¹œ êµìœ¡í™˜ê²½ì—"
"ì„œ ì œê³µë˜ë„ë¡ ì´ ì½”ìŠ¤ë¥¼ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤. ê° ì°¸ì„ìëŠ” ìì‹ ë§Œì˜ í˜ì´ìŠ¤ë¡œ, ìˆ™ë ¨ëœ ê°•"
"ì‚¬ì˜ ì§€ë„ë¥¼ ë°›ìœ¼ë©°, ì§ˆë¬¸ì— ë‹µí•˜ê³ , í•„ìš”ì— ë”°ë¼ ì£¼ì œì— ëŒ€í•´ ë” ê¹Šì´ íŒŒê³ ë“¤ë©° ìˆ˜"
"ì—…ì„ ì§„í–‰í•©ë‹ˆë‹¤.  \n"
"êµìœ¡ ì„¸ì…˜ì— ì°¸ì—¬í•˜ê³  ì‹¶ê±°ë‚˜ ì´ êµìœ¡ ê³¼ì •ì„ íšŒì‚¬ì— ë„ì…í•˜ê³  ì‹¶ë‹¤ë©´ ì—°ë½í•´ ì£¼ì„¸"
"ìš”."

#: src/01_intro/00_welcome.md:30
msgid ""
"You can also follow the course on your own, but we recommend you find a "
"friend or a mentor to help you along the way should you get stuck. You can "
"also find solutions to all exercises in the [`solutions` branch of the GitHub "
"repository](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/"
"solutions)."
msgstr ""
"ìŠ¤ìŠ¤ë¡œ ê³¼ì •ì„ ë”°ë¼ê°ˆ ìˆ˜ë„ ìˆì§€ë§Œ, ë§‰íˆëŠ” ê²½ìš° ê³¼ì •ì„ ì§„í–‰í•˜ëŠ” ë° ë„ì›€ì„ ì¤„ ìˆ˜ "
"ìˆëŠ” ì¹œêµ¬ë‚˜ ë©˜í† ë¥¼ ì°¾ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.  [ê¹ƒí—™ ë¦¬í¬ì§€í† ë¦¬ì˜ `solutions` ë¸Œëœì¹˜]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/solutions)ì—"
"ì„œ ëª¨ë“  ì—°ìŠµì— ëŒ€í•œ ì†”ë£¨ì…˜ì„ ì°¾ì„ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."

#: src/01_intro/00_welcome.md:35
msgid "Structure"
msgstr "êµ¬ì¡°"

#: src/01_intro/00_welcome.md:37
msgid ""
"On the left side of the screen, you can see that the course is divided into "
"sections. Each section introduces a new concept or feature of the Rust "
"language.  \n"
"To verify your understanding, each section is paired with an exercise that "
"you need to solve."
msgstr ""
"í™”ë©´ ì™¼ìª½ì„ ë³´ë©´ ì½”ìŠ¤ê°€ ì—¬ëŸ¬ ì„¹ì…˜ìœ¼ë¡œ ë‚˜ëˆ„ì–´ì ¸ ìˆëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê° ì„¹"
"ì…˜ì—ì„œëŠ” Rust ì–¸ì–´ì˜ ìƒˆë¡œìš´ ê°œë…ì´ë‚˜ ê¸°ëŠ¥ì„ ì†Œê°œí•©ë‹ˆë‹¤.  \n"
"ì´í•´ë¥¼ í™•ì¸í•˜ê¸° ìœ„í•´ ê° ì„¹ì…˜ì€ í•´ê²°í•´ì•¼ í•˜ëŠ” ì—°ìŠµë¬¸ì œì™€ ì§ì„ ì´ë£¹ë‹ˆë‹¤."

#: src/01_intro/00_welcome.md:41
msgid ""
"You can find the exercises in the [companion GitHub repository](https://"
"github.com/mainmatter/100-exercises-to-learn-rust).  \n"
"Before starting the course, make sure to clone the repository to your local "
"machine:"
msgstr ""
"[ìë§¤ ê¹ƒí—™ ë¦¬í¬ì§€í† ë¦¬](https://github.com/mainmatter/100-exercises-to-learn-"
"rust)ì—ì„œ ì˜ˆì œë“¤ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"ì½”ìŠ¤ë¥¼ ì‹œì‘í•˜ê¸°ì „ì— ë¦¬í¬ì§€í† ë¦¬ë¥¼ ë¡œì»¬ì— í´ë¡ í•˜ì„¸ìš”:"

#: src/01_intro/00_welcome.md:46
msgid "# If you have an SSH key set up with GitHub\n"
msgstr "# GitHubì— SSH í‚¤ê°€ ì„¤ì •ë˜ì–´ ìˆëŠ” ê²½ìš°\n"

#: src/01_intro/00_welcome.md:47
msgid ""
"# Otherwise, use the HTTPS URL:\n"
"#\n"
"#   git clone https://github.com/mainmatter/100-exercises-to-learn-rust.git\n"
msgstr ""
"# ì•„ë‹ˆë©´ HTTPS URLì„ ì‚¬ìš©í•˜ì‹­ì‹œì˜¤:\n"
"# \n"
"#    git clone https://github.com/mainmatter/100-exercises-to-learn-rust.git\n"

#: src/01_intro/00_welcome.md:53
msgid ""
"We also recommend you work on a branch, so you can easily track your progress "
"and pull in updates from the main repository, if needed:"
msgstr ""
"ë˜í•œ ì§„í–‰ ìƒí™©ì„ ì‰½ê²Œ ì¶”ì í•˜ê³  í•„ìš”í•œ ê²½ìš° ë©”ì¸ ë¦¬í¬ì§€í† ë¦¬ì—ì„œ ì—…ë°ì´íŠ¸ë¥¼ ê°€ì ¸"
"ì˜¬ ìˆ˜ ìˆë„ë¡ ë¸Œëœì¹˜ì—ì„œ ì‘ì—…í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤:"

#: src/01_intro/00_welcome.md:61
msgid ""
"All exercises are located in the `exercises` folder. Each exercise is "
"structured as a Rust package. The package contains the exercise itself, "
"instructions on what to do (in `src/lib.rs`), and a test suite to "
"automatically verify your solution."
msgstr ""
"ëª¨ë“  ì˜ˆì œëŠ” `exercises` í´ë”ì— ìˆìŠµë‹ˆë‹¤. ê° ë¬¸ì œëŠ” Rust íŒ¨í‚¤ì§€ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤. "
"íŒ¨í‚¤ì§€ì—ëŠ” ì—°ìŠµ ìì²´, ìˆ˜í–‰í•  ì‘ì—…ì— ëŒ€í•œ ì§€ì¹¨(`src/lib.rs`ì— ìˆìŒ), ì†”ë£¨ì…˜ì„ "
"ìë™ìœ¼ë¡œ ê²€ì¦í•˜ê¸° ìœ„í•œ í…ŒìŠ¤íŠ¸ ëª¨ìŒì´ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤."

#: src/01_intro/00_welcome.md:66
msgid "`wr`, the workshop runner"
msgstr "`wr`, ì›Œí¬ìˆ ëŸ¬ë„ˆ"

#: src/01_intro/00_welcome.md:68
msgid ""
"To verify your solutions, we've provided a tool that will guide you through "
"the course. It is the `wr` CLI (short for \"workshop runner\"). Install it "
"with:"
msgstr ""
"ì†”ë£¨ì…˜ì„ ê²€ì¦í•˜ê¸° ìœ„í•´ ì½”ìŠ¤ ë‚´ë‚´ ë‹¹ì‹ ì„ ë„ì™€ì¤„ ë„êµ¬ë¥¼ ì œê³µí•©ë‹ˆë‹¤. `wr` "
"CLI(\"ì›Œí¬ìˆ ëŸ¬ë„ˆ\"ì˜ ì¤„ì„ë§)ì…ë‹ˆë‹¤. ì•„ë˜ ëª…ë ¹ì„ ì‚¬ìš©í•˜ì—¬ ì„¤ì¹˜í•˜ì„¸ìš”:"

#: src/01_intro/00_welcome.md:76
msgid ""
"In a new terminal, navigate back to the top-level folder of the repository. "
"Run the `wr` command to start the course:"
msgstr ""
"ìƒˆ í„°ë¯¸ë„ì—ì„œ ë¦¬í¬ì§€í† ë¦¬ì˜ ìµœìƒìœ„ í´ë”ë¡œ ì´ë™í•©ë‹ˆë‹¤. ì½”ìŠ¤ë¥¼ ì‹œì‘í•˜ë ¤ë©´ `wr` ëª…"
"ë ¹ì„ ì‹¤í–‰í•˜ì„¸ìš”:"

#: src/01_intro/00_welcome.md:83
msgid ""
"`wr` will verify the solution to the current exercise.  \n"
"Don't move on to the next section until you've solved the exercise for the "
"current one."
msgstr ""
"`wr`ì€ í˜„ì¬ ì—°ìŠµì— ëŒ€í•œ ì†”ë£¨ì…˜ì„ í™•ì¸í•©ë‹ˆë‹¤.  \n"
"í˜„ì¬ ì—°ìŠµë¬¸ì œë¥¼ í’€ ë•Œê¹Œì§€ ë‹¤ìŒ ì„¹ì…˜ìœ¼ë¡œ ë„˜ì–´ê°€ì§€ ë§ˆì„¸ìš”."

#: src/01_intro/00_welcome.md:86
msgid ""
"We recommend committing your solutions to Git as you progress through the "
"course, so you can easily track your progress and \"restart\" from a known "
"point if needed."
msgstr ""
"ê³¼ì •ì„ ì§„í–‰í•˜ë©´ì„œ ì†”ë£¨ì…˜ì„ Gitì— ì»¤ë°‹í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë©´ ì§„í–‰ ìƒí™©ì„ ì‰½"
"ê²Œ ì¶”ì í•˜ê³  í•„ìš”í•œ ê²½ìš° íŠ¹ì • ì§€ì ì—ì„œ \"ë‹¤ì‹œ ì‹œì‘í• \" ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/01_intro/00_welcome.md:89
msgid "Enjoy the course!"
msgstr "ì½”ìŠ¤ë¥¼ ì¦ê²¨ë³´ì„¸ìš”!"

#: src/01_intro/00_welcome.md:91
msgid "Author"
msgstr "ì‘ì„±ì"

#: src/01_intro/00_welcome.md:93
msgid ""
"This course was written by [Luca Palmieri](https://www.lpalmieri.com/), "
"Principal Engineering Consultant at [Mainmatter](https://mainmatter.com/rust-"
"consulting/).  \n"
"Luca has been working with Rust since 2018, initially at TrueLayer and then "
"at AWS.  \n"
"Luca is the author of [\"Zero to Production in Rust\"](https://zero2prod."
"com), the go-to resource for learning how to build backend applications in "
"Rust.  \n"
"He is also the author and maintainer of a variety of open-source Rust "
"projects, including [`cargo-chef`](https://github.com/LukeMathWalker/cargo-"
"chef), [Pavex](https://pavex.dev) and [`wiremock`](https://github.com/"
"LukeMathWalker/wiremock-rs)."
msgstr ""
"ì´ ê³¼ì •ì€ [Mainmatter](https://mainmatter.com/rust-consulting/)ì˜ ìˆ˜ì„ ì—”ì§€ë‹ˆ"
"ì–´ë§ ì»¨ì„¤í„´íŠ¸ì¸ [Luca Palmieri](https://www.lpalmieri.com/)ê°€ ì‘ì„±í–ˆìŠµë‹ˆ"
"ë‹¤.  \n"
"LucaëŠ” 2018ë…„ë¶€í„° ì²˜ìŒì—ëŠ” TrueLayerì—ì„œ, ê·¸ë‹¤ìŒì—ëŠ” AWSì—ì„œ Rustì™€ í˜‘ë ¥í•´ ì™”"
"ìŠµë‹ˆë‹¤.  \n"
"LucaëŠ” Rustì—ì„œ ë°±ì—”ë“œ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ êµ¬ì¶•í•˜ëŠ” ë°©ë²•ì„ ë°°ìš°ê¸° ìœ„í•œ ìœ ìš©í•œ ë¦¬ì†Œ"
"ìŠ¤ì¸ [\"Zero to Production in Rust\"](https://zero2prod.com)ì˜ ì €ìì…ë‹ˆë‹¤.  \n"
"ê·¸ëŠ” ë˜í•œ [`cargo-chef`](https://github.com/LukeMathWalker/cargo-chef), "
"[Pavex](https://pavex.dev)ì™€ [`wiremock`](https://github.com/LukeMathWalker/"
"wiremock-rs)ì„ í¬í•¨í•œ ë‹¤ì–‘í•œ ì˜¤í”ˆ ì†ŒìŠ¤ Rust í”„ë¡œì íŠ¸ì˜ ì €ìì´ì ê´€ë¦¬ìì´ê¸°ë„ "
"í•©ë‹ˆë‹¤."

#: src/01_intro/00_welcome.md:102 src/01_intro/01_syntax.md:117
#: src/02_basic_calculator/00_intro.md:18
#: src/02_basic_calculator/01_integers.md:136
#: src/02_basic_calculator/02_variables.md:102
#: src/02_basic_calculator/03_if_else.md:103
#: src/02_basic_calculator/04_panics.md:56
#: src/02_basic_calculator/05_factorial.md:13
#: src/02_basic_calculator/06_while.md:87 src/02_basic_calculator/07_for.md:66
#: src/02_basic_calculator/08_overflow.md:108
#: src/02_basic_calculator/09_saturating.md:41
#: src/02_basic_calculator/10_as_casting.md:103 src/03_ticket_v1/00_intro.md:20
#: src/03_ticket_v1/01_struct.md:140 src/03_ticket_v1/02_validation.md:23
#: src/03_ticket_v1/03_modules.md:116 src/03_ticket_v1/04_visibility.md:47
#: src/03_ticket_v1/05_encapsulation.md:61 src/03_ticket_v1/06_ownership.md:235
#: src/03_ticket_v1/07_setters.md:110 src/03_ticket_v1/08_stack.md:60
#: src/03_ticket_v1/09_heap.md:144
#: src/03_ticket_v1/10_references_in_memory.md:52
#: src/03_ticket_v1/11_destructor.md:171 src/03_ticket_v1/12_outro.md:7
#: src/04_traits/00_intro.md:22 src/04_traits/01_trait.md:129
#: src/04_traits/02_orphan_rule.md:114
#: src/04_traits/03_operator_overloading.md:100 src/04_traits/04_derive.md:105
#: src/04_traits/05_trait_bounds.md:174 src/04_traits/06_str_slice.md:118
#: src/04_traits/07_deref.md:93 src/04_traits/08_sized.md:81
#: src/04_traits/09_from.md:142 src/04_traits/10_assoc_vs_generic.md:148
#: src/04_traits/11_clone.md:109 src/04_traits/12_copy.md:115
#: src/04_traits/13_drop.md:54 src/04_traits/14_outro.md:29
#: src/05_ticket_v2/00_intro.md:17 src/05_ticket_v2/01_enum.md:45
#: src/05_ticket_v2/02_match.md:72 src/05_ticket_v2/03_variants_with_data.md:90
#: src/05_ticket_v2/04_if_let.md:68 src/05_ticket_v2/05_nullability.md:76
#: src/05_ticket_v2/06_fallibility.md:85 src/05_ticket_v2/07_unwrap.md:42
#: src/05_ticket_v2/08_error_enums.md:40 src/05_ticket_v2/09_error_trait.md:54
#: src/05_ticket_v2/10_packages.md:65 src/05_ticket_v2/11_dependencies.md:56
#: src/05_ticket_v2/12_thiserror.md:43 src/05_ticket_v2/13_try_from.md:42
#: src/05_ticket_v2/14_source.md:152 src/05_ticket_v2/15_outro.md:20
#: src/06_ticket_management/00_intro.md:20
#: src/06_ticket_management/01_arrays.md:83
#: src/06_ticket_management/02_vec.md:114
#: src/06_ticket_management/03_resizing.md:27
#: src/06_ticket_management/04_iterators.md:109
#: src/06_ticket_management/05_iter.md:44
#: src/06_ticket_management/06_lifetimes.md:86
#: src/06_ticket_management/07_combinators.md:109
#: src/06_ticket_management/08_impl_trait.md:71
#: src/06_ticket_management/09_impl_trait_2.md:34
#: src/06_ticket_management/10_slices.md:108
#: src/06_ticket_management/11_mutable_slices.md:43
#: src/06_ticket_management/12_two_states.md:69
#: src/06_ticket_management/13_index.md:39
#: src/06_ticket_management/14_index_mut.md:22
#: src/06_ticket_management/15_hashmap.md:118
#: src/06_ticket_management/16_btreemap.md:84 src/07_threads/00_intro.md:17
#: src/07_threads/01_threads.md:117 src/07_threads/02_static.md:116
#: src/07_threads/03_leak.md:48 src/07_threads/04_scoped_threads.md:75
#: src/07_threads/05_channels.md:75 src/07_threads/06_interior_mutability.md:116
#: src/07_threads/07_ack.md:18 src/07_threads/08_client.md:10
#: src/07_threads/09_bounded.md:45 src/07_threads/10_patch.md:41
#: src/07_threads/11_locks.md:224 src/07_threads/12_rw_lock.md:47
#: src/07_threads/13_without_channels.md:56 src/07_threads/14_sync.md:30
#: src/08_futures/00_intro.md:13 src/08_futures/01_async_fn.md:146
#: src/08_futures/02_spawn.md:124 src/08_futures/03_runtime.md:90
#: src/08_futures/04_future.md:167 src/08_futures/05_blocking.md:81
#: src/08_futures/06_async_aware_primitives.md:131
#: src/08_futures/07_cancellation.md:111 src/08_futures/08_outro.md:36
msgid "Exercise"
msgstr "ì˜ˆì œ"

#: src/01_intro/00_welcome.md:104
msgid ""
"The exercise for this section is located in [`01_intro/00_welcome`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/01_intro/00_welcome)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`01_intro/00_welcome`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/01_intro/00_welcome)ì— ìˆìŠµë‹ˆë‹¤"

#: src/01_intro/01_syntax.md:5
msgid ""
"Don't jump ahead!  \n"
"Complete the exercise for the previous section before you start this one.  \n"
"It's located in `exercises/01_intro/00_welcome`, in the [course GitHub's "
"repository](https://github.com/mainmatter/100-exercises-to-learn-rust).  \n"
"Use [`wr`](00_welcome.md#wr-the-workshop-runner) to start the course and "
"verify your solutions."
msgstr ""
"ì•ìœ¼ë¡œ ê±´ë„ˆë›°ì§€ë§ˆì„¸ìš”!  \n"
"ì´ ì„¹ì…˜ì„ ì‹œì‘í•˜ê¸° ì „ì— ì´ì „ ì„¹ì…˜ì˜ ì—°ìŠµì„ ì™„ë£Œí•˜ì„¸ìš”.  \n"
"ì´ì „ ì„¹ì…˜ì€ [GitHub ì €ì¥ì†Œ](https://github.com/mainmatter/100-exercises-to-"
"learn-rust)ì˜ `exercises/01_intro/00_welcome`ì— ìˆìŠµë‹ˆë‹¤.  \n"
"[`wr`](00_welcome.md#wr-the-workshop-runner)ì„ ì‚¬ìš©í•˜ì—¬ ì½”ìŠ¤ë¥¼ ì‹œì‘í•˜ê³  ì†”ë£¨ì…˜"
"ì„ í™•ì¸í•˜ì„¸ìš”."

#: src/01_intro/01_syntax.md:12
msgid ""
"The previous task doesn't even qualify as an exercise, but it already exposed "
"you to quite a bit of Rust **syntax**. We won't cover every single detail of "
"Rust's syntax used in the previous exercise. Instead, we'll cover _just "
"enough_ to keep going without getting stuck in the details.  \n"
"One step at a time!"
msgstr ""
"ì´ì „ ì‘ì—…ì€ ì—°ìŠµìœ¼ë¡œë„ ì í•©í•˜ì§€ ì•Šì§€ë§Œ ì´ë¯¸ ê½¤ ë§ì€ Rust **ë¬¸ë²•**ì„ ë…¸ì¶œì‹œì¼°ìŠµ"
"ë‹ˆë‹¤. ì´ì „ ì—°ìŠµì—ì„œ ì‚¬ìš©ëœ Rust êµ¬ë¬¸ì„ ì„¸ì„¸í•˜ê²Œ ë‹¤ë£¨ì§€ëŠ” ì•Šì„ ê²ƒì…ë‹ˆë‹¤. ëŒ€ì‹ , "
"_ê³„ì† ì§„í–‰í•  ìˆ˜ ìˆì„ ì •ë„ë§Œ_ ë‹¤ë£¨ê² ìŠµë‹ˆë‹¤.  \n"
"í•œ ë²ˆì— í•œ ê±¸ìŒ ì”©!"

#: src/01_intro/01_syntax.md:17
msgid "Comments"
msgstr "ì½”ë©˜íŠ¸"

#: src/01_intro/01_syntax.md:19
msgid "You can use `//` for single-line comments:"
msgstr "í•œ ì¤„ ì£¼ì„ì—ëŠ” `//`ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/01_intro/01_syntax.md:22
msgid ""
"// This is a single-line comment\n"
"// Followed by another single-line comment\n"
msgstr ""
"// ì´ê²ƒì€ í•œ ì¤„ ì£¼ì„ì…ë‹ˆë‹¤\n"
"// ë˜ ë‹¤ë¥¸ í•œ ì¤„ ì£¼ì„ì´ ì´ì–´ì§‘ë‹ˆë‹¤\n"

#: src/01_intro/01_syntax.md:26
msgid "Functions"
msgstr "í•¨ìˆ˜"

#: src/01_intro/01_syntax.md:28
msgid ""
"Functions in Rust are defined using the `fn` keyword, followed by the "
"function's name, its input parameters, and its return type. The function's "
"body is enclosed in curly braces `{}`."
msgstr ""
"Rustì˜ í•¨ìˆ˜ëŠ” `fn` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ì •ì˜ë˜ë©° ê·¸ ë’¤ì— í•¨ìˆ˜ ì´ë¦„, ì…ë ¥ ë§¤ê°œë³€"
"ìˆ˜, ë°˜í™˜ ìœ í˜•ì´ ì˜µë‹ˆë‹¤. í•¨ìˆ˜ ë³¸ë¬¸ì€ ì¤‘ê´„í˜¸ `{}`ë¡œ ê°ì‹¸ì¤ë‹ˆë‹¤."

#: src/01_intro/01_syntax.md:32
msgid "In previous exercise, you saw the `greeting` function:"
msgstr "ì´ì „ ì—°ìŠµì—ì„œëŠ” `ì¸ì‚¬ë§` ê¸°ëŠ¥ì„ ë³´ì•˜ìŠµë‹ˆë‹¤:"

#: src/01_intro/01_syntax.md:35
msgid ""
"// `fn` <function_name> ( <input parameters> ) -> <return_type> { <body> }\n"
msgstr ""
"// `fn` \\<function_name> ( <input parameters> ) -> \\<return_type> "
"{ <body> }\n"

#: src/01_intro/01_syntax.md:37
msgid ""
"// TODO: fix me ğŸ‘‡\n"
"    \"I'm ready to __!\""
msgstr ""
"// TODO: fix me ğŸ‘‡\n"
"    \"I'm ready to \\_\\_!\""

#: src/01_intro/01_syntax.md:42
msgid ""
"`greeting` has no input parameters and returns a reference to a string slice "
"(`&'static str`)."
msgstr ""
"`greeting`ì—ëŠ” ì…ë ¥ ë§¤ê°œë³€ìˆ˜ê°€ ì—†ìœ¼ë©° ë¬¸ìì—´ ìŠ¬ë¼ì´ìŠ¤ (`&'static str`)ì— ëŒ€í•œ "
"ì°¸ì¡°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."

#: src/01_intro/01_syntax.md:44
msgid "Return type"
msgstr "ë°˜í™˜ ìœ í˜•"

#: src/01_intro/01_syntax.md:46
msgid ""
"The return type can be omitted from the signature if the function doesn't "
"return anything (i.e. if it returns `()`, Rust's unit type). That's what "
"happened with the `test_welcome` function:"
msgstr ""
"í•¨ìˆ˜ê°€ ì•„ë¬´ ê²ƒë„ ë°˜í™˜í•˜ì§€ ì•Šìœ¼ë©´(ì¦‰, Rustì˜ ë‹¨ìœ„ ìœ í˜•ì¸ `()`ë¥¼ ë°˜í™˜í•˜ëŠ” ê²½ìš°) "
"ë°˜í™˜ ìœ í˜•ì„ ì‹œê·¸ë‹ˆì²˜ì—ì„œ ìƒëµí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ê²ƒì´ `test_welcome` í•¨ìˆ˜ì—ì„œ ìˆ"
"ì—ˆë˜ ì¼ì…ë‹ˆë‹¤:"

#: src/01_intro/01_syntax.md:52 src/01_intro/01_syntax.md:62
#: src/01_intro/01_syntax.md:83
msgid "\"I'm ready to learn Rust!\""
msgstr "\"I'm ready to learn Rust!\""

#: src/01_intro/01_syntax.md:56
msgid "The above is equivalent to:"
msgstr "ìœ„ì˜ ë‚´ìš©ì€ ë‹¤ìŒê³¼ ë™ì¼í•©ë‹ˆë‹¤:"

#: src/01_intro/01_syntax.md:59
msgid ""
"// Spelling out the unit return type explicitly\n"
"//                   ğŸ‘‡\n"
msgstr ""
"// Spelling out the unit return type explicitly\n"
"//                   ğŸ‘‡\n"

#: src/01_intro/01_syntax.md:66
msgid "Returning values"
msgstr "ë°˜í™˜ ê°’"

#: src/01_intro/01_syntax.md:68
msgid "The last expression in a function is implicitly returned:"
msgstr "í•¨ìˆ˜ì˜ ë§ˆì§€ë§‰ í‘œí˜„ì‹ì€ ì•”ì‹œì ìœ¼ë¡œ ë°˜í™˜ë©ë‹ˆë‹¤:"

#: src/01_intro/01_syntax.md:72
msgid ""
"// This is the last expression in the function\n"
"    // Therefore its value is returned by `greeting`\n"
"    \"I'm ready to learn Rust!\""
msgstr ""
"// This is the last expression in the function\n"
"    // Therefore its value is returned by `greeting`\n"
"    \"I'm ready to learn Rust!\""

#: src/01_intro/01_syntax.md:78
msgid "You can also use the `return` keyword to return a value early:"
msgstr "ì¤‘ê°„ì— ê°’ì„ ë°˜í™˜í•˜ë ¤ë©´ `return` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤:"

#: src/01_intro/01_syntax.md:82
msgid "// Notice the semicolon at the end of the line!\n"
msgstr "// Notice the semicolon at the end of the line!\n"

#: src/01_intro/01_syntax.md:87
msgid "It is considered idiomatic to omit the `return` keyword when possible."
msgstr "ê°€ëŠ¥í•˜ë©´ 'return' í‚¤ì›Œë“œë¥¼ ìƒëµí•˜ëŠ” ê²ƒì´ ê´€ìš©ì ì…ë‹ˆë‹¤."

#: src/01_intro/01_syntax.md:89
msgid "Input parameters"
msgstr "ì…ë ¥ ë§¤ê°œë³€ìˆ˜"

#: src/01_intro/01_syntax.md:91
msgid ""
"Input parameters are declared inside the parentheses `()` that follow the "
"function's name.  \n"
"Each parameter is declared with its name, followed by a colon `:`, followed "
"by its type."
msgstr ""
"ì…ë ¥ ë§¤ê°œë³€ìˆ˜ëŠ” í•¨ìˆ˜ ì´ë¦„ ë’¤ì— ì˜¤ëŠ” ê´„í˜¸ '()' ì•ˆì— ì„ ì–¸ë©ë‹ˆë‹¤.  \n"
"ê° ë§¤ê°œë³€ìˆ˜ëŠ” `ì´ë¦„: íƒ€ì…` ëª¨ì–‘ìœ¼ë¡œ ì„ ì–¸ë©ë‹ˆë‹¤."

#: src/01_intro/01_syntax.md:94
msgid ""
"For example, the `greet` function below takes a `name` parameter of type "
"`&str` (a \"string slice\"):"
msgstr ""
"ì˜ˆë¥¼ ë“¤ì–´, ì•„ë˜ `greet` í•¨ìˆ˜ëŠ” `&str` íƒ€ì…(\"ë¬¸ìì—´ ìŠ¬ë¼ì´ìŠ¤\")ì˜ `name` ë§¤ê°œ"
"ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤:"

#: src/01_intro/01_syntax.md:97
msgid ""
"// An input parameter\n"
"//        ğŸ‘‡\n"
msgstr ""
"// An input parameter\n"
"//        ğŸ‘‡\n"

#: src/01_intro/01_syntax.md:100
msgid "\"Hello, {}!\""
msgstr "\"Hello, {}!\""

#: src/01_intro/01_syntax.md:104
msgid ""
"If there are multiple input parameters, they must be separated with commas."
msgstr "ì…ë ¥ ë§¤ê°œë³€ìˆ˜ê°€ ì—¬ëŸ¬ ê°œì¸ ê²½ìš° ì‰¼í‘œë¡œ êµ¬ë¶„í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/01_intro/01_syntax.md:106
msgid "Type annotations"
msgstr "íƒ€ì… ì–´ë…¸í…Œì´ì…˜"

#: src/01_intro/01_syntax.md:108
msgid ""
"Since we've been mentioned \"types\" a few times, let's state it clearly: "
"Rust is a **statically typed language**.  \n"
"Every single value in Rust has a type and that type must be known to the "
"compiler at compile-time."
msgstr ""
"ìš°ë¦¬ëŠ” \"íƒ€ì…\"ì— ëŒ€í•´ ì—¬ëŸ¬ ë²ˆ ì–¸ê¸‰í–ˆìœ¼ë¯€ë¡œ ëª…í™•í•˜ê²Œ ë§í•˜ê² ìŠµë‹ˆë‹¤: RustëŠ” **ì •"
"ì  íƒ€ì… ì–¸ì–´**ì…ë‹ˆë‹¤.  \n"
"Rustì˜ ëª¨ë“  ë‹¨ì¼ ê°’ì—ëŠ” ìœ í˜•ì´ ìˆìœ¼ë©° í•´ë‹¹ ìœ í˜•ì€ ì»´íŒŒì¼ íƒ€ì„ì— ì»´íŒŒì¼ëŸ¬ê°€ ì•Œ "
"ìˆ˜ ìˆì–´ì•¼ í•©ë‹ˆë‹¤."

#: src/01_intro/01_syntax.md:111
msgid ""
"Types are a form of **static analysis**.  \n"
"You can think of a type as a **tag** that the compiler attaches to every "
"value in your program. Depending on the tag, the compiler can enforce "
"different rulesâ€”e.g. you can't add a string to a number, but you can add two "
"numbers together. If leveraged correctly, types can prevent whole classes of "
"runtime bugs."
msgstr ""
"íƒ€ì…ì€ **static analysis**ì˜ í•œ í˜•íƒœì…ë‹ˆë‹¤.  \n"
"íƒ€ì…ì€ ì»´íŒŒì¼ëŸ¬ê°€ í”„ë¡œê·¸ë¨ì˜ ëª¨ë“  ê°’ì— ì²¨ë¶€í•˜ëŠ” **íƒœê·¸**ë¡œ ìƒê°í•  ìˆ˜ ìˆìŠµë‹ˆ"
"ë‹¤. íƒœê·¸ì— ë”°ë¼ ì»´íŒŒì¼ëŸ¬ëŠ” ë‹¤ë¥¸ ê·œì¹™ì„ ì ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìˆ«ìì— ë¬¸ìì—´ì„ ë”"
"í•  ìˆ˜ëŠ” ì—†ì§€ë§Œ ë‘ ìˆ«ìë¥¼ í•¨ê»˜ ë”í•  ìˆ˜ëŠ” ìˆìŠµë‹ˆë‹¤. íƒ€ì…ì„ ì˜¬ë°”ë¥´ê²Œ í™œìš©í•˜ë©´ ëª¨"
"ë“  ì¢…ë¥˜ì˜ ëŸ°íƒ€ì„ ë²„ê·¸ë¥¼ ë°©ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/01_intro/01_syntax.md:119
msgid ""
"The exercise for this section is located in [`01_intro/01_syntax`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/01_intro/01_syntax)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`01_intro/01_syntax`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/01_intro/01_syntax)ì— ìˆìŠµë‹ˆë‹¤"

#: src/02_basic_calculator/00_intro.md:3
msgid ""
"In this chapter we'll learn how to use Rust as a **calculator**.  \n"
"It might not sound like much, but it'll give us a chance to cover a lot of "
"Rust's basics, such as:"
msgstr ""
"ì´ë²ˆ ì¥ì—ì„œëŠ” Rustë¥¼ **ê³„ì‚°ê¸°**ë¡œ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì„ ë°°ìš°ê² ìŠµë‹ˆë‹¤.  \n"
"ë³„ê²ƒ ì•„ë‹Œ ê²ƒì²˜ëŸ¼ ë“¤ë¦¬ê² ì§€ë§Œ, ë‹¤ìŒê³¼ ê°™ì€ Rustì˜ ê¸°ë³¸ê¸°ë¥¼ ë§ì´ ë‹¤ë£° ìˆ˜ ìˆëŠ” ê¸°"
"íšŒë¥¼ ì œê³µí•  ê²ƒì…ë‹ˆë‹¤:"

#: src/02_basic_calculator/00_intro.md:6
msgid "How to define and call functions"
msgstr "í•¨ìˆ˜ë¥¼ ì •ì˜í•˜ê³  í˜¸ì¶œí•˜ëŠ” ë°©ë²•"

#: src/02_basic_calculator/00_intro.md:7
msgid "How to declare and use variables"
msgstr "ë³€ìˆ˜ ì„ ì–¸ ë° ì‚¬ìš© ë°©ë²•"

#: src/02_basic_calculator/00_intro.md:8
msgid "Primitive types (integers and booleans)"
msgstr "ì›ì‹œ íƒ€ì…(ì •ìˆ˜ ì™€ ë¶ˆë¦¬ì–¸)"

#: src/02_basic_calculator/00_intro.md:9
msgid "Arithmetic operators (including overflow and underflow behavior)"
msgstr "ì‚°ìˆ  ì—°ì‚°ì(ì˜¤ë²„í”Œë¡œ ë° ì–¸ë”í”Œë¡œ ë™ì‘ í¬í•¨)"

#: src/02_basic_calculator/00_intro.md:10
#: src/02_basic_calculator/03_if_else.md:73
msgid "Comparison operators"
msgstr "ë¹„êµ ì—°ì‚°ì"

#: src/02_basic_calculator/00_intro.md:11
msgid "Control flow"
msgstr "íë¦„ ì œì–´"

#: src/02_basic_calculator/00_intro.md:14
msgid ""
"Nailing the basics with a few exercises will get the language flowing under "
"your fingers. When we move on to more complex topics, such as traits and "
"ownership, you'll be able to focus on the new concepts without getting bogged "
"down by the syntax or other trivial details."
msgstr ""
"ëª‡ ê°€ì§€ ì—°ìŠµì„ í†µí•´ ê¸°ë³¸ê¸°ë¥¼ ìµíˆë©´ ì–¸ì–´ê°€ ë¬¼íë¥´ë“¯ ì¨ì§€ê²Œ ë©ë‹ˆë‹¤. Traitì™€ ì†Œ"
"ìœ ê¶Œê°™ì€ ë” ë³µì¡í•œ ì£¼ì œë¡œ ë„˜ì–´ê°ˆ ë•Œ ë¬¸ë²•ì´ë‚˜ ê¸°íƒ€ ì‚¬ì†Œí•œ ì„¸ë¶€ì‚¬í•­ì— ì–½ë§¤ì´ì§€ "
"ì•Šê³  ìƒˆë¡œìš´ ê°œë…ì— ì§‘ì¤‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/02_basic_calculator/00_intro.md:20
msgid ""
"The exercise for this section is located in [`02_basic_calculator/00_intro`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/00_intro)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`02_basic_calculator/00_intro`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/00_intro)ì— ìˆìŠµë‹ˆë‹¤"

#: src/02_basic_calculator/01_integers.md:1
msgid "Types, part 1"
msgstr "Types, part 1"

#: src/02_basic_calculator/01_integers.md:3
msgid ""
"In the [\"Syntax\" section](../01_intro/01_syntax.md) `compute`'s input "
"parameters were of type `u32`.  \n"
"Let's unpack what that _means_."
msgstr ""
"[\"ë¬¸ë²•\" section](../01_intro/01_syntax.md)ì„¹ì…˜ì—ì„œ `compute`ì˜ ì…ë ¥ ë§¤ê°œë³€ìˆ˜"
"ëŠ” `u32` íƒ€ì…ì´ì—ˆìŠµë‹ˆë‹¤.  \n"
"ê·¸ê²ƒì´ _ì˜ë¯¸_ ë¬´ì—‡ì¸ì§€ í’€ì–´ë´…ì‹œë‹¤."

#: src/02_basic_calculator/01_integers.md:6
msgid "Primitive types"
msgstr "ì›ì‹œ íƒ€ì…"

#: src/02_basic_calculator/01_integers.md:8
msgid ""
"`u32` is one of Rust's **primitive types**. Primitive types are the most "
"basic building blocks of a language. They're built into the language itselfâ€”i."
"e. they are not defined in terms of other types."
msgstr ""
"`u32`ëŠ” Rustì˜ **ì›ì‹œ íƒ€ì…** ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤. ì›ì‹œ íƒ€ì…ì€ ì–¸ì–´ì˜ ê°€ì¥ ê¸°ë³¸ì ì¸ "
"êµ¬ì„± ìš”ì†Œì…ë‹ˆë‹¤. ì´ëŠ” ì–¸ì–´ ìì²´ì— ë‚´ì¥ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ë‹¤ë¥¸ íƒ€ì…ì²˜ëŸ¼ ì •ì˜ë˜ì§€ ì•Š"
"ìŠµë‹ˆë‹¤."

#: src/02_basic_calculator/01_integers.md:11
msgid ""
"You can combine these primitive types to create more complex types. We'll see "
"how soon enough."
msgstr ""
"ì´ëŸ¬í•œ ì›ì‹œ íƒ€ì…ì„ ê²°í•©í•˜ì—¬ ë” ë³µì¡í•œ íƒ€ì…ì„ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê³§ ë°°ìš°ê²Œ ë˜ì‹¤"
"ê²ë‹ˆë‹¤."

#: src/02_basic_calculator/01_integers.md:15
msgid "`u32`, in particular, is an **unsigned 32-bit integer**."
msgstr "`u32`ëŠ” **ë¶€í˜¸ ì—†ëŠ” 32ë¹„íŠ¸ ì •ìˆ˜**ì…ë‹ˆë‹¤."

#: src/02_basic_calculator/01_integers.md:17
msgid ""
"An integer is a number that can be written without a fractional component. E."
"g. `1` is an integer, while `1.2` is not."
msgstr ""
"ì •ìˆ˜ëŠ” ë¶„ìˆ˜ì—†ì´ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆëŠ” ìˆ«ìì…ë‹ˆë‹¤. ì˜ˆ: '1'ì€ ì •ìˆ˜ì´ì§€ë§Œ '1.2'ëŠ” ì •ìˆ˜"
"ê°€ ì•„ë‹™ë‹ˆë‹¤."

#: src/02_basic_calculator/01_integers.md:19
msgid "Signed vs. unsigned"
msgstr "Signed vs. unsigned"

#: src/02_basic_calculator/01_integers.md:21
msgid ""
"An integer can be **signed** or **unsigned**.  \n"
"An unsigned integer can only represent non-negative numbers (i.e. `0` or "
"greater). A signed integer can represent both positive and negative numbers "
"(e.g. `-1`, `12`, etc.)."
msgstr ""
"ì •ìˆ˜ëŠ” **signed** ë˜ëŠ” **unsigned**ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"ë¶€í˜¸ ì—†ëŠ” ì •ìˆ˜ëŠ” ìŒìˆ˜ê°€ ì•„ë‹Œ ìˆ«ì(ì˜ˆ: '0' ì´ìƒ)ë§Œ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë¶€í˜¸ ìˆ"
"ëŠ” ì •ìˆ˜ëŠ” ì–‘ìˆ˜ì™€ ìŒìˆ˜ë¥¼ ëª¨ë‘ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤(ì˜ˆ: '-1', '12' ë“±)."

#: src/02_basic_calculator/01_integers.md:25
msgid ""
"The `u` in `u32` stands for **unsigned**.  \n"
"The equivalent type for signed integer is `i32`, where the `i` stands for "
"integer (i.e. any integer, positive or negative)."
msgstr ""
"`u32`ì˜ `u`ëŠ” **unsigned**ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.  \n"
"ë¶€í˜¸ ìˆëŠ” ì •ìˆ˜ì— í•´ë‹¹í•˜ëŠ” ìœ í˜•ì€ 'i32'ì…ë‹ˆë‹¤. ì—¬ê¸°ì„œ 'i'ëŠ” ì •ìˆ˜(ì˜ˆ: ì–‘ìˆ˜ ë˜ëŠ” "
"ìŒìˆ˜)ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤."

#: src/02_basic_calculator/01_integers.md:29
#: src/02_basic_calculator/01_integers.md:48
msgid "Bit width"
msgstr "ë¹„íŠ¸ í­"

#: src/02_basic_calculator/01_integers.md:31
msgid ""
"The `32` in `u32` refers to the **number of bits[^bit]** used to represent "
"the number in memory.  \n"
"The more bits, the larger the range of numbers that can be represented."
msgstr ""
"'u32'ì˜ '32'ëŠ” ë©”ëª¨ë¦¬ì˜ ìˆ«ìë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë° ì‚¬ìš©ë˜ëŠ” **ë¹„íŠ¸ ìˆ˜[^bit]**ë¥¼ ë‚˜íƒ€ëƒ…"
"ë‹ˆë‹¤.  \n"
"ë¹„íŠ¸ê°€ ë§ì„ìˆ˜ë¡ í‘œí˜„í•  ìˆ˜ ìˆëŠ” ìˆ«ìì˜ ë²”ìœ„ê°€ ì»¤ì§‘ë‹ˆë‹¤."

#: src/02_basic_calculator/01_integers.md:34
msgid ""
"Rust supports multiple bit widths for integers: `8`, `16`, `32`, `64`, `128`."
msgstr ""
"RustëŠ” ì •ìˆ˜ì— ëŒ€í•´ `8`, `16`, `32`, `64`, `128`ê³¼ ê°™ì€ ë‹¤ì¤‘ ë¹„íŠ¸ ë„ˆë¹„ë¥¼ ì§€ì›í•©"
"ë‹ˆë‹¤."

#: src/02_basic_calculator/01_integers.md:36
msgid ""
"With 32 bits, `u32` can represent numbers from `0` to `2^32 - 1` (a.k.a. "
"[`u32::MAX`](https://doc.rust-lang.org/std/primitive.u32."
"html#associatedconstant.MAX)).  \n"
"With the same number of bits, a signed integer (`i32`) can represent numbers "
"from `-2^31` to `2^31 - 1` (i.e. from [`i32::MIN`](https://doc.rust-lang.org/"
"std/primitive.i32.html#associatedconstant.MIN) to [`i32::MAX`](https://doc."
"rust-lang.org/std/primitive.i32.html#associatedconstant.MAX)).  \n"
"The maximum value for `i32` is smaller than the maximum value for `u32` "
"because one bit is used to represent the sign of the number. Check out the "
"[two's complement](https://en.wikipedia.org/wiki/Two%27s_complement) "
"representation for more details on how signed integers are represented in "
"memory."
msgstr ""
"32ë¹„íŠ¸ë¥¼ ì‚¬ìš©í•˜ë©´ `u32`ëŠ” `0`ë¶€í„° `2^32 - 1`(ì¦‰, [`u32::MAX`](https://doc."
"rust-lang.org/std/primitive.u32.html#associatedconstant.MAX))ê¹Œì§€ì˜ ìˆ«ìë¥¼ ë‚˜"
"íƒ€ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"ë™ì¼í•œ ë¹„íŠ¸ ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ë¶€í˜¸ ìˆëŠ” ì •ìˆ˜(`i32`)ëŠ” `-2^31`ë¶€í„° `2^31 - 1`ê¹Œì§€"
"(ì¦‰, [`i32::MIN`](https://doc.rust-lang.org/std/primitive.i32."
"html#associatedconstant.MIN)ë¶€í„° [`i32::MAX`](https://doc.rust-lang.org/std/"
"primitive.i32.html#associatedconstant.MAX)ê¹Œì§€)ì˜ ìˆ«ìë¥¼ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆìŠµë‹ˆ"
"ë‹¤.  \n"
"'i32'ì˜ ìµœëŒ€ê°’ì€ 'u32'ì˜ ìµœëŒ€ê°’ë³´ë‹¤ ì‘ìŠµë‹ˆë‹¤. 1ë¹„íŠ¸ê°€ ìˆ«ìì˜ ë¶€í˜¸ë¥¼ ë‚˜íƒ€ë‚´ëŠ” "
"ë° ì‚¬ìš©ë˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ë¶€í˜¸ ìˆëŠ” ì •ìˆ˜ê°€ ë©”ëª¨ë¦¬ì— ì–´ë–»ê²Œ í‘œí˜„ë˜ëŠ”ì§€ì— ëŒ€í•œ ì"
"ì„¸í•œ ë‚´ìš©ì€ [2ì˜ ë³´ìˆ˜](https://en.wikipedia.org/wiki/Two%27s_complement)ë¥¼ í™•"
"ì¸í•˜ì„¸ìš”."

#: src/02_basic_calculator/01_integers.md:46
msgid ""
"Combining the two variables (signed/unsigned and bit width), we get the "
"following integer types:"
msgstr ""
"ë‘ ë³€ìˆ˜(signed/unsignedì™€ ë¹„íŠ¸ í­)ë¥¼ ê²°í•©í•˜ë©´ ë‹¤ìŒê³¼ ê°™ì€ ì •ìˆ˜ ìœ í˜•ì„ ì–»ì„ ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤:"

#: src/02_basic_calculator/01_integers.md:48
msgid "Signed"
msgstr "Signed"

#: src/02_basic_calculator/01_integers.md:48
msgid "Unsigned"
msgstr "Unsigned"

#: src/02_basic_calculator/01_integers.md:50
msgid "8-bit"
msgstr "8-bit"

#: src/02_basic_calculator/01_integers.md:50
msgid "`i8`"
msgstr "`i8`"

#: src/02_basic_calculator/01_integers.md:50
msgid "`u8`"
msgstr "`u8`"

#: src/02_basic_calculator/01_integers.md:51
msgid "16-bit"
msgstr "16-bit"

#: src/02_basic_calculator/01_integers.md:51
msgid "`i16`"
msgstr "`i16`"

#: src/02_basic_calculator/01_integers.md:51
msgid "`u16`"
msgstr "`u16`"

#: src/02_basic_calculator/01_integers.md:52
msgid "32-bit"
msgstr "32-bit"

#: src/02_basic_calculator/01_integers.md:52
msgid "`i32`"
msgstr "`i32`"

#: src/02_basic_calculator/01_integers.md:52
msgid "`u32`"
msgstr "`u32`"

#: src/02_basic_calculator/01_integers.md:53
msgid "64-bit"
msgstr "64-bit"

#: src/02_basic_calculator/01_integers.md:53
msgid "`i64`"
msgstr "`i64`"

#: src/02_basic_calculator/01_integers.md:53
msgid "`u64`"
msgstr "`u64`"

#: src/02_basic_calculator/01_integers.md:54
msgid "128-bit"
msgstr "128-bit"

#: src/02_basic_calculator/01_integers.md:54
msgid "`i128`"
msgstr "`i128`"

#: src/02_basic_calculator/01_integers.md:54
msgid "`u128`"
msgstr "`u128`"

#: src/02_basic_calculator/01_integers.md:56
msgid "Literals"
msgstr "ë¦¬í„°ëŸ´"

#: src/02_basic_calculator/01_integers.md:58
msgid ""
"A **literal** is a notation for representing a fixed value in source code.  \n"
"For example, `42` is a Rust literal for the number forty-two."
msgstr ""
"**ë¦¬í„°ëŸ´**ì€ ì†ŒìŠ¤ ì½”ë“œì—ì„œ ê³ ì •ëœ ê°’ì„ ë‚˜íƒ€ë‚´ëŠ” í‘œê¸°ë²•ì…ë‹ˆë‹¤.  \n"
"ì˜ˆë¥¼ ë“¤ì–´ '42'ëŠ” ìˆ«ì 42ì— ëŒ€í•œ Rust ë¦¬í„°ëŸ´ì…ë‹ˆë‹¤."

#: src/02_basic_calculator/01_integers.md:61
msgid "Type annotations for literals"
msgstr "íƒ€ì… ì–´ë…¸í…Œì´ì…˜ ë¦¬í„°ëŸ´"

#: src/02_basic_calculator/01_integers.md:63
msgid "But all values in Rust have a type, so... what's the type of `42`?"
msgstr ""
"í•˜ì§€ë§Œ Rustì˜ ëª¨ë“  ê°’ì—ëŠ” ìœ í˜•ì´ ìˆìŠµë‹ˆë‹¤. ê·¸ë ‡ë‹¤ë©´... '42'ì˜ íƒ€ì…ì€ ë¬´ì—‡ì¼ê¹Œ"
"ìš”?"

#: src/02_basic_calculator/01_integers.md:65
msgid ""
"The Rust compiler will try to infer the type of a literal based on how it's "
"used.  \n"
"If you don't provide any context, the compiler will default to `i32` for "
"integer literals.  \n"
"If you want to use a different type, you can add the desired integer type as "
"a suffixâ€”e.g. `2u64` is a 2 that's explicitly typed as a `u64`."
msgstr ""
"Rust ì»´íŒŒì¼ëŸ¬ëŠ” ë¦¬í„°ëŸ´ì´ ì‚¬ìš©ë˜ëŠ” ë°©ì‹ì— ë”°ë¼ ë¦¬í„°ëŸ´ì˜ íƒ€ì…ì„ ì¶”ë¡ í•˜ë ¤ê³  ì‹œë„"
"í•©ë‹ˆë‹¤.  \n"
"ì»¨í…ìŠ¤íŠ¸ë¥¼ ì œê³µí•˜ì§€ ì•Šìœ¼ë©´ ì»´íŒŒì¼ëŸ¬ëŠ” ì •ìˆ˜ ë¦¬í„°ëŸ´ì— ëŒ€í•´ ê¸°ë³¸ì ìœ¼ë¡œ `i32`ë¥¼ ì‚¬"
"ìš©í•©ë‹ˆë‹¤.  \n"
"ë‹¤ë¥¸ íƒ€ì…ì„ ì‚¬ìš©í•˜ë ¤ë©´ ì›í•˜ëŠ” ì •ìˆ˜ íƒ€ì…ì„ ì ‘ë¯¸ì‚¬ë¡œ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. "
"'2u64'ëŠ” ëª…ì‹œì ìœ¼ë¡œ 'u64'ë¼ê³  ì •í•´ì§„ 2ì…ë‹ˆë‹¤."

#: src/02_basic_calculator/01_integers.md:70
msgid "Underscores in literals"
msgstr "ë¦¬í„°ëŸ´ì—ì„œì˜ ë°‘ì¤„"

#: src/02_basic_calculator/01_integers.md:72
msgid ""
"You can use underscores `_` to improve the readability of large numbers.  \n"
"For example, `1_000_000` is the same as `1000000`."
msgstr ""
"ë°‘ì¤„ '_'ì„ ì‚¬ìš©í•˜ë©´ í° ìˆ«ìì˜ ê°€ë…ì„±ì„ ë†’ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"ì˜ˆë¥¼ ë“¤ì–´ '1_000_000'ì€ '1000000'ê³¼ ë™ì¼í•©ë‹ˆë‹¤."

#: src/02_basic_calculator/01_integers.md:75
msgid "Arithmetic operators"
msgstr "ì‚°ìˆ  ì—°ì‚°ì"

#: src/02_basic_calculator/01_integers.md:77
msgid "Rust supports the following arithmetic operators[^traits] for integers:"
msgstr "RustëŠ” ì •ìˆ˜ì— ëŒ€í•´ ë‹¤ìŒê³¼ ê°™ì€ ì‚°ìˆ  ì—°ì‚°ì[^traits]ë¥¼ ì§€ì›í•©ë‹ˆë‹¤:"

#: src/02_basic_calculator/01_integers.md:79
msgid "`+` for addition"
msgstr "`+` ë”í•˜ê¸°"

#: src/02_basic_calculator/01_integers.md:80
msgid "`-` for subtraction"
msgstr "`-` ë¹¼ê¸°"

#: src/02_basic_calculator/01_integers.md:81
msgid "`*` for multiplication"
msgstr "`*` ê³±í•˜ê¸°"

#: src/02_basic_calculator/01_integers.md:82
msgid "`/` for division"
msgstr "`/` ë‚˜ëˆ„ê¸°"

#: src/02_basic_calculator/01_integers.md:83
msgid "`%` for remainder"
msgstr "`%` ë‚˜ë¨¸ì§€"

#: src/02_basic_calculator/01_integers.md:85
msgid ""
"Precedence and associativity rules for these operators are the same as in "
"mathematics.  \n"
"You can use parentheses to override the default precedence. E.g. `2 * (3 + "
"4)`."
msgstr ""
"ì´ëŸ¬í•œ ì—°ì‚°ìì˜ ìš°ì„ ìˆœìœ„ ë° ê²°í•©ì„± ê·œì¹™ì€ ìˆ˜í•™ê³¼ ë™ì¼í•©ë‹ˆë‹¤.  \n"
"ê´„í˜¸ë¥¼ ì‚¬ìš©í•˜ì—¬ ê¸°ë³¸ ìš°ì„  ìˆœìœ„ë¥¼ ì¬ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆ: `2 * (3 + 4)`."

#: src/02_basic_calculator/01_integers.md:88
msgid "âš ï¸ **Warning**"
msgstr "âš ï¸ **ê²½ê³ **"

#: src/02_basic_calculator/01_integers.md:90
msgid ""
"The division operator `/` performs integer division when used with integer "
"types. I.e. the result is truncated towards zero. For example, `5 / 2` is "
"`2`, not `2.5`."
msgstr ""
"ë‚˜ëˆ„ê¸° ì—°ì‚°ì '/'ëŠ” ì •ìˆ˜ ìœ í˜•ê³¼ í•¨ê»˜ ì‚¬ìš©ë  ë•Œ ì •ìˆ˜ ë‚˜ëˆ„ê¸°ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤. ì¦‰. "
"ê²°ê³¼ëŠ” 0ìª½ìœ¼ë¡œ ì˜ë¦½ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ '5/2'ëŠ” '2.5'ê°€ ì•„ë‹ˆë¼ '2'ì…ë‹ˆë‹¤."

#: src/02_basic_calculator/01_integers.md:93
msgid "No automatic type coercion"
msgstr "ìë™ íƒ€ì… ë³€í™˜ ì—†ìŒ"

#: src/02_basic_calculator/01_integers.md:95
msgid ""
"As we discussed in the previous exercise, Rust is a statically typed "
"language.  \n"
"In particular, Rust is quite strict about type coercion. It won't "
"automatically convert a value from one type to another[^coercion], even if "
"the conversion is lossless. You have to do it explicitly."
msgstr ""
"ì´ì „ ì—°ìŠµì—ì„œ ë…¼ì˜í•œ ê²ƒì²˜ëŸ¼ RustëŠ” ì •ì ìœ¼ë¡œ íƒ€ì…ì´ ì§€ì •ëœ ì–¸ì–´ì…ë‹ˆë‹¤.  \n"
"íŠ¹íˆ RustëŠ” íƒ€ì… ê°•ì œì— ëŒ€í•´ ìƒë‹¹íˆ ì—„ê²©í•©ë‹ˆë‹¤. íƒ€ì… ë³€í™˜ì´ ë¬´ì†ì‹¤ì´ë”ë¼ë„ ì"
"ë™ìœ¼ë¡œ ê°’ì„ í•œ íƒ€ì…ì—ì„œ ë‹¤ë¥¸ íƒ€ì…ìœ¼ë¡œ ë³€í™˜[^coercion]í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ëª…ì‹œì ìœ¼"
"ë¡œ í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/02_basic_calculator/01_integers.md:100
msgid ""
"For example, you can't assign a `u8` value to a variable with type `u32`, "
"even though all `u8` values are valid `u32` values:"
msgstr ""
"ì˜ˆë¥¼ ë“¤ì–´, ëª¨ë“  `u8` ê°’ì´ ìœ íš¨í•œ `u32` ê°’ì´ë”ë¼ë„ `u32` íƒ€ì…ì— `u8`íƒ€ì…ì˜ ê°’"
"ì„ í• ë‹¹í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤:"

#: src/02_basic_calculator/01_integers.md:108
msgid "It'll throw a compilation error:"
msgstr "ì»´íŒŒì¼ ì˜¤ë¥˜ê°€ ë°œìƒí•©ë‹ˆë‹¤:"

#: src/02_basic_calculator/01_integers.md:120
msgid ""
"We'll see how to convert between types [later in this course]"
"(../04_traits/09_from.md)."
msgstr ""
"[ì´ ì½”ìŠ¤ì˜ ë’·ë¶€ë¶„](../04_traits/09_from.md)ì—ì„œ íƒ€ì… ê°„ ë³€í™˜ ë°©ë²•ì„ ì‚´í´ë³´ê² ìŠµ"
"ë‹ˆë‹¤."

#: src/02_basic_calculator/01_integers.md:122
#: src/02_basic_calculator/04_panics.md:44
#: src/02_basic_calculator/06_while.md:83 src/02_basic_calculator/07_for.md:57
#: src/02_basic_calculator/08_overflow.md:103
#: src/02_basic_calculator/10_as_casting.md:97
#: src/03_ticket_v1/02_validation.md:18 src/04_traits/02_orphan_rule.md:108
#: src/04_traits/04_derive.md:100 src/05_ticket_v2/15_outro.md:15
#: src/06_ticket_management/07_combinators.md:103
#: src/07_threads/02_static.md:112 src/07_threads/11_locks.md:218
#: src/08_futures/05_blocking.md:76 src/08_futures/07_cancellation.md:101
msgid "Further reading"
msgstr "ì½ì„ê±°ë¦¬"

#: src/02_basic_calculator/01_integers.md:124
msgid ""
"[The integer types section](https://doc.rust-lang.org/book/ch03-02-data-types."
"html#integer-types) in the official Rust book"
msgstr ""
"ê³µì‹ Rust bookì˜ [ì •ìˆ˜ íƒ€ì… ì„¹ì…˜](https://doc.rust-lang.org/book/ch03-02-data-"
"types.html#integer-types)"

#: src/02_basic_calculator/01_integers.md:126
msgid ""
"A bit is the smallest unit of data in a computer. It can only have two "
"values: `0` or `1`."
msgstr ""
"ë¹„íŠ¸ëŠ” ì»´í“¨í„°ì˜ ê°€ì¥ ì‘ì€ ë°ì´í„° ë‹¨ìœ„ì…ë‹ˆë‹¤. '0' ë˜ëŠ” '1'ì˜ ë‘ ê°€ì§€ ê°’ë§Œ ê°€ì§ˆ "
"ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/02_basic_calculator/01_integers.md:128
msgid ""
"Rust doesn't let you define custom operators, but it puts you in control of "
"how the built-in operators behave. We'll talk about operator overloading "
"[later in the course](../04_traits/03_operator_overloading.md), after we've "
"covered traits."
msgstr ""
"Rustì—ì„œëŠ” ì‚¬ìš©ì ì •ì˜ ì—°ì‚°ìë¥¼ ì •ì˜í•  ìˆ˜ ì—†ì§€ë§Œ ë‚´ì¥ ì—°ì‚°ìì˜ ì‘ë™ ë°©ì‹ì„ ì œ"
"ì–´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‚˜ì¤‘ì— Traitì— ëŒ€í•´ ë‹¤ë£¬ í›„ ì—°ì‚°ì ì˜¤ë²„ë¡œë”©ì— ëŒ€í•´ ì„¤ëª…í•˜ê² "
"ìŠµë‹ˆë‹¤."

#: src/02_basic_calculator/01_integers.md:132
msgid ""
"There are some exceptions to this rule, mostly related to references, smart "
"pointers and ergonomics. We'll cover those [later on](../04_traits/07_deref."
"md). A mental model of \"all conversions are explicit\" will serve you well "
"in the meantime."
msgstr ""
"ì´ ê·œì¹™ì—ëŠ” ì£¼ë¡œ ì°¸ì¡°, ìŠ¤ë§ˆíŠ¸ í¬ì¸í„° ë° ì¸ì²´ ê³µí•™ê³¼ ê´€ë ¨ëœ ëª‡ ê°€ì§€ ì˜ˆì™¸ê°€ ìˆìŠµ"
"ë‹ˆë‹¤. ì´ì— ëŒ€í•´ì„œëŠ” [ë‚˜ì¤‘ì—](../04_traits/07_deref.md) ë‹¤ë£¨ê² ìŠµë‹ˆë‹¤. ê·¸ ì „ê¹Œì§€"
"ëŠ” \"ëª¨ë“  íƒ€ì… ë³€í™˜ì´ ëª…ì‹œì \"ì´ë¼ëŠ” ì •ì‹ ì´ ë„ì›€ì´ ë  ê²ƒì…ë‹ˆë‹¤."

#: src/02_basic_calculator/01_integers.md:138
msgid ""
"The exercise for this section is located in "
"[`02_basic_calculator/01_integers`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/01_integers)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`02_basic_calculator/01_integers`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/01_integers)ì— ìˆìŠµë‹ˆë‹¤"

#: src/02_basic_calculator/02_variables.md:3
msgid ""
"In Rust, you can use the `let` keyword to declare **variables**.  \n"
"For example:"
msgstr ""
"Rustì—ì„œëŠ” `let` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ **ë³€ìˆ˜**ë¥¼ ì„ ì–¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"ì˜ˆì‹œ:"

#: src/02_basic_calculator/02_variables.md:10
msgid "Above we defined a variable `x` and assigned it the value `42`."
msgstr "ìœ„ì—ì„œëŠ” ë³€ìˆ˜ `x`ë¥¼ ì •ì˜í•˜ê³  ê°’ `42`ë¥¼ í• ë‹¹í–ˆìŠµë‹ˆë‹¤."

#: src/02_basic_calculator/02_variables.md:12
msgid "Type"
msgstr "íƒ€ì…"

#: src/02_basic_calculator/02_variables.md:14
msgid ""
"Every variable in Rust must have a type. It can either be inferred by the "
"compiler or explicitly specified by the developer."
msgstr ""
"Rustì˜ ëª¨ë“  ë³€ìˆ˜ì—ëŠ” íƒ€ì…ì´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤. ì´ëŠ” ì»´íŒŒì¼ëŸ¬ì— ì˜í•´ ìœ ì¶”ë˜ê±°ë‚˜ ê°œ"
"ë°œìê°€ ëª…ì‹œì ìœ¼ë¡œ ì§€ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/02_basic_calculator/02_variables.md:17
msgid "Explicit type annotation"
msgstr "ëª…ì‹œì  íƒ€ì… ì–´ë…¸í…Œì´ì…˜"

#: src/02_basic_calculator/02_variables.md:19
msgid ""
"You can specify the variable type by adding a colon `:` followed by the type "
"after the variable name. For example:"
msgstr ""
"ë³€ìˆ˜ ì´ë¦„ ë’¤ì— ì½œë¡  `:`ì„ ì¶”ê°€í•˜ê³  íƒ€ì…ì„ ì¶”ê°€í•˜ì—¬ ë³€ìˆ˜ íƒ€ì…ì„ ì§€ì •í•  ìˆ˜ ìˆìŠµ"
"ë‹ˆë‹¤. ì˜ˆì‹œ:"

#: src/02_basic_calculator/02_variables.md:22
msgid "// let <variable_name>: <type> = <expression>;\n"
msgstr "// let <variable_name>: <type> = <expression>;\n"

#: src/02_basic_calculator/02_variables.md:26
msgid ""
"In the example above, we explicitly constrained the type of `x` to be `u32`."
msgstr "ìœ„ì˜ ì˜ˆì—ì„œëŠ” `x`ì˜ íƒ€ì…ì„ `u32`ë¡œ ëª…ì‹œì ìœ¼ë¡œ ì œí•œí–ˆìŠµë‹ˆë‹¤."

#: src/02_basic_calculator/02_variables.md:28
msgid "Type inference"
msgstr "íƒ€ì… ì¶”ë¡ "

#: src/02_basic_calculator/02_variables.md:30
msgid ""
"If we don't specify the type of a variable, the compiler will try to infer it "
"based on the context in which the variable is used."
msgstr ""
"ë³€ìˆ˜ íƒ€ì…ì„ ì§€ì •í•˜ì§€ ì•Šìœ¼ë©´ ì»´íŒŒì¼ëŸ¬ëŠ” ë³€ìˆ˜ê°€ ì‚¬ìš©ë˜ëŠ” ì»¨í…ìŠ¤íŠ¸ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë³€"
"ìˆ˜ íƒ€ì…ì„ ì¶”ë¡ í•˜ë ¤ê³  ì‹œë„í•©ë‹ˆë‹¤."

#: src/02_basic_calculator/02_variables.md:38
msgid ""
"In the example above, we didn't specify the type of `x`.  \n"
"`x` is later assigned to `y`, which is explicitly typed as `u32`. Since Rust "
"doesn't perform automatic type coercion, the compiler infers the type of `x` "
"to be `u32`â€”the same as `y` and the only type that will allow the program to "
"compile without errors."
msgstr ""
"ìœ„ì˜ ì˜ˆì—ì„œëŠ” `x`ì˜ íƒ€ì…ì„ ì§€ì •í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.  \n"
"`x`ëŠ” ë‚˜ì¤‘ì— ëª…ì‹œì ìœ¼ë¡œ `u32`ë¡œ ì…ë ¥ë˜ëŠ” `y`ì— í• ë‹¹ë©ë‹ˆë‹¤. RustëŠ” ìë™ íƒ€ì… ê°•"
"ì œ ë³€í™˜ì„ ìˆ˜í–‰í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ì»´íŒŒì¼ëŸ¬ëŠ” `x`ì˜ íƒ€ì…ì„ `u32`ë¡œ ì¶”ë¡ í•©ë‹ˆë‹¤. ì´"
"ëŠ” `y`ì™€ ë™ì¼í•˜ê³  í”„ë¡œê·¸ë¨ì´ ì˜¤ë¥˜ ì—†ì´ ì»´íŒŒì¼í•  ìˆ˜ ìˆê²Œ í•´ì£¼ëŠ” ìœ ì¼í•œ íƒ€ì…ì…ë‹ˆ"
"ë‹¤."

#: src/02_basic_calculator/02_variables.md:43
msgid "Inference limitations"
msgstr "ì¶”ë¡ ì˜ í•œê³„"

#: src/02_basic_calculator/02_variables.md:45
msgid ""
"The compiler sometimes needs a little help to infer the correct variable type "
"based on its usage.  \n"
"In those cases you'll get a compilation error and the compiler will ask you "
"to provide an explicit type hint to disambiguate the situation."
msgstr ""
"ì»´íŒŒì¼ëŸ¬ëŠ” ì‚¬ìš©ë²•ì— ë”°ë¼ ì˜¬ë°”ë¥¸ ë³€ìˆ˜ íƒ€ì…ì„ ìœ ì¶”í•˜ê¸° ìœ„í•´ ì•½ê°„ì˜ ë„ì›€ì´ í•„ìš”"
"í•œ ê²½ìš°ê°€ ìˆìŠµë‹ˆë‹¤.  \n"
"ì´ëŸ¬í•œ ê²½ìš° ì»´íŒŒì¼ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ê³  ì»´íŒŒì¼ëŸ¬ëŠ” ìƒí™©ì„ ëª…í™•í•˜ê²Œ í•˜ê¸° ìœ„í•´ ëª…ì‹œì "
"ì¸ íƒ€ì… íŒíŠ¸ë¥¼ ì œê³µí•˜ë„ë¡ ìš”ì²­í•©ë‹ˆë‹¤."

#: src/02_basic_calculator/02_variables.md:49
msgid "Function arguments are variables"
msgstr "í•¨ìˆ˜ ì¸ìˆ˜ëŠ” ë³€ìˆ˜ì…ë‹ˆë‹¤"

#: src/02_basic_calculator/02_variables.md:51
msgid ""
"Not all heroes wear capes, not all variables are declared with `let`.  \n"
"Function arguments are variables too!"
msgstr ""
"ëª¨ë“  ì˜ì›…ì´ ë§í† ë¥¼ ì…ëŠ” ê²ƒì€ ì•„ë‹ˆë©°, ëª¨ë“  ë³€ìˆ˜ê°€ `let`ìœ¼ë¡œ ì„ ì–¸ë˜ëŠ” ê²ƒì€ ì•„ë‹™"
"ë‹ˆë‹¤.  \n"
"í•¨ìˆ˜ ì¸ìˆ˜ë„ ë³€ìˆ˜ì…ë‹ˆë‹¤!"

#: src/02_basic_calculator/02_variables.md:60
msgid ""
"In the example above, `x` is a variable of type `u32`.  \n"
"The only difference between `x` and a variable declared with `let` is that "
"functions arguments **must** have their type explicitly declared. The "
"compiler won't infer it for you.  \n"
"This constraint allows the Rust compiler (and us humans!) to understand the "
"function's signature without having to look at its implementation. That's a "
"big boost for compilation speed[^speed]!"
msgstr ""
"ìœ„ì˜ ì˜ˆì—ì„œ `x`ëŠ” `u32` íƒ€ì…ì˜ ë³€ìˆ˜ì…ë‹ˆë‹¤.  \n"
"`x`ì™€ `let`ìœ¼ë¡œ ì„ ì–¸ëœ ë³€ìˆ˜ì˜ ìœ ì¼í•œ ì°¨ì´ì ì€ í•¨ìˆ˜ ì¸ìˆ˜ **ë°˜ë“œì‹œ** í•´ë‹¹ íƒ€ì…"
"ì´ ëª…ì‹œì ìœ¼ë¡œ ì„ ì–¸ë˜ì–´ì•¼ í•œë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” ì´ë¥¼ ì¶”ë¡ í•˜ì§€ ì•ŠìŠµë‹ˆ"
"ë‹¤.  \n"
"ì´ ì œì•½ì€ Rust ì»´íŒŒì¼ëŸ¬(ê·¸ë¦¬ê³  ìš°ë¦¬ ì¸ê°„ë„!)ê°€ êµ¬í˜„ì„ ì‚´í´ë³´ì§€ ì•Šê³ ë„ í•¨ìˆ˜ì˜ "
"ì‹œê·¸ë‹ˆì²˜ë¥¼ ì´í•´í•  ìˆ˜ ìˆê²Œ í•´ì¤ë‹ˆë‹¤. ì´ëŠ” ì»´íŒŒì¼ ì†ë„[^speed]ë¥¼ í¬ê²Œ í–¥ìƒì‹œí‚µë‹ˆ"
"ë‹¤!"

#: src/02_basic_calculator/02_variables.md:66
msgid "Initialization"
msgstr "ì´ˆê¸°í™”"

#: src/02_basic_calculator/02_variables.md:68
msgid ""
"You don't have to initialize a variable when you declare it.  \n"
"For example"
msgstr ""
"ë³€ìˆ˜ë¥¼ ì„ ì–¸í•  ë•Œ ë³€ìˆ˜ë¥¼ ì´ˆê¸°í™”í•  í•„ìš”ëŠ” ì—†ìŠµë‹ˆë‹¤.  \n"
"ì˜ˆë¥¼ ë“¤ì–´"

#: src/02_basic_calculator/02_variables.md:75
msgid ""
"is a valid variable declaration.  \n"
"However, you must initialize the variable before using it. The compiler will "
"throw an error if you don't:"
msgstr ""
"ìœ íš¨í•œ ë³€ìˆ˜ ì„ ì–¸ì…ë‹ˆë‹¤.  \n"
"ê·¸ëŸ¬ë‚˜ ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ê¸° ì „ì— ì´ˆê¸°í™”í•´ì•¼ í•©ë‹ˆë‹¤. ë‹¤ìŒì„ ìˆ˜í–‰í•˜ì§€ ì•Šìœ¼ë©´ ì»´íŒŒì¼ëŸ¬"
"ì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí•©ë‹ˆë‹¤:"

#: src/02_basic_calculator/02_variables.md:83
msgid "will throw a compilation error:"
msgstr "ì»´íŒŒì¼ ì˜¤ë¥˜ê°€ ë°œìƒí•©ë‹ˆë‹¤:"

#: src/02_basic_calculator/02_variables.md:100
msgid ""
"The Rust compiler needs all the help it can get when it comes to compilation "
"speed."
msgstr "Rust ì»´íŒŒì¼ëŸ¬ëŠ” ì»´íŒŒì¼ ì†ë„ë¥¼ ìœ„í•œ ì–´ë–¤ ë„ì›€ì´ë¼ë„ í•„ìš”ë¡œí•©ë‹ˆë‹¤."

#: src/02_basic_calculator/02_variables.md:104
msgid ""
"The exercise for this section is located in "
"[`02_basic_calculator/02_variables`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/02_variables)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`02_basic_calculator/02_variables`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/02_variables)ì— ìˆìŠµë‹ˆë‹¤"

#: src/02_basic_calculator/03_if_else.md:1
msgid "Control flow, part 1"
msgstr "íë¦„ ì œì–´, part 1"

#: src/02_basic_calculator/03_if_else.md:3
msgid ""
"All our programs so far have been pretty straightforward.  \n"
"A sequence of instructions is executed from top to bottom, and that's it."
msgstr ""
"ì§€ê¸ˆê¹Œì§€ ìš°ë¦¬ì˜ ëª¨ë“  í”„ë¡œê·¸ë¨ì€ ë§¤ìš° ê°„ë‹¨í–ˆìŠµë‹ˆë‹¤.  \n"
"ì¼ë ¨ì˜ ëª…ë ¹ì´ ìœ„ì—ì„œ ì•„ë˜ë¡œ ì‹¤í–‰ë©ë‹ˆë‹¤."

#: src/02_basic_calculator/03_if_else.md:6
msgid "It's time to introduce some **branching**."
msgstr "ì´ì œ ëª‡ ê°€ì§€ **ë¶„ê¸°**ë¥¼ ì†Œê°œí•  ì‹œê°„ì…ë‹ˆë‹¤."

#: src/02_basic_calculator/03_if_else.md:8
msgid "`if` clauses"
msgstr "`if` ë¬¸"

#: src/02_basic_calculator/03_if_else.md:10
msgid ""
"The `if` keyword is used to execute a block of code only if a condition is "
"true."
msgstr "`if` í‚¤ì›Œë“œëŠ” ì¡°ê±´ì´ ì°¸ì¸ ê²½ìš°ì—ë§Œ ì½”ë“œ ë¸”ë¡ì„ ì‹¤í–‰í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤."

#: src/02_basic_calculator/03_if_else.md:12
msgid "Here's a simple example:"
msgstr "ê°„ë‹¨í•œ ì˜ˆëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/02_basic_calculator/03_if_else.md:17
#: src/02_basic_calculator/03_if_else.md:33
msgid "\"`number` is smaller than 5\""
msgstr "\"`number` is smaller than 5\""

#: src/02_basic_calculator/03_if_else.md:21
msgid ""
"This program will print `number is smaller than 5` because the condition "
"`number < 5` is true."
msgstr ""
"ì´ í”„ë¡œê·¸ë¨ì€ `number < 5` ì¡°ê±´ì´ trueì´ê¸° ë•Œë¬¸ì— `number is less than 5`ë¥¼ í”„"
"ë¦°íŠ¸í•©ë‹ˆë‹¤."

#: src/02_basic_calculator/03_if_else.md:23
msgid "`else` clauses"
msgstr "`else` ë¬¸"

#: src/02_basic_calculator/03_if_else.md:25
msgid ""
"Like most programming languages, Rust supports an optional `else` branch to "
"execute a block of code when the condition in an `if` expression is false.  \n"
"For example:"
msgstr ""
"ëŒ€ë¶€ë¶„ì˜ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì™€ ë§ˆì°¬ê°€ì§€ë¡œ RustëŠ” `if` í‘œí˜„ì‹ì˜ ì¡°ê±´ì´ ê±°ì§“ì¼ ë•Œ ì½”"
"ë“œ ë¸”ë¡ì„ ì‹¤í–‰í•˜ê¸° ìœ„í•œ ì„ íƒì ì¸ `else` ë¶„ê¸°ë¥¼ ì§€ì›í•©ë‹ˆë‹¤.  \n"
"ì˜ˆì‹œ:"

#: src/02_basic_calculator/03_if_else.md:35
msgid "\"`number` is greater than or equal to 5\""
msgstr "\"`number` is greater than or equal to 5\""

#: src/02_basic_calculator/03_if_else.md:39
msgid "Booleans"
msgstr "ë¶ˆë¦¬ì–¸"

#: src/02_basic_calculator/03_if_else.md:41
msgid ""
"The condition in an `if` expression must be of type `bool`, a **boolean**.  \n"
"Booleans, just like integers, are a primitive type in Rust."
msgstr ""
"`if` í‘œí˜„ì‹ì˜ ì¡°ê±´ì€ `bool` íƒ€ì…ì˜ **ë¶ˆë¦¬ì–¸**ì´ì–´ì•¼ í•©ë‹ˆë‹¤.  \n"
"ì •ìˆ˜ì™€ ë§ˆì°¬ê°€ì§€ë¡œ ë¶ˆë¦¬ì–¸ë„ Rustì˜ ì›ì‹œ íƒ€ì…ì…ë‹ˆë‹¤."

#: src/02_basic_calculator/03_if_else.md:44
msgid "A boolean can have one of two values: `true` or `false`."
msgstr "ë¶ˆë¦¬ì–¸ì€ `true` ë˜ëŠ” `false`ë¼ëŠ” ë‘ ê°€ì§€ ê°’ ì¤‘ í•˜ë‚˜ë¥¼ ê°€ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/02_basic_calculator/03_if_else.md:46
msgid "No truthy or falsy values"
msgstr "ì°¸ í˜¹ì€ ê±°ì§“ì´ ì•„ë‹Œ ê²½ã…‡"

#: src/02_basic_calculator/03_if_else.md:48
msgid ""
"If the condition in an `if` expression is not a boolean, you'll get a "
"compilation error."
msgstr "`if` í‘œí˜„ì‹ì˜ ì¡°ê±´ì´ ë¶ˆë¦¬ì–¸ì´ ì•„ë‹Œ ê²½ìš° ì»´íŒŒì¼ ì˜¤ë¥˜ê°€ ë°œìƒí•©ë‹ˆë‹¤."

#: src/02_basic_calculator/03_if_else.md:50
msgid "For example, the following code will not compile:"
msgstr "ì˜ˆë¥¼ ë“¤ì–´ ë‹¤ìŒ ì½”ë“œëŠ” ì»´íŒŒì¼ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤:"

#: src/02_basic_calculator/03_if_else.md:55
msgid "\"`number` is not zero\""
msgstr "\"`number` is not zero\""

#: src/02_basic_calculator/03_if_else.md:59
msgid "You'll get the following compilation error:"
msgstr "ë‹¤ìŒê³¼ ê°™ì€ ì»´íŒŒì¼ ì˜¤ë¥˜ê°€ ë°œìƒí•©ë‹ˆë‹¤:"

#: src/02_basic_calculator/03_if_else.md:69
msgid ""
"This follows from Rust's philosophy around type coercion: there's no "
"automatic conversion from non-boolean types to booleans. Rust doesn't have "
"the concept of **truthy** or **falsy** values, like JavaScript or Python.  \n"
"You have to be explicit about the condition you want to check."
msgstr ""
"ì´ëŠ” íƒ€ì… ê°•ì œì— ê´€í•œ Rustì˜ ì² í•™ì„ ë”°ë¥¸ ê²ƒì…ë‹ˆë‹¤. ì¦‰, ë¶ˆë¦¬ì–¸ì´ ì•„ë‹Œ íƒ€ì…ì—ì„œ "
"ë¶ˆë¦¬ì–¸ìœ¼ë¡œì˜ ìë™ ë³€í™˜ì€ ì—†ìŠµë‹ˆë‹¤. Rustì—ëŠ” JavaScriptë‚˜ Pythonì²˜ëŸ¼ **ì°¸** ë˜"
"ëŠ” **ê±°ì§“** ê°’ì´ë¼ëŠ” ê°œë…ì´ ì—†ìŠµë‹ˆë‹¤.  \n"
"í™•ì¸í•˜ë ¤ëŠ” ì¡°ê±´ì— ëŒ€í•´ ëª…ì‹œì ìœ¼ë¡œ ì„¤ëª…í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/02_basic_calculator/03_if_else.md:75
msgid ""
"It's quite common to use comparison operators to build conditions for `if` "
"expressions.  \n"
"Here are the comparison operators available in Rust when working with "
"integers:"
msgstr ""
"`if` í‘œí˜„ì‹ì˜ ì¡°ê±´ì„ ì‘ì„±í•˜ê¸° ìœ„í•´ ë¹„êµ ì—°ì‚°ìë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì€ ë§¤ìš° ì¼ë°˜ì ì…ë‹ˆ"
"ë‹¤.  \n"
"ì •ìˆ˜ë¡œ ì‘ì—…í•  ë•Œ Rustì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë¹„êµ ì—°ì‚°ìëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/02_basic_calculator/03_if_else.md:78
msgid "`==`: equal to"
msgstr "`==`: ê°™ìŒ"

#: src/02_basic_calculator/03_if_else.md:79
msgid "`!=`: not equal to"
msgstr "`!=`: ê°™ì§€ ì•ŠìŒ"

#: src/02_basic_calculator/03_if_else.md:80
msgid "`<`: less than"
msgstr "`<`: ë¯¸ë§Œ"

#: src/02_basic_calculator/03_if_else.md:81
msgid "`>`: greater than"
msgstr "`>`: ì´ˆê³¼"

#: src/02_basic_calculator/03_if_else.md:82
msgid "`<=`: less than or equal to"
msgstr "`<=`: ì‘ê±°ë‚˜ ê°™ìŒ"

#: src/02_basic_calculator/03_if_else.md:83
msgid "`>=`: greater than or equal to"
msgstr "`>=`: í¬ê±°ë‚˜ ê°™ìŒ"

#: src/02_basic_calculator/03_if_else.md:85
msgid "`if/else` is an expression"
msgstr "`if/else`ëŠ” í‘œí˜„ì‹ì…ë‹ˆë‹¤"

#: src/02_basic_calculator/03_if_else.md:87
msgid ""
"In Rust, `if` expressions are **expressions**, not statements: they return a "
"value.  \n"
"That value can be assigned to a variable or used in other expressions. For "
"example:"
msgstr ""
"Rustì—ì„œ `if` í‘œí˜„ì‹ì€ ëª…ë ¹ë¬¸ì´ ì•„ë‹Œ **í‘œí˜„ì‹**ì…ë‹ˆë‹¤. ì¦‰, ê°’ì„ ë°˜í™˜í•©ë‹ˆ"
"ë‹¤.  \n"
"í•´ë‹¹ ê°’ì€ ë³€ìˆ˜ì— í• ë‹¹ë˜ê±°ë‚˜ ë‹¤ë¥¸ í‘œí˜„ì‹ì— ì‚¬ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆì‹œ:"

#: src/02_basic_calculator/03_if_else.md:93
msgid "\"smaller than 5\""
msgstr "\"smaller than 5\""

#: src/02_basic_calculator/03_if_else.md:95
msgid "\"greater than or equal to 5\""
msgstr "\"greater than or equal to 5\""

#: src/02_basic_calculator/03_if_else.md:99
msgid ""
"In the example above, each branch of the `if` evaluates to a string literal, "
"which is then assigned to the `message` variable.  \n"
"The only requirement is that both `if` branches return the same type."
msgstr ""
"ìœ„ì˜ ì˜ˆì—ì„œ `if`ì˜ ê° ë¶„ê¸°ëŠ” ë¬¸ìì—´ ë¦¬í„°ëŸ´ë¡œ í‰ê°€ëœ ë‹¤ìŒ `message` ë³€ìˆ˜ì— í• ë‹¹"
"ë©ë‹ˆë‹¤.  \n"
"ìœ ì¼í•œ ìš”êµ¬ ì‚¬í•­ì€ ë‘ `if` ë¶„ê¸°ê°€ ë™ì¼í•œ íƒ€ì…ì„ ë°˜í™˜í•œë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/02_basic_calculator/03_if_else.md:105
msgid ""
"The exercise for this section is located in [`02_basic_calculator/03_if_else`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/03_if_else)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`02_basic_calculator/03_if_else`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/03_if_else)ì— ìˆìŠµë‹ˆë‹¤"

#: src/02_basic_calculator/04_panics.md:3
msgid ""
"Let's go back to the `speed` function you wrote for the [\"Variables\" "
"section](02_variables.md). It probably looked something like this:"
msgstr ""
"[\"ë³€ìˆ˜\" ì„¹ì…˜](02_variables.md)ì— ì‘ì„±í•œ `speed` í•¨ìˆ˜ë¡œ ëŒì•„ê°€ ë³´ê² ìŠµë‹ˆë‹¤. ì•„"
"ë§ˆë„ ë‹¤ìŒê³¼ ê°™ì•˜ì„ ê²ƒì…ë‹ˆë‹¤:"

#: src/02_basic_calculator/04_panics.md:13
msgid ""
"If you have a keen eye, you might have spotted one issue[^one]: what happens "
"if `time_elapsed` is zero?"
msgstr ""
"ì˜ˆë¦¬í•œ ëˆˆì„ ê°–ê³  ê³„ì‹œë‹¤ë©´ í•œ ê°€ì§€ ë¬¸ì œë¥¼ ë°œê²¬í•˜ì…¨ì„ ê²ƒì…ë‹ˆë‹¤[^one]: "
"`time_elapsed`ê°€ 0ì´ë©´ ì–´ë–»ê²Œ ë ê¹Œìš”?"

#: src/02_basic_calculator/04_panics.md:15
msgid ""
"You can try it out [on the Rust playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=36e5ddbe3b3f741dfa9f74c956622bac)!  \n"
"The program will exit with the following error message:"
msgstr ""
"[Rust playgroundì—ì„œ](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=36e5ddbe3b3f741dfa9f74c956622bac) "
"í•´ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤!  \n"
"í”„ë¡œê·¸ë¨ì€ ë‹¤ìŒ ì˜¤ë¥˜ ë©”ì‹œì§€ì™€ í•¨ê»˜ ì¢…ë£Œë©ë‹ˆë‹¤:"

#: src/02_basic_calculator/04_panics.md:24
msgid ""
"This is known as a **panic**.  \n"
"A panic is Rust's way to signal that something went so wrong that the program "
"can't continue executing, it's an **unrecoverable error**[^catching]. "
"Division by zero classifies as such an error."
msgstr ""
"ì´ë¥¼ **íŒ¨ë‹‰**ì´ë¼ê³  í•©ë‹ˆë‹¤.  \n"
"íŒ¨ë‹‰ì€ ë¬´ì–¸ê°€ ì˜ëª»ë˜ì–´ í”„ë¡œê·¸ë¨ì´ ê³„ì† ì‹¤í–‰ë  ìˆ˜ ì—†ìŒì„ ì•Œë¦¬ëŠ” Rustì˜ ë°©ë²•ì…ë‹ˆ"
"ë‹¤. ì´ëŠ” **ë³µêµ¬í•  ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜**[^catching]ì…ë‹ˆë‹¤. 0ìœ¼ë¡œ ë‚˜ëˆ„ëŠ” ê²ƒì€ ì´ëŸ¬í•œ ì˜¤"
"ë¥˜ë¡œ ë¶„ë¥˜ë©ë‹ˆë‹¤."

#: src/02_basic_calculator/04_panics.md:29
msgid "The panic! macro"
msgstr "panic! ë§¤í¬ë¡œ"

#: src/02_basic_calculator/04_panics.md:31
msgid ""
"You can intentionally trigger a panic by calling the `panic!` macro[^macro]:"
msgstr ""
"`panic!` ë§¤í¬ë¡œ[^macro]ë¥¼ í˜¸ì¶œí•˜ì—¬ ì˜ë„ì ìœ¼ë¡œ íŒ¨ë‹‰ì„ ìœ ë°œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/02_basic_calculator/04_panics.md:35
msgid "\"This is a panic!\""
msgstr "\"This is a panic!\""

#: src/02_basic_calculator/04_panics.md:36
msgid "// The line below will never be executed\n"
msgstr "// ì•„ë˜ ì¤„ì€ ì ˆëŒ€ ì‹¤í–‰ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤\n"

#: src/02_basic_calculator/04_panics.md:41
msgid ""
"There are other mechanisms to work with recoverable errors in Rust, which "
"[we'll cover later](../05_ticket_v2/06_fallibility.md). For the time being "
"we'll stick with panics as a brutal but simple stopgap solution."
msgstr ""
"Rustì—ëŠ” ë³µêµ¬ ê°€ëŠ¥í•œ ì˜¤ë¥˜ë¥¼ ì²˜ë¦¬í•˜ëŠ” ë‹¤ë¥¸ ë©”ì»¤ë‹ˆì¦˜ì´ ìˆëŠ”ë°, ì´ì— ëŒ€í•´ì„œëŠ” [ë‚˜"
"ì¤‘ì— ë‹¤ë£¨ê² ìŠµë‹ˆë‹¤](../05_ticket_v2/06_fallibility.md). ë‹¹ë¶„ê°„ ìš°ë¦¬ëŠ” ë¬´ì‹í•˜ì§€"
"ë§Œ ê°„ë‹¨í•œ ì„ì‹œë°©í¸ìœ¼ë¡œ íŒ¨ë‹‰ì„ ê³ ìˆ˜í•  ê²ƒì…ë‹ˆë‹¤."

#: src/02_basic_calculator/04_panics.md:46
msgid ""
"[The panic! macro documentation](https://doc.rust-lang.org/std/macro.panic."
"html)"
msgstr "[panic! ë§¤í¬ë¡œ ë¬¸ì„œ](https://doc.rust-lang.org/std/macro.panic.html)"

#: src/02_basic_calculator/04_panics.md:48
msgid ""
"There's another issue with `speed` that we'll address soon enough. Can you "
"spot it?"
msgstr ""
"ìš°ë¦¬ê°€ ê³§ ë‹¤ë£¨ê²Œ ë  `speed` ì™€ ê´€ë ¨ëœ ë˜ ë‹¤ë¥¸ ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤. ë°œê²¬í•˜ì…¨ë‚˜ìš”?"

#: src/02_basic_calculator/04_panics.md:50
msgid ""
"You can try to catch a panic, but it should be a last resort attempt reserved "
"for very specific circumstances."
msgstr ""
"íŒ¨ë‹‰ì„ catch ì‹œë„í•  ìˆ˜ ìˆì§€ë§Œ ì´ëŠ” ë§¤ìš° íŠ¹ì •í•œ ìƒí™©ì—ì„œì˜ ìµœí›„ì˜ ìˆ˜ë‹¨ìœ¼ë¡œ ì‹œë„"
"í•´ì•¼í•©ë‹ˆë‹¤."

#: src/02_basic_calculator/04_panics.md:53
msgid ""
"If it's followed by a `!`, it's a macro invocation. Think of macros as spicy "
"functions for now. We'll cover them in more detail later in the course."
msgstr ""
"ë’¤ì— `!`ê°€ ì˜¤ë©´ ë§¤í¬ë¡œ í˜¸ì¶œì…ë‹ˆë‹¤. ì§€ê¸ˆì€ ë§¤í¬ë¡œë¥¼ ì–‘ë… í•¨ìˆ˜ë¡œ ìƒê°í•˜ì„¸ìš”. ì´ "
"ì½”ìŠ¤ì˜ ë’·ë¶€ë¶„ì—ì„œ ì´ì— ëŒ€í•´ ë” ìì„¸íˆ ë‹¤ë£¨ê² ìŠµë‹ˆë‹¤."

#: src/02_basic_calculator/04_panics.md:58
msgid ""
"The exercise for this section is located in [`02_basic_calculator/04_panics`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/04_panics)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`02_basic_calculator/04_panics`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/04_panics)ì— ìˆìŠµë‹ˆë‹¤"

#: src/02_basic_calculator/05_factorial.md:3
msgid "So far you've learned:"
msgstr "ì§€ê¸ˆê¹Œì§€ ë°°ìš´ ë‚´ìš©:"

#: src/02_basic_calculator/05_factorial.md:5
msgid "How to define a function"
msgstr "í•¨ìˆ˜ë¥¼ ì •ì˜í•˜ëŠ” ë°©ë²•"

#: src/02_basic_calculator/05_factorial.md:6
msgid "How to call a function"
msgstr "í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ëŠ” ë°©ë²•"

#: src/02_basic_calculator/05_factorial.md:7
msgid "Which integer types are available in Rust"
msgstr "Rustì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì •ìˆ˜ íƒ€ì…"

#: src/02_basic_calculator/05_factorial.md:8
msgid "Which arithmetic operators are available for integers"
msgstr "ì •ìˆ˜ì— ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì‚°ìˆ  ì—°ì‚°ì"

#: src/02_basic_calculator/05_factorial.md:9
msgid ""
"How to execute conditional logic via comparisons and `if`/`else` expressions"
msgstr "ë¹„êµ ë° `if`/`else` í‘œí˜„ì‹ì„ í†µí•´ ì¡°ê±´ ë¡œì§ ì‹¤í–‰í•˜ëŠ” ë°©ë²•"

#: src/02_basic_calculator/05_factorial.md:11
msgid "It looks like you're ready to tackle factorials!"
msgstr "íŒ©í† ë¦¬ì–¼ì„ ë‹¤ë£° ì¤€ë¹„ê°€ ëœ ê²ƒ ê°™ìŠµë‹ˆë‹¤!"

#: src/02_basic_calculator/05_factorial.md:15
msgid ""
"The exercise for this section is located in "
"[`02_basic_calculator/05_factorial`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/05_factorial)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`02_basic_calculator/05_factorial`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/05_factorial)ì— ìˆìŠµë‹ˆë‹¤"

#: src/02_basic_calculator/06_while.md:1
msgid "Loops, part 1: `while`"
msgstr "ë£¨í”„, part 1: `while`"

#: src/02_basic_calculator/06_while.md:3
msgid ""
"Your implementation of `factorial` has been forced to use recursion.  \n"
"This may feel natural to you, especially if you're coming from a functional "
"programming background. Or it may feel strange, if you're used to more "
"imperative languages like C or Python."
msgstr ""
"`factorial` êµ¬í˜„ì—ì„œëŠ” ì¬ê·€ë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.  \n"
"ì´ëŠ” íŠ¹íˆ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì— ëŒ€í•œ ë°°ê²½ ì§€ì‹ì´ ìˆëŠ” ê²½ìš° ìì—°ìŠ¤ëŸ½ê²Œ ëŠê»´ì§ˆ ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤. ë˜ëŠ” Cë‚˜ Pythonê³¼ ê°™ì€ ëª…ë ¹í˜• ì–¸ì–´ì— ìµìˆ™í•˜ë‹¤ë©´ ì´ìƒí•˜ê²Œ ëŠê»´ì§ˆ ìˆ˜"
"ë„ ìˆìŠµë‹ˆë‹¤."

#: src/02_basic_calculator/06_while.md:7
msgid ""
"Let's see how you can implement the same functionality using a **loop** "
"instead."
msgstr "ëŒ€ì‹  **ë£¨í”„**ë¥¼ ì‚¬ìš©í•˜ì—¬ ë™ì¼í•œ ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ëŠ” ë°©ë²•ì„ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤."

#: src/02_basic_calculator/06_while.md:9
msgid "The `while` loop"
msgstr "`while` ë£¨í”„"

#: src/02_basic_calculator/06_while.md:11
msgid ""
"A `while` loop is a way to execute a block of code as long as a **condition** "
"is true.  \n"
"Here's the general syntax:"
msgstr ""
"`while` ë£¨í”„ëŠ” **ì¡°ê±´**ì´ trueì¸ ë™ì•ˆ ì½”ë“œ ë¸”ë¡ì„ ì‹¤í–‰í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.  \n"
"ì¼ë°˜ì ì¸ ë¬¸ë²•ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/02_basic_calculator/06_while.md:16 src/02_basic_calculator/07_for.md:14
msgid "// code to execute\n"
msgstr "// ì‹¤í–‰í•  ì½”ë“œ\n"

#: src/02_basic_calculator/06_while.md:20
msgid "For example, we might want to sum the numbers from 1 to 5:"
msgstr "ì˜ˆë¥¼ ë“¤ì–´ 1ë¶€í„° 5ê¹Œì§€ì˜ ìˆ«ìë¥¼ ë”í•˜ë ¤í•  ë•Œ:"

#: src/02_basic_calculator/06_while.md:24
msgid "// \"while i is less than or equal to 5\"\n"
msgstr "// \"iê°€ 5ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì€ ë™ì•ˆ\"\n"

#: src/02_basic_calculator/06_while.md:27
msgid "// `+=` is a shorthand for `sum = sum + i`\n"
msgstr "// `+=`ëŠ” `sum = sum + i`ì˜ ì•½ì–´ì…ë‹ˆë‹¤.\n"

#: src/02_basic_calculator/06_while.md:33
msgid ""
"This will keep adding 1 to `i` and `i` to `sum` until `i` is no longer less "
"than or equal to 5."
msgstr ""
"ì´ëŠ” `i`ê°€ ë” ì´ìƒ 5ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì§€ ì•Šì„ ë•Œê¹Œì§€ `i`ì— 1ì„ ê³„ì† ì¶”ê°€í•˜ê³  `sum`"
"ì— `i`ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤."

#: src/02_basic_calculator/06_while.md:35
msgid "The `mut` keyword"
msgstr "`mut` í‚¤ì›Œë“œ"

#: src/02_basic_calculator/06_while.md:37
msgid "The example above won't compile as is. You'll get an error like:"
msgstr ""
"ìœ„ì˜ ì˜ˆëŠ” ìˆëŠ” ê·¸ëŒ€ë¡œ ì»´íŒŒì¼ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‹¤ìŒê³¼ ê°™ì€ ì˜¤ë¥˜ê°€ ë°œìƒí•©ë‹ˆë‹¤:"

#: src/02_basic_calculator/06_while.md:65
msgid ""
"This is because variables in Rust are **immutable** by default.  \n"
"You can't change their value once it has been assigned."
msgstr ""
"ì´ëŠ” Rustì˜ ë³€ìˆ˜ê°€ ê¸°ë³¸ì ìœ¼ë¡œ **immutable**ì´ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.  \n"
"ì¼ë‹¨ í• ë‹¹ëœ ê°’ì€ ìˆ˜ì €í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/02_basic_calculator/06_while.md:68
msgid ""
"If you want to allow modifications, you have to declare the variable as "
"**mutable** using the `mut` keyword:"
msgstr ""
"ìˆ˜ì •ì„ í—ˆìš©í•˜ë ¤ë©´ `mut` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ë³€ìˆ˜ë¥¼ **mutable**ìœ¼ë¡œ ì„ ì–¸í•´ì•¼ í•©ë‹ˆ"
"ë‹¤:"

#: src/02_basic_calculator/06_while.md:71
msgid "// `sum` and `i` are mutable now!\n"
msgstr "// `sum`ê³¼ `i`ëŠ” ì´ì œ ìˆ˜ì • ê°€ëŠ¥í•©ë‹ˆë‹¤!\n"

#: src/02_basic_calculator/06_while.md:81
msgid "This will compile and run without errors."
msgstr "ê·¸ëŸ¬ë©´ ì˜¤ë¥˜ ì—†ì´ ì»´íŒŒì¼ë˜ê³  ì‹¤í–‰ë©ë‹ˆë‹¤."

#: src/02_basic_calculator/06_while.md:85
msgid ""
"[`while` loop documentation](https://doc.rust-lang.org/std/keyword.while.html)"
msgstr "[`while` ë£¨í”„ ë¬¸ì„œ](https://doc.rust-lang.org/std/keyword.while.html)"

#: src/02_basic_calculator/06_while.md:89
msgid ""
"The exercise for this section is located in [`02_basic_calculator/06_while`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/06_while)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`02_basic_calculator/06_while`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/06_while)ì— ìˆìŠµë‹ˆë‹¤"

#: src/02_basic_calculator/07_for.md:1
msgid "Loops, part 2: `for`"
msgstr "ë£¨í”„, part 2: `for`"

#: src/02_basic_calculator/07_for.md:3
msgid ""
"Having to manually increment a counter variable is somewhat tedious. The "
"pattern is also extremely common!  \n"
"To make this easier, Rust provides a more concise way to iterate over a range "
"of values: the `for` loop."
msgstr ""
"ì¹´ìš´í„° ë³€ìˆ˜ë¥¼ ìˆ˜ë™ìœ¼ë¡œ ì¦ê°€ì‹œí‚¤ëŠ” ê²ƒì€ ë‹¤ì†Œ ì§€ë£¨í•œ ì¼ì…ë‹ˆë‹¤. êµ‰ì¥íˆ í”í•œ íŒ¨í„´"
"ì´ê¸°ë„í•´ìš”!  \n"
"ì´ë¥¼ ë” ì‰½ê²Œ ë§Œë“¤ê¸° ìœ„í•´ RustëŠ” ë‹¤ì–‘í•œ ê°’ì„ ë°˜ë³µí•˜ëŠ” ë³´ë‹¤ ê°„ê²°í•œ ë°©ë²•ì¸ `for` "
"ë£¨í”„ë¥¼ ì œê³µí•©ë‹ˆë‹¤."

#: src/02_basic_calculator/07_for.md:6
msgid "The `for` loop"
msgstr "`for` ë£¨í”„"

#: src/02_basic_calculator/07_for.md:8
msgid ""
"A `for` loop is a way to execute a block of code for each element in an "
"iterator[^iterator]."
msgstr ""
"`for` ë£¨í”„ëŠ” ë°˜ë³µì[^iterator]ì˜ ê° ìš”ì†Œì— ëŒ€í•´ ì½”ë“œ ë¸”ë¡ì„ ì‹¤í–‰í•˜ëŠ” ë°©ë²•ì…ë‹ˆ"
"ë‹¤."

#: src/02_basic_calculator/07_for.md:10
msgid "Here's the general syntax:"
msgstr "ì¼ë°˜ì ì¸ ë¬¸ë²•ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/02_basic_calculator/07_for.md:18
msgid "Ranges"
msgstr "ë²”ìœ„"

#: src/02_basic_calculator/07_for.md:20
msgid ""
"Rust's standard library provides **range** type that can be used to iterate "
"over a sequence of numbers[^weird-ranges]."
msgstr ""
"Rustì˜ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ì¼ë ¨ì˜ ìˆ«ì[^weird-ranges]ë¥¼ ë°˜ë³µí•˜ëŠ” ë° ì‚¬ìš©í•  ìˆ˜ ìˆ"
"ëŠ” **range** íƒ€ì…ì„ ì œê³µí•©ë‹ˆë‹¤."

#: src/02_basic_calculator/07_for.md:22
msgid "For example, if we want to sum the numbers from 1 to 5:"
msgstr "ì˜ˆë¥¼ ë“¤ì–´ 1ë¶€í„° 5ê¹Œì§€ì˜ í•©ì„ êµ¬í•œë‹¤ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/02_basic_calculator/07_for.md:31
msgid ""
"Every time the loop runs, `i` will be assigned the next value in the range "
"before executing the block of code."
msgstr ""
"ë£¨í”„ê°€ ì‹¤í–‰ë  ë•Œë§ˆë‹¤ `i`ì—ëŠ” ì½”ë“œ ë¸”ë¡ì„ ì‹¤í–‰í•˜ê¸° ì „ì— ë²”ìœ„ì˜ ë‹¤ìŒ ê°’ì´ í• ë‹¹ë©"
"ë‹ˆë‹¤."

#: src/02_basic_calculator/07_for.md:33
msgid "There are five kinds of ranges in Rust:"
msgstr "Rustì—ëŠ” 5ê°€ì§€ ì¢…ë¥˜ì˜ ë²”ìœ„ê°€ ìˆìŠµë‹ˆë‹¤:"

#: src/02_basic_calculator/07_for.md:35
msgid ""
"`1..5`: A (half-open) range. It includes all numbers from 1 to 4. It doesn't "
"include the last value, 5."
msgstr ""
"`1..5`: A (half-open) ë²”ìœ„. ì—¬ê¸°ì—ëŠ” 1ë¶€í„° 4ê¹Œì§€ì˜ ëª¨ë“  ìˆ«ìê°€ í¬í•¨ë©ë‹ˆë‹¤. ë§ˆ"
"ì§€ë§‰ ê°’ì¸ 5ëŠ” í¬í•¨ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/02_basic_calculator/07_for.md:36
msgid ""
"`1..=5`: An inclusive range. It includes all numbers from 1 to 5. It includes "
"the last value, 5."
msgstr ""
"`1..=5`: í¬í•¨ ë²”ìœ„ì…ë‹ˆë‹¤. ì—¬ê¸°ì—ëŠ” 1ë¶€í„° 5ê¹Œì§€ì˜ ëª¨ë“  ìˆ«ìê°€ í¬í•¨ë©ë‹ˆë‹¤. ë§ˆì§€"
"ë§‰ ê°’ì¸ 5ë„ í¬í•¨ë©ë‹ˆë‹¤."

#: src/02_basic_calculator/07_for.md:37
msgid ""
"`1..`: An open-ended range. It includes all numbers from 1 to infinity (well, "
"until the maximum value of the integer type)."
msgstr ""
"`1..`: ê°œë°©í˜• ë²”ìœ„ì…ë‹ˆë‹¤. 1ë¶€í„° ë¬´í•œëŒ€(ì •ìˆ˜í˜•ì˜ ìµœëŒ€ê°’ê¹Œì§€)ê¹Œì§€ì˜ ëª¨ë“  ìˆ«ìë¥¼ "
"í¬í•¨í•©ë‹ˆë‹¤."

#: src/02_basic_calculator/07_for.md:38
msgid ""
"`..5`: A range that starts at the minimum value for the integer type and ends "
"at 4. It doesn't include the last value, 5."
msgstr ""
"`..5`: ì •ìˆ˜í˜•ì˜ ìµœì†Œê°’ì—ì„œ ì‹œì‘í•˜ì—¬ 4ë¡œ ëë‚˜ëŠ” ë²”ìœ„ì…ë‹ˆë‹¤. ë§ˆì§€ë§‰ ê°’ì¸ 5ëŠ” í¬"
"í•¨ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/02_basic_calculator/07_for.md:39
msgid ""
"`..=5`: A range that starts at the minimum value for the integer type and "
"ends at 5. It includes the last value, 5."
msgstr ""
"`..=5`: ì •ìˆ˜í˜•ì˜ ìµœì†Œê°’ì—ì„œ ì‹œì‘í•˜ì—¬ 5ë¡œ ëë‚˜ëŠ” ë²”ìœ„. ë§ˆì§€ë§‰ ê°’ì¸ 5ë¥¼ í¬í•¨í•©ë‹ˆ"
"ë‹¤."

#: src/02_basic_calculator/07_for.md:41
msgid ""
"You can use a `for` loop with the first three kinds of ranges, where the "
"starting point is explicitly specified. The last two range types are used in "
"other contexts, that we'll cover later."
msgstr ""
"ì‹œì‘ì ì´ ëª…ì‹œì ìœ¼ë¡œ ì§€ì •ëœ ì²˜ìŒ ì„¸ ì¢…ë¥˜ì˜ ë²”ìœ„ì— `for` ë£¨í”„ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆ"
"ë‹¤. ë§ˆì§€ë§‰ ë‘ ê°€ì§€ ë²”ìœ„ íƒ€ì…ì€ ë‚˜ì¤‘ì— ë‹¤ë£¨ê²Œ ë  ë‹¤ë¥¸ ìƒí™©ì—ì„œ ì‚¬ìš©ë©ë‹ˆë‹¤."

#: src/02_basic_calculator/07_for.md:44
msgid ""
"The extreme values of a range don't have to be integer literalsâ€”they can be "
"variables or expressions too!"
msgstr ""
"ë²”ìœ„ì˜ ê·¹ë‹¨ê°’ì€ ì •ìˆ˜ ë¦¬í„°ëŸ´ì¼ í•„ìš”ëŠ” ì—†ìŠµë‹ˆë‹¤â€”ë³€ìˆ˜ë‚˜ í‘œí˜„ì‹ì¼ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤!"

#: src/02_basic_calculator/07_for.md:46
#: src/02_basic_calculator/10_as_casting.md:12
#: src/03_ticket_v1/06_ownership.md:188 src/04_traits/02_orphan_rule.md:51
#: src/04_traits/09_from.md:55 src/05_ticket_v2/14_source.md:112
#: src/07_threads/01_threads.md:47
msgid "For example:"
msgstr "ì˜ˆì‹œ:"

#: src/02_basic_calculator/07_for.md:59
msgid ""
"[`for` loop documentation](https://doc.rust-lang.org/std/keyword.for.html)"
msgstr "[`for` ë£¨í”„ ë¬¸ì„œ](https://doc.rust-lang.org/std/keyword.for.html)"

#: src/02_basic_calculator/07_for.md:61
msgid ""
"Later in the course we'll give a precise definition of what counts as an "
"\"iterator\". For now, think of it as a sequence of values that you can loop "
"over. [^weird-ranges]: You can use ranges with other types too (e.g. "
"characters and IP addresses), but integers are definitely the most common "
"case in day-to-day Rust programming."
msgstr ""
"ì´ ê³¼ì •ì˜ í›„ë°˜ë¶€ì—ì„œ \"ë°˜ë³µì\"ë¡œ ê°„ì£¼ë˜ëŠ” ê²ƒì´ ë¬´ì—‡ì¸ì§€ì— ëŒ€í•œ ì •í™•í•œ ì •ì˜ë¥¼ "
"ì œê³µí•  ê²ƒì…ë‹ˆë‹¤. ì§€ê¸ˆì€ ì´ë¥¼ ë°˜ë³µí•  ìˆ˜ ìˆëŠ” ì¼ë ¨ì˜ ê°’ìœ¼ë¡œ ìƒê°í•˜ì„¸ìš”. [^weird-"
"ranges]: ë‹¤ë¥¸ íƒ€ì…(ì˜ˆ: ë¬¸ì ë° IP ì£¼ì†Œ)ì—ë„ ë²”ìœ„ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆì§€ë§Œ ì¼ìƒì ì¸ "
"Rust í”„ë¡œê·¸ë˜ë°ì—ì„œëŠ” í™•ì‹¤íˆ ì •ìˆ˜ê°€ ê°€ì¥ ì¼ë°˜ì ì¸ ê²½ìš°ì…ë‹ˆë‹¤."

#: src/02_basic_calculator/07_for.md:68
msgid ""
"The exercise for this section is located in [`02_basic_calculator/07_for`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/07_for)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`02_basic_calculator/07_for`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/07_for)ì— ìˆìŠµë‹ˆë‹¤"

#: src/02_basic_calculator/08_overflow.md:1
msgid "Overflow"
msgstr "ì˜¤ë²„í”Œë¡œìš°"

#: src/02_basic_calculator/08_overflow.md:3
msgid ""
"The factorial of a number grows quite fast.  \n"
"For example, the factorial of 20 is 2,432,902,008,176,640,000. That's already "
"bigger than the maximum value for a 32-bit integer, 2,147,483,647."
msgstr ""
"íŒ©í† ë¦¬ì–¼ì€ ë§¤ìš° ë¹ ë¥´ê²Œ ì¦ê°€í•©ë‹ˆë‹¤.  \n"
"ì˜ˆë¥¼ ë“¤ì–´, íŒ©í† ë¦¬ì–¼ 20ì€ 2,432,902,008,176,640,000ì…ë‹ˆë‹¤. ì´ëŠ” ì´ë¯¸ 32ë¹„íŠ¸ ì •"
"ìˆ˜ì˜ ìµœëŒ€ê°’ì¸ 2,147,483,647ë³´ë‹¤ í½ë‹ˆë‹¤."

#: src/02_basic_calculator/08_overflow.md:7
msgid ""
"When the result of an arithmetic operation is bigger than the maximum value "
"for a given integer type, we are talking about **an integer overflow**."
msgstr ""
"ì‚°ìˆ  ì—°ì‚°ì˜ ê²°ê³¼ê°€ ì£¼ì–´ì§„ ì •ìˆ˜ ìœ í˜•ì˜ ìµœëŒ€ê°’ë³´ë‹¤ í° ê²½ìš° **ì •ìˆ˜ ì˜¤ë²„í”Œë¡œìš°**"
"ì— ëŒ€í•´ ì´ì•¼ê¸°í•©ë‹ˆë‹¤."

#: src/02_basic_calculator/08_overflow.md:10
msgid ""
"Integer overflows are an issue because they violate the contract for "
"arithmetic operations.  \n"
"The result of an arithmetic operation between two integers of a given type "
"should be another integer of the same type. But the _mathematically correct "
"result_ doesn't fit into that integer type!"
msgstr ""
"ì •ìˆ˜ ì˜¤ë²„í”Œë¡œìš°ëŠ” ì‚°ìˆ  ì—°ì‚° ì •ì˜ë¥¼ ìœ„ë°˜í•˜ê¸° ë•Œë¬¸ì— ë¬¸ì œê°€ ë©ë‹ˆë‹¤.  \n"
"ì£¼ì–´ì§„ íƒ€ì…ì˜ ë‘ ì •ìˆ˜ ì‚¬ì´ì˜ ì‚°ìˆ  ì—°ì‚° ê²°ê³¼ëŠ” ë™ì¼í•œ íƒ€ì…ì˜ ë˜ ë‹¤ë¥¸ ì •ìˆ˜ì—¬ì•¼ "
"í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ _ìˆ˜í•™ì ìœ¼ë¡œ ì˜¬ë°”ë¥¸ ê²°ê³¼_ëŠ” í•´ë‹¹ ì •ìˆ˜ íƒ€ì…ì— ë§ì§€ ì•ŠìŠµë‹ˆë‹¤!"

#: src/02_basic_calculator/08_overflow.md:14
msgid ""
"If the result is smaller than the minimum value for a given integer type, we "
"refer to the event as **an integer underflow**.  \n"
"For brevity, we'll only talk about integer overflows for the rest of this "
"section, but keep in mind that everything we say applies to integer "
"underflows as well."
msgstr ""
"ê²°ê³¼ê°€ íŠ¹ì • ì •ìˆ˜ ìœ í˜•ì˜ ìµœì†Œê°’ë³´ë‹¤ ì‘ì€ ê²½ìš° í•´ë‹¹ ìƒí™©ì„ **ì •ìˆ˜ ì–¸ë”í”Œë¡œìš°**ë¼"
"ê³  í•©ë‹ˆë‹¤.  \n"
"ê°„ê²°í•˜ê²Œ í•˜ê¸° ìœ„í•´ ì´ ì„¹ì…˜ì˜ ë‚˜ë¨¸ì§€ ë¶€ë¶„ì—ì„œëŠ” ì •ìˆ˜ ì˜¤ë²„í”Œë¡œìš°ì— ëŒ€í•´ì„œë§Œ ì„¤ëª…"
"í•˜ê² ìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ìš°ë¦¬ê°€ ë§í•˜ëŠ” ëª¨ë“  ë‚´ìš©ì€ ì •ìˆ˜ ì–¸ë”í”Œë¡œìš°ì—ë„ ì ìš©ëœë‹¤ëŠ” ì "
"ì„ ëª…ì‹¬í•˜ì„¸ìš”."

#: src/02_basic_calculator/08_overflow.md:19
msgid ""
"The `speed` function you wrote in the [\"Variables\" section](02_variables."
"md) underflowed for some input combinations. E.g. if `end` is smaller than "
"`start`, `end - start` will underflow the `u32` type since the result is "
"supposed to be negative but `u32` can't represent negative numbers."
msgstr ""
"[\"ë³€ìˆ˜\" ì„¹ì…˜](02_variables.md)ì— ì‘ì„±í•œ `speed`í•¨ìˆ˜ëŠ” ì¼ë¶€ ì…ë ¥ ì¡°í•©ì— ëŒ€í•´ "
"ì–¸ë”í”Œë¡œìš°ë©ë‹ˆë‹¤. ì˜ˆ: `end`ê°€ `start`ë³´ë‹¤ ì‘ìœ¼ë©´ `end - start`ëŠ” ê²°ê³¼ê°€ ìŒìˆ˜"
"ë¡œ ê°€ì •ë˜ì§€ë§Œ `u32`ëŠ” ìŒìˆ˜ë¥¼ ë‚˜íƒ€ë‚¼ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ `u32` íƒ€ì…ìœ¼ë¡œ ì–¸ë”í”Œë¡œìš°ë©ë‹ˆ"
"ë‹¤."

#: src/02_basic_calculator/08_overflow.md:24
msgid "No automatic promotion"
msgstr "ìë™ ìŠ¹ê²© ì—†ìŒ"

#: src/02_basic_calculator/08_overflow.md:26
msgid ""
"One possible approach would be automatically promote the result to a bigger "
"integer type. E.g. if you're summing two `u8` integers and the result is 256 "
"(`u8::MAX + 1`), Rust could choose to interpret the result as `u16`, the next "
"integer type that's big enough to hold 256."
msgstr ""
"í•œ ê°€ì§€ ê°€ëŠ¥í•œ ì ‘ê·¼ ë°©ì‹ì€ ê²°ê³¼ë¥¼ ë” í° ì •ìˆ˜ íƒ€ì…ìœ¼ë¡œ ìë™ ìŠ¹ê²©ì‹œí‚¤ëŠ” ê²ƒì…ë‹ˆ"
"ë‹¤. ì˜ˆ: ë‘ ê°œì˜ `u8` ì •ìˆ˜ë¥¼ í•©ì‚°í•˜ê³  ê·¸ ê²°ê³¼ê°€ 256(`u8::MAX + 1`)ì´ë¼ë©´ Rust"
"ëŠ” ê·¸ ê²°ê³¼ë¥¼ 256ì„ ìˆ˜ìš©í•  ë§Œí¼ í° ë‹¤ìŒ ì •ìˆ˜ íƒ€ì…ì¸ `u16`ìœ¼ë¡œ í•´ì„í•˜ë„ë¡ ì„ íƒ"
"í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/02_basic_calculator/08_overflow.md:30
msgid ""
"But, as we've discussed before, Rust is quite picky about type conversions. "
"Automatic integer promotion is not Rust's solution to the integer overflow "
"problem."
msgstr ""
"ê·¸ëŸ¬ë‚˜ ì´ì „ì— ë…¼ì˜í•œ ê²ƒì²˜ëŸ¼ RustëŠ” íƒ€ì… ë³€í™˜ì— ëŒ€í•´ ë§¤ìš° ê¹Œë‹¤ë¡­ìŠµë‹ˆë‹¤. ìë™ ì •"
"ìˆ˜ ìŠ¹ê²©ì€ ì •ìˆ˜ ì˜¤ë²„í”Œë¡œìš° ë¬¸ì œì— ëŒ€í•œ Rustì˜ ì†”ë£¨ì…˜ì´ ì•„ë‹™ë‹ˆë‹¤."

#: src/02_basic_calculator/08_overflow.md:33
msgid "Alternatives"
msgstr "ëŒ€ì•ˆ"

#: src/02_basic_calculator/08_overflow.md:35
msgid ""
"Since we ruled out automatic promotion, what can we do when an integer "
"overflow occurs?  \n"
"It boils down to two different approaches:"
msgstr ""
"ìë™ ìŠ¹ê²©ì„ ë°°ì œí–ˆìœ¼ë¯€ë¡œ ì •ìˆ˜ ì˜¤ë²„í”Œë¡œìš°ê°€ ë°œìƒí•˜ë©´ ì–´ë–»ê²Œ í•´ì•¼ í• ê¹Œìš”?  \n"
"ì´ëŠ” ë‘ ê°€ì§€ ì ‘ê·¼ ë°©ì‹ìœ¼ë¡œ ìš”ì•½ë©ë‹ˆë‹¤:"

#: src/02_basic_calculator/08_overflow.md:38
#: src/02_basic_calculator/08_overflow.md:41
msgid "Reject the operation"
msgstr "ì‘ì—… ê±°ë¶€"

#: src/02_basic_calculator/08_overflow.md:39
msgid ""
"Come up with a \"sensible\" result that fits into the expected integer type"
msgstr "ì˜ˆìƒë˜ëŠ” ì •ìˆ˜ íƒ€ì…ì— ë§ëŠ” \"í•©ë¦¬ì ì¸\" ê²°ê³¼ë¥¼ ìƒê°í•´ ë³´ì„¸ìš”."

#: src/02_basic_calculator/08_overflow.md:43
msgid ""
"This is the most conservative approach: we stop the program when an integer "
"overflow occurs.  \n"
"That's done via a panic, the mechanism we've already seen in the [\"Panics\" "
"section](04_panics.md)."
msgstr ""
"ì´ê²ƒì€ ê°€ì¥ ë³´ìˆ˜ì ì¸ ì ‘ê·¼ ë°©ì‹ì…ë‹ˆë‹¤. ì •ìˆ˜ ì˜¤ë²„í”Œë¡œìš°ê°€ ë°œìƒí•˜ë©´ í”„ë¡œê·¸ë¨ì„ ì¤‘"
"ì§€í•©ë‹ˆë‹¤.  \n"
"ì´ëŠ” [\"íŒ¨ë‹‰\" ì„¹ì…˜](04_panics.md)ì—ì„œ ì´ë¯¸ ë³¸ ë©”ì»¤ë‹ˆì¦˜ì¸ íŒ¨ë‹‰ì„ í†µí•´ ìˆ˜í–‰ë©ë‹ˆ"
"ë‹¤."

#: src/02_basic_calculator/08_overflow.md:46
msgid "Come up with a \"sensible\" result"
msgstr "\"í•©ë¦¬ì ì¸\" ê²°ê³¼ë¥¼ ë‚´ì„¸ìš”"

#: src/02_basic_calculator/08_overflow.md:48
msgid ""
"When the result of an arithmetic operation is bigger than the maximum value "
"for a given integer type, you can choose to **wrap around**.  \n"
"If you think of all the possible values for a given integer type as a circle, "
"wrapping around means that when you reach the maximum value, you start again "
"from the minimum value."
msgstr ""
"ì‚°ìˆ  ì—°ì‚°ì˜ ê²°ê³¼ê°€ íŠ¹ì • ì •ìˆ˜ íƒ€ì…ì˜ ìµœëŒ€ê°’ë³´ë‹¤ í° ê²½ìš° **wrap around**ë¥¼ ì„ íƒ"
"í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"ì£¼ì–´ì§„ ì •ìˆ˜í˜•ì— ê°€ëŠ¥í•œ ëª¨ë“  ê°’ì„ ì›ìœ¼ë¡œ ìƒê°í•œë‹¤ë©´, wrap aroundëŠ” ìµœëŒ€ê°’ì— ë„"
"ë‹¬í•˜ë©´ ìµœì†Œê°’ë¶€í„° ë‹¤ì‹œ ì‹œì‘í•œë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤."

#: src/02_basic_calculator/08_overflow.md:53
msgid ""
"For example, if you do a **wrapping addition** between 1 and 255 (=`u8::"
"MAX`), the result is 0 (=`u8::MIN`). If you're working with signed integers, "
"the same principle applies. E.g. adding 1 to 127 (=`i8::MAX`) with wrapping "
"will give you -128 (=`i8::MIN`)."
msgstr ""
"ì˜ˆë¥¼ ë“¤ì–´, 1ê³¼ 255(=`u8::MAX`)ì— **wrapping addition**ë¥¼ ìˆ˜í–‰í•˜ë©´ ê²°ê³¼ëŠ” "
"0(=`u8::MIN`)ì…ë‹ˆë‹¤. ë¶€í˜¸ ìˆëŠ” ì •ìˆ˜ë¡œ ì‘ì—…í•˜ëŠ” ê²½ìš°ì—ë„ ë™ì¼í•œ ì›ì¹™ì´ ì ìš©ë©ë‹ˆ"
"ë‹¤. ì˜ˆ: 127(=`i8::MAX`)ì— wrappingì™€ í•¨ê»˜ 1ì„ ë”í•˜ë©´ -128(=`i8::MIN`)ì´ ë©ë‹ˆ"
"ë‹¤."

#: src/02_basic_calculator/08_overflow.md:57
msgid "`overflow-checks`"
msgstr "`ì˜¤ë²„í”Œë¡œìš° ê²€ì‚¬`"

#: src/02_basic_calculator/08_overflow.md:59
msgid ""
"Rust lets you, the developer, choose which approach to use when an integer "
"overflow occurs. The behaviour is controlled by the `overflow-checks` profile "
"setting."
msgstr ""
"Rustë¥¼ ì‚¬ìš©í•˜ë©´ ê°œë°œìê°€ ì •ìˆ˜ ì˜¤ë²„í”Œë¡œìš°ê°€ ë°œìƒí•  ë•Œ ì‚¬ìš©í•  ì ‘ê·¼ ë°©ì‹ì„ ì„ íƒ"
"í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë™ì‘ì€ `overflow-checks` í”„ë¡œí•„ ì„¤ì •ì— ì˜í•´ ì œì–´ë©ë‹ˆë‹¤."

#: src/02_basic_calculator/08_overflow.md:62
msgid ""
"If `overflow-checks` is set to `true`, Rust will **panic at runtime** when an "
"integer operation overflows. If `overflow-checks` is set to `false`, Rust "
"will **wrap around** when an integer operation overflows."
msgstr ""
"`overflow-checks`ê°€ `true`ë¡œ ì„¤ì •ë˜ë©´ RustëŠ” ì •ìˆ˜ ì—°ì‚°ì´ ì˜¤ë²„í”Œë¡œìš°ë  ë•Œ **ëŸ°"
"íƒ€ì„ì— íŒ¨ë‹‰**ì„ ì¼ìœ¼í‚¬ ê²ƒì…ë‹ˆë‹¤. `overflow-checks`ê°€ `false`ë¡œ ì„¤ì •ë˜ë©´ Rust"
"ëŠ” ì •ìˆ˜ ì—°ì‚°ì´ ì˜¤ë²„í”Œë¡œë  ë•Œ **wrap around**í•©ë‹ˆë‹¤."

#: src/02_basic_calculator/08_overflow.md:65
msgid "You may be wonderingâ€”what is a profile setting? Let's get into that!"
msgstr "í”„ë¡œí•„ ì„¤ì •ì´ ë¬´ì—‡ì¸ì§€ ê¶ê¸ˆí•˜ì‹¤ ê²ë‹ˆë‹¤. ê·¸ê²ƒì— ëŒ€í•´ ì‚´í´ ë³´ê² ìŠµë‹ˆë‹¤!"

#: src/02_basic_calculator/08_overflow.md:67
msgid "Profiles"
msgstr "í”„ë¡œí•„"

#: src/02_basic_calculator/08_overflow.md:69
msgid ""
"A [**profile**](https://doc.rust-lang.org/cargo/reference/profiles.html) is a "
"set of configuration options that can be used to customize the way Rust code "
"is compiled."
msgstr ""
"[**í”„ë¡œí•„**](https://doc.rust-lang.org/cargo/reference/profiles.html)ì€ Rust "
"ì½”ë“œê°€ ì»´íŒŒì¼ë˜ëŠ” ë°©ì‹ì„ ì‚¬ìš©ì ì •ì˜í•˜ëŠ” ë° ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” êµ¬ì„± ì˜µì…˜ ì„¸íŠ¸ì…ë‹ˆ"
"ë‹¤."

#: src/02_basic_calculator/08_overflow.md:72
msgid ""
"Cargo provides two built-in profiles: `dev` and `release`.  \n"
"The `dev` profile is used every time you run `cargo build`, `cargo run` or "
"`cargo test`. It's aimed at local development, therefore it sacrifices "
"runtime performance in favor of faster compilation times and a better "
"debugging experience.  \n"
"The `release` profile, instead, is optimized for runtime performance but "
"incurs longer compilation times. You need to explicitly request via the `--"
"release` flagâ€”e.g. `cargo build --release` or `cargo run --release`."
msgstr ""
"CargoëŠ” `dev`ì™€ `release`ë¼ëŠ” ë‘ ê°€ì§€ ë‚´ì¥ í”„ë¡œí•„ì„ ì œê³µí•©ë‹ˆë‹¤.  \n"
"`dev` í”„ë¡œí•„ì€ `cargo build`, `cargo run` ë˜ëŠ” `cargo test`ë¥¼ ì‹¤í–‰í•  ë•Œë§ˆë‹¤ ì‚¬"
"ìš©ë©ë‹ˆë‹¤. ë¡œì»¬ ê°œë°œì„ ëª©í‘œë¡œ í•˜ë¯€ë¡œ ë” ë¹ ë¥¸ ì»´íŒŒì¼ ì‹œê°„ê³¼ ë” ë‚˜ì€ ë””ë²„ê¹… í™˜ê²½"
"ì„ ìœ„í•´ ëŸ°íƒ€ì„ ì„±ëŠ¥ì„ í¬ìƒí•©ë‹ˆë‹¤.  \n"
"ëŒ€ì‹  `release` í”„ë¡œí•„ì€ ëŸ°íƒ€ì„ ì„±ëŠ¥ì— ìµœì í™”ë˜ì–´ ìˆì§€ë§Œ ì»´íŒŒì¼ ì‹œê°„ì´ ë” ê¸¸ì–´"
"ì§‘ë‹ˆë‹¤. `--release` í”Œë˜ê·¸ë¥¼ í†µí•´ ëª…ì‹œì ìœ¼ë¡œ ìš”ì²­í•´ì•¼ í•©ë‹ˆë‹¤. `cargo build --"
"release` ë˜ëŠ” `cargo run --release`."

#: src/02_basic_calculator/08_overflow.md:79
msgid ""
"\"Have you built your project in release mode?\" is almost a meme in the Rust "
"community.  \n"
"It refers to developers who are not familiar with Rust and complain about its "
"performance on social media (e.g. Reddit, Twitter, etc.) before realizing "
"they haven't built their project in release mode."
msgstr ""
"\"ë¦´ë¦¬ìŠ¤ ëª¨ë“œì—ì„œ í”„ë¡œì íŠ¸ë¥¼ ë¹Œë“œí•˜ì…¨ë‚˜ìš”?\"ë¼ëŠ” ë§ì€ Rust ì»¤ë®¤ë‹ˆí‹°ì—ì„œ ê±°ì˜ "
"ë°ˆì´ ë˜ì—ˆìŠµë‹ˆë‹¤.  \n"
"ì´ëŠ” Rustì— ìµìˆ™í•˜ì§€ ì•Šê³  ë¦´ë¦¬ìŠ¤ ëª¨ë“œì—ì„œ ìì‹ ì˜ í”„ë¡œì íŠ¸ë¥¼ ë¹Œë“œí•˜ì§€ ì•Šì•˜ë‹¤ëŠ” "
"ì‚¬ì‹¤ì„ ê¹¨ë‹«ê¸°ë„ ì „ì— ì†Œì…œ ë¯¸ë””ì–´(ì˜ˆ: Reddit, Twitter ë“±)ì—ì„œ Rustì˜ ì„±ëŠ¥ì— ëŒ€"
"í•´ ë¶ˆí‰í•˜ëŠ” ê°œë°œìì—ê²Œ ì‚¬ìš©í•˜ëŠ” ë°ˆì…ë‹ˆë‹¤."

#: src/02_basic_calculator/08_overflow.md:84
msgid "You can also define custom profiles or customize the built-in ones."
msgstr ""
"ì‚¬ìš©ì ì •ì˜ í”„ë¡œí•„ì„ ì •ì˜í•˜ê±°ë‚˜ ê¸°ë³¸ ì œê³µ í”„ë¡œí•„ì„ ì‚¬ìš©ì ì •ì˜í•  ìˆ˜ë„ ìˆìŠµë‹ˆ"
"ë‹¤."

#: src/02_basic_calculator/08_overflow.md:86
msgid "`overflow-check`"
msgstr "`overflow-check`"

#: src/02_basic_calculator/08_overflow.md:88
msgid "By default, `overflow-checks` is set to:"
msgstr "ê¸°ë³¸ì ìœ¼ë¡œ `overflow-checks`ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì„¤ì •ë©ë‹ˆë‹¤:"

#: src/02_basic_calculator/08_overflow.md:90
msgid "`true` for the `dev` profile"
msgstr "`dev` í”„ë¡œí•„ì˜ ê²½ìš° `true`"

#: src/02_basic_calculator/08_overflow.md:91
msgid "`false` for the `release` profile"
msgstr "`release` í”„ë¡œí•„ì˜ ê²½ìš° `false`"

#: src/02_basic_calculator/08_overflow.md:93
msgid ""
"This is in line with the goals of the two profiles.  \n"
"`dev` is aimed at local development, so it panics in order to highlight "
"potential issues as early as possible.  \n"
"`release`, instead, is tuned for runtime performance: checking for overflows "
"would slow down the program, so it prefers to wrap around."
msgstr ""
"ì´ëŠ” ë‘ í”„ë¡œí•„ì˜ ëª©í‘œì™€ ì¼ì¹˜í•©ë‹ˆë‹¤.  \n"
"`dev`ëŠ” ë¡œì»¬ ê°œë°œì„ ëª©í‘œë¡œ í•˜ê¸° ë•Œë¬¸ì— ì ì¬ì ì¸ ë¬¸ì œë¥¼ ì¡°ê¸°ì— ë¶€ê°ì‹œí‚¤ê¸° ìœ„í•´ "
"íŒ¨ë‹‰í•©ë‹ˆë‹¤.  \n"
"ë°˜ë©´ì— `release`ëŠ” ëŸ°íƒ€ì„ ì„±ëŠ¥ì— ë§ê²Œ ì¡°ì •ë©ë‹ˆë‹¤. ì˜¤ë²„í”Œë¡œìš°ë¥¼ í™•ì¸í•˜ë©´ í”„ë¡œê·¸"
"ë¨ ì†ë„ê°€ ëŠë ¤ì§€ë¯€ë¡œ wrap aroundë¥¼ ì„ í˜¸í•©ë‹ˆë‹¤."

#: src/02_basic_calculator/08_overflow.md:98
msgid ""
"At the same time, having different behaviours for the two profiles can lead "
"to subtle bugs.  \n"
"Our recommendation is to enable `overflow-checks` for both profiles: it's "
"better to crash than to silently produce incorrect results. The runtime "
"performance hit is negligible in most cases; if you're working on a "
"performance-critical application, you can run benchmarks to decide if it's "
"something you can afford."
msgstr ""
"ë™ì‹œì— ë‘ í”„ë¡œíŒŒì¼ì— ëŒ€í•´ ë‹¤ë¥¸ ë™ì‘ì„ í•˜ë©´ ë¯¸ë¬˜í•œ ë²„ê·¸ê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"ë‘ í”„ë¡œíŒŒì¼ ëª¨ë‘ì—ì„œ `overflow-check`ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤. "
"ì¡°ìš©íˆ ì˜ëª»ëœ ê²°ê³¼ë¥¼ ë‚´ëŠ” ê²ƒë³´ë‹¤ í¬ë˜ì‹œë‚˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤. ëŸ°íƒ€ì„ ì„±ëŠ¥ ë¬¸ì œëŠ” "
"ëŒ€ë¶€ë¶„ì˜ ê²½ìš° ë¬´ì‹œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì„±ëŠ¥ì´ ì¤‘ìš”í•œ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ì‚¬ìš©í•˜ëŠ” ê²½ìš° "
"ë²¤ì¹˜ë§ˆí¬ë¥¼ ì‹¤í–‰í•˜ì—¬ ê°ë‹¹ ê°€ëŠ¥í•œ ìˆ˜ì¤€ì¸ì§€ ê²°ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/02_basic_calculator/08_overflow.md:105
msgid ""
"Check out [\"Myths and legends about integer overflow in Rust\"](https://"
"huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-"
"rust/) for an in-depth discussion about integer overflow in Rust."
msgstr ""
"Rustì˜ ì •ìˆ˜ ì˜¤ë²„í”Œë¡œì— ëŒ€í•œ ì‹¬ì¸µì ì¸ ë…¼ì˜ëŠ” [\"Myths and legends about "
"integer overflow in Rust\"](https://huonw.github.io/blog/2016/04/myths-and-"
"legends-about-integer-overflow-in-rust/)ì„ í™•ì¸í•˜ì„¸ìš”."

#: src/02_basic_calculator/08_overflow.md:110
msgid ""
"The exercise for this section is located in "
"[`02_basic_calculator/08_overflow`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/08_overflow)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`02_basic_calculator/08_overflow`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/08_overflow)ì— ìˆìŠµë‹ˆë‹¤"

#: src/02_basic_calculator/09_saturating.md:1
msgid "Case-by-case behavior"
msgstr "ì‚¬ë¡€ë³„ ë™ì‘"

#: src/02_basic_calculator/09_saturating.md:3
msgid ""
"`overflow-checks` is a blunt tool: it's a global setting that affects the "
"whole program.  \n"
"It often happens that you want to handle integer overflows differently "
"depending on the context: sometimes wrapping is the right choice, other times "
"panicking is preferable."
msgstr ""
"`overflow-checks`ëŠ” ë¬´ëšëší•œ ë„êµ¬ì…ë‹ˆë‹¤. ì „ì²´ í”„ë¡œê·¸ë¨ì— ì˜í–¥ì„ ë¯¸ì¹˜ëŠ” ì „ì—­ ì„¤"
"ì •ì…ë‹ˆë‹¤.  \n"
"ìƒí™©ì— ë”°ë¼ ì •ìˆ˜ ì˜¤ë²„í”Œë¡œìš°ë¥¼ ë‹¤ë¥´ê²Œ ì²˜ë¦¬í•˜ë ¤ëŠ” ê²½ìš°ê°€ ì¢…ì¢… ìˆìŠµë‹ˆë‹¤. ë•Œë¡œëŠ” "
"ë˜í•‘ì´ ì˜¬ë°”ë¥¸ ì„ íƒì´ê³ , ë‹¤ë¥¸ ê²½ìš°ì—ëŠ” íŒ¨ë‹‰ì´ ë” ì¢‹ìŠµë‹ˆë‹¤."

#: src/02_basic_calculator/09_saturating.md:7
msgid "`wrapping_` methods"
msgstr "`wrapping_` ë©”ì†Œë“œ"

#: src/02_basic_calculator/09_saturating.md:9
msgid ""
"You can opt into wrapping arithmetic on a per-operation basis by using the "
"`wrapping_` methods[^method].  \n"
"For example, you can use `wrapping_add` to add two integers with wrapping:"
msgstr ""
"`wrapping_` ë©”ì†Œë“œ[^method]ë¥¼ ì‚¬ìš©í•˜ì—¬ ì—°ì‚°ë³„ë¡œ ë˜í•‘ ì‚°ìˆ ì„ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆ"
"ë‹¤.  \n"
"ì˜ˆë¥¼ ë“¤ì–´ `wrapping_add`ë¥¼ ì‚¬ìš©í•˜ì—¬ ë˜í•‘ìœ¼ë¡œ ë‘ ê°œì˜ ì •ìˆ˜ë¥¼ ë”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/02_basic_calculator/09_saturating.md:19
msgid "`saturating_` methods"
msgstr "`saturating_` ë©”ì†Œë“œ"

#: src/02_basic_calculator/09_saturating.md:21
msgid ""
"Alternatively, you can opt into **saturating arithmetic** by using the "
"`saturating_` methods.  \n"
"Instead of wrapping around, saturating arithmetic will return the maximum or "
"minimum value for the integer type. For example:"
msgstr ""
"ë˜ëŠ” `saturating_` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ **í¬í™” ì‚°ìˆ **ì„ ì„ íƒí•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.  \n"
"ë˜í•‘ ëŒ€ì‹  í¬í™” ì‚°ìˆ ì€ ì •ìˆ˜ íƒ€ì…ì˜ ìµœëŒ€ê°’ ë˜ëŠ” ìµœì†Œê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤. ì˜ˆì‹œ:"

#: src/02_basic_calculator/09_saturating.md:32
msgid ""
"Since `255 + 1` is `256`, which is bigger than `u8::MAX`, the result is `u8::"
"MAX` (255).  \n"
"The opposite happens for underflows: `0 - 1` is `-1`, which is smaller than "
"`u8::MIN`, so the result is `u8::MIN` (0)."
msgstr ""
"`255 + 1`ì€ `256`ì´ë©° ì´ëŠ” `u8::MAX`ë³´ë‹¤ í¬ë¯€ë¡œ ê²°ê³¼ëŠ” `u8::MAX` (255)ì…ë‹ˆ"
"ë‹¤.  \n"
"ì–¸ë”í”Œë¡œìš°ì˜ ê²½ìš° ë°˜ëŒ€ê°€ ë°œìƒí•©ë‹ˆë‹¤. `0 - 1`ì€ `-1`ì´ë©° ì´ëŠ” `u8::MIN`ë³´ë‹¤ ì‘"
"ìœ¼ë¯€ë¡œ ê²°ê³¼ëŠ” `u8::MIN` (0)ì…ë‹ˆë‹¤."

#: src/02_basic_calculator/09_saturating.md:35
msgid ""
"You can't get saturating arithmetic via the `overflow-checks` profile settingâ€”"
"you have to explicitly opt into it when performing the arithmetic operation."
msgstr ""
"`overflow-checks` í”„ë¡œí•„ ì„¤ì •ì„ í†µí•´ í¬í™” ì‚°ìˆ ì„ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì‚°ìˆ  ì—°ì‚°ì„ "
"ìˆ˜í–‰í•  ë•Œ ì´ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤."

#: src/02_basic_calculator/09_saturating.md:38
msgid ""
"You can think of methods as functions that are \"attached\" to a specific "
"type. We'll cover methods (and how to define them) in the next chapter."
msgstr ""
"ë©”ì†Œë“œë¥¼ íŠ¹ì • ìœ í˜•ì— \"ì—°ê²°ëœ\" í•¨ìˆ˜ë¡œ ìƒê°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ì¥ì—ì„œëŠ” ë©”ì„œ"
"ë“œ(ê·¸ë¦¬ê³  ì´ë¥¼ ì •ì˜í•˜ëŠ” ë°©ë²•)ë¥¼ ë‹¤ë£° ê²ƒì…ë‹ˆë‹¤."

#: src/02_basic_calculator/09_saturating.md:43
msgid ""
"The exercise for this section is located in "
"[`02_basic_calculator/09_saturating`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/09_saturating)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`02_basic_calculator/09_saturating`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/09_saturating)ì— ìˆìŠµë‹ˆë‹¤"

#: src/02_basic_calculator/10_as_casting.md:1
msgid "Conversions, pt. 1"
msgstr "ë³€í™˜, pt. 1"

#: src/02_basic_calculator/10_as_casting.md:3
msgid ""
"We've repeated over and over again that Rust won't perform implicit type "
"conversions for integers.  \n"
"How do you perform _explicit_ conversions then?"
msgstr ""
"ìš°ë¦¬ëŠ” Rustê°€ ì •ìˆ˜ì— ëŒ€í•´ ì•”ë¬µì ì¸ íƒ€ì… ë³€í™˜ì„ ìˆ˜í–‰í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì ì„ ê³„ì†í•´"
"ì„œ ë°˜ë³µí–ˆìŠµë‹ˆë‹¤.  \n"
"ê·¸ë ‡ë‹¤ë©´ _ëª…ì‹œì _ ë³€í™˜ì„ ì–´ë–»ê²Œ ìˆ˜í–‰í• ê¹Œìš”?"

#: src/02_basic_calculator/10_as_casting.md:7
msgid "`as`"
msgstr "`as`"

#: src/02_basic_calculator/10_as_casting.md:9
msgid ""
"You can use the `as` operator to convert between integer types.  \n"
"`as` conversions are **infallible**."
msgstr ""
"`as` ì—°ì‚°ìë¥¼ ì‚¬ìš©í•˜ì—¬ ì •ìˆ˜ íƒ€ì… ê°„ì— ë³€í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"`as` ë³€í™˜ì€ **infallible**ì…ë‹ˆë‹¤."

#: src/02_basic_calculator/10_as_casting.md:16
msgid "// Cast `a` into the `u64` type\n"
msgstr "// `a`ë¥¼ `u64` íƒ€ì…ìœ¼ë¡œ ìºìŠ¤íŠ¸\n"

#: src/02_basic_calculator/10_as_casting.md:19
msgid ""
"// You can use `_` as the target type\n"
"// if it can be correctly inferred \n"
"// by the compiler. For example:\n"
msgstr ""
"// ì»´íŒŒì¼ëŸ¬ê°€\n"
"// ì˜¬ë°”ë¥´ê²Œ ì¶”ë¡ í•  ìˆ˜ ìˆëŠ” ê²½ìš°\n"
"// `_`ë¥¼ ëŒ€ìƒ íƒ€ì…ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆì‹œ:\n"

#: src/02_basic_calculator/10_as_casting.md:26
msgid ""
"The semantics of this conversion are what you expect: all `u32` values are "
"valid `u64` values."
msgstr ""
"ì´ ë³€í™˜ì˜ ì˜ë¯¸ëŠ” ì—¬ëŸ¬ë¶„ì´ ì˜ˆìƒí•˜ëŠ” ê²ƒê³¼ ê°™ìŠµë‹ˆë‹¤. ëª¨ë“  `u32` ê°’ì€ ìœ íš¨í•œ "
"`u64` ê°’ì…ë‹ˆë‹¤."

#: src/02_basic_calculator/10_as_casting.md:29
msgid "Truncation"
msgstr "Truncation"

#: src/02_basic_calculator/10_as_casting.md:31
msgid "Things get more interesting if we go in the opposite direction:"
msgstr "ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ ê°€ë©´ ìƒí™©ì´ ë” í¥ë¯¸ë¡œì›Œì§‘ë‹ˆë‹¤:"

#: src/02_basic_calculator/10_as_casting.md:34
msgid ""
"// A number that's too big \n"
"// to fit into a `u8`\n"
msgstr ""
"// ë„ˆë¬´ ì»¤ì„œ\n"
"// `u8`ì— ë“¤ì–´ê°ˆ ìˆ˜ ì—†ëŠ” ìˆ«ì\n"

#: src/02_basic_calculator/10_as_casting.md:40
msgid ""
"This program will run without issues, because `as` conversions are "
"infallible. But what is the value of `b`? When going from a larger integer "
"type to a smaller, the Rust compiler will perform a **truncation**."
msgstr ""
"`as` ë³€í™˜ì—ëŠ” ì˜¤ë¥˜ê°€ ì—†ê¸° ë•Œë¬¸ì— ì´ í”„ë¡œê·¸ë¨ì€ ë¬¸ì œ ì—†ì´ ì‹¤í–‰ë©ë‹ˆë‹¤. ê·¸ëŸ°ë° "
"`b`ì˜ ê°’ì€ ë¬´ì—‡ì…ë‹ˆê¹Œ? ë” í° ì •ìˆ˜ íƒ€ì…ì—ì„œ ë” ì‘ì€ íƒ€ì…ìœ¼ë¡œ ì „í™˜í•  ë•Œ Rust ì»´"
"íŒŒì¼ëŸ¬ëŠ” **truncation**ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤."

#: src/02_basic_calculator/10_as_casting.md:45
msgid ""
"To understand what happens, let's start by looking at how `256u16` is "
"represented in memory, as a sequence of bits:"
msgstr ""
"ë¬´ìŠ¨ ì¼ì´ ì¼ì–´ë‚˜ëŠ”ì§€ ì´í•´í•˜ê¸° ìœ„í•´ `256u16`ì´ ë©”ëª¨ë¦¬ì— ë¹„íŠ¸ ì‹œí€€ìŠ¤ë¡œ ì–´ë–»ê²Œ í‘œ"
"ì‹œë˜ëŠ”ì§€ë¶€í„° ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/02_basic_calculator/10_as_casting.md:55
msgid ""
"When converting to a `u8`, the Rust compiler will keep the last 8 bits of a "
"`u16` memory representation:"
msgstr ""
"`u8`ë¡œ ë³€í™˜í•  ë•Œ Rust ì»´íŒŒì¼ëŸ¬ëŠ” `u16` ë©”ëª¨ë¦¬ í‘œí˜„ì˜ ë§ˆì§€ë§‰ 8ë¹„íŠ¸ë¥¼ ìœ ì§€í•©ë‹ˆ"
"ë‹¤:"

#: src/02_basic_calculator/10_as_casting.md:65
msgid ""
"Hence `256 as u8` is equal to `0`. That's... not ideal, in most scenarios.  \n"
"In fact, the Rust compiler will actively try to stop you if it sees you "
"trying to cast a literal value which will result in a truncation:"
msgstr ""
"ë”°ë¼ì„œ `256 as u8`ì€ `0`ê³¼ ê°™ìŠµë‹ˆë‹¤. ê·¸ê±´... ëŒ€ë¶€ë¶„ì˜ ì‹œë‚˜ë¦¬ì˜¤ì—ì„œ ì´ìƒì ì´ì§€ "
"ì•ŠìŠµë‹ˆë‹¤.  \n"
"ì‹¤ì œë¡œ, Rust ì»´íŒŒì¼ëŸ¬ëŠ” ì—¬ëŸ¬ë¶„ì´ ë¦¬í„°ëŸ´ ê°’ì„ ìºìŠ¤íŒ…í•˜ë ¤ê³  ì‹œë„í•˜ëŠ” ê²ƒì„ ë°œê²¬í•˜"
"ë©´ ì ê·¹ì ìœ¼ë¡œ ì—¬ëŸ¬ë¶„ì„ ë§‰ìœ¼ë ¤ê³  ë…¸ë ¥í•  ê²ƒì…ë‹ˆë‹¤:"

#: src/02_basic_calculator/10_as_casting.md:80
msgid "Recommendation"
msgstr "ì¶”ì²œí•˜ëŠ” ë°©ì‹"

#: src/02_basic_calculator/10_as_casting.md:82
msgid ""
"As a rule of thumb, be quite careful with `as` casting.  \n"
"Use it _exclusively_ for going from a smaller type to a larger type. To "
"convert from a larger to smaller integer type, rely on the [_fallible_ "
"conversion machinery](../05_ticket_v2/13_try_from.md) that we'll explore "
"later in the course."
msgstr ""
"ê²½í—˜ìƒ `as` ìºìŠ¤íŒ…í•  ë•ŒëŠ” ë§¤ìš° ì£¼ì˜í•´ì•¼ í•©ë‹ˆë‹¤.  \n"
"ë” ì‘ì€ íƒ€ì…ì—ì„œ ë” í° íƒ€ì…ìœ¼ë¡œ ì „í™˜í•˜ë ¤ë©´ _ë…ì ì ìœ¼ë¡œ_ ì‚¬ìš©í•˜ì„¸ìš”. ë” í° ì •"
"ìˆ˜ íƒ€ì…ì—ì„œ ë” ì‘ì€ ì •ìˆ˜ íƒ€ì…ìœ¼ë¡œ ë³€í™˜í•˜ë ¤ë©´ ì´ ê³¼ì •ì˜ ë’·ë¶€ë¶„ì—ì„œ ì‚´í´ë³¼ "
"[_fallible_ ë³€í™˜ ë©”ì»¤ë‹ˆì¦˜](../05_ticket_v2/13_try_from.md)ì„ ì‚¬ìš©í•˜ì„¸ìš”."

#: src/02_basic_calculator/10_as_casting.md:88
#: src/06_ticket_management/11_mutable_slices.md:21
msgid "Limitations"
msgstr "í•œê³„ì "

#: src/02_basic_calculator/10_as_casting.md:90
msgid ""
"Surprising behaviour is not the only downside of `as` casting. It is also "
"fairly limited: you can only rely on `as` casting for primitive types and a "
"few other special cases.  \n"
"When working with composite types, you'll have to rely on different "
"conversion mechanisms ([fallible](../05_ticket_v2/13_try_from.md) and "
"[infallible](../04_traits/09_from.md)), which we'll explore later on."
msgstr ""
"ë†€ë¼ìš´ ë™ì‘ì´ as ìºìŠ¤íŒ…ì˜ ìœ ì¼í•œ ë‹¨ì ì€ ì•„ë‹™ë‹ˆë‹¤. as ìºìŠ¤íŒ…ì€ ìƒë‹¹íˆ ì œí•œì ì´"
"ì–´ì„œ, ì›ì‹œ íƒ€ì…ê³¼ ëª‡ ê°€ì§€ íŠ¹ë³„í•œ ê²½ìš°ì—ë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"ë³µí•© íƒ€ì…ìœ¼ë¡œ ì‘ì—…í•  ë•Œ ë‚˜ì¤‘ì— ì‚´í´ë³´ê²Œ ë  ë‹¤ì–‘í•œ ë³€í™˜ ë©”ì»¤ë‹ˆì¦˜([fallible]"
"(../05_ticket_v2/13_try_from.md)ê³¼ [infallible](../04_traits/09_from.md))ë¥¼ ì‚¬"
"ìš©í•´ì•¼í•©ë‹ˆë‹¤."

#: src/02_basic_calculator/10_as_casting.md:99
msgid ""
"Check out [Rust's official reference](https://doc.rust-lang.org/reference/"
"expressions/operator-expr.html#numeric-cast) to learn the precise behaviour "
"of `as` casting for each source/target combination, as well as the exhaustive "
"list of allowed conversions."
msgstr ""
"ê° ì†ŒìŠ¤/íƒ€ê²Ÿ ì¡°í•©ì— ëŒ€í•œ `as` ìºìŠ¤íŒ…ì˜ ì •í™•í•œ ë™ì‘ê³¼ í—ˆìš©ë˜ëŠ” ë³€í™˜ì˜ ì „ì²´ ëª©ë¡"
"ì„ ì•Œì•„ë³´ë ¤ë©´ [Rust's official reference](https://doc.rust-lang.org/reference/"
"expressions/operator-expr.html#numeric-cast)ë¥¼ í™•ì¸í•˜ì„¸ìš”."

#: src/02_basic_calculator/10_as_casting.md:105
msgid ""
"The exercise for this section is located in "
"[`02_basic_calculator/10_as_casting`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/10_as_casting)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`02_basic_calculator/10_as_casting`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/10_as_casting)ì— ìˆìŠµë‹ˆë‹¤"

#: src/03_ticket_v1/00_intro.md:1
msgid "Modelling A Ticket"
msgstr "í‹°ì¼“ ëª¨ë¸ë§"

#: src/03_ticket_v1/00_intro.md:3
msgid ""
"The first chapter should have given you a good grasp over some of Rust's "
"primitive types, operators and basic control flow constructs.  \n"
"In this chapter we'll go one step further and cover what makes Rust truly "
"unique: **ownership**.  \n"
"Ownership is what enables Rust to be both memory-safe and performant, with no "
"garbage collector."
msgstr ""
"ì²« ë²ˆì§¸ ì¥ì—ì„œëŠ” Rustì˜ ì›ì‹œ íƒ€ì…, ì—°ì‚°ì ë° ê¸°ë³¸ íë¦„ ì œì–´ êµ¬ì„± ì¤‘ ì¼ë¶€ì— ëŒ€"
"í•´ ì˜ ì´í•´í•  ìˆ˜ ìˆì—ˆì„ ê²ƒì…ë‹ˆë‹¤.  \n"
"ì´ë²ˆ ì¥ì—ì„œ ìš°ë¦¬ëŠ” í•œ ë‹¨ê³„ ë” ë‚˜ì•„ê°€ Rustë¥¼ ì§„ì •ìœ¼ë¡œ ë…íŠ¹í•˜ê²Œ ë§Œë“œëŠ” ìš”ì†Œì¸ **"
"ì†Œìœ ê¶Œ**ì„ ë‹¤ë£° ê²ƒì…ë‹ˆë‹¤.  \n"
"ì†Œìœ ê¶Œì€ Rustê°€ ê°€ë¹„ì§€ì½œë ‰í„° ì—†ì´ë„ ë©”ëª¨ë¦¬ ì•ˆì „ê³¼ ì„±ëŠ¥ì„ ëª¨ë‘ ë°œíœ˜í•  ìˆ˜ ìˆê²Œ "
"í•´ì¤ë‹ˆë‹¤."

#: src/03_ticket_v1/00_intro.md:8
msgid ""
"As our running example, we'll use a (JIRA-like) ticket, the kind you'd use to "
"track bugs, features, or tasks in a software project.  \n"
"We'll take a stab at modeling it in Rust. It'll be the first iterationâ€”it "
"won't be perfect nor very idiomatic by the end of the chapter. It'll be "
"enough of a challenge though!  \n"
"To move forward you'll have to pick up several new Rust concepts, such as:"
msgstr ""
"ì‹¤í–‰ ì˜ˆì œë¡œì„œ ì†Œí”„íŠ¸ì›¨ì–´ í”„ë¡œì íŠ¸ì—ì„œ ë²„ê·¸, ê¸°ëŠ¥ ë˜ëŠ” ì‘ì—…ì„ ì¶”ì í•˜ëŠ” ë° ì‚¬ìš©"
"í•˜ëŠ” ì¢…ë¥˜ì˜ (JIRAì™€ ìœ ì‚¬í•œ) í‹°ì¼“ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.  \n"
"ìš°ë¦¬ëŠ” Rustì—ì„œ ëª¨ë¸ë§ì„ ì‹œë„í•´ ë³¼ ê²ƒì…ë‹ˆë‹¤. ì´ê²ƒì€ ì²« ë²ˆì§¸ ë°˜ë³µì´ ë  ê²ƒì…ë‹ˆ"
"ë‹¤. ì´ ì¥ì˜ ëê¹Œì§€ ì™„ë²½í•˜ì§€ë„ ì•Šê³  ë§¤ìš° ê´€ìš©ì ì´ì§€ë„ ì•Šì„ ê²ƒì…ë‹ˆë‹¤. ê·¸ë˜ë„ ì¶©"
"ë¶„íˆ ë„ì „í•  ìˆ˜ ìˆì„ ê±°ì˜ˆìš”!  \n"
"ì•ìœ¼ë¡œ ë‚˜ì•„ê°€ë ¤ë©´ ë‹¤ìŒê³¼ ê°™ì€ ëª‡ ê°€ì§€ ìƒˆë¡œìš´ Rust ê°œë…ì„ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤:"

#: src/03_ticket_v1/00_intro.md:14
msgid "`struct`s, one of Rust's ways to define custom types"
msgstr "`struct`, ì‚¬ìš©ì ì •ì˜ íƒ€ì…ì„ ì •ì˜í•˜ëŠ” Rustì˜ ë°©ë²• ì¤‘ í•˜ë‚˜"

#: src/03_ticket_v1/00_intro.md:15
msgid "Ownership, references and borrowing"
msgstr "ì†Œìœ ê¶Œ, ì°¸ì¡° ë° ì°¨ìš©"

#: src/03_ticket_v1/00_intro.md:16
msgid "Memory management: stack, heap, pointers, data layout, destructors"
msgstr "ë©”ëª¨ë¦¬ ê´€ë¦¬: ìŠ¤íƒ, í™, í¬ì¸í„°, ë°ì´í„° ë ˆì´ì•„ì›ƒ, ì†Œë©¸ì"

#: src/03_ticket_v1/00_intro.md:17
msgid "Modules and visibility"
msgstr "ëª¨ë“ˆ ë° ê°€ì‹œì„±"

#: src/03_ticket_v1/00_intro.md:18
msgid "Strings"
msgstr "ë¬¸ìì—´"

#: src/03_ticket_v1/00_intro.md:22
msgid ""
"The exercise for this section is located in [`03_ticket_v1/00_intro`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/00_intro)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`03_ticket_v1/00_intro`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/00_intro)ì— ìˆìŠµë‹ˆë‹¤"

#: src/03_ticket_v1/01_struct.md:3
msgid "We need to keep track of three pieces of information for each ticket:"
msgstr "ìš°ë¦¬ëŠ” ê° í‹°ì¼“ì— ëŒ€í•´ ì„¸ ê°€ì§€ ì •ë³´ë¥¼ ì¶”ì í•´ì•¼ í•©ë‹ˆë‹¤:"

#: src/03_ticket_v1/01_struct.md:5
msgid "A title"
msgstr "ì œëª©"

#: src/03_ticket_v1/01_struct.md:6
msgid "A description"
msgstr "ì„¤ëª…"

#: src/03_ticket_v1/01_struct.md:7
msgid "A status"
msgstr "ìƒíƒœ"

#: src/03_ticket_v1/01_struct.md:9
msgid ""
"We can start by using a [`String`](https://doc.rust-lang.org/std/string/"
"struct.String.html) to represent them. `String` is the type defined in Rust's "
"standard library to represent [UTF-8 encoded](https://en.wikipedia.org/wiki/"
"UTF-8) text."
msgstr ""
"ì´ë¥¼ í‘œí˜„í•˜ê¸° ìœ„í•´ [`String`](https://doc.rust-lang.org/std/string/struct."
"String.html)ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒë¶€í„° ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `String`ì€ [UTF-8ë¡œ ì¸ì½”ë”©"
"ëœ](https://en.wikipedia.org/wiki/UTF-8) í…ìŠ¤íŠ¸ë¥¼ ë‚˜íƒ€ë‚´ê¸° ìœ„í•´ Rustì˜ í‘œì¤€ ë¼"
"ì´ë¸ŒëŸ¬ë¦¬ì— ì •ì˜ëœ íƒ€ì…ì…ë‹ˆë‹¤."

#: src/03_ticket_v1/01_struct.md:13
msgid ""
"But how do we **combine** these three pieces of information into a single "
"entity?"
msgstr "í•˜ì§€ë§Œ ì´ ì„¸ ê°€ì§€ ì •ë³´ë¥¼ ì–´ë–»ê²Œ ë‹¨ì¼ í•­ëª©ìœ¼ë¡œ **ê²°í•©**í•  ìˆ˜ ìˆì„ê¹Œìš”?"

#: src/03_ticket_v1/01_struct.md:15
msgid "Defining a `struct`"
msgstr "`êµ¬ì¡°ì²´` ì •ì˜"

#: src/03_ticket_v1/01_struct.md:17
msgid "A `struct` defines a **new Rust type**."
msgstr "`struct`ëŠ” **ìƒˆë¡œìš´ Rust íƒ€ì…**ì„ ì •ì˜í•©ë‹ˆë‹¤."

#: src/03_ticket_v1/01_struct.md:27
msgid ""
"A struct is quite similar to what you would call a class or an object in "
"other programming languages."
msgstr ""
"êµ¬ì¡°ì²´ëŠ” ë‹¤ë¥¸ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì—ì„œ í´ë˜ìŠ¤ë‚˜ ê°œì²´ë¼ê³  ë¶€ë¥´ëŠ” ê²ƒê³¼ ë§¤ìš° ìœ ì‚¬í•©ë‹ˆ"
"ë‹¤."

#: src/03_ticket_v1/01_struct.md:29
msgid "Defining fields"
msgstr "í•„ë“œ ì •ì˜"

#: src/03_ticket_v1/01_struct.md:31
msgid ""
"The new type is built by combining other types as **fields**.  \n"
"Each field must have a name and a type, separated by a colon, `:`. If there "
"are multiple fields, they are separated by a comma, `,`."
msgstr ""
"ìƒˆë¡œìš´ ìœ í˜•ì€ ë‹¤ë¥¸ ìœ í˜•ì„ **í•„ë“œ**ë¡œ ê²°í•©í•˜ì—¬ êµ¬ì¶•ë©ë‹ˆë‹¤.  \n"
"ê° í•„ë“œì—ëŠ” ì½œë¡  `:`ìœ¼ë¡œ êµ¬ë¶„ëœ ì´ë¦„ê³¼ ìœ í˜•ì´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤. í•„ë“œê°€ ì—¬ëŸ¬ ê°œì¸ "
"ê²½ìš° ì‰¼í‘œ `,`ë¡œ êµ¬ë¶„í•©ë‹ˆë‹¤."

#: src/03_ticket_v1/01_struct.md:34
msgid ""
"Fields don't have to be of the same type, as you can see in the "
"`Configuration` struct below:"
msgstr ""
"ì•„ë˜ `Configuration` êµ¬ì¡°ì²´ì—ì„œ ë³¼ ìˆ˜ ìˆë“¯ì´ í•„ë“œëŠ” ë™ì¼í•œ ìœ í˜•ì¼ í•„ìš”ëŠ” ì—†ìŠµ"
"ë‹ˆë‹¤:"

#: src/03_ticket_v1/01_struct.md:43
msgid "Instantiation"
msgstr "ì¸ìŠ¤í„´ìŠ¤í™”"

#: src/03_ticket_v1/01_struct.md:45
msgid ""
"You can create an instance of a struct by specifying the values for each "
"field:"
msgstr "ê° í•„ë“œì˜ ê°’ì„ ì§€ì •í•˜ì—¬ êµ¬ì¡°ì²´ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/03_ticket_v1/01_struct.md:48
msgid "// Syntax: <StructName> { <field_name>: <value>, ... }\n"
msgstr "// ë¬¸ë²•: <StructName> { <field_name>: <value>, ... }\n"

#: src/03_ticket_v1/01_struct.md:50 src/03_ticket_v1/05_encapsulation.md:32
msgid "\"Build a ticket system\""
msgstr "\"Build a ticket system\""

#: src/03_ticket_v1/01_struct.md:51 src/03_ticket_v1/05_encapsulation.md:33
msgid "\"Create a system that can manage tickets across a Kanban board\""
msgstr "\"Create a system that can manage tickets across a Kanban board\""

#: src/03_ticket_v1/01_struct.md:52 src/03_ticket_v1/01_struct.md:73
#: src/03_ticket_v1/05_encapsulation.md:34
msgid "\"Open\""
msgstr "\"Open\""

#: src/03_ticket_v1/01_struct.md:56
msgid "Accessing fields"
msgstr "í•„ë“œì— ì ‘ê·¼í•˜ê¸°"

#: src/03_ticket_v1/01_struct.md:58
msgid "You can access the fields of a struct using the `.` operator:"
msgstr "`.` ì—°ì‚°ìë¥¼ ì‚¬ìš©í•˜ì—¬ êµ¬ì¡°ì²´ì˜ í•„ë“œì— ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/03_ticket_v1/01_struct.md:61
msgid "// Field access\n"
msgstr "// í•„ë“œ ì ‘ê·¼\n"

#: src/03_ticket_v1/01_struct.md:65
msgid "Methods"
msgstr "ë©”ì„œë“œ"

#: src/03_ticket_v1/01_struct.md:67
msgid ""
"We can attach behaviour to our structs by defining **methods**.  \n"
"Using the `Ticket` struct as an example:"
msgstr ""
"**ë©”ì„œë“œ**ë¥¼ ì •ì˜í•˜ì—¬ êµ¬ì¡°ì²´ì— ë™ì‘ì„ ì—°ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"ì˜ˆë¥¼ ë“¤ì–´ `Ticket` êµ¬ì¡°ì²´ë¥¼ ì‚¬ìš©í•˜ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/03_ticket_v1/01_struct.md:76
msgid ""
"// Syntax:\n"
"// impl <StructName> {\n"
"//    fn <method_name>(<parameters>) -> <return_type> {\n"
"//        // Method body\n"
"//    }\n"
"// }\n"
msgstr ""
"// ë¬¸ë²•:\n"
"// impl <StructName> {\n"
"//    fn <method_name>(<parameters>) -> <return_type> {\n"
"//        // Method body\n"
"//    }\n"
"// }\n"

#: src/03_ticket_v1/01_struct.md:85
msgid "Methods are pretty similar to functions, with two key differences:"
msgstr "ë©”ì†Œë“œëŠ” í•¨ìˆ˜ì™€ ë§¤ìš° ìœ ì‚¬í•˜ì§€ë§Œ ë‘ ê°€ì§€ ì£¼ìš” ì°¨ì´ì ì´ ìˆìŠµë‹ˆë‹¤:"

#: src/03_ticket_v1/01_struct.md:87
msgid "methods must be defined inside an **`impl` block**"
msgstr "ë©”ì†Œë“œëŠ” **`impl` ë¸”ë¡** ì•ˆì— ì •ì˜ë˜ì–´ì•¼ í•©ë‹ˆë‹¤"

#: src/03_ticket_v1/01_struct.md:88
msgid ""
"methods may use `self` as their first parameter. `self` is a keyword and "
"represents the instance of the struct the method is being called on."
msgstr ""
"ë©”ì†Œë“œëŠ” `self`ë¥¼ ì²« ë²ˆì§¸ ë§¤ê°œë³€ìˆ˜ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `self`ëŠ” í‚¤ì›Œë“œì´ë©° "
"ë©”ì†Œë“œê°€ í˜¸ì¶œë˜ëŠ” êµ¬ì¡°ì²´ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤."

#: src/03_ticket_v1/01_struct.md:91
msgid "`self`"
msgstr "`self`"

#: src/03_ticket_v1/01_struct.md:93
msgid ""
"If a method takes `self` as its first parameter, it can be called using the "
"**method call syntax**:"
msgstr ""
"ë©”ì†Œë“œê°€ `self`ë¥¼ ì²« ë²ˆì§¸ ë§¤ê°œë³€ìˆ˜ë¡œ ì‚¬ìš©í•˜ëŠ” ê²½ìš° **ë©”ì„œë“œ í˜¸ì¶œ ë¬¸ë²•**ì„ ì‚¬ìš©"
"í•˜ì—¬ í˜¸ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/01_struct.md:96
msgid "// Method call syntax: <instance>.<method_name>(<parameters>)\n"
msgstr "// ë©”ì†Œë“œ í˜¸ì¶œ ë¬¸ë²•: <instance>.<method_name>(<parameters>)\n"

#: src/03_ticket_v1/01_struct.md:100
msgid ""
"This is the same calling syntax you used to perform saturating arithmetic "
"operations on `u32` values in [the previous chapter]"
"(../02_basic_calculator/09_saturating.md)."
msgstr ""
"ì´ëŠ” ì´ì „ ì¥ì—ì„œ `u32` ê°’ì— ëŒ€í•´ í¬í™” ì‚°ìˆ  ì—°ì‚°ì„ ìˆ˜í–‰í•˜ëŠ” ë° ì‚¬ìš©í•œ ê²ƒê³¼ ë™ì¼"
"í•œ í˜¸ì¶œ ë¬¸ë²•ì…ë‹ˆë‹¤."

#: src/03_ticket_v1/01_struct.md:103
msgid "Static methods"
msgstr "ì •ì  ë©”ì„œë“œ"

#: src/03_ticket_v1/01_struct.md:105
msgid ""
"If a method doesn't take `self` as its first parameter, it's a **static "
"method**."
msgstr ""
"ë©”ì†Œë“œê°€ `self`ë¥¼ ì²« ë²ˆì§¸ ë§¤ê°œë³€ìˆ˜ë¡œ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë©´ **ì •ì  ë©”ì„œë“œ**ì…ë‹ˆë‹¤."

#: src/03_ticket_v1/01_struct.md:114
msgid "// `default` is a static method on `Configuration`\n"
msgstr "// `default`ëŠ” `Configuration`ì˜ ì •ì  ë©”ì„œë“œì…ë‹ˆë‹¤.\n"

#: src/03_ticket_v1/01_struct.md:121
msgid ""
"The only way to call a static method is by using the **function call syntax**:"
msgstr ""
"ì •ì  ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ëŠ” ìœ ì¼í•œ ë°©ë²•ì€ **í•¨ìˆ˜ í˜¸ì¶œ ë¬¸ë²•**ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/03_ticket_v1/01_struct.md:124
msgid "// Function call syntax: <StructName>::<method_name>(<parameters>)\n"
msgstr "// í•¨ìˆ˜ í˜¸ì¶œ ë¬¸ë²•: <StructName>::<method_name>(<parameters>)\n"

#: src/03_ticket_v1/01_struct.md:128
msgid "Equivalence"
msgstr "ë“±ê°€"

#: src/03_ticket_v1/01_struct.md:130
msgid ""
"You can use the function call syntax even for methods that take `self` as "
"their first parameter:"
msgstr ""
"`self`ë¥¼ ì²« ë²ˆì§¸ ë§¤ê°œë³€ìˆ˜ë¡œ ì‚¬ìš©í•˜ëŠ” ë©”ì†Œë“œì˜ ê²½ìš°ì—ë„ í•¨ìˆ˜ í˜¸ì¶œ ë¬¸ë²•ì„ ì‚¬ìš©"
"í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/01_struct.md:133
msgid ""
"// Function call syntax: <StructName>::<method_name>(<instance>, "
"<parameters>)\n"
msgstr ""
"// í•¨ìˆ˜ í˜¸ì¶œ ë¬¸ë²•: <StructName>::<method_name>(<instance>, <parameters>)\n"

#: src/03_ticket_v1/01_struct.md:137
msgid ""
"The function call syntax makes it quite clear that `ticket` is being used as "
"`self`, the first parameter of the method, but it's definitely more verbose. "
"Prefer the method call syntax when possible."
msgstr ""
"í•¨ìˆ˜ í˜¸ì¶œ êµ¬ë¬¸ì„ ë³´ë©´ `ticket`ì´ ë©”ì„œë“œì˜ ì²« ë²ˆì§¸ ë§¤ê°œë³€ìˆ˜ì¸ `self`ë¡œ ì‚¬ìš©ë˜"
"ê³  ìˆìŒì´ ë¶„ëª…í•˜ì§€ë§Œ í™•ì‹¤íˆ ë” ì¥í™©í•©ë‹ˆë‹¤. ê°€ëŠ¥í•˜ë©´ ë©”ì„œë“œ í˜¸ì¶œ ë¬¸ë²•ì„ ì‚¬ìš©í•˜"
"ì„¸ìš”."

#: src/03_ticket_v1/01_struct.md:142
msgid ""
"The exercise for this section is located in [`03_ticket_v1/01_struct`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/01_struct)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`03_ticket_v1/01_struct`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/01_struct)ì— ìˆìŠµë‹ˆë‹¤"

#: src/03_ticket_v1/02_validation.md:3
msgid "Let's go back to our ticket definition:"
msgstr "í‹°ì¼“ ì •ì˜ë¡œ ëŒì•„ê°€ ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/03_ticket_v1/02_validation.md:13
msgid ""
"We are using \"raw\" types for the fields of our `Ticket` struct. This means "
"that users can create a ticket with an empty title, a suuuuuuuper long "
"description or a nonsensical status (e.g. \"Funny\").  \n"
"We can do better than that!"
msgstr ""
"ìš°ë¦¬ëŠ” `Ticket` êµ¬ì¡°ì²´ì˜ í•„ë“œì— \"ì›ì‹œ\" íƒ€ì…ì„ ì‚¬ìš©í•˜ê³  ìˆìŠµë‹ˆë‹¤. ì¦‰, ì‚¬ìš©ì"
"ëŠ” ë¹ˆ ì œëª©, ì–´ì–´ì–´ì—„ì²­ë‚˜ê²Œ ê¸´ ì„¤ëª… ë˜ëŠ” ì˜ë¯¸ì—†ëŠ” ìƒíƒœ(ì˜ˆ: \"ì¬ë¯¸ìˆìŒ\")ë¡œ í‹°ì¼“"
"ì„ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"ìš°ë¦¬ëŠ” ì´ê²ƒë³´ë‹¤ ë” ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!"

#: src/03_ticket_v1/02_validation.md:20
msgid ""
"Check out [`String`'s documentation](https://doc.rust-lang.org/std/string/"
"struct.String.html) for a thorough overview of the methods it provides. "
"You'll need it for the exercise!"
msgstr ""
"ì œê³µë˜ëŠ” ë©”ì†Œë“œì— ëŒ€í•œ ì² ì €í•œ ê°œìš”ëŠ” [`String`ì˜ ë¬¸ì„œ](https://doc.rust-lang."
"org/std/string/struct.String.html)ë¥¼ í™•ì¸í•˜ì„¸ìš”. ì˜ˆì œë¥¼ í’€ ë•Œ ê¼­ í•„ìš”í•´ìš”!"

#: src/03_ticket_v1/02_validation.md:25
msgid ""
"The exercise for this section is located in [`03_ticket_v1/02_validation`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/02_validation)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`03_ticket_v1/02_validation`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/02_validation)ì— ìˆìŠµë‹ˆë‹¤"

#: src/03_ticket_v1/03_modules.md:3
msgid ""
"The `new` method you've just defined is trying to enforce some "
"**constraints** on the field values for `Ticket`. But are those invariants "
"really enforced? What prevents a developer from creating a `Ticket` without "
"going through `Ticket::new`?"
msgstr ""
"ë°©ê¸ˆ ì •ì˜í•œ `new` ë©”ì†Œë“œëŠ” `Ticket`ì˜ í•„ë“œ ê°’ì— ì¼ë¶€ **ì œì•½ì¡°ê±´**ì„ ì ìš©í•˜ë ¤"
"ê³  í•©ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì´ëŸ¬í•œ ë¶ˆë³€ì„±ì´ ì‹¤ì œë¡œ ì§€ì¼œì§€ë‚˜ìš”? ê°œë°œìê°€ `Ticket::new`ë¥¼ "
"ê±°ì¹˜ì§€ ì•Šê³  `Ticket`ì„ ìƒì„±í•˜ëŠ” ê²ƒì„ ë§‰ëŠ”ê²Œ ìˆë‚˜ìš”?"

#: src/03_ticket_v1/03_modules.md:7
msgid ""
"To get proper **encapsulation** you need to become familiar with two new "
"concepts: **visibility** and **modules**. Let's start with modules."
msgstr ""
"ì ì ˆí•œ **ìº¡ìŠí™”**ë¥¼ ì–»ìœ¼ë ¤ë©´ **ê°€ì‹œì„±**ê³¼ **ëª¨ë“ˆ**ì´ë¼ëŠ” ë‘ ê°€ì§€ ìƒˆë¡œìš´ ê°œë…"
"ì— ìµìˆ™í•´ì ¸ì•¼ í•©ë‹ˆë‹¤. ëª¨ë“ˆë¶€í„° ì‹œì‘í•´ ë³´ê² ìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/03_modules.md:10
msgid "What is a module?"
msgstr "ëª¨ë“ˆì´ë€ ë¬´ì—‡ì…ë‹ˆê¹Œ?"

#: src/03_ticket_v1/03_modules.md:12
msgid ""
"In Rust a **module** is a way to group related code together, under a common "
"namespace (i.e. the module's name).  \n"
"You've already seen modules in action: the unit tests that verify the "
"correctness of your code are defined in a different module, named `tests`."
msgstr ""
"Rustì—ì„œ **ëª¨ë“ˆ**ì€ ê´€ë ¨ ì½”ë“œë¥¼ ê³µí†µ ë„¤ì„ìŠ¤í˜ì´ìŠ¤(ì˜ˆ: ëª¨ë“ˆ ì´ë¦„) ì•„ë˜ì— í•¨ê»˜ "
"ê·¸ë£¹í™”í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.  \n"
"ì—¬ëŸ¬ë¶„ì€ ì´ë¯¸ ì‘ë™ ì¤‘ì¸ ëª¨ë“ˆì„ ë³´ì•˜ìŠµë‹ˆë‹¤. ì½”ë“œì˜ ì •í™•ì„±ì„ í™•ì¸í•˜ëŠ” ë‹¨ìœ„ í…ŒìŠ¤"
"íŠ¸ëŠ” `tests`ë¼ëŠ” ë‹¤ë¥¸ ëª¨ë“ˆì— ì •ì˜ë˜ì–´ ìˆìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/03_modules.md:19 src/03_ticket_v1/03_modules.md:69
#: src/03_ticket_v1/03_modules.md:75 src/03_ticket_v1/03_modules.md:97
#: src/03_ticket_v1/06_ownership.md:217 src/04_traits/02_orphan_rule.md:40
#: src/04_traits/04_derive.md:21 src/04_traits/04_derive.md:43
#: src/04_traits/05_trait_bounds.md:134 src/04_traits/05_trait_bounds.md:156
#: src/04_traits/07_deref.md:78 src/04_traits/09_from.md:18
#: src/04_traits/10_assoc_vs_generic.md:97
#: src/04_traits/10_assoc_vs_generic.md:123 src/05_ticket_v2/01_enum.md:18
#: src/06_ticket_management/05_iter.md:19 src/06_ticket_management/05_iter.md:33
#: src/06_ticket_management/06_lifetimes.md:47
#: src/06_ticket_management/06_lifetimes.md:68
#: src/06_ticket_management/15_hashmap.md:40
#: src/07_threads/06_interior_mutability.md:8 src/08_futures/01_async_fn.md:27
#: src/08_futures/01_async_fn.md:61 src/08_futures/02_spawn.md:76
#: src/08_futures/02_spawn.md:80 src/08_futures/02_spawn.md:109
#: src/08_futures/05_blocking.md:62
#: src/08_futures/06_async_aware_primitives.md:29
#: src/08_futures/07_cancellation.md:16
msgid "// [...]\n"
msgstr "// [...]\n"

#: src/03_ticket_v1/03_modules.md:23
msgid "Inline modules"
msgstr "ì¸ë¼ì¸ ëª¨ë“ˆ"

#: src/03_ticket_v1/03_modules.md:25
msgid ""
"The `tests` module above is an example of an **inline module**: the module "
"declaration (`mod tests`) and the module contents (the stuff inside `{ ... }"
"`) are next to each other."
msgstr ""
"ìœ„ì˜ `tests` ëª¨ë“ˆì€ **ì¸ë¼ì¸ ëª¨ë“ˆ**ì˜ ì˜ˆì…ë‹ˆë‹¤. ëª¨ë“ˆ ì„ ì–¸(`mod tests`)ê³¼ ëª¨ë“ˆ "
"ë‚´ìš©(`{ ... }` ë‚´ë¶€ì˜ í•­ëª©)ì´ ë°”ë¡œ ì˜†ì— ìˆìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/03_modules.md:28
msgid "Module tree"
msgstr "ëª¨ë“ˆ íŠ¸ë¦¬"

#: src/03_ticket_v1/03_modules.md:30
msgid ""
"Modules can be nested, forming a **tree** structure.  \n"
"The root of the tree is the **crate** itself, which is the top-level module "
"that contains all the other modules. For a library crate, the root module is "
"usually `src/lib.rs` (unless its location has been customized). The root "
"module is also known as the **crate root**."
msgstr ""
"ëª¨ë“ˆì€ ì¤‘ì²©ë˜ì–´ **íŠ¸ë¦¬** êµ¬ì¡°ë¥¼ í˜•ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"íŠ¸ë¦¬ì˜ ë£¨íŠ¸ëŠ” ë‹¤ë¥¸ ëª¨ë“  ëª¨ë“ˆì„ í¬í•¨í•˜ëŠ” ìµœìƒìœ„ ëª¨ë“ˆì¸ **í¬ë ˆì´íŠ¸** ìì²´ì…ë‹ˆ"
"ë‹¤. ë¼ì´ë¸ŒëŸ¬ë¦¬ í¬ë ˆì´íŠ¸ì˜ ê²½ìš° ë£¨íŠ¸ ëª¨ë“ˆì€ ì¼ë°˜ì ìœ¼ë¡œ `src/lib.rs`ì…ë‹ˆë‹¤(ìœ„ì¹˜"
"ê°€ ì‚¬ìš©ì ì •ì˜ ë˜ì§€ ì•Šì€ ê²½ìš°). ë£¨íŠ¸ ëª¨ë“ˆì€ **í¬ë ˆì´íŠ¸ ë£¨íŠ¸**ë¼ê³ ë„ í•©ë‹ˆë‹¤."

#: src/03_ticket_v1/03_modules.md:35
msgid ""
"The crate root can have submodules, which in turn can have their own "
"submodules, and so on."
msgstr ""
"í¬ë ˆì´íŠ¸ ë£¨íŠ¸ì—ëŠ” í•˜ìœ„ ëª¨ë“ˆì´ ìˆì„ ìˆ˜ ìˆìœ¼ë©°, ì´ í•˜ìœ„ ëª¨ë“ˆì€ ìì²´ í•˜ìœ„ ëª¨ë“ˆì„ "
"ê°€ì§ˆ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/03_modules.md:37
msgid "External modules and the filesystem"
msgstr "ì™¸ë¶€ ëª¨ë“ˆê³¼ íŒŒì¼ ì‹œìŠ¤í…œ"

#: src/03_ticket_v1/03_modules.md:39
msgid ""
"Inline modules are useful for small pieces of code, but as your project grows "
"you'll want to split your code into multiple files. In the parent module, you "
"declare the existence of a submodule using the `mod` keyword."
msgstr ""
"ì¸ë¼ì¸ ëª¨ë“ˆì€ ì‘ì€ ì½”ë“œ ì¡°ê°ì— ìœ ìš©í•˜ì§€ë§Œ í”„ë¡œì íŠ¸ê°€ ì»¤ì§€ë©´ ì½”ë“œë¥¼ ì—¬ëŸ¬ íŒŒì¼"
"ë¡œ ë¶„í• í•˜ê³  ì‹¶ì„ ê²ƒì…ë‹ˆë‹¤. ìƒìœ„ ëª¨ë“ˆì—ì„œëŠ” `mod` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ í•˜ìœ„ ëª¨ë“ˆ"
"ì˜ ì¡´ì¬ë¥¼ ì„ ì–¸í•©ë‹ˆë‹¤."

#: src/03_ticket_v1/03_modules.md:46
msgid ""
"`cargo`, Rust's build tool, is then in charge of finding the file that "
"contains the module implementation.  \n"
"If your module is declared in the root of your crate (e.g. `src/lib.rs` or "
"`src/main.rs`), `cargo` expects the file to be named either:"
msgstr ""
"Rustì˜ ë¹Œë“œ ë„êµ¬ì¸ `cargo`ëŠ” ëª¨ë“ˆ êµ¬í˜„ì´ í¬í•¨ëœ íŒŒì¼ì„ ì°¾ëŠ” ì¼ì„ ë‹´ë‹¹í•©ë‹ˆ"
"ë‹¤.  \n"
"ëª¨ë“ˆì´ í¬ë ˆì´íŠ¸ ë£¨íŠ¸(ì˜ˆ: `src/lib.rs` ë˜ëŠ” `src/main.rs`)ì— ì„ ì–¸ëœ ê²½ìš° "
"`cargo`ëŠ” íŒŒì¼ ì´ë¦„ì´ ë‹¤ìŒ ì¤‘ í•˜ë‚˜ë¡œ ì§€ì •ë  ê²ƒìœ¼ë¡œ ì˜ˆìƒí•©ë‹ˆë‹¤:"

#: src/03_ticket_v1/03_modules.md:51
msgid "`src/<module_name>.rs`"
msgstr "`src/<module_name>.rs`"

#: src/03_ticket_v1/03_modules.md:52
msgid "`src/<module_name>/mod.rs`"
msgstr "`src/<module_name>/mod.rs`"

#: src/03_ticket_v1/03_modules.md:54
msgid ""
"If your module is a submodule of another module, the file should be named:"
msgstr "ëª¨ë“ˆì´ ë‹¤ë¥¸ ëª¨ë“ˆì˜ í•˜ìœ„ ëª¨ë“ˆì¸ ê²½ìš° íŒŒì¼ ì´ë¦„ì€ ë‹¤ìŒê³¼ ê°™ì•„ì•¼ í•©ë‹ˆë‹¤:"

#: src/03_ticket_v1/03_modules.md:56
msgid "`[..]/<parent_module>/<module_name>.rs`"
msgstr "`[..]/<parent_module>/<module_name>.rs`"

#: src/03_ticket_v1/03_modules.md:57
msgid "`[..]/<parent_module>/<module_name>/mod.rs`"
msgstr "`[..]/<parent_module>/<module_name>/mod.rs`"

#: src/03_ticket_v1/03_modules.md:59
msgid ""
"E.g. `src/animals/dog.rs` or `src/animals/dog/mod.rs` if `dog` is a submodule "
"of `animals`."
msgstr ""
"ì˜ˆ: `dog`ê°€ `animals`ì˜ í•˜ìœ„ ëª¨ë“ˆì¸ ê²½ìš° `src/animals/dog.rs` ë˜ëŠ” `src/"
"animals/dog/mod.rs`."

#: src/03_ticket_v1/03_modules.md:61
msgid ""
"Your IDE might help you create these files automatically when you declare a "
"new module using the `mod` keyword."
msgstr ""
"IDEëŠ” `mod` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒˆ ëª¨ë“ˆì„ ì„ ì–¸í•  ë•Œ ì´ëŸ¬í•œ íŒŒì¼ì„ ìë™ìœ¼ë¡œ ìƒì„±"
"í•˜ëŠ” ë° ë„ì›€ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/03_modules.md:63
msgid "Item paths and `use` statements"
msgstr "ì•„ì´í…œ ê²½ë¡œì™€ `use` ë¬¸"

#: src/03_ticket_v1/03_modules.md:65
msgid ""
"You can access items defined in the same module without any special syntax. "
"You just use their name."
msgstr ""
"íŠ¹ë³„í•œ ë¬¸ë²• ì—†ì´ ë™ì¼í•œ ëª¨ë“ˆì— ì •ì˜ëœ í•­ëª©ì— ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•­ëª©ë“¤ì˜ ì´"
"ë¦„ì„ ì‚¬ìš©í•˜ë©´ ë©ë‹ˆë‹¤."

#: src/03_ticket_v1/03_modules.md:71
msgid ""
"// No need to qualify `Ticket` in any way here\n"
"// because we're in the same module\n"
msgstr ""
"// ì—¬ê¸°ì„œëŠ” `Ticket`ì„ ì–´ë–¤ ì‹ìœ¼ë¡œë“  ì •í•´ì¤„ í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤.\n"
"// ì™œëƒí•˜ë©´ ìš°ë¦¬ëŠ” ë™ì¼í•œ ëª¨ë“ˆì— ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.\n"

#: src/03_ticket_v1/03_modules.md:79
msgid ""
"That's not the case if you want to access an entity from a different "
"module.  \n"
"You have to use a **path** pointing to the entity you want to access."
msgstr ""
"ë‹¤ë¥¸ ëª¨ë“ˆì—ì„œ ì—”í„°í‹°ì— ì•¡ì„¸ìŠ¤í•˜ë ¤ëŠ” ê²½ìš°ì—ëŠ” ê·¸ë ‡ì§€ ì•ŠìŠµë‹ˆë‹¤.  \n"
"ì•¡ì„¸ìŠ¤í•˜ë ¤ëŠ” ì—”í„°í‹°ë¥¼ ê°€ë¦¬í‚¤ëŠ” **ê²½ë¡œ**ë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/03_ticket_v1/03_modules.md:82
msgid "You can compose the path in various ways:"
msgstr "ë‹¤ì–‘í•œ ë°©ë²•ìœ¼ë¡œ ê²½ë¡œë¥¼ êµ¬ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/03_ticket_v1/03_modules.md:84
msgid ""
"starting from the root of the current crate, e.g. `crate::module_1::module_2::"
"MyStruct`"
msgstr ""
"í˜„ì¬ í¬ë ˆì´íŠ¸ì˜ ë£¨íŠ¸ë¶€í„° ì‹œì‘í•©ë‹ˆë‹¤. ì˜ˆ: `crate::module_1::module_2::MyStruct`"

#: src/03_ticket_v1/03_modules.md:85
msgid "starting from the parent module, e.g. `super::my_function`"
msgstr "ìƒìœ„ ëª¨ë“ˆì—ì„œ ì‹œì‘í•©ë‹ˆë‹¤. ì˜ˆ: `super::my_function`"

#: src/03_ticket_v1/03_modules.md:86
msgid "starting from the current module, e.g. `sub_module_1::MyStruct`"
msgstr "í˜„ì¬ ëª¨ë“ˆì—ì„œ ì‹œì‘í•©ë‹ˆë‹¤. ì˜ˆ: `sub_module_1::MyStruct`"

#: src/03_ticket_v1/03_modules.md:88
msgid ""
"Having to write the full path every time you want to refer to a type can be "
"cumbersome. To make your life easier, you can introduce a `use` statement to "
"bring the entity into scope."
msgstr ""
"íƒ€ì…ì„ ì°¸ì¡°í•  ë•Œë§ˆë‹¤ ì „ì²´ ê²½ë¡œë¥¼ ì‘ì„±í•´ì•¼ í•˜ëŠ” ê²ƒì€ ë²ˆê±°ë¡œìš¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì¸ìƒ"
"ì„ ë” ì‰½ê²Œ ë§Œë“¤ê¸° ìœ„í•´ `use` ë¬¸ì„ ì‚¬ìš©í•´ ì—”í„°í‹°ë¥¼ ìŠ¤ì½”í”„ë¡œ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/03_modules.md:92
msgid "// Bring `MyStruct` into scope\n"
msgstr "// `MyStruct`ë¥¼ ìŠ¤ì½”í”„ë¡œ ê°€ì ¸ì˜µë‹ˆë‹¤.\n"

#: src/03_ticket_v1/03_modules.md:94
msgid "// Now you can refer to `MyStruct` directly\n"
msgstr "// ì´ì œ `MyStruct`ë¥¼ ì§ì ‘ ì°¸ì¡°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"

#: src/03_ticket_v1/03_modules.md:101
msgid "Star imports"
msgstr "ë³„í‘œ ì„í¬íŠ¸"

#: src/03_ticket_v1/03_modules.md:103
msgid ""
"You can also import all the items from a module with a single `use` statement."
msgstr "ë‹¨ì¼ `use` ë¬¸ì„ ì‚¬ìš©í•˜ì—¬ ëª¨ë“ˆì˜ ëª¨ë“  í•­ëª©ì„ ê°€ì ¸ì˜¬ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/03_modules.md:109
msgid ""
"This is known as a **star import**.  \n"
"It is generally discouraged because it can pollute the current namespace, "
"making it hard to understand where each name comes from and potentially "
"introducing name conflicts.  \n"
"Nonetheless, it can be useful in some cases, like when writing unit tests. "
"You might have noticed that most of our test modules start with a `use super::"
"*;` statement to bring all the items from the parent module (the one being "
"tested) into scope."
msgstr ""
"ì´ê²ƒì„ **ë³„í‘œ ì„í¬íŠ¸**ë¼ê³  í•©ë‹ˆë‹¤.\n"
"ì¼ë°˜ì ìœ¼ë¡œ í˜„ì¬ ë„¤ì„ìŠ¤í˜ì´ìŠ¤ë¥¼ ì˜¤ì—¼ì‹œí‚¬ ìˆ˜ ìˆì–´ ê° ì´ë¦„ì´ ì–´ë””ì—ì„œ ì™”ëŠ”ì§€ ì´í•´"
"í•˜ê¸° ì–´ë µê²Œ ë§Œë“¤ê³  ì ì¬ì ìœ¼ë¡œ ì´ë¦„ ì¶©ëŒì„ ì¼ìœ¼í‚¬ ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ê¶Œì¥ë˜ì§€ ì•ŠìŠµ"
"ë‹ˆë‹¤.\n"
"ê·¸ëŸ¼ì—ë„ ë¶ˆêµ¬í•˜ê³ , ìœ ë‹› í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í•  ë•Œì²˜ëŸ¼ ìœ ìš©í•œ ê²½ìš°ê°€ ìˆìŠµë‹ˆë‹¤. ëŒ€ë¶€ë¶„"
"ì˜ í…ŒìŠ¤íŠ¸ ëª¨ë“ˆì´ `use super::*;` ë¬¸ìœ¼ë¡œ ì‹œì‘í•˜ì—¬ ë¶€ëª¨ ëª¨ë“ˆ(í…ŒìŠ¤íŠ¸ ì¤‘ì¸ ëª¨ë“ˆ)"
"ì˜ ëª¨ë“  í•­ëª©ì„ ìŠ¤ì½”í”„ì— ê°€ì ¸ì˜¤ëŠ” ê²ƒì„ ëˆˆì¹˜ì±˜ì„ ê²ì…ë‹ˆë‹¤."

#: src/03_ticket_v1/03_modules.md:118
msgid ""
"The exercise for this section is located in [`03_ticket_v1/03_modules`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/03_modules)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`03_ticket_v1/03_modules`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/03_modules)ì— ìˆìŠµë‹ˆë‹¤"

#: src/03_ticket_v1/04_visibility.md:3
msgid ""
"When you start breaking down your code into multiple modules, you need to "
"start thinking about **visibility**. Visibility determines which regions of "
"your code (or other people's code) can access a given entity, be it a struct, "
"a function, a field, etc."
msgstr ""
"ì½”ë“œë¥¼ ì—¬ëŸ¬ ëª¨ë“ˆë¡œ ë‚˜ëˆ„ê¸° ì‹œì‘í•  ë•Œ **ê°€ì‹œì„±**ì— ëŒ€í•´ ìƒê°í•´ì•¼ í•©ë‹ˆë‹¤. ê°€ì‹œì„±"
"ì€ êµ¬ì¡°ì²´, í•¨ìˆ˜, í•„ë“œ ë“± íŠ¹ì • ì—”í„°í‹°ì— ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆëŠ” ì½”ë“œ(ë˜ëŠ” ë‹¤ë¥¸ ì‚¬ëŒì˜ "
"ì½”ë“œ) ì˜ì—­ì„ ê²°ì •í•©ë‹ˆë‹¤."

#: src/03_ticket_v1/04_visibility.md:7
msgid "Private by default"
msgstr "ê¸°ë³¸ì ìœ¼ë¡œ ë¹„ê³µê°œ"

#: src/03_ticket_v1/04_visibility.md:9
msgid ""
"By default, everything in Rust is **private**.  \n"
"A private entity can only be accessed:"
msgstr ""
"ê¸°ë³¸ì ìœ¼ë¡œ Rustì˜ ëª¨ë“  ê²ƒì€ **ë¹„ê³µê°œ**ì…ë‹ˆë‹¤.  \n"
"í”„ë¼ì´ë¹— ì—”í„°í‹°ì—ëŠ” ë‹¤ìŒ ê²½ìš°ì—ë§Œ ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/03_ticket_v1/04_visibility.md:12
msgid "within the same module where it's defined, or"
msgstr "ì •ì˜ëœ ë™ì¼í•œ ëª¨ë“ˆ ë‚´ì—ì„œ ë˜ëŠ”"

#: src/03_ticket_v1/04_visibility.md:13
msgid "by one of its submodules"
msgstr "í•˜ìœ„ ëª¨ë“ˆ ì¤‘ í•˜ë‚˜ì— ì˜í•´"

#: src/03_ticket_v1/04_visibility.md:15
msgid "We've used this extensively in the previous exercises:"
msgstr "ì´ì „ ì˜ˆì œì—ì„œëŠ” ì´ë¥¼ ê´‘ë²”ìœ„í•˜ê²Œ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/04_visibility.md:17
msgid ""
"`create_todo_ticket` worked (once you added a `use` statement) because "
"`helpers` is a submodule of the crate root, where `Ticket` is defined. "
"Therefore, `create_todo_ticket` can access `Ticket` without any issues even "
"though `Ticket` is private."
msgstr ""
"`create_todo_ticket`ì´ ì‘ë™í–ˆìŠµë‹ˆë‹¤(`use` ë¬¸ì„ ì¶”ê°€í•œ í›„). `helpers`ëŠ” "
"`Ticket`ì´ ì •ì˜ëœ í¬ë ˆì´íŠ¸ ë£¨íŠ¸ì˜ í•˜ìœ„ ëª¨ë“ˆì´ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ë”°ë¼ì„œ "
"`create_todo_ticket`ì€ `Ticket`ì´ ë¹„ê³µê°œì¸ ê²½ìš°ì—ë„ ë¬¸ì œ ì—†ì´ `Ticket`ì— ì•¡ì„¸"
"ìŠ¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/04_visibility.md:20
msgid ""
"All our unit tests are defined in a submodule of the code they're testing, so "
"they can access everything without restrictions."
msgstr ""
"ëª¨ë“  ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ëŠ” í…ŒìŠ¤íŠ¸ ì¤‘ì¸ ì½”ë“œì˜ í•˜ìœ„ ëª¨ë“ˆì— ì •ì˜ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ì œí•œ ì—†ì´ "
"ëª¨ë“  ê²ƒì— ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/04_visibility.md:23
msgid "Visibility modifiers"
msgstr "ê°€ì‹œì„± ìˆ˜ì •ì"

#: src/03_ticket_v1/04_visibility.md:25
msgid ""
"You can modify the default visibility of an entity using a **visibility "
"modifier**.  \n"
"Some common visibility modifiers are:"
msgstr ""
"**ê°€ì‹œì„± ìˆ˜ì •ì**ë¥¼ ì‚¬ìš©í•˜ì—¬ ì—”í„°í‹°ì˜ ê¸°ë³¸ ê°€ì‹œì„±ì„ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"ëª‡ ê°€ì§€ ì¼ë°˜ì ì¸ ê°€ì‹œì„± ìˆ˜ì •ìëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/03_ticket_v1/04_visibility.md:28
msgid ""
"`pub`: makes the entity **public**, i.e. accessible from outside the module "
"where it's defined, potentially from other crates."
msgstr ""
"`pub`: ì—”í„°í‹°ë¥¼ **ê³µê°œ**ë¡œ ë§Œë“­ë‹ˆë‹¤. ì¦‰, ì—”í„°í‹°ê°€ ì •ì˜ëœ ëª¨ë“ˆ ì™¸ë¶€, ì ì¬ì ìœ¼"
"ë¡œ ë‹¤ë¥¸ í¬ë ˆì´íŠ¸ì—ì„œ ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/04_visibility.md:30
msgid ""
"`pub(crate)`: makes the entity public within the same **crate**, but not "
"outside of it."
msgstr ""
"`pub(crate)`: ë™ì¼í•œ **í¬ë ˆì´íŠ¸** ë‚´ì—ì„œ ì—”í„°í‹°ë¥¼ ê³µê°œí•˜ì§€ë§Œ ì™¸ë¶€ì—ì„œëŠ” ê³µê°œí•˜"
"ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/04_visibility.md:31
msgid "`pub(super)`: makes the entity public within the parent module."
msgstr "`pub(super)`: ìƒìœ„ ëª¨ë“ˆ ë‚´ì—ì„œ ì—”í„°í‹°ë¥¼ ê³µê°œí•©ë‹ˆë‹¤."

#: src/03_ticket_v1/04_visibility.md:32
msgid ""
"`pub(in path::to::module)`: makes the entity public within the specified "
"module."
msgstr "`pub(in path::to::module)`: ì§€ì •ëœ ëª¨ë“ˆ ë‚´ì—ì„œ ì—”í„°í‹°ë¥¼ ê³µê°œí•©ë‹ˆë‹¤."

#: src/03_ticket_v1/04_visibility.md:34
msgid ""
"You can use these modifiers on modules, structs, functions, fields, etc. For "
"example:"
msgstr ""
"ëª¨ë“ˆ, êµ¬ì¡°ì²´, í•¨ìˆ˜, í•„ë“œ ë“±ì— ì´ëŸ¬í•œ ìˆ˜ì •ìë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ë©´ ë‹¤"
"ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/03_ticket_v1/04_visibility.md:44
msgid ""
"`Configuration` is public, but you can only access the `version` field from "
"within the same crate. The `active` field, instead, is private and can only "
"be accessed from within the same module or one of its submodules."
msgstr ""
"`Configuration`ì€ ê³µê°œë˜ì§€ë§Œ ë™ì¼í•œ í¬ë ˆì´íŠ¸ ë‚´ì—ì„œëŠ” `version` í•„ë“œì—ë§Œ ì•¡ì„¸"
"ìŠ¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ëŒ€ì‹  `active` í•„ë“œëŠ” ë¹„ê³µê°œì´ë©° ë™ì¼í•œ ëª¨ë“ˆì´ë‚˜ í•´ë‹¹ í•˜ìœ„ ëª¨"
"ë“ˆ ì¤‘ í•˜ë‚˜ì—ì„œë§Œ ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/04_visibility.md:49
msgid ""
"The exercise for this section is located in [`03_ticket_v1/04_visibility`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/04_visibility)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`03_ticket_v1/04_visibility`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/04_visibility)ì— ìˆìŠµë‹ˆë‹¤"

#: src/03_ticket_v1/05_encapsulation.md:3
msgid ""
"Now that we have a basic understanding of modules and visibility, let's "
"circle back to **encapsulation**.  \n"
"Encapsulation is the practice of hiding the internal representation of an "
"object. It is most commonly used to enforce some **invariants** on the "
"object's state."
msgstr ""
"ì´ì œ ëª¨ë“ˆê³¼ ê°€ì‹œì„±ì— ëŒ€í•œ ê¸°ë³¸ì ì¸ ì´í•´ë¥¼ ë§ˆì³¤ìœ¼ë¯€ë¡œ ë‹¤ì‹œ **ìº¡ìŠí™”**ë¡œ ëŒì•„ê°€"
"ê² ìŠµë‹ˆë‹¤.  \n"
"ìº¡ìŠí™”ëŠ” ê°ì²´ì˜ ë‚´ë¶€ í‘œí˜„ì„ ìˆ¨ê¸°ëŠ” ë°©ë²•ì…ë‹ˆë‹¤. ê°ì²´ì˜ ìƒíƒœì— ì¼ë¶€ **ë¶ˆë³€ì„±**"
"ì„ ì ìš©í•˜ëŠ” ë° ê°€ì¥ ì¼ë°˜ì ìœ¼ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤."

#: src/03_ticket_v1/05_encapsulation.md:7
msgid "Going back to our `Ticket` struct:"
msgstr "`Ticket` êµ¬ì¡°ì²´ë¡œ ëŒì•„ê°€ë©´:"

#: src/03_ticket_v1/05_encapsulation.md:17
msgid ""
"If all fields are made public, there is no encapsulation.  \n"
"You must assume that the fields can be modified at any time, set to any value "
"that's allowed by their type. You can't rule out that a ticket might have an "
"empty title or a status that doesn't make sense."
msgstr ""
"ëª¨ë“  í•„ë“œê°€ ê³µê°œë˜ë©´ ìº¡ìŠí™”ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.  \n"
"í•„ë“œëŠ” ì–¸ì œë“ ì§€ ìˆ˜ì •ë  ìˆ˜ ìˆê³  í•´ë‹¹ ìœ í˜•ì—ì„œ í—ˆìš©ë˜ëŠ” ê°’ìœ¼ë¡œ ì„¤ì •ë  ìˆ˜ ìˆë‹¤ê³  "
"ê°€ì •í•´ì•¼ í•©ë‹ˆë‹¤. í‹°ì¼“ì˜ ì œëª©ì´ ë¹„ì–´ ìˆê±°ë‚˜ ì˜ë¯¸ê°€ ì—†ëŠ” ìƒíƒœì¼ ìˆ˜ ìˆë‹¤ëŠ” ì ì„ "
"ë°°ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/05_encapsulation.md:22
msgid ""
"To enforce stricter rules, we must keep the fields private[^newtype]. We can "
"then provide public methods to interact with a `Ticket` instance. Those "
"public methods will have the responsibility of upholding our invariants (e.g. "
"a title must not be empty)."
msgstr ""
"ë” ì—„ê²©í•œ ê·œì¹™ì„ ì ìš©í•˜ë ¤ë©´ í•„ë“œë¥¼ ë¹„ê³µê°œë¡œ ìœ ì§€í•´ì•¼ í•©ë‹ˆë‹¤[^newtype]. ê·¸ëŸ° ë‹¤"
"ìŒ `Ticket` ì¸ìŠ¤í„´ìŠ¤ì™€ ìƒí˜¸ ì‘ìš©í•˜ëŠ” ê³µê°œ ë©”ì„œë“œë¥¼ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŸ¬í•œ "
"ê³µê°œ ë©”ì†Œë“œëŠ” ìš°ë¦¬ì˜ ë¶ˆë³€ì„±ì„ ìœ ì§€í•˜ëŠ” ì±…ì„ì„ ê°–ìŠµë‹ˆë‹¤(ì˜ˆ: ì œëª©ì€ ë¹„ì–´ ìˆìœ¼ë©´ "
"ì•ˆ ë©ë‹ˆë‹¤)."

#: src/03_ticket_v1/05_encapsulation.md:26
msgid ""
"If all fields are private, it is no longer possible to create a `Ticket` "
"instance directly using the struct instantiation syntax:"
msgstr ""
"ëª¨ë“  í•„ë“œê°€ ë¹„ê³µê°œì¸ ê²½ìš° ë” ì´ìƒ êµ¬ì¡°ì²´ ì¸ìŠ¤í„´ìŠ¤í™” êµ¬ë¬¸ì„ ì‚¬ìš©í•˜ì—¬ 'Ticket' "
"ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì§ì ‘ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤:"

#: src/03_ticket_v1/05_encapsulation.md:30
msgid "// This won't work!\n"
msgstr "// ì´ê²ƒì€ ì‘ë™í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤!\n"

#: src/03_ticket_v1/05_encapsulation.md:38
msgid ""
"You've seen this in action in the previous exercise on visibility.  \n"
"We now need to provide one or more public **constructors**â€”i.e. static "
"methods or functions that can be used from outside the module to create a new "
"instance of the struct.  \n"
"Luckily enough we already have one: `Ticket::new`, as implemented in [a "
"previous exercise](02_validation.md)."
msgstr ""
"ê°€ì‹œì„±ì— ëŒ€í•œ ì´ì „ ì—°ìŠµì—ì„œ ì´ ë‚´ìš©ì„ í™•ì¸í–ˆìŠµë‹ˆë‹¤.  \n"
"ì´ì œ í•˜ë‚˜ ì´ìƒì˜ ê³µê°œ **ìƒì„±ì**ë¥¼ ì œê³µí•´ì•¼ í•©ë‹ˆë‹¤. êµ¬ì¡°ì²´ì˜ ìƒˆ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒ"
"ì„±í•˜ê¸° ìœ„í•´ ëª¨ë“ˆ ì™¸ë¶€ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì •ì  ë©”ì„œë“œ ë˜ëŠ” í•¨ìˆ˜.  \n"
"ìš´ ì¢‹ê²Œë„ ì´ì „ ì—°ìŠµì—ì„œ êµ¬í˜„í•œ `Ticket::new`ê°€ ì´ë¯¸ ìˆìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/05_encapsulation.md:43
msgid "Accessor methods"
msgstr "ì ‘ê·¼ì ë©”ì„œë“œ"

#: src/03_ticket_v1/05_encapsulation.md:45
msgid "In summary:"
msgstr "ìš”ì•½:"

#: src/03_ticket_v1/05_encapsulation.md:47
msgid "All `Ticket` fields are private"
msgstr "ëª¨ë“  `Ticket` í•„ë“œëŠ” ë¹„ê³µê°œì…ë‹ˆë‹¤."

#: src/03_ticket_v1/05_encapsulation.md:48
msgid ""
"We provide a public constructor, `Ticket::new`, that enforces our validation "
"rules on creation"
msgstr ""
"ìš°ë¦¬ëŠ” ìƒì„± ì‹œ ìœ íš¨ì„± ê²€ì‚¬ ê·œì¹™ì„ ì ìš©í•˜ëŠ” ê³µê°œ ìƒì„±ì `Ticket::new`ë¥¼ ì œê³µí•©"
"ë‹ˆë‹¤"

#: src/03_ticket_v1/05_encapsulation.md:50
msgid ""
"That's a good start, but it's not enough: apart from creating a `Ticket`, we "
"also need to interact with it. But how can we access the fields if they're "
"private?"
msgstr ""
"ì¢‹ì€ ì‹œì‘ì´ì§€ë§Œ ì¶©ë¶„í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. `Ticket`ì„ ë§Œë“œëŠ” ê²ƒ ì™¸ì—ë„ í‹°ì¼“ê³¼ ìƒí˜¸ ì‘"
"ìš©í•´ì•¼ í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ ë¹„ê³µê°œ í•„ë“œì¸ ê²½ìš° ì–´ë–»ê²Œ í•´ë‹¹ í•„ë“œì— ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆê² ìŠµ"
"ë‹ˆê¹Œ?"

#: src/03_ticket_v1/05_encapsulation.md:53
msgid ""
"We need to provide **accessor methods**.  \n"
"Accessor methods are public methods that allow you to read the value of a "
"private field (or fields) of a struct."
msgstr ""
"**ì ‘ì†ì ë©”ì„œë“œ**ë¥¼ ì œê³µí•´ì•¼ í•©ë‹ˆë‹¤.  \n"
"ì ‘ê·¼ì ë©”ì„œë“œëŠ” êµ¬ì¡°ì²´ì˜ ë¹„ê³µê°œ í•„ë“œ ê°’ì„ ì½ì„ ìˆ˜ ìˆëŠ” ê³µê°œ ë©”ì„œë“œì…ë‹ˆë‹¤."

#: src/03_ticket_v1/05_encapsulation.md:56
msgid ""
"Rust doesn't have a built-in way to generate accessor methods for you, like "
"some other languages do. You have to write them yourselfâ€”they're just regular "
"methods."
msgstr ""
"Rustì—ëŠ” ë‹¤ë¥¸ ì–¸ì–´ì²˜ëŸ¼ ì ‘ê·¼ì ë©”ì„œë“œë¥¼ ìƒì„±í•˜ëŠ” ë‚´ì¥ëœ ë°©ë²•ì´ ì—†ìŠµë‹ˆë‹¤. ì§ì ‘ "
"ì‘ì„±í•´ì•¼ í•©ë‹ˆë‹¤. ì´ëŠ” ë‹¨ì§€ ì¼ë°˜ì ì¸ ë©”ì„œë“œì¼ ë¿ì…ë‹ˆë‹¤."

#: src/03_ticket_v1/05_encapsulation.md:59
msgid ""
"Or refine their type, a technique we'll explore [later on]"
"(../05_ticket_v2/15_outro.md)."
msgstr ""
"ë˜ëŠ” íƒ€ì…ì„ ì„¸ë¶„í™”í•˜ëŠ” ë°©ë²•, ì´ í…Œí¬ë‹‰ì€ [ë‚˜ì¤‘ì—](../05_ticket_v2/15_outro."
"md) ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/05_encapsulation.md:63
msgid ""
"The exercise for this section is located in [`03_ticket_v1/05_encapsulation`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/05_encapsulation)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`03_ticket_v1/05_encapsulation`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/05_encapsulation)ì— ìˆìŠµë‹ˆë‹¤"

#: src/03_ticket_v1/06_ownership.md:3
msgid ""
"If you solved the previous exercise using what this course has taught you so "
"far, your accessor methods probably look like this:"
msgstr ""
"ì§€ê¸ˆê¹Œì§€ ì´ ê³¼ì •ì—ì„œ ë°°ìš´ ë‚´ìš©ì„ ì‚¬ìš©í•˜ì—¬ ì´ì „ ì—°ìŠµì„ í•´ê²°í–ˆë‹¤ë©´ ì ‘ê·¼ì ë©”ì„œë“œ"
"ëŠ” ë‹¤ìŒê³¼ ê°™ì„ ê²ƒì…ë‹ˆë‹¤:"

#: src/03_ticket_v1/06_ownership.md:22
msgid ""
"Those methods compile and are enough to get tests to pass, but in a real-"
"world scenario they won't get you very far. Consider this snippet:"
msgstr ""
"ì´ëŸ¬í•œ ë©”ì„œë“œëŠ” ì»´íŒŒì¼ë˜ê³  í…ŒìŠ¤íŠ¸ë¥¼ í†µê³¼í•˜ê¸°ì— ì¶©ë¶„í•˜ì§€ë§Œ ì‹¤ì œ ì‹œë‚˜ë¦¬ì˜¤ì—ì„œëŠ” "
"ê·¸ë¦¬ í° ë„ì›€ì´ ë˜ì§„ ì•ŠìŠµë‹ˆë‹¤. ë‹¤ìŒ ì½”ë“œë¥¼ ê³ ë ¤í•´ë³´ì„¸ìš”:"

#: src/03_ticket_v1/06_ownership.md:26 src/03_ticket_v1/07_setters.md:53
#: src/03_ticket_v1/07_setters.md:91 src/04_traits/09_from.md:6
msgid "\"To-Do\""
msgstr "\"To-Do\""

#: src/03_ticket_v1/06_ownership.md:27
msgid ""
"// We haven't covered the `println!` macro yet,\n"
"    // but for now it's enough to know that it prints \n"
"    // a (templated) message to the console\n"
msgstr ""
"// ì•„ì§ `println!` ë§¤í¬ë¡œë¥¼ ë‹¤ë£¨ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n"
"    // ì§€ê¸ˆì€ ì´ ë§¤í¬ë¡œê°€ ì½˜ì†”ì— (í…œí”Œë¦¿í™”ëœ) ë©”ì‹œì§€ë¥¼\n"
"    // ì¸ì‡„í•œë‹¤ëŠ” ê²ƒë§Œ ì•Œë©´ ì¶©ë¶„í•©ë‹ˆë‹¤.\n"

#: src/03_ticket_v1/06_ownership.md:30
msgid "\"Your next task is: {}\""
msgstr "\"Your next task is: {}\""

#: src/03_ticket_v1/06_ownership.md:34
msgid "If you try to compile it, you'll get an error:"
msgstr "ì»´íŒŒì¼í•˜ë ¤ê³  í•˜ë©´ ì˜¤ë¥˜ê°€ ë°œìƒí•©ë‹ˆë‹¤:"

#: src/03_ticket_v1/06_ownership.md:36 src/03_ticket_v1/06_ownership.md:122
msgid ""
"```text\n"
"error[E0382]: use of moved value: `ticket`\n"
"  --> src/main.rs:30:43\n"
"   |\n"
"25 |     let ticket = Ticket::new(/* */);\n"
"   |         ------ move occurs because `ticket` has type `Ticket`, \n"
"   |                which does not implement the `Copy` trait\n"
"26 |     if ticket.status() == \"To-Do\" {\n"
"   |               -------- `ticket` moved due to this method call\n"
"...\n"
"30 |         println!(\"Your next task is: {}\", ticket.title());\n"
"   |                                           ^^^^^^ value used here after "
"move\n"
"   |\n"
"note: `Ticket::status` takes ownership of the receiver `self`, which moves "
"`ticket`\n"
"  --> src/main.rs:12:23\n"
"   |\n"
"12 |         pub fn status(self) -> String {\n"
"   |                       ^^^^\n"
"```"
msgstr ""
"```text\n"
"error[E0382]: use of moved value: `ticket`\n"
"  --> src/main.rs:30:43\n"
"   |\n"
"25 |     let ticket = Ticket::new(/* */);\n"
"   |         ------ move occurs because `ticket` has type `Ticket`, \n"
"   |                which does not implement the `Copy` trait\n"
"26 |     if ticket.status() == \"To-Do\" {\n"
"   |               -------- `ticket` moved due to this method call\n"
"...\n"
"30 |         println!(\"Your next task is: {}\", ticket.title());\n"
"   |                                           ^^^^^^ value used here after "
"move\n"
"   |\n"
"note: `Ticket::status` takes ownership of the receiver `self`, which moves "
"`ticket`\n"
"  --> src/main.rs:12:23\n"
"   |\n"
"12 |         pub fn status(self) -> String {\n"
"   |                       ^^^^\n"
"```"

#: src/03_ticket_v1/06_ownership.md:56
msgid "Congrats, this is your first borrow-checker error!"
msgstr "ì¶•í•˜í•©ë‹ˆë‹¤. ì²« ë²ˆì§¸ ì°¨ìš© ê²€ì‚¬ê¸° ì˜¤ë¥˜ì…ë‹ˆë‹¤!"

#: src/03_ticket_v1/06_ownership.md:58
msgid "The perks of Rust's ownership system"
msgstr "Rust ì†Œìœ ê¶Œ ì‹œìŠ¤í…œì˜ ì¥ì "

#: src/03_ticket_v1/06_ownership.md:60
msgid "Rust's ownership system is designed to ensure that:"
msgstr "Rustì˜ ì†Œìœ ê¶Œ ì‹œìŠ¤í…œì€ ë‹¤ìŒì„ ë³´ì¥í•˜ë„ë¡ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤:"

#: src/03_ticket_v1/06_ownership.md:62 src/03_ticket_v1/06_ownership.md:166
msgid "Data is never mutated while it's being read"
msgstr "ë°ì´í„°ë¥¼ ì½ëŠ” ë™ì•ˆì—ëŠ” ë°ì´í„°ê°€ ë³€ê²½ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤"

#: src/03_ticket_v1/06_ownership.md:63 src/03_ticket_v1/06_ownership.md:167
msgid "Data is never read while it's being mutated"
msgstr "ë°ì´í„°ê°€ ë³€ê²½ë˜ëŠ” ë™ì•ˆì—ëŠ” ë°ì´í„°ë¥¼ ì½ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"

#: src/03_ticket_v1/06_ownership.md:64
msgid "Data is never accessed after it has been destroyed"
msgstr "ë°ì´í„°ê°€ íŒŒê¸°ëœ í›„ì—ëŠ” ì ˆëŒ€ ì•¡ì„¸ìŠ¤í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤"

#: src/03_ticket_v1/06_ownership.md:66
msgid ""
"These constraints are enforced by the **borrow checker**, a subsystem of the "
"Rust compiler, often the subject of jokes and memes in the Rust community."
msgstr ""
"ì´ëŸ¬í•œ ì œì•½ì€ Rust ì»¤ë®¤ë‹ˆí‹°ì—ì„œ ì¢…ì¢… ë†ë‹´ê³¼ ë°ˆì˜ ì£¼ì œê°€ ë˜ëŠ” Rust ì»´íŒŒì¼ëŸ¬ì˜ "
"í•˜ìœ„ ì‹œìŠ¤í…œì¸ **ì°¨ìš© ê²€ì‚¬ê¸°**ì— ì˜í•´ ì‹œí–‰ë©ë‹ˆë‹¤."

#: src/03_ticket_v1/06_ownership.md:69
msgid ""
"Ownership is a key concept in Rust, and it's what makes the language unique. "
"Ownership enables Rust to provide **memory safety without compromising "
"performance**. All these things are true at the same time for Rust:"
msgstr ""
"ì†Œìœ ê¶Œì€ Rustì˜ í•µì‹¬ ê°œë…ì´ë©° ì–¸ì–´ë¥¼ ë…íŠ¹í•˜ê²Œ ë§Œë“œëŠ” ìš”ì†Œì…ë‹ˆë‹¤. ì†Œìœ ê¶Œì„ í†µ"
"í•´ RustëŠ” **ì„±ëŠ¥ ì €í•˜ ì—†ëŠ” ë©”ëª¨ë¦¬ ì•ˆì „**ì„ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. Rustì—ì„œëŠ” ì´ "
"ëª¨ë“  ê²ƒë“¤ì´ ë™ì‹œì— ì ìš©ë©ë‹ˆë‹¤:"

#: src/03_ticket_v1/06_ownership.md:73
msgid "There is no runtime garbage collector"
msgstr "ëŸ°íƒ€ì„ ê°€ë¹„ì§€ ì½œë ‰í„°ê°€ ì—†ìŠµë‹ˆë‹¤"

#: src/03_ticket_v1/06_ownership.md:74
msgid "As a developer, you rarely have to manage memory directly"
msgstr "ê°œë°œìë¡œì„œ ë©”ëª¨ë¦¬ë¥¼ ì§ì ‘ ê´€ë¦¬í•´ì•¼ í•˜ëŠ” ê²½ìš°ëŠ” ê±°ì˜ ì—†ìŠµë‹ˆë‹¤"

#: src/03_ticket_v1/06_ownership.md:75
msgid ""
"You can't cause dangling pointers, double frees, and other memory-related bugs"
msgstr "ëŒ•ê¸€ë§ í¬ì¸í„°, ë”ë¸” í”„ë¦¬, ê¸°íƒ€ ë©”ëª¨ë¦¬ ê´€ë ¨ ë²„ê·¸ë¥¼ ì¼ìœ¼í‚¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/06_ownership.md:77
msgid ""
"Languages like Python, JavaScript, and Java give you 2. and 3., but not 1.  \n"
"Language like C or C++ give you 1., but neither 2. nor 3."
msgstr ""
"Python, JavaScript, Javaì™€ ê°™ì€ ì–¸ì–´ëŠ” 2ì™€ 3ì„ ì œê³µí•˜ì§€ë§Œ 1ì€ ì œê³µí•˜ì§€ ì•ŠìŠµë‹ˆ"
"ë‹¤.  \n"
"Cë‚˜ C++ ê°™ì€ ì–¸ì–´ëŠ” 1.ì„ ì œê³µí•˜ì§€ë§Œ 2.ë„ 3ë„ ì œê³µí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/06_ownership.md:80
msgid ""
"Depending on your background, 3. might sound a bit arcane: what is a "
"\"dangling pointer\"? What is a \"double free\"? Why are they dangerous?  \n"
"Don't worry: we'll cover these concepts in more details during the rest of "
"the course."
msgstr ""
"3. ë°°ê²½ì— ë”°ë¼ ë‹¤ì†Œ ë‚œí•´í•˜ê²Œ ë“¤ë¦´ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. \"ëŒ•ê¸€ë§ í¬ì¸í„°\"ë€ ë¬´ì—‡ì…ë‹ˆ"
"ê¹Œ? \"ë”ë¸” í”„ë¦¬\"ë€ ë¬´ì—‡ì…ë‹ˆê¹Œ? ì™œ ìœ„í—˜í•©ë‹ˆê¹Œ?  \n"
"ê±±ì •í•˜ì§€ ë§ˆì‹­ì‹œì˜¤. ë‚˜ë¨¸ì§€ ê³¼ì •ì—ì„œ ì´ëŸ¬í•œ ê°œë…ì„ ë” ìì„¸íˆ ë‹¤ë£° ê²ƒì…ë‹ˆë‹¤."

#: src/03_ticket_v1/06_ownership.md:84
msgid ""
"For now, though, let's focus on learning how to work within Rust's ownership "
"system."
msgstr ""
"í•˜ì§€ë§Œ ì§€ê¸ˆì€ Rustì˜ ì†Œìœ ê¶Œ ì‹œìŠ¤í…œ ë‚´ì—ì„œ ì‘ì—…í•˜ëŠ” ë°©ë²•ì„ ë°°ìš°ëŠ” ë° ì§‘ì¤‘í•˜ê² ìŠµ"
"ë‹ˆë‹¤."

#: src/03_ticket_v1/06_ownership.md:86
msgid "The owner"
msgstr "ì†Œìœ ì"

#: src/03_ticket_v1/06_ownership.md:88
msgid ""
"In Rust, each value has an **owner**, statically determined at compile-time. "
"There is only one owner for each value at any given time."
msgstr ""
"Rustì—ì„œ ê° ê°’ì—ëŠ” ì»´íŒŒì¼ íƒ€ì„ì— ì •ì ìœ¼ë¡œ ê²°ì •ë˜ëŠ” **ì†Œìœ ì**ê°€ ìˆìŠµë‹ˆë‹¤. ì£¼ì–´"
"ì§„ ì‹œê°„ì— ê° ê°’ì— ëŒ€í•œ ì†Œìœ ìëŠ” ë‹¨ í•œ ëª…ë¿ì…ë‹ˆë‹¤."

#: src/03_ticket_v1/06_ownership.md:91
#, fuzzy
msgid "Move semantics"
msgstr "ì˜ë¯¸ë¡  ì´ë™"

#: src/03_ticket_v1/06_ownership.md:93
msgid "Ownership can be transferred."
msgstr "ì†Œìœ ê¶Œì„ ì´ì „í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/06_ownership.md:95
msgid ""
"If you own a value, for example, you can transfer ownership to another "
"variable:"
msgstr "ì˜ˆë¥¼ ë“¤ì–´, ê°’ì„ ì†Œìœ í•œ ê²½ìš° ì†Œìœ ê¶Œì„ ë‹¤ë¥¸ ë³€ìˆ˜ë¡œ ì´ì „í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/03_ticket_v1/06_ownership.md:98
msgid "\"hello, world\""
msgstr "\"hello, world\""

#: src/03_ticket_v1/06_ownership.md:98
msgid "// <--- `a` is the owner of the String\n"
msgstr "// <--- `a` ëŠ” ë¬¸ìì—´ì˜ ì†Œìœ ìì…ë‹ˆë‹¤\n"

#: src/03_ticket_v1/06_ownership.md:99
msgid "// <--- `b` is now the owner of the String\n"
msgstr "// <--- `b` ëŠ” ì´ì œ ë¬¸ìì—´ì˜ ì†Œìœ ìì…ë‹ˆë‹¤\n"

#: src/03_ticket_v1/06_ownership.md:102
msgid ""
"Rust's ownership system is baked into the type system: each function has to "
"declare in its signature _how_ it wants to interact with its arguments."
msgstr ""
"Rustì˜ ì†Œìœ ê¶Œ ì‹œìŠ¤í…œì€ íƒ€ì… ì‹œìŠ¤í…œì— ì ìš©ë©ë‹ˆë‹¤. ê° í•¨ìˆ˜ëŠ” ì¸ìˆ˜ì™€ ìƒí˜¸ ì‘ìš©í•˜"
"ëŠ” ë°©ë²•ì„ ì‹œê·¸ë‹ˆì²˜ì— ì„ ì–¸í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/03_ticket_v1/06_ownership.md:105
msgid ""
"So far, all our methods and functions have **consumed** their arguments: "
"they've taken ownership of them. For example:"
msgstr ""
"ì§€ê¸ˆê¹Œì§€ ìš°ë¦¬ì˜ ëª¨ë“  ë©”ì†Œë“œì™€ í•¨ìˆ˜ëŠ” ì¸ìˆ˜ë¥¼ **ì†Œë¹„**í–ˆìŠµë‹ˆë‹¤. ì¦‰, ì¸ìˆ˜ì˜ ì†Œìœ "
"ê¶Œì„ ì–»ì—ˆìŠµë‹ˆë‹¤. ì˜ˆì‹œ:"

#: src/03_ticket_v1/06_ownership.md:116
msgid ""
"`Ticket::description` takes ownership of the `Ticket` instance it's called "
"on.  \n"
"This is known as **move semantics**: ownership of the value (`self`) is "
"**moved** from the caller to the callee, and the caller can't use it anymore."
msgstr ""
"`Ticket::description`ì€ í˜¸ì¶œëœ `Ticket` ì¸ìŠ¤í„´ìŠ¤ì˜ ì†Œìœ ê¶Œì„ ê°–ìŠµë‹ˆë‹¤.  \n"
"ì´ë¥¼ **move semantics**ë¼ê³  í•©ë‹ˆë‹¤. ê°’ (`self`)ì˜ ì†Œìœ ê¶Œì´ í˜¸ì¶œìì—ì„œ í˜¸ì¶œ ìˆ˜"
"ì‹ ìë¡œ **ì´ë™**í•˜ê³  í˜¸ì¶œìëŠ” ë” ì´ìƒ ì´ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/06_ownership.md:120
msgid ""
"That's exactly the language used by the compiler in the error message we saw "
"earlier:"
msgstr "ì´ëŠ” ì•ì„œ ë³¸ ì˜¤ë¥˜ ë©”ì‹œì§€ì—ì„œ ì»´íŒŒì¼ëŸ¬ê°€ ì‚¬ìš©í•œ ì–¸ì–´ì™€ ì •í™•íˆ ê°™ìŠµë‹ˆë‹¤:"

#: src/03_ticket_v1/06_ownership.md:142
msgid ""
"In particular, this is the sequence of events that unfold when we call "
"`ticket.status()`:"
msgstr ""
"íŠ¹íˆ, ë‹¤ìŒì€ `ticket.status()`ë¥¼ í˜¸ì¶œí•  ë•Œ í¼ì³ì§€ëŠ” ì¼ë ¨ì˜ ì´ë²¤íŠ¸ì…ë‹ˆë‹¤:"

#: src/03_ticket_v1/06_ownership.md:144
msgid "`Ticket::status` takes ownership of the `Ticket` instance"
msgstr "`Ticket::status`ëŠ” `Ticket` ì¸ìŠ¤í„´ìŠ¤ì˜ ì†Œìœ ê¶Œì„ ê°–ìŠµë‹ˆë‹¤"

#: src/03_ticket_v1/06_ownership.md:145
msgid ""
"`Ticket::status` extracts `status` from `self` and transfers ownership of "
"`status` back to the caller"
msgstr ""
"`Ticket::status`ëŠ” `self`ì—ì„œ `status`ë¥¼ ì¶”ì¶œí•˜ê³  `status`ì˜ ì†Œìœ ê¶Œì„ í˜¸ì¶œìì—"
"ê²Œ ë‹¤ì‹œ ì´ì „í•©ë‹ˆë‹¤"

#: src/03_ticket_v1/06_ownership.md:146
msgid ""
"The rest of the `Ticket` instance is discarded (`title` and `description`)"
msgstr "ë‚˜ë¨¸ì§€ `Ticket` ì¸ìŠ¤í„´ìŠ¤ëŠ” ì‚­ì œë©ë‹ˆë‹¤(`title` ë° `description`)"

#: src/03_ticket_v1/06_ownership.md:148
msgid ""
"When we try to use `ticket` again via `ticket.title()`, the compiler "
"complains: the `ticket` value is gone now, we no longer own it, therefore we "
"can't use it anymore."
msgstr ""
"`ticket.title()`ì„ í†µí•´ `ticket`ì„ ë‹¤ì‹œ ì‚¬ìš©í•˜ë ¤ê³  í•˜ë©´ ì»´íŒŒì¼ëŸ¬ëŠ” `ticket` ê°’"
"ì´ ì´ì œ ì‚¬ë¼ì¡Œê³  ë” ì´ìƒ ì†Œìœ í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ë” ì´ìƒ ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤ê³  ë¶ˆí‰í•©ë‹ˆ"
"ë‹¤."

#: src/03_ticket_v1/06_ownership.md:151
msgid ""
"To build _useful_ accessor methods we need to start working with "
"**references**."
msgstr "_ìœ ìš©í•œ_ ì ‘ê·¼ì ë©”ì†Œë“œë¥¼ êµ¬ì¶•í•˜ë ¤ë©´ **ì°¸ì¡°** ì‘ì—…ì„ ì‹œì‘í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/03_ticket_v1/06_ownership.md:153
msgid "Borrowing"
msgstr "ì°¨ìš©"

#: src/03_ticket_v1/06_ownership.md:155
msgid ""
"It is desirable to have methods that can read the value of a variable without "
"taking ownership of it.  \n"
"Programming would be quite limited otherwise. In Rust, that's done via "
"**borrowing**."
msgstr ""
"ë³€ìˆ˜ì˜ ì†Œìœ ê¶Œì„ ê°€ì ¸ì˜¤ì§€ ì•Šê³  ë³€ìˆ˜ì˜ ê°’ì„ ì½ì„ ìˆ˜ ìˆëŠ” ë©”ì„œë“œë¥¼ ê°–ëŠ” ê²ƒì´ ë°”ëŒ"
"ì§í•©ë‹ˆë‹¤.  \n"
"ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ í”„ë¡œê·¸ë˜ë°ì´ ìƒë‹¹íˆ ì œí•œë  ê²ƒì…ë‹ˆë‹¤. Rustì—ì„œëŠ” **ì°¨ìš©**ì„ í†µí•´ "
"ì´ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤."

#: src/03_ticket_v1/06_ownership.md:158
msgid ""
"Whenever you borrow a value, you get a **reference** to it.  \n"
"References are tagged with their privileges[^refine]:"
msgstr ""
"ê°’ì„ ë¹Œë¦´ ë•Œë§ˆë‹¤ í•´ë‹¹ ê°€ì¹˜ì— ëŒ€í•œ **ì°¸ì¡°**ë¥¼ ì–»ê²Œ ë©ë‹ˆë‹¤.  \n"
"ì°¸ì¡°ì—ëŠ” í•´ë‹¹ ê¶Œí•œì´ íƒœê·¸ë¡œ ì§€ì •ë©ë‹ˆë‹¤[^refine]:"

#: src/03_ticket_v1/06_ownership.md:161
msgid ""
"Immutable references (`&`) allow you to read the value, but not to mutate it"
msgstr "ë¶ˆë³€ ì°¸ì¡°(`&`)ë¥¼ ì‚¬ìš©í•˜ë©´ ê°’ì„ ì½ì„ ìˆ˜ ìˆì§€ë§Œ ë³€ê²½í•  ìˆ˜ëŠ” ì—†ìŠµë‹ˆë‹¤"

#: src/03_ticket_v1/06_ownership.md:162
msgid "Mutable references (`&mut`) allow you to read and mutate the value"
msgstr "ë³€ê²½ ê°€ëŠ¥í•œ ì°¸ì¡°(`&mut`)ë¥¼ ì‚¬ìš©í•˜ë©´ ê°’ì„ ì½ê³  ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤"

#: src/03_ticket_v1/06_ownership.md:164
msgid "Going back to the goals of Rust's ownership system:"
msgstr "Rustì˜ ì†Œìœ ê¶Œ ì‹œìŠ¤í…œì˜ ëª©í‘œë¡œ ëŒì•„ê°€ë©´:"

#: src/03_ticket_v1/06_ownership.md:169
msgid ""
"To ensure these two properties, Rust has to introduce some restrictions on "
"references:"
msgstr ""
"ì´ ë‘ ê°€ì§€ ì†ì„±ì„ ë³´ì¥í•˜ê¸° ìœ„í•´ RustëŠ” ì°¸ì¡°ì— ëª‡ ê°€ì§€ ì œí•œ ì‚¬í•­ì„ ë„ì…í•´ì•¼ í•©"
"ë‹ˆë‹¤:"

#: src/03_ticket_v1/06_ownership.md:171
msgid ""
"You can't have a mutable reference and an immutable reference to the same "
"value at the same time"
msgstr ""
"ë™ì¼í•œ ê°’ì— ëŒ€í•œ ë³€ê²½ ê°€ëŠ¥í•œ ì°¸ì¡°ì™€ ë³€ê²½ ë¶ˆê°€ëŠ¥í•œ ì°¸ì¡°ë¥¼ ë™ì‹œì— ê°€ì§ˆ ìˆ˜ ì—†ìŠµë‹ˆ"
"ë‹¤"

#: src/03_ticket_v1/06_ownership.md:172
msgid ""
"You can't have more than one mutable reference to the same value at the same "
"time"
msgstr ""
"ë™ì¼í•œ ê°’ì— ëŒ€í•´ ë™ì‹œì— ë‘ ê°œ ì´ìƒì˜ ë³€ê²½ ê°€ëŠ¥í•œ ì°¸ì¡°ë¥¼ ê°€ì§ˆ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"

#: src/03_ticket_v1/06_ownership.md:173
msgid "The owner can't mutate the value while it's being borrowed"
msgstr "ì†Œìœ ìëŠ” ê°’ì„ ë¹Œë¦¬ëŠ” ë™ì•ˆ ê°’ì„ ë³€ê²½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤"

#: src/03_ticket_v1/06_ownership.md:174
msgid ""
"You can have as many immutable references as you want, as long as there are "
"no mutable references"
msgstr "ë³€ê²½ ê°€ëŠ¥í•œ ì°¸ì¡°ê°€ ì—†ëŠ” í•œ ì›í•˜ëŠ” ë§Œí¼ ë¶ˆë³€ ì°¸ì¡°ë¥¼ ê°€ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤"

#: src/03_ticket_v1/06_ownership.md:176
msgid ""
"In a way, you can think of an immutable reference as a \"read-only\" lock on "
"the value, while a mutable reference is like a \"read-write\" lock."
msgstr ""
"ì–´ë–¤ ë©´ì—ì„œëŠ” ë¶ˆë³€ ì°¸ì¡°ë¥¼ ê°’ì— ëŒ€í•œ \"read-only\" ì ê¸ˆìœ¼ë¡œ ìƒê°í•  ìˆ˜ ìˆëŠ” ë°˜"
"ë©´, ë³€ê²½ ê°€ëŠ¥ ì°¸ì¡°ëŠ” \"read-write\" ì ê¸ˆê³¼ ë¹„ìŠ·í•˜ë‹¤ê³  ìƒê°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/06_ownership.md:179
msgid ""
"All these restrictions are enforced at compile-time by the borrow checker."
msgstr "ì´ëŸ¬í•œ ëª¨ë“  ì œí•œ ì‚¬í•­ì€ ì°¨ìš© ê²€ì‚¬ê¸°ì— ì˜í•´ ì»´íŒŒì¼ íƒ€ì„ì— ì ìš©ë©ë‹ˆë‹¤."

#: src/03_ticket_v1/06_ownership.md:183
msgid ""
"How do you borrow a value, in practice?  \n"
"By adding `&` or `&mut` **in front a variable**, you're borrowing its value. "
"Careful though! The same symbols (`&` and `&mut`) in **front of a type** have "
"a different meaning: they denote a different type, a reference to the "
"original type."
msgstr ""
"ì‹¤ì œë¡œ ê°’ì„ ì–´ë–»ê²Œ ë¹Œë¦¬ë‚˜ìš”?  \n"
"ë³€ìˆ˜ ì•ì— `&` ë˜ëŠ” `&mut`ë¥¼ ì¶”ê°€í•˜ë©´ í•´ë‹¹ ê°’ì„ ë¹Œë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ë˜ë„ ì¡°ì‹¬í•˜"
"ì„¸ìš”! **íƒ€ì… ì•**ì— ìˆëŠ” ë™ì¼í•œ ê¸°í˜¸(`&` ë° `&mut`)ëŠ” ë‹¤ë¥¸ ì˜ë¯¸ë¥¼ ê°–ìŠµë‹ˆë‹¤. "
"ì¦‰, ì›ë˜ íƒ€ì…ì— ëŒ€í•œ ì°¸ì¡°ì¸ ë˜ ë‹¤ë¥¸ íƒ€ì…ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤."

#: src/03_ticket_v1/06_ownership.md:201
msgid ""
"// `b` is a reference to the `version` field of `config`.\n"
"    // The type of `b` is `&u32`, since it contains a reference to a `u32` "
"value.\n"
"    // We create a reference by borrowing `config.version`, using the `&` "
"operator.\n"
"    // Same symbol (`&`), different meaning depending on the context!\n"
msgstr ""
"// `b`ëŠ” `config`ì˜ `version` í•„ë“œì— ëŒ€í•œ ì°¸ì¡°ì…ë‹ˆë‹¤.\n"
"    // `b`ì˜ íƒ€ì…ì€ `u32` ê°’ì— ëŒ€í•œ ì°¸ì¡°ë¥¼ í¬í•¨í•˜ë¯€ë¡œ `&u32`ì…ë‹ˆë‹¤.\n"
"    // `&` ì—°ì‚°ìë¥¼ ì‚¬ìš©í•˜ì—¬ `config.version`ì„ ë¹Œë ¤ ì°¸ì¡°ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.\n"
"    // ê°™ì€ ê¸°í˜¸(`&`), ìƒí™©ì— ë”°ë¼ ë‹¤ë¥¸ ì˜ë¯¸!\n"

#: src/03_ticket_v1/06_ownership.md:206
msgid ""
"//     ^ The type annotation is not necessary, \n"
"    //       it's just there to clarify what's going on\n"
msgstr ""
"//     ^ íƒ€ì… ì–´ë…¸í…Œì´ì…˜ì€ ì¤‘ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n"
"    //       ë‹¨ì§€ ë¬´ìŠ¨ ì¼ì´ ì¼ì–´ë‚˜ê³  ìˆëŠ”ì§€ ëª…í™•íˆ í•˜ê¸° ìœ„í•´ ì¡´ì¬í•©ë‹ˆë‹¤.\n"

#: src/03_ticket_v1/06_ownership.md:211
msgid "The same concept applies to function arguments and return types:"
msgstr "í•¨ìˆ˜ ì¸ìˆ˜ì™€ ë°˜í™˜ ìœ í˜•ì—ë„ ë™ì¼í•œ ê°œë…ì´ ì ìš©ë©ë‹ˆë‹¤:"

#: src/03_ticket_v1/06_ownership.md:214
msgid ""
"// `f` takes a mutable reference to a `u32` as an argument, \n"
"// bound to the name `number`\n"
msgstr ""
"// `f`ëŠ” `u32`ì— ëŒ€í•œ ë³€ê²½ ê°€ëŠ¥í•œ ì°¸ì¡°ë¥¼ ì¸ìˆ˜ë¡œ ì‚¬ìš©í•˜ê³ \n"
"// `number`ë¼ëŠ” ì´ë¦„ì— ë°”ì¸ë”©ë©ë‹ˆë‹¤\n"

#: src/03_ticket_v1/06_ownership.md:221
msgid "Breathe in, breathe out"
msgstr "ì§„ì •í•˜ê³  ì‹¬í˜¸í¡í•˜ì„¸ìš”"

#: src/03_ticket_v1/06_ownership.md:223
msgid ""
"Rust's ownership system can be a bit overwhelming at first.  \n"
"But don't worry: it'll become second nature with practice.  \n"
"And you're going to get a lot of practice over the rest of this chapter, as "
"well as the rest of the course! We'll revisit each concept multiple times to "
"make sure you get familiar with them and truly understand how they work."
msgstr ""
"Rustì˜ ì†Œìœ ê¶Œ ì‹œìŠ¤í…œì€ ì²˜ìŒì—ëŠ” ë‹¤ì†Œ ë¶€ë‹´ìŠ¤ëŸ¬ìš¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"í•˜ì§€ë§Œ ê±±ì •í•˜ì§€ ë§ˆì‹­ì‹œì˜¤. ì—°ìŠµì„ í•˜ë©´ ìì—°ìŠ¤ëŸ½ê²Œ ìµìˆ™í•´ì§ˆ ê²ƒì…ë‹ˆë‹¤.  \n"
"ê·¸ë¦¬ê³  ì´ ì¥ì˜ ë‚˜ë¨¸ì§€ ë¶€ë¶„ê³¼ ê³¼ì •ì˜ ë‚˜ë¨¸ì§€ ë¶€ë¶„ì— ê±¸ì³ ë§ì€ ì—°ìŠµì„ í•˜ê²Œ ë  ê²ƒ"
"ì…ë‹ˆë‹¤! ìš°ë¦¬ëŠ” ê° ê°œë…ì„ ì—¬ëŸ¬ ë²ˆ ì¬ê²€í† í•˜ì—¬ ì—¬ëŸ¬ë¶„ì´ ê°œë…ì— ìµìˆ™í•´ì§€ê³  ì‘ë™ ë°©"
"ì‹ì„ ì§„ì •ìœ¼ë¡œ ì´í•´í•  ìˆ˜ ìˆë„ë¡ í•  ê²ƒì…ë‹ˆë‹¤."

#: src/03_ticket_v1/06_ownership.md:229
msgid ""
"Towards the end of this chapter we'll explain _why_ Rust's ownership system "
"is designed the way it is. For the time being, focus on understanding the "
"_how_. Take each compiler error as a learning opportunity!"
msgstr ""
"ì´ ì¥ì˜ ë§ˆì§€ë§‰ ë¶€ë¶„ì—ì„œ ìš°ë¦¬ëŠ” Rustì˜ ì†Œìœ ê¶Œ ì‹œìŠ¤í…œì´ ê·¸ëŸ° ë°©ì‹ìœ¼ë¡œ ì„¤ê³„ëœ _ì´"
"ìœ _ë¥¼ ì„¤ëª…í•  ê²ƒì…ë‹ˆë‹¤. ë‹¹ë¶„ê°„ì€ _ì–´ë–»ê²Œ_ë¥¼ ì´í•´í•˜ëŠ” ë° ì§‘ì¤‘í•˜ì„¸ìš”. ê°ê°ì˜ ì»´íŒŒ"
"ì¼ëŸ¬ ì˜¤ë¥˜ë¥¼ í•™ìŠµ ê¸°íšŒë¡œ ì‚¼ìœ¼ì„¸ìš”!"

#: src/03_ticket_v1/06_ownership.md:232
msgid ""
"This is a great mental model to start out, but it doesn't capture the _full_ "
"picture. We'll refine our understanding of references [later in the course]"
"(../07_threads/06_interior_mutability.md)."
msgstr ""
"ì´ê²ƒì€ ì‹œì‘í•˜ê¸°ì— í›Œë¥­í•œ ì •ì‹ ì  ëª¨ë¸ì´ì§€ë§Œ _ì „ì²´_ ê·¸ë¦¼ì„ í¬ì°©í•˜ì§€ëŠ” ëª»í•©ë‹ˆë‹¤. "
"[ì´ ì½”ìŠ¤ì˜ ë’·ë¶€ë¶„](../07_threads/06_interior_mutability.md)ì—ì„œ ì°¸ì¡°ì— ëŒ€í•œ ì´"
"í•´ë¥¼ ë”ìš± êµ¬ì²´í™”í•  ê²ƒì…ë‹ˆë‹¤."

#: src/03_ticket_v1/06_ownership.md:237
msgid ""
"The exercise for this section is located in [`03_ticket_v1/06_ownership`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/06_ownership)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`03_ticket_v1/06_ownership`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/06_ownership)ì— ìˆìŠµë‹ˆë‹¤"

#: src/03_ticket_v1/07_setters.md:1
msgid "Mutable references"
msgstr "ë³€ê²½ ê°€ëŠ¥í•œ ì°¸ì¡°"

#: src/03_ticket_v1/07_setters.md:3
msgid "Your accessor methods should look like this now:"
msgstr "ì´ì œ ì ‘ê·¼ì ë©”ì„œë“œëŠ” ë‹¤ìŒê³¼ ê°™ì•„ì•¼ í•©ë‹ˆë‹¤:"

#: src/03_ticket_v1/07_setters.md:21
msgid ""
"A sprinkle of `&` here and there did the trick!  \n"
"We now have a way to access the fields of a `Ticket` instance without "
"consuming it in the process. Let's see how we can enhance our `Ticket` struct "
"with **setter methods** next."
msgstr ""
"ì—¬ê¸°ì €ê¸°ì— `&`ë¥¼ ë¿Œë¦¬ë©´ íš¨ê³¼ê°€ ìˆìŠµë‹ˆë‹¤!  \n"
"ì´ì œ í”„ë¡œì„¸ìŠ¤ì—ì„œ ì´ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  `Ticket` ì¸ìŠ¤í„´ìŠ¤ì˜ í•„ë“œì— ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆ"
"ëŠ” ë°©ë²•ì´ ìˆìŠµë‹ˆë‹¤. ë‹¤ìŒì—ëŠ” **setter ë©”ì„œë“œ**ë¥¼ ì‚¬ìš©í•˜ì—¬ `Ticket` êµ¬ì¡°ì²´ë¥¼ ì–´"
"ë–»ê²Œ ê°œì„ í•  ìˆ˜ ìˆëŠ”ì§€ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/07_setters.md:27
msgid ""
"Setter methods allow users to change the values of `Ticket`'s private fields "
"while making sure that its invariants are respected (i.e. you can't set a "
"`Ticket`'s title to an empty string)."
msgstr ""
"Setter ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ë©´ ì‚¬ìš©ìëŠ” `Ticket`ì˜ ë¹„ê³µê°œ í•„ë“œ ê°’ì„ ë³€ê²½í•˜ëŠ” ë™ì‹œì— "
"í•´ë‹¹ ë¶ˆë³€ì„±ì„ ì¤€ìˆ˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤(ì˜ˆ: `Ticket` ì œëª©ì„ ë¹ˆ ë¬¸ìì—´ë¡œ ì„¤ì •í•  ìˆ˜ ì—†"
"ìŒ)."

#: src/03_ticket_v1/07_setters.md:30
msgid "There are two common ways to implement setters in Rust:"
msgstr "Rustì—ì„œ setterë¥¼ êµ¬í˜„í•˜ëŠ” ë‘ ê°€ì§€ ì¼ë°˜ì ì¸ ë°©ë²•ì´ ìˆìŠµë‹ˆë‹¤:"

#: src/03_ticket_v1/07_setters.md:32
msgid "Taking `self` as input."
msgstr "`self`ë¥¼ ì¸í’‹ìœ¼ë¡œ ë°›ê¸°."

#: src/03_ticket_v1/07_setters.md:33
msgid "Taking `&mut self` as input."
msgstr "`&mut self`ë¥¼ ì¸í’‹ìœ¼ë¡œ ë°›ê¸°."

#: src/03_ticket_v1/07_setters.md:35
msgid "Taking `self` as input"
msgstr "'self'ë¥¼ ì¸í’‹ìœ¼ë¡œ ë°›ê¸°"

#: src/03_ticket_v1/07_setters.md:37
msgid "The first approach looks like this:"
msgstr "ì²« ë²ˆì§¸ ì ‘ê·¼ ë°©ì‹ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/03_ticket_v1/07_setters.md:42 src/03_ticket_v1/07_setters.md:78
msgid "// Validate the new title [...]\n"
msgstr "// ìƒˆ ì œëª© ê²€ì¦ [...]\n"

#: src/03_ticket_v1/07_setters.md:49
msgid ""
"It takes ownership of `self`, changes the title, and returns the modified "
"`Ticket` instance.  \n"
"This is how you'd use it:"
msgstr ""
"`self`ì˜ ì†Œìœ ê¶Œì„ ê°€ì ¸ì™€ ì œëª©ì„ ë³€ê²½í•˜ê³  ìˆ˜ì •ëœ `Ticket` ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•©ë‹ˆ"
"ë‹¤.  \n"
"ì‚¬ìš© ë°©ë²•ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/03_ticket_v1/07_setters.md:53 src/03_ticket_v1/07_setters.md:91
msgid "\"Title\""
msgstr "\"Title\""

#: src/03_ticket_v1/07_setters.md:53 src/03_ticket_v1/07_setters.md:91
msgid "\"Description\""
msgstr "\"Description\""

#: src/03_ticket_v1/07_setters.md:54 src/03_ticket_v1/07_setters.md:66
#: src/03_ticket_v1/07_setters.md:92 src/03_ticket_v1/07_setters.md:105
msgid "\"New title\""
msgstr "\"New title\""

#: src/03_ticket_v1/07_setters.md:57
msgid ""
"Since `set_title` takes ownership of `self` (i.e. it **consumes it**), we "
"need to reassign the result to a variable. In the example above we take "
"advantage of **variable shadowing** to reuse the same variable name: when you "
"declare a new variable with the same name as an existing one, the new "
"variable **shadows** the old one. This is a common pattern in Rust code."
msgstr ""
"`set_title`ì€ `self`ì˜ ì†Œìœ ê¶Œì„ ê°–ê¸° ë•Œë¬¸ì—(ì¦‰ **ì†Œë¹„**) ê²°ê³¼ë¥¼ ë³€ìˆ˜ì— ë‹¤ì‹œ í• "
"ë‹¹í•´ì•¼ í•©ë‹ˆë‹¤. ìœ„ì˜ ì˜ˆì—ì„œëŠ” **ë³€ìˆ˜ ì„€ë„ì‰**ì„ í™œìš©í•˜ì—¬ ë™ì¼í•œ ë³€ìˆ˜ ì´ë¦„ì„ ì¬"
"ì‚¬ìš©í•©ë‹ˆë‹¤. ê¸°ì¡´ ë³€ìˆ˜ì™€ ë™ì¼í•œ ì´ë¦„ìœ¼ë¡œ ìƒˆ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ë©´ ìƒˆ ë³€ìˆ˜ê°€ ì´ì „ ë³€ìˆ˜"
"ë¥¼ **ì„€ë„ìš°**í•©ë‹ˆë‹¤. ì´ëŠ” Rust ì½”ë“œì˜ ì¼ë°˜ì ì¸ íŒ¨í„´ì…ë‹ˆë‹¤."

#: src/03_ticket_v1/07_setters.md:62
msgid ""
"`self`\\-setters work quite nicely when you need to change multiple fields at "
"once: you can chain multiple calls together!"
msgstr ""
"`self`\\-setterëŠ” ì—¬ëŸ¬ í•„ë“œë¥¼ í•œ ë²ˆì— ë³€ê²½í•´ì•¼ í•  ë•Œ ì•„ì£¼ ì˜ ì‘ë™í•©ë‹ˆë‹¤. ì—¬ëŸ¬ "
"í˜¸ì¶œì„ í•¨ê»˜ ì—°ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!"

#: src/03_ticket_v1/07_setters.md:67 src/03_ticket_v1/07_setters.md:106
msgid "\"New description\""
msgstr "\"New description\""

#: src/03_ticket_v1/07_setters.md:68 src/03_ticket_v1/07_setters.md:107
msgid "\"In Progress\""
msgstr "\"In Progress\""

#: src/03_ticket_v1/07_setters.md:71
msgid "Taking `&mut self` as input"
msgstr "`&mut self`ë¥¼ ì¸í’‹ìœ¼ë¡œ ë°›ê¸°"

#: src/03_ticket_v1/07_setters.md:73
msgid ""
"The second approach to setters, using `&mut self`, looks like this instead:"
msgstr ""
"`&mut self`ë¥¼ ì‚¬ìš©í•˜ëŠ” ì„¸í„°ì— ëŒ€í•œ ë‘ ë²ˆì§¸ ì ‘ê·¼ ë°©ì‹ì€ ëŒ€ì‹  ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/03_ticket_v1/07_setters.md:85
msgid ""
"This time the method takes a mutable reference to `self` as input, changes "
"the title, and that's it. Nothing is returned."
msgstr ""
"ì´ë²ˆì—ëŠ” ë©”ì„œë“œê°€ 'self'ì— ëŒ€í•œ ë³€ê²½ ê°€ëŠ¥í•œ ì°¸ì¡°ë¥¼ ì…ë ¥ìœ¼ë¡œ ì‚¬ìš©í•˜ê³  ì œëª©ì„ ë³€"
"ê²½í•˜ë©´ ê·¸ê²Œ ì „ë¶€ì…ë‹ˆë‹¤. ì•„ë¬´ê²ƒë„ ë°˜í™˜ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/07_setters.md:88
msgid "You'd use it like this:"
msgstr "ë‹¤ìŒê³¼ ê°™ì´ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/03_ticket_v1/07_setters.md:93
msgid "// Use the modified ticket\n"
msgstr "// ìˆ˜ì •ëœ í‹°ì¼“ ì‚¬ìš©\n"

#: src/03_ticket_v1/07_setters.md:97
msgid ""
"Ownership stays with the caller, so the original `ticket` variable is still "
"valid. We don't need to reassign the result. We need to mark `ticket` as "
"mutable though, because we're taking a mutable reference to it."
msgstr ""
"ì†Œìœ ê¶Œì€ í˜¸ì¶œìì—ê²Œ ìˆìœ¼ë¯€ë¡œ ì›ë˜ `ticket` ë³€ìˆ˜ëŠ” ì—¬ì „íˆ ìœ íš¨í•©ë‹ˆë‹¤. ê²°ê³¼ë¥¼ ë‹¤"
"ì‹œ í• ë‹¹í•  í•„ìš”ëŠ” ì—†ìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ `ticket`ì— ëŒ€í•œ ë³€ê²½ ê°€ëŠ¥í•œ ì°¸ì¡°ë¥¼ ì‚¬ìš©í•˜ê³  "
"ìˆìœ¼ë¯€ë¡œ ë³€ê²½ ê°€ëŠ¥ìœ¼ë¡œ í‘œì‹œí•´ì•¼ í•©ë‹ˆë‹¤."

#: src/03_ticket_v1/07_setters.md:100
msgid ""
"`&mut`\\-setters have a downside: you can't chain multiple calls together. "
"Since they don't return the modified `Ticket` instance, you can't call "
"another setter on the result of the first one. You have to call each setter "
"separately:"
msgstr ""
"`&mut`\\-setterì—ëŠ” ë‹¨ì ì´ ìˆìŠµë‹ˆë‹¤. ì—¬ëŸ¬ í˜¸ì¶œì„ í•¨ê»˜ ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ìˆ˜ì •"
"ëœ `Ticket` ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì²« ë²ˆì§¸ ê²°ê³¼ì— ëŒ€í•´ ë‹¤ë¥¸ setterë¥¼ í˜¸"
"ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê° setterë¥¼ ë³„ë„ë¡œ í˜¸ì¶œí•´ì•¼ í•©ë‹ˆë‹¤:"

#: src/03_ticket_v1/07_setters.md:112
msgid ""
"The exercise for this section is located in [`03_ticket_v1/07_setters`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/07_setters)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`03_ticket_v1/07_setters`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/07_setters)ì— ìˆìŠµë‹ˆë‹¤"

#: src/03_ticket_v1/08_stack.md:1 src/04_traits/06_str_slice.md:17
#: src/06_ticket_management/02_vec.md:71
#: src/06_ticket_management/10_slices.md:55
msgid "Memory layout"
msgstr "ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒ"

#: src/03_ticket_v1/08_stack.md:3
msgid ""
"We've looked at ownership and references from an operational point of viewâ€”"
"what you can and can't do with them. Now it's a good time to take a look "
"under the hood: let's talk about **memory**."
msgstr ""
"ìš°ë¦¬ëŠ” ìš´ì˜ ê´€ì ì—ì„œ ì†Œìœ ê¶Œê³¼ ì°¸ì¡°ë¥¼ ì‚´í´ë³´ì•˜ìŠµë‹ˆë‹¤. ì¦‰, ì´ë¥¼ ì‚¬ìš©í•˜ì—¬ ë¬´ì—‡ì„ "
"í•  ìˆ˜ ìˆê³  ë¬´ì—‡ì„ í•  ìˆ˜ ì—†ëŠ”ì§€ ì‚´í´ë³´ì•˜ìŠµë‹ˆë‹¤. ì´ì œ ë‚´ë¶€ë¥¼ ì‚´í´ë³¼ ì¢‹ì€ ì‹œê°„ì…"
"ë‹ˆë‹¤. **ë©”ëª¨ë¦¬**ì— ëŒ€í•´ ì´ì•¼ê¸°í•´ ë³´ê² ìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/08_stack.md:6
msgid "Stack and heap"
msgstr "ìŠ¤íƒê³¼ í™"

#: src/03_ticket_v1/08_stack.md:8
msgid ""
"When discussing memory, you'll often hear people talk about the **stack** and "
"the **heap**.  \n"
"These are two different memory regions used by programs to store data."
msgstr ""
"ë©”ëª¨ë¦¬ì— ê´€í•´ ë…¼ì˜í•  ë•Œ ì‚¬ëŒë“¤ì´ **ìŠ¤íƒ**ê³¼ **í™**ì— ê´€í•´ ì´ì•¼ê¸°í•˜ëŠ” ê²ƒì„ ì"
"ì£¼ ë“£ê²Œ ë©ë‹ˆë‹¤.  \n"
"ì´ëŠ” í”„ë¡œê·¸ë¨ì—ì„œ ë°ì´í„°ë¥¼ ì €ì¥í•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” ë‘ ê°€ì§€ ë‹¤ë¥¸ ë©”ëª¨ë¦¬ ì˜ì—­ì…ë‹ˆ"
"ë‹¤."

#: src/03_ticket_v1/08_stack.md:11
msgid "Let's start with the stack."
msgstr "ìŠ¤íƒë¶€í„° ì‹œì‘í•´ ë³´ê² ìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/08_stack.md:15
msgid ""
"The **stack** is a **LIFO** (Last In, First Out) data structure.  \n"
"When you call a function, a new **stack frame** is added on top of the stack. "
"That stack frame stores the function's arguments, local variables and a few "
"\"bookkeeping\" values.  \n"
"When the function returns, the stack frame is popped off the stack[^stack-"
"overflow]."
msgstr ""
"**ìŠ¤íƒ**ì€ **LIFO**(Last In, First Out) ë°ì´í„° êµ¬ì¡°ì…ë‹ˆë‹¤.  \n"
"í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ë©´ ìƒˆë¡œìš´ **ìŠ¤íƒ í”„ë ˆì„**ì´ ìŠ¤íƒ ìœ„ì— ì¶”ê°€ë©ë‹ˆë‹¤. í•´ë‹¹ ìŠ¤íƒ í”„ë ˆ"
"ì„ì€ í•¨ìˆ˜ì˜ ì¸ìˆ˜, ë¡œì»¬ ë³€ìˆ˜ì™€ ëª‡ ê°€ì§€ \"ë¶€ê°€ì ì¸\" ê°’ì„ ì €ì¥í•©ë‹ˆë‹¤.  \n"
"í•¨ìˆ˜ê°€ ë°˜í™˜ë˜ë©´ ìŠ¤íƒ í”„ë ˆì„ì´ ìŠ¤íƒì—ì„œ íŒë©ë‹ˆë‹¤[^stack-overflow]."

#: src/03_ticket_v1/08_stack.md:28
msgid ""
"From an operational point of view, stack allocation/de-allocation is **very "
"fast**.  \n"
"We are always pushing and popping data from the top of the stack, so we don't "
"need to search for free memory. We also don't have to worry about "
"fragmentation: the stack is a single contiguous block of memory."
msgstr ""
"ìš´ì˜ ê´€ì ì—ì„œ ìŠ¤íƒ í• ë‹¹/í• ë‹¹ í•´ì œëŠ” **ë§¤ìš° ë¹ ë¦…ë‹ˆë‹¤**.  \n"
"ìš°ë¦¬ëŠ” í•­ìƒ ìŠ¤íƒ ìƒë‹¨ì—ì„œ ë°ì´í„°ë¥¼ í‘¸ì‹œí•˜ê³  íŒí•˜ë¯€ë¡œ ì—¬ìœ  ë©”ëª¨ë¦¬ë¥¼ ê²€ìƒ‰í•  í•„ìš”"
"ê°€ ì—†ìŠµë‹ˆë‹¤. ë˜í•œ ì¡°ê°í™”ì— ëŒ€í•´ ê±±ì •í•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤. ìŠ¤íƒì€ ë‹¨ì¼ ì—°ì† ë©”ëª¨"
"ë¦¬ ë¸”ë¡ì…ë‹ˆë‹¤."

#: src/03_ticket_v1/08_stack.md:32
msgid "Rust"
msgstr "Rust"

#: src/03_ticket_v1/08_stack.md:34
msgid ""
"Rust will often allocate data on the stack.  \n"
"You have a `u32` input argument in a function? Those 32 bits will be on the "
"stack.  \n"
"You define a local variable of type `i64`? Those 64 bits will be on the "
"stack.  \n"
"It all works quite nicely because the size of those integers is known at "
"compile time, therefore the compiled program knows how much space it needs to "
"reserve on the stack for them."
msgstr ""
"RustëŠ” ì¢…ì¢… ìŠ¤íƒì— ë°ì´í„°ë¥¼ í• ë‹¹í•©ë‹ˆë‹¤.  \n"
"í•¨ìˆ˜ì— 'u32' ì…ë ¥ ì¸ìˆ˜ê°€ ìˆë‚˜ìš”? í•´ë‹¹ 32ë¹„íŠ¸ëŠ” ìŠ¤íƒì— ì €ì¥ë©ë‹ˆë‹¤.  \n"
"`i64` íƒ€ì…ì˜ ë¡œì»¬ ë³€ìˆ˜ë¥¼ ì •ì˜í•˜ì‹œê² ìŠµë‹ˆê¹Œ? í•´ë‹¹ 64ë¹„íŠ¸ëŠ” ìŠ¤íƒì— ì €ì¥ë©ë‹ˆ"
"ë‹¤.  \n"
"ì´ëŸ¬í•œ ì •ìˆ˜ì˜ í¬ê¸°ëŠ” ì»´íŒŒì¼ íƒ€ì„ì— ì•Œë ¤ì§€ê¸° ë•Œë¬¸ì— ëª¨ë“  ê²ƒì´ ë§¤ìš° ì˜ ì‘ë™í•©ë‹ˆ"
"ë‹¤. ë”°ë¼ì„œ ì»´íŒŒì¼ëœ í”„ë¡œê·¸ë¨ì€ ì´ë¥¼ ìœ„í•´ ìŠ¤íƒì— ì˜ˆì•½í•´ì•¼ í•˜ëŠ” ê³µê°„ì˜ ì–‘ì„ ì•Œ"
"ê³  ìˆìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/08_stack.md:40
msgid "`std::mem::size_of`"
msgstr "`std::mem::size_of`"

#: src/03_ticket_v1/08_stack.md:42
msgid ""
"You can verify how much space a type would take on the stack using the [`std::"
"mem::size_of`](https://doc.rust-lang.org/std/mem/fn.size_of.html) function."
msgstr ""
"[`std::mem::size_of`](https://doc.rust-lang.org/std/mem/fn.size_of.html) í•¨ìˆ˜"
"ë¥¼ ì‚¬ìš©í•˜ì—¬ ìœ í˜•ì´ ìŠ¤íƒì—ì„œ ì°¨ì§€í•˜ëŠ” ê³µê°„ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/08_stack.md:45
msgid "For a `u8`, for example:"
msgstr "ì˜ˆë¥¼ ë“¤ì–´ 'u8'ì˜ ê²½ìš°:"

#: src/03_ticket_v1/08_stack.md:48
msgid ""
"// We'll explain this funny-looking syntax (`::<u8>`) later on.\n"
"// Ignore it for now.\n"
msgstr ""
"// ì´ ì¬ë¯¸ìˆì–´ ë³´ì´ëŠ” êµ¬ë¬¸(`::<u8>`)ì— ëŒ€í•´ì„œëŠ” ë‚˜ì¤‘ì— ì„¤ëª…í•˜ê² ìŠµë‹ˆë‹¤.\n"
"// ì§€ê¸ˆì€ ë¬´ì‹œí•˜ì„¸ìš”.\n"

#: src/03_ticket_v1/08_stack.md:53
msgid "1 makes sense, because a `u8` is 8 bits long, or 1 byte."
msgstr "'u8'ì˜ ê¸¸ì´ê°€ 8ë¹„íŠ¸, ì¦‰ 1ë°”ì´íŠ¸ì´ê¸° ë•Œë¬¸ì— 1ì´ ë§ì´ ë©ë‹ˆë‹¤."

#: src/03_ticket_v1/08_stack.md:55
msgid ""
"If you have nested function calls, each function pushes its data onto the "
"stack when it's called but it doesn't pop it off until the innermost function "
"returns. If you have too many nested function calls, you can run out of stack "
"spaceâ€”the stack is not infinite! That's called a [**stack overflow**](https://"
"en.wikipedia.org/wiki/Stack_overflow)."
msgstr ""
"ì¤‘ì²©ëœ í•¨ìˆ˜ í˜¸ì¶œì´ ìˆëŠ” ê²½ìš° ê° í•¨ìˆ˜ëŠ” í˜¸ì¶œë  ë•Œ í•´ë‹¹ ë°ì´í„°ë¥¼ ìŠ¤íƒì— í‘¸ì‹œí•˜ì§€"
"ë§Œ ê°€ì¥ ì•ˆìª½ í•¨ìˆ˜ê°€ ë°˜í™˜ë  ë•Œê¹Œì§€ ë°ì´í„°ë¥¼ íŒí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì¤‘ì²©ëœ í•¨ìˆ˜ í˜¸ì¶œ"
"ì´ ë„ˆë¬´ ë§ìœ¼ë©´ ìŠ¤íƒ ê³µê°„ì´ ë¶€ì¡±í•´ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìŠ¤íƒì€ ë¬´í•œí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤! ì´"
"ë¥¼ **ìŠ¤íƒ ì˜¤ë²„í”Œë¡œ**ë¼ê³  í•©ë‹ˆë‹¤."

#: src/03_ticket_v1/08_stack.md:62
msgid ""
"The exercise for this section is located in [`03_ticket_v1/08_stack`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/08_stack)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`03_ticket_v1/08_stack`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/08_stack)ì— ìˆìŠµë‹ˆë‹¤"

#: src/03_ticket_v1/09_heap.md:3
msgid ""
"The stack is great, but it can't solve all our problems. What about data "
"whose size is not known at compile time? Collections, strings, and other "
"dynamically-sized data cannot be (entirely) stack-allocated. That's where the "
"**heap** comes in."
msgstr ""
"ìŠ¤íƒì€ í›Œë¥­í•˜ì§€ë§Œ ëª¨ë“  ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ëŠ” ì—†ìŠµë‹ˆë‹¤. ì»´íŒŒì¼ íƒ€ì„ì— í¬ê¸°ë¥¼ ì•Œ "
"ìˆ˜ ì—†ëŠ” ë°ì´í„°ëŠ” ì–´ë–»ê²Œ ë˜ë‚˜ìš”? ì»¬ë ‰ì…˜, ë¬¸ìì—´ ë° ê¸°íƒ€ ë™ì ìœ¼ë¡œ í¬ê¸°ê°€ ì¡°ì •ëœ "
"ë°ì´í„°ëŠ” (ì „ì²´) ìŠ¤íƒì— í• ë‹¹ë  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. **í™**ì´ í•„ìš”í•œ ê³³ì´ ë°”ë¡œ ì—¬ê¸°ì…ë‹ˆ"
"ë‹¤."

#: src/03_ticket_v1/09_heap.md:7
msgid "Heap allocations"
msgstr "í™ í• ë‹¹"

#: src/03_ticket_v1/09_heap.md:9
msgid ""
"You can visualize the heap as a big chunk of memoryâ€”a huge array, if you "
"will.  \n"
"Whenever you need to store data on the heap, you ask a special program, the "
"**allocator**, to reserve for you a subset of the heap. We call this "
"interaction (and the memory you reserved) a **heap allocation**. If the "
"allocation succeeds, the allocator will give you a **pointer** to the start "
"of the reserved block."
msgstr ""
"í™ì„ í° ë©”ëª¨ë¦¬ ë©ì–´ë¦¬, ì¦‰ ê±°ëŒ€í•œ ë°°ì—´ë¡œ ì‹œê°í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"í™ì— ë°ì´í„°ë¥¼ ì €ì¥í•´ì•¼ í•  ë•Œë§ˆë‹¤ íŠ¹ìˆ˜ í”„ë¡œê·¸ë¨ì¸ **í• ë‹¹ì**ì— ìš”ì²­í•˜ì—¬ í™ì˜ í•˜"
"ìœ„ ì§‘í•©ì„ ì˜ˆì•½í•©ë‹ˆë‹¤. ìš°ë¦¬ëŠ” ì´ ìƒí˜¸ ì‘ìš©(ë° ì˜ˆì•½í•œ ë©”ëª¨ë¦¬)ì„ **í™ í• ë‹¹**ì´ë¼"
"ê³  ë¶€ë¦…ë‹ˆë‹¤. í• ë‹¹ì´ ì„±ê³µí•˜ë©´ í• ë‹¹ìëŠ” ì˜ˆì•½ëœ ë¸”ë¡ì˜ ì‹œì‘ì— ëŒ€í•œ **í¬ì¸í„°**ë¥¼ "
"ì œê³µí•©ë‹ˆë‹¤."

#: src/03_ticket_v1/09_heap.md:14
msgid "No automatic de-allocation"
msgstr "ìë™ í• ë‹¹ í•´ì œ ì—†ìŒ"

#: src/03_ticket_v1/09_heap.md:16
msgid ""
"The heap is structured quite differently from the stack.  \n"
"Heap allocations are not contiguous, they can be located anywhere inside the "
"heap."
msgstr ""
"í™ì€ ìŠ¤íƒê³¼ êµ¬ì¡°ê°€ ìƒë‹¹íˆ ë‹¤ë¦…ë‹ˆë‹¤.  \n"
"í™ í• ë‹¹ì€ ì—°ì†ì ì´ì§€ ì•Šìœ¼ë©° í™ ë‚´ë¶€ ì–´ë””ì—ë‚˜ ìœ„ì¹˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/09_heap.md:25
msgid ""
"It's the allocator's job to keep track of which parts of the heap are in use "
"and which are free. The allocator won't automatically free the memory you "
"allocated, though: you need to be deliberate about it, calling the allocator "
"again to **free** the memory you no longer need."
msgstr ""
"í™ì˜ ì–´ëŠ ë¶€ë¶„ì´ ì‚¬ìš© ì¤‘ì´ê³  ì–´ëŠ ë¶€ë¶„ì´ ì‚¬ìš© ê°€ëŠ¥í•œì§€ ì¶”ì í•˜ëŠ” ê²ƒì´ í• ë‹¹ìì˜ "
"ì„ë¬´ì…ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ í• ë‹¹ìëŠ” í• ë‹¹í•œ ë©”ëª¨ë¦¬ë¥¼ ìë™ìœ¼ë¡œ í•´ì œí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë” ì´"
"ìƒ í•„ìš”í•˜ì§€ ì•Šì€ ë©”ëª¨ë¦¬ë¥¼ **í•´ì œ**í•˜ë ¤ë©´ í• ë‹¹ìë¥¼ ë‹¤ì‹œ í˜¸ì¶œí•˜ì—¬ ì´ì— ëŒ€í•´ ì‹ ì¤‘"
"í•˜ê²Œ ìƒê°í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/03_ticket_v1/09_heap.md:29 src/06_ticket_management/01_arrays.md:62
msgid "Performance"
msgstr "ì„±ëŠ¥"

#: src/03_ticket_v1/09_heap.md:31
msgid ""
"The heap's flexibility comes at a cost: heap allocations are **slower** than "
"stack allocations. There's a lot more bookkeeping involved!  \n"
"If you read articles about performance optimization you'll often be advised "
"to minimize heap allocations and prefer stack-allocated data whenever "
"possible."
msgstr ""
"í™ì˜ ìœ ì—°ì„±ì—ëŠ” ë¹„ìš©ì´ ë”°ë¦…ë‹ˆë‹¤. í™ í• ë‹¹ì€ ìŠ¤íƒ í• ë‹¹ë³´ë‹¤ **ëŠë¦½ë‹ˆë‹¤**. ì¥ë¶€ì— "
"ê´€ë ¨ëœ ì¼ì´ í›¨ì”¬ ë” ë§ìŠµë‹ˆë‹¤!  \n"
"ì„±ëŠ¥ ìµœì í™”ì— ëŒ€í•œ ê¸°ì‚¬ë¥¼ ì½ìœ¼ë©´ ê°€ëŠ¥í•˜ë©´ í™ í• ë‹¹ì„ ìµœì†Œí™”í•˜ê³  ìŠ¤íƒ í• ë‹¹ ë°ì´"
"í„°ë¥¼ ì„ í˜¸í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/09_heap.md:36
msgid "`String`'s memory layout"
msgstr "`String`ì˜ ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒ"

#: src/03_ticket_v1/09_heap.md:38
msgid ""
"When you create a local variable of type `String`, Rust is forced to allocate "
"on the heap[^empty]: it doesn't know in advance how much text you're going to "
"put in it, so it can't reserve the right amount of space on the stack.  \n"
"But a `String` is not _entirely_ heap-allocated, it also keeps some data on "
"the stack. In particular:"
msgstr ""
"`String` íƒ€ì…ì˜ ë¡œì»¬ ë³€ìˆ˜ë¥¼ ë§Œë“¤ ë•Œ RustëŠ” ê°•ì œë¡œ í™ì— í• ë‹¹í•©ë‹ˆë‹¤[^empty]: ê±°"
"ê¸°ì— ì–¼ë§ˆë‚˜ ë§ì€ í…ìŠ¤íŠ¸ë¥¼ ë„£ì„ì§€ ë¯¸ë¦¬ ì•Œì§€ ëª»í•˜ë¯€ë¡œ ì˜ˆì•½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ìŠ¤íƒ"
"ì— ì ì ˆí•œ ì–‘ì˜ ê³µê°„ì´ ìˆìŠµë‹ˆë‹¤.  \n"
"í•˜ì§€ë§Œ `String`ì€ _ì™„ì „íˆ_ í™ì— í• ë‹¹ë˜ì§€ ì•Šìœ¼ë©° ì¼ë¶€ ë°ì´í„°ë¥¼ ìŠ¤íƒì— ìœ ì§€í•˜ê¸°"
"ë„ í•©ë‹ˆë‹¤. íŠ¹íˆ:"

#: src/03_ticket_v1/09_heap.md:43 src/06_ticket_management/02_vec.md:101
msgid "The **pointer** to the heap region you reserved."
msgstr "ì˜ˆì•½í•œ í™ ì˜ì—­ì— ëŒ€í•œ **í¬ì¸í„°**."

#: src/03_ticket_v1/09_heap.md:44
msgid "The **length** of the string, i.e. how many bytes are in the string."
msgstr "ë¬¸ìì—´ì˜ **ê¸¸ì´**, ì¦‰ ë¬¸ìì—´ì— ëª‡ ë°”ì´íŠ¸ê°€ ìˆëŠ”ì§€ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤."

#: src/03_ticket_v1/09_heap.md:45
msgid ""
"The **capacity** of the string, i.e. how many bytes have been reserved on the "
"heap."
msgstr "ë¬¸ìì—´ì˜ **ìš©ëŸ‰**, ì¦‰ í™ì— ì˜ˆì•½ëœ ë°”ì´íŠ¸ ìˆ˜ì…ë‹ˆë‹¤."

#: src/03_ticket_v1/09_heap.md:47
msgid "Let's look at an example to understand this better:"
msgstr "ì´ë¥¼ ë” ì˜ ì´í•´í•˜ê¸° ìœ„í•´ ì˜ˆë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/03_ticket_v1/09_heap.md:53
msgid "If you run this code, memory will be laid out like this:"
msgstr "ì´ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ë©´ ë©”ëª¨ë¦¬ê°€ ë‹¤ìŒê³¼ ê°™ì´ ë°°ì¹˜ë©ë‹ˆë‹¤:"

#: src/03_ticket_v1/09_heap.md:68
msgid ""
"We asked for a `String` that can hold up to 5 bytes of text.  \n"
"`String::with_capacity` goes to the allocator and asks for 5 bytes of heap "
"memory. The allocator returns a pointer to the start of that memory block.  \n"
"The `String` is empty, though. On the stack, we keep track of this "
"information by distinguishing between the length and the capacity: this "
"`String` can hold up to 5 bytes, but it currently holds 0 bytes of actual "
"text."
msgstr ""
"ìš°ë¦¬ëŠ” ìµœëŒ€ 5ë°”ì´íŠ¸ì˜ í…ìŠ¤íŠ¸ë¥¼ ë‹´ì„ ìˆ˜ ìˆëŠ” `String`ì„ ìš”ì²­í–ˆìŠµë‹ˆë‹¤.  \n"
"`String::with_capacity`ëŠ” í• ë‹¹ìë¡œ ê°€ì„œ 5ë°”ì´íŠ¸ì˜ í™ ë©”ëª¨ë¦¬ë¥¼ ìš”ì²­í•©ë‹ˆë‹¤. í• ë‹¹"
"ìëŠ” í•´ë‹¹ ë©”ëª¨ë¦¬ ë¸”ë¡ì˜ ì‹œì‘ì— ëŒ€í•œ í¬ì¸í„°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.  \n"
"í•˜ì§€ë§Œ `String`ì€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤. ìŠ¤íƒì—ì„œëŠ” ê¸¸ì´ì™€ ìš©ëŸ‰ì„ êµ¬ë³„í•˜ì—¬ ì´ ì •ë³´ë¥¼ "
"ì¶”ì í•©ë‹ˆë‹¤. ì´ `String`ì€ ìµœëŒ€ 5ë°”ì´íŠ¸ë¥¼ ì €ì¥í•  ìˆ˜ ìˆì§€ë§Œ í˜„ì¬ ì‹¤ì œ í…ìŠ¤íŠ¸ëŠ” 0"
"ë°”ì´íŠ¸ë¥¼ í¬í•¨í•©ë‹ˆë‹¤."

#: src/03_ticket_v1/09_heap.md:75
msgid "If you push some text into the `String`, the situation will change:"
msgstr "ì¼ë¶€ í…ìŠ¤íŠ¸ë¥¼ `String`ì— ë„£ìœ¼ë©´ ìƒí™©ì´ ë³€ê²½ë©ë‹ˆë‹¤:"

#: src/03_ticket_v1/09_heap.md:78 src/03_ticket_v1/10_references_in_memory.md:19
msgid "\"Hey\""
msgstr "\"Hey\""

#: src/03_ticket_v1/09_heap.md:94
msgid ""
"`s` now holds 3 bytes of text. Its length is updated to 3, but capacity "
"remains 5. Three of the five bytes on the heap are used to store the "
"characters `H`, `e`, and `y`."
msgstr ""
"`s`ëŠ” ì´ì œ 3ë°”ì´íŠ¸ì˜ í…ìŠ¤íŠ¸ë¥¼ ë³´ìœ í•©ë‹ˆë‹¤. ê¸¸ì´ëŠ” 3ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë˜ì§€ë§Œ ìš©ëŸ‰ì€ 5"
"ë¡œ ìœ ì§€ë©ë‹ˆë‹¤. í™ì˜ 5ë°”ì´íŠ¸ â€‹â€‹ì¤‘ 3ë°”ì´íŠ¸ëŠ” `H`, `e` ë° `y` ë¬¸ìë¥¼ ì €ì¥í•˜ëŠ” ë° ì‚¬"
"ìš©ë©ë‹ˆë‹¤."

#: src/03_ticket_v1/09_heap.md:97
msgid "`usize`"
msgstr "`usize`"

#: src/03_ticket_v1/09_heap.md:99
msgid ""
"How much space do we need to store pointer, length and capacity on the "
"stack?  \n"
"It depends on the **architecture** of the machine you're running on."
msgstr ""
"ìŠ¤íƒì— í¬ì¸í„°, ê¸¸ì´ ë° ìš©ëŸ‰ì„ ì €ì¥í•˜ë ¤ë©´ ì–¼ë§ˆë‚˜ ë§ì€ ê³µê°„ì´ í•„ìš”í•©ë‹ˆê¹Œ?  \n"
"ì‹¤í–‰ ì¤‘ì¸ ë¨¸ì‹ ì˜ **ì•„í‚¤í…ì²˜**ì— ë”°ë¼ ë‹¤ë¦…ë‹ˆë‹¤."

#: src/03_ticket_v1/09_heap.md:102
msgid ""
"Every memory location on your machine has an [**address**](https://en."
"wikipedia.org/wiki/Memory_address), commonly represented as an unsigned "
"integer. Depending on the maximum size of the address space (i.e. how much "
"memory your machine can address), this integer can have a different size. "
"Most modern machines use either a 32-bit or a 64-bit address space."
msgstr ""
"ì»´í“¨í„°ì˜ ëª¨ë“  ë©”ëª¨ë¦¬ ìœ„ì¹˜ì—ëŠ” ì¼ë°˜ì ìœ¼ë¡œ ë¶€í˜¸ ì—†ëŠ” ì •ìˆ˜ë¡œ í‘œì‹œë˜ëŠ” [**ì£¼ì†Œ**]"
"(https://en.wikipedia.org/wiki/Memory_address)ê°€ ìˆìŠµë‹ˆë‹¤. ì£¼ì†Œ ê³µê°„ì˜ ìµœëŒ€ í¬"
"ê¸°(ì¦‰, ì»´í“¨í„°ê°€ ì£¼ì†Œë¥¼ ì§€ì •í•  ìˆ˜ ìˆëŠ” ë©”ëª¨ë¦¬ ì–‘)ì— ë”°ë¼ ì´ ì •ìˆ˜ì˜ í¬ê¸°ê°€ ë‹¤ë¥¼ "
"ìˆ˜ ìˆìŠµë‹ˆë‹¤. ëŒ€ë¶€ë¶„ì˜ ìµœì‹  ì»´í“¨í„°ëŠ” 32ë¹„íŠ¸ ë˜ëŠ” 64ë¹„íŠ¸ ì£¼ì†Œ ê³µê°„ì„ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/03_ticket_v1/09_heap.md:107
msgid ""
"Rust abstracts away these architecture-specific details by providing the "
"`usize` type: an unsigned integer that's as big as the number of bytes needed "
"to address memory on your machine. On a 32-bit machine, `usize` is equivalent "
"to `u32`. On a 64-bit machine, it matches `u64`."
msgstr ""
"RustëŠ” `usize` ìœ í˜•ì„ ì œê³µí•˜ì—¬ ì´ëŸ¬í•œ ì•„í‚¤í…ì²˜ë³„ ì„¸ë¶€ ì •ë³´ë¥¼ ì¶”ìƒí™”í•©ë‹ˆë‹¤. ì´"
"ëŠ” ë¨¸ì‹ ì˜ ë©”ëª¨ë¦¬ ì£¼ì†Œë¥¼ ì§€ì •í•˜ëŠ” ë° í•„ìš”í•œ ë°”ì´íŠ¸ ìˆ˜ë§Œí¼ í° ë¶€í˜¸ ì—†ëŠ” ì •ìˆ˜ì…ë‹ˆ"
"ë‹¤. 32ë¹„íŠ¸ ì‹œìŠ¤í…œì—ì„œ `usize`ëŠ” `u32`ì™€ ë™ì¼í•©ë‹ˆë‹¤. 64ë¹„íŠ¸ ì‹œìŠ¤í…œì—ì„œëŠ” "
"'u64'ì™€ ì¼ì¹˜í•©ë‹ˆë‹¤."

#: src/03_ticket_v1/09_heap.md:111
msgid ""
"Capacity, length and pointers are all represented as `usize`s in "
"Rust[^equivalence]."
msgstr "ìš©ëŸ‰, ê¸¸ì´, í¬ì¸í„°ëŠ” ëª¨ë‘ Rust[^equivalence]ì—ì„œ `usize`ë¡œ í‘œì‹œë©ë‹ˆë‹¤."

#: src/03_ticket_v1/09_heap.md:113
msgid "No `std::mem::size_of` for the heap"
msgstr "í™ì—ëŠ” `std::mem::size_of`ê°€ ì—†ìŠµë‹ˆë‹¤"

#: src/03_ticket_v1/09_heap.md:115
msgid ""
"`std::mem::size_of` returns the amount of space a type would take on the "
"stack, which is also known as the **size of the type**."
msgstr ""
"`std::mem::size_of`ëŠ” íƒ€ì…ì´ ìŠ¤íƒì—ì„œ ì°¨ì§€í•  ê³µê°„ì˜ ì–‘ì„ ë°˜í™˜í•˜ë©°, ì´ëŠ” **íƒ€ì…"
"ì˜ í¬ê¸°**ë¼ê³ ë„ ì•Œë ¤ì ¸ ìˆìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/09_heap.md:118
msgid ""
"What about the memory buffer that `String` is managing on the heap? Isn't "
"that part of the size of `String`?"
msgstr ""
"`String`ì´ í™ì—ì„œ ê´€ë¦¬í•˜ëŠ” ë©”ëª¨ë¦¬ ë²„í¼ëŠ” ì–´ë–»ìŠµë‹ˆê¹Œ? ê·¸ê²ƒì€ `String` í¬ê¸°ì˜ ì¼"
"ë¶€ê°€ ì•„ë‹ê¹Œìš”?"

#: src/03_ticket_v1/09_heap.md:121
msgid ""
"No!  \n"
"That heap allocation is a **resource** that `String` is managing. It's not "
"considered to be part of the `String` type by the compiler."
msgstr ""
"ì•„ë‹ˆìš”!  \n"
"í•´ë‹¹ í™ í• ë‹¹ì€ `String`ì´ ê´€ë¦¬í•˜ëŠ” **ë¦¬ì†ŒìŠ¤**ì…ë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” `String` ìœ í˜•"
"ì˜ ì¼ë¶€ë¡œ ê°„ì£¼í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/09_heap.md:125
msgid ""
"`std::mem::size_of` doesn't know (or care) about additional heap-allocated "
"data that a type might manage or refer to via pointers, as is the case with "
"`String`, therefore it doesn't track its size."
msgstr ""
"`std::mem::size_of`ëŠ” `String`ì˜ ê²½ìš°ì²˜ëŸ¼ ìœ í˜•ì´ í¬ì¸í„°ë¥¼ í†µí•´ ê´€ë¦¬í•˜ê±°ë‚˜ ì°¸ì¡°"
"í•  ìˆ˜ ìˆëŠ” ì¶”ê°€ í™ í• ë‹¹ ë°ì´í„°ì— ëŒ€í•´ ì•Œì§€(ë˜ëŠ” ì‹ ê²½ ì“°ì§€) ì•Šìœ¼ë¯€ë¡œ í•´ë‹¹ ë°ì´"
"í„°ì˜ í¬ê¸°ë¥¼ ì¶”ì í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/09_heap.md:129
msgid ""
"Unfortunately there is no equivalent of `std::mem::size_of` to measure the "
"amount of heap memory that a certain value is allocating at runtime. Some "
"types might provide methods to inspect their heap usage (e.g. `String`'s "
"`capacity` method), but there is no general-purpose \"API\" to retrieve "
"runtime heap usage in Rust.  \n"
"You can, however, use a memory profiler tool (e.g. [DHAT](https://valgrind."
"org/docs/manual/dh-manual.html) or [a custom allocator](https://docs.rs/dhat/"
"latest/dhat/)) to inspect the heap usage of your program."
msgstr ""
"ë¶ˆí–‰í•˜ê²Œë„ íŠ¹ì • ê°’ì´ ëŸ°íƒ€ì„ì— í• ë‹¹í•˜ëŠ” í™ ë©”ëª¨ë¦¬ì˜ ì–‘ì„ ì¸¡ì •í•˜ëŠ” `std::mem::"
"size_of`ì™€ ë™ë“±í•œ ê²ƒì€ ì—†ìŠµë‹ˆë‹¤. ì¼ë¶€ ìœ í˜•ì€ í™ ì‚¬ìš©ëŸ‰ì„ ê²€ì‚¬í•˜ëŠ” ë©”ì„œë“œ(ì˜ˆ: "
"`String`ì˜ `capacity` ë©”ì„œë“œ)ë¥¼ ì œê³µí•  ìˆ˜ ìˆì§€ë§Œ Rustì—ëŠ” ëŸ°íƒ€ì„ í™ ì‚¬ìš©ëŸ‰ì„ "
"ê²€ìƒ‰í•˜ëŠ” ë²”ìš© \"API\"ê°€ ì—†ìŠµë‹ˆë‹¤.  \n"
"ê·¸ëŸ¬ë‚˜ ë©”ëª¨ë¦¬ í”„ë¡œíŒŒì¼ëŸ¬ ë„êµ¬(ì˜ˆ: DHAT ë˜ëŠ” ì‚¬ìš©ì ì •ì˜ í• ë‹¹ì)ë¥¼ ì‚¬ìš©í•˜ì—¬ í”„"
"ë¡œê·¸ë¨ì˜ í™ ì‚¬ìš©ëŸ‰ì„ ê²€ì‚¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/09_heap.md:136
msgid ""
"`std` doesn't allocate if you create an **empty** `String` (i.e. `String::"
"new()`). Heap memory will be reserved when you push data into it for the "
"first time."
msgstr ""
"**ë¹ˆ** `String`(ì˜ˆ: `String::new()`)ì„ ìƒì„±í•˜ë©´ `std`ëŠ” í™ì„ í• ë‹¹í•˜ì§€ ì•ŠìŠµë‹ˆ"
"ë‹¤. í™ ë©”ëª¨ë¦¬ëŠ” ì²˜ìŒìœ¼ë¡œ ë°ì´í„°ë¥¼ í‘¸ì‹œí•  ë•Œ ì˜ˆì•½ë©ë‹ˆë‹¤."

#: src/03_ticket_v1/09_heap.md:139
msgid ""
"The size of a pointer depends on the operating system too. In certain "
"environments, a pointer is **larger** than a memory address (e.g. [CHERI]"
"(https://blog.acolyer.org/2019/05/28/cheri-abi/)). Rust makes the simplifying "
"assumption that pointers are the same size as memory addresses, which is true "
"for most modern systems you're likely to encounter."
msgstr ""
"í¬ì¸í„°ì˜ í¬ê¸°ëŠ” ìš´ì˜ ì²´ì œì— ë”°ë¼ ë‹¤ë¦…ë‹ˆë‹¤. íŠ¹ì • í™˜ê²½ì—ì„œëŠ” í¬ì¸í„°ê°€ ë©”ëª¨ë¦¬ ì£¼"
"ì†Œ(ì˜ˆ: CHERI)ë³´ë‹¤ **ë” í½ë‹ˆë‹¤**. RustëŠ” í¬ì¸í„°ê°€ ë©”ëª¨ë¦¬ ì£¼ì†Œì™€ ë™ì¼í•œ í¬ê¸°ë¼"
"ëŠ” ë‹¨ìˆœí™”ëœ ê°€ì •ì„ í•˜ê³  ìˆìœ¼ë©°, ì´ëŠ” ì—¬ëŸ¬ë¶„ì´ ì ‘í•˜ê²Œ ë  ëŒ€ë¶€ë¶„ì˜ ìµœì‹  ì‹œìŠ¤í…œ"
"ì— í•´ë‹¹ë©ë‹ˆë‹¤."

#: src/03_ticket_v1/09_heap.md:146
msgid ""
"The exercise for this section is located in [`03_ticket_v1/09_heap`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/09_heap)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`03_ticket_v1/09_heap`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/09_heap)ì— ìˆìŠµë‹ˆë‹¤"

#: src/03_ticket_v1/10_references_in_memory.md:1
#: src/06_ticket_management/06_lifetimes.md:80
msgid "References"
msgstr "ì°¸ì¡°"

#: src/03_ticket_v1/10_references_in_memory.md:3
msgid ""
"What about references, like `&String` or `&mut String`? How are they "
"represented in memory?"
msgstr ""
"`&String` ë˜ëŠ” `&mut String`ê³¼ ê°™ì€ ì°¸ì¡°ëŠ” ì–´ë–¨ê¹Œìš”? ë©”ëª¨ë¦¬ì—ì„œ ì–´ë–»ê²Œ í‘œí˜„ë "
"ê¹Œìš”?"

#: src/03_ticket_v1/10_references_in_memory.md:5
msgid ""
"Most references[^fat] in Rust are represented, in memory, as a pointer to a "
"memory location.  \n"
"It follows that their size is the same as the size of a pointer, a `usize`."
msgstr ""
"Rustì—ì„œ ëŒ€ë¶€ë¶„ì˜ ì°¸ì¡°[^fat]ëŠ” ë©”ëª¨ë¦¬ì—ì„œ ë©”ëª¨ë¦¬ ìœ„ì¹˜ì— ëŒ€í•œ í¬ì¸í„°ë¡œ í‘œì‹œë©ë‹ˆ"
"ë‹¤.  \n"
"ê·¸ í¬ê¸°ëŠ” í¬ì¸í„°ì˜ í¬ê¸°ì¸ `usize`ì™€ ë™ì¼í•©ë‹ˆë‹¤."

#: src/03_ticket_v1/10_references_in_memory.md:8
msgid "You can verify this using `std::mem::size_of`:"
msgstr "`std::mem::size_of`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ë¥¼ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/03_ticket_v1/10_references_in_memory.md:15
msgid ""
"A `&String`, in particular, is a pointer to the memory location where the "
"`String`'s metadata is stored.  \n"
"If you run this snippet:"
msgstr ""
"íŠ¹íˆ `&String`ì€ `String`ì˜ ë©”íƒ€ë°ì´í„°ê°€ ì €ì¥ë˜ëŠ” ë©”ëª¨ë¦¬ ìœ„ì¹˜ì— ëŒ€í•œ í¬ì¸í„°ì…"
"ë‹ˆë‹¤.  \n"
"ì´ ìŠ¤ë‹ˆí«ì„ ì‹¤í–‰í•˜ë©´:"

#: src/03_ticket_v1/10_references_in_memory.md:23
msgid "you'll get something like this in memory:"
msgstr "ë©”ëª¨ë¦¬ì— ë‹¤ìŒê³¼ ê°™ì€ ë‚´ìš©ì´ í‘œì‹œë©ë‹ˆë‹¤:"

#: src/03_ticket_v1/10_references_in_memory.md:40
msgid ""
"It's a pointer to a pointer to the heap-allocated data, if you will. The same "
"goes for `&mut String`."
msgstr ""
"ì›í•œë‹¤ë©´ í™ í• ë‹¹ ë°ì´í„°ì— ëŒ€í•œ í¬ì¸í„°ì— ëŒ€í•œ í¬ì¸í„°ì…ë‹ˆë‹¤. `&mut String`ë„ ë§ˆ"
"ì°¬ê°€ì§€ì…ë‹ˆë‹¤."

#: src/03_ticket_v1/10_references_in_memory.md:43
msgid "Not all pointers point to the heap"
msgstr "ëª¨ë“  í¬ì¸í„°ê°€ í™ì„ ê°€ë¦¬í‚¤ëŠ” ê²ƒì€ ì•„ë‹™ë‹ˆë‹¤"

#: src/03_ticket_v1/10_references_in_memory.md:45
msgid ""
"The example above should clarify one thing: not all pointers point to the "
"heap.  \n"
"They just point to a memory location, which _may_ be on the heap, but doesn't "
"have to be."
msgstr ""
"ìœ„ì˜ ì˜ˆì—ì„œëŠ” í•œ ê°€ì§€ë¥¼ ëª…í™•íˆ í•´ì•¼ í•©ë‹ˆë‹¤. ëª¨ë“  í¬ì¸í„°ê°€ í™ì„ ê°€ë¦¬í‚¤ëŠ” ê²ƒì€ "
"ì•„ë‹™ë‹ˆë‹¤.  \n"
"ê·¸ë“¤ì€ ë‹¨ì§€ í™ì— ìˆì„ ìˆ˜ë„ ìˆì§€ë§Œ ë°˜ë“œì‹œ ê·¸ëŸ´ í•„ìš”ëŠ” ì—†ëŠ” ë©”ëª¨ë¦¬ ìœ„ì¹˜ë¥¼ ê°€ë¦¬"
"í‚¬ ë¿ì…ë‹ˆë‹¤."

#: src/03_ticket_v1/10_references_in_memory.md:48
msgid ""
"[Later in the course](../04_traits/06_str_slice.md) we'll talk about **fat "
"pointers**, i.e. pointers with additional metadata. As the name implies, they "
"are larger than the pointers we discussed in this chapter, also known as "
"**thin pointers**."
msgstr ""
"[ì´ ì½”ìŠ¤ì˜ ë’·ë¶€ë¶„](../04_traits/06_str_slice.md)ì—ì„œëŠ” **íŒ» í¬ì¸í„°**, ì¦‰ ì¶”ê°€ "
"ë©”íƒ€ë°ì´í„°ê°€ í¬í•¨ëœ í¬ì¸í„°ì— ëŒ€í•´ ì„¤ëª…í•˜ê² ìŠµë‹ˆë‹¤. ì´ë¦„ì—ì„œ ì•Œ ìˆ˜ ìˆë“¯ì´ ì´ ì¥"
"ì—ì„œ ë…¼ì˜í•œ í¬ì¸í„°(**ì–‡ì€ í¬ì¸í„°**ë¼ê³ ë„ í•¨)ë³´ë‹¤ í½ë‹ˆë‹¤."

#: src/03_ticket_v1/10_references_in_memory.md:54
msgid ""
"The exercise for this section is located in "
"[`03_ticket_v1/10_references_in_memory`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/10_references_in_memory)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`03_ticket_v1/10_references_in_memory`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/10_references_in_memory)ì— ìˆìŠµë‹ˆë‹¤"

#: src/03_ticket_v1/11_destructor.md:3
msgid ""
"When introducing the heap, we mentioned that you're responsible for freeing "
"the memory you allocate.  \n"
"When introducing the borrow-checker, we also stated that you rarely have to "
"manage memory directly in Rust."
msgstr ""
"í™ì„ ì†Œê°œí•  ë•Œ í• ë‹¹í•œ ë©”ëª¨ë¦¬ë¥¼ í•´ì œí•  ì±…ì„ì€ ì‚¬ìš©ìì—ê²Œ ìˆë‹¤ê³  ì–¸ê¸‰í–ˆìŠµë‹ˆ"
"ë‹¤.  \n"
"ì°¨ìš© ê²€ì‚¬ê¸°ë¥¼ ì†Œê°œí•  ë•Œ ìš°ë¦¬ëŠ” Rustì—ì„œ ì§ì ‘ ë©”ëª¨ë¦¬ë¥¼ ê´€ë¦¬í•  í•„ìš”ê°€ ê±°ì˜ ì—†ë‹¤"
"ê³  ì–¸ê¸‰í–ˆìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/11_destructor.md:6
msgid ""
"These two statements might seem contradictory at first. Let's see how they "
"fit together by introducing **scopes** and **destructors**."
msgstr ""
"ì´ ë‘ ì§„ìˆ ì€ ì²˜ìŒì—ëŠ” ëª¨ìˆœë˜ëŠ” ê²ƒì²˜ëŸ¼ ë³´ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. **ë²”ìœ„**ì™€ **ì†Œë©¸ì**"
"ë¥¼ ë„ì…í•˜ì—¬ ì´ë“¤ì´ ì–´ë–»ê²Œ ì¡°í™”ë¥¼ ì´ë£¨ëŠ”ì§€ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/11_destructor.md:9
msgid "Scopes"
msgstr "ìŠ¤ì½”í”„"

#: src/03_ticket_v1/11_destructor.md:11
msgid ""
"The **scope** of a variable is the region of Rust code where that variable is "
"valid, or **alive**."
msgstr ""
"ë³€ìˆ˜ì˜ **ìŠ¤ì½”í”„**ëŠ” í•´ë‹¹ ë³€ìˆ˜ê°€ ìœ íš¨í•˜ê±°ë‚˜ **ì‚´ì•„ìˆëŠ”** Rust ì½”ë“œì˜ ì˜ì—­ì…ë‹ˆ"
"ë‹¤."

#: src/03_ticket_v1/11_destructor.md:13
msgid ""
"The scope of a variable starts with its declaration. It ends when one of the "
"following happens:"
msgstr "ë³€ìˆ˜ì˜ ë²”ìœ„ëŠ” ì„ ì–¸ë¶€í„° ì‹œì‘ë©ë‹ˆë‹¤. ë‹¤ìŒ ì¤‘ í•˜ë‚˜ê°€ ë°œìƒí•˜ë©´ ì¢…ë£Œë©ë‹ˆë‹¤:"

#: src/03_ticket_v1/11_destructor.md:16
msgid ""
"the block (i.e. the code between `{}`) where the variable was declared ends"
msgstr "ë³€ìˆ˜ê°€ ì„ ì–¸ëœ ë¸”ë¡(ì¦‰ `{}` ì‚¬ì´ì˜ ì½”ë“œ)ì´ ëë‚  "

#: src/03_ticket_v1/11_destructor.md:19
msgid "// `x` is not yet in scope here\n"
msgstr "// `x`ëŠ” ì•„ì§ ìŠ¤ì½”í”„ì— í¬í•¨ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤\n"

#: src/03_ticket_v1/11_destructor.md:20 src/03_ticket_v1/11_destructor.md:32
#: src/03_ticket_v1/11_destructor.md:54 src/03_ticket_v1/11_destructor.md:64
#: src/03_ticket_v1/11_destructor.md:82 src/03_ticket_v1/11_destructor.md:98
#: src/03_ticket_v1/11_destructor.md:115 src/04_traits/06_str_slice.md:26
#: src/04_traits/06_str_slice.md:74 src/04_traits/08_sized.md:13
msgid "\"Hello\""
msgstr "\"Hello\""

#: src/03_ticket_v1/11_destructor.md:21 src/03_ticket_v1/11_destructor.md:55
#: src/03_ticket_v1/11_destructor.md:65
msgid "\"World\""
msgstr "\"World\""

#: src/03_ticket_v1/11_destructor.md:21
msgid "// <-- x's scope starts here...\n"
msgstr "// <-- x's ìŠ¤ì½”í”„ëŠ” ì—¬ê¸°ì„œ ì‹œì‘ë©ë‹ˆë‹¤...\n"

#: src/03_ticket_v1/11_destructor.md:22 src/03_ticket_v1/11_destructor.md:56
#: src/03_ticket_v1/11_destructor.md:66
msgid "\"!\""
msgstr "\"!\""

#: src/03_ticket_v1/11_destructor.md:22
msgid "//   |\n"
msgstr "//   |\n"

#: src/03_ticket_v1/11_destructor.md:23
msgid "//  <-------------- ...and ends here\n"
msgstr "// \\<\\--------------- ...ê·¸ë¦¬ê³  ì—¬ê¸°ì„œ ëë‚©ë‹ˆë‹¤\n"

#: src/03_ticket_v1/11_destructor.md:25
msgid ""
"ownership of the variable is transferred to someone else (e.g. a function or "
"another variable)"
msgstr "ë³€ìˆ˜ì˜ ì†Œìœ ê¶Œì´ ë‹¤ë¥¸ ì‚¬ëŒì—ê²Œ ì´ì „ë  ë•Œ(ì˜ˆ: í•¨ìˆ˜ ë˜ëŠ” ë‹¤ë¥¸ ë³€ìˆ˜)"

#: src/03_ticket_v1/11_destructor.md:28 src/03_ticket_v1/11_destructor.md:78
#: src/03_ticket_v1/11_destructor.md:91
msgid "// Do something [...]\n"
msgstr "// ë­ë“  í•˜ì„¸ìš” [...]\n"

#: src/03_ticket_v1/11_destructor.md:32
msgid "// <-- s's scope starts here...\n"
msgstr "// <-- sì˜ ìŠ¤ì½”í”„ëŠ” ì—¬ê¸°ì„œ ì‹œì‘ë©ë‹ˆë‹¤...\n"

#: src/03_ticket_v1/11_destructor.md:33
msgid "//                    | \n"
msgstr "//                    | \n"

#: src/03_ticket_v1/11_destructor.md:34
msgid "// <------------------- ..and ends here\n"
msgstr "// <------------------- ..ê·¸ë¦¬ê³  ì—¬ê¸°ì„œ ëë‚©ë‹ˆë‹¤\n"

#: src/03_ticket_v1/11_destructor.md:35
msgid "//   because `s` is moved into `compute`\n"
msgstr "//   `s`ê°€ `compute`ë¡œ ì´ë™ë˜ì—ˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤\n"

#: src/03_ticket_v1/11_destructor.md:41
msgid ""
"When the owner of a value goes out of scope, Rust invokes its "
"**destructor**.  \n"
"The destructor tries to clean up the resources used by that valueâ€”in "
"particular, whatever memory it allocated."
msgstr ""
"ê°’ì˜ ì†Œìœ ìê°€ ìŠ¤ì½”í”„ë¥¼ ë²—ì–´ë‚˜ë©´ RustëŠ” í•´ë‹¹ **ì†Œë©¸ì**ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.  \n"
"ì†Œë©¸ìëŠ” í•´ë‹¹ ê°’ì— ì‚¬ìš©ëœ ë¦¬ì†ŒìŠ¤, íŠ¹íˆ í• ë‹¹í•œ ë©”ëª¨ë¦¬ë¥¼ ì •ë¦¬í•˜ë ¤ê³  í•©ë‹ˆë‹¤."

#: src/03_ticket_v1/11_destructor.md:44
msgid ""
"You can manually invoke the destructor of a value by passing it to `std::mem::"
"drop`.  \n"
"That's why you'll often hear Rust developers saying \"that value has been "
"**dropped**\" as a way to state that a value has gone out of scope and its "
"destructor has been invoked."
msgstr ""
"ê°’ì„ `std::mem::drop`ì— ì „ë‹¬í•˜ì—¬ ê°’ì˜ ì†Œë©¸ìë¥¼ ìˆ˜ë™ìœ¼ë¡œ í˜¸ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆ"
"ë‹¤.  \n"
"ì´ê²ƒì´ ë°”ë¡œ Rust ê°œë°œìê°€ ê°’ì´ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ í•´ë‹¹ ì†Œë©¸ìê°€ í˜¸ì¶œë˜ì—ˆìŒì„ ë‚˜íƒ€ë‚´"
"ëŠ” ë°©ë²•ìœ¼ë¡œ \"í•´ë‹¹ ê°’ì´ **ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤**\"ë¼ê³  ë§í•˜ëŠ” ê²ƒì„ ìì£¼ ë“£ê²Œ ë˜ëŠ” ì´"
"ìœ ì…ë‹ˆë‹¤."

#: src/03_ticket_v1/11_destructor.md:48
msgid "Visualizing drop points"
msgstr "ë“œë¡­ í¬ì¸íŠ¸ ì‹œê°í™”"

#: src/03_ticket_v1/11_destructor.md:50
msgid ""
"We can insert explicit calls to `drop` to \"spell out\" what the compiler "
"does for us. Going back to the previous example:"
msgstr ""
"ìš°ë¦¬ëŠ” dropì— ëª…ì‹œì ìœ¼ë¡œ í˜¸ì¶œì„ ì‚½ì…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” ì»´íŒŒì¼ëŸ¬ê°€ ìš°ë¦¬ë¥¼ ìœ„"
"í•´ ìˆ˜í–‰í•˜ëŠ” ì‘ì—…ì„ ëª…í™•í•˜ê²Œ ì„¤ëª…í•´ ì¤ë‹ˆë‹¤. ì´ì „ ì˜ˆì œë¡œ ëŒì•„ê°€ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/03_ticket_v1/11_destructor.md:60
msgid "It's equivalent to:"
msgstr "ì´ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/03_ticket_v1/11_destructor.md:67
msgid "// Variables are dropped in reverse order of declaration\n"
msgstr "// ë³€ìˆ˜ëŠ” ì„ ì–¸ì˜ ì—­ìˆœìœ¼ë¡œ ì‚­ì œë©ë‹ˆë‹¤\n"

#: src/03_ticket_v1/11_destructor.md:74
msgid ""
"Let's look at the second example instead, where `s`'s ownership is "
"transferred to `compute`:"
msgstr "ëŒ€ì‹  `s`ì˜ ì†Œìœ ê¶Œì´ `compute`ë¡œ ì´ì „ë˜ëŠ” ë‘ ë²ˆì§¸ ì˜ˆë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/03_ticket_v1/11_destructor.md:87
msgid "It's equivalent to this:"
msgstr "ì´ëŠ” ë‹¤ìŒê³¼ ë™ì¼í•©ë‹ˆë‹¤:"

#: src/03_ticket_v1/11_destructor.md:92
msgid ""
"// <-- Assuming `t` wasn't dropped or moved \n"
"             //     before this point, the compiler will call \n"
"             //     `drop` here, when it goes out of scope\n"
msgstr ""
"// <-- ì´ ì§€ì  ì´ì „ì— `t`ê°€ ì‚­ì œë˜ê±°ë‚˜ ì´ë™ë˜ì§€ ì•Šì•˜ë‹¤ê³  ê°€ì •í•˜ë©´ \n"
"             //     ì»´íŒŒì¼ëŸ¬ëŠ” ìŠ¤ì½”í”„ë¥¼ ë²—ì–´ë‚  ë•Œ \n"
"             //     ì—¬ê¸°ì—ì„œ `drop`ì„ í˜¸ì¶œí•©ë‹ˆë‹¤.\n"

#: src/03_ticket_v1/11_destructor.md:103
msgid ""
"Notice the difference: even though `s` is no longer valid after `compute` is "
"called in `main`, there is no `drop(s)` in `main`. When you transfer "
"ownership of a value to a function, you're also **transferring the "
"responsibility of cleaning it up**."
msgstr ""
"ì°¨ì´ì ì— ì£¼ëª©í•˜ì‹­ì‹œì˜¤. `main`ì—ì„œ `compute`ì´ í˜¸ì¶œëœ í›„ì— `s`ê°€ ë” ì´ìƒ ìœ íš¨í•˜"
"ì§€ ì•Šë”ë¼ë„ `main`ì—ëŠ” `drop(s)`ì´ ì—†ìŠµë‹ˆë‹¤. ê°’ì˜ ì†Œìœ ê¶Œì„ í•¨ìˆ˜ë¡œ ì´ì „í•˜ë©´ **"
"ê°’ ì •ë¦¬ ì±…ì„**ë„ ì´ì „ë©ë‹ˆë‹¤."

#: src/03_ticket_v1/11_destructor.md:107
msgid ""
"This ensures that the destructor for a value is called **at most[^leak] "
"once**, preventing [double free bugs](https://owasp.org/www-community/"
"vulnerabilities/Doubly_freeing_memory) by design."
msgstr ""
"ì´ë ‡ê²Œ í•˜ë©´ ê°’ì— ëŒ€í•œ ì†Œë©¸ìê°€ **ìµœëŒ€ë¡œ[^leak] í•œ ë²ˆ** í˜¸ì¶œë˜ì–´ ì„¤ê³„ìƒ [ë”ë¸” "
"í”„ë¦¬ ë²„ê·¸](https://owasp.org/www-community/vulnerabilities/"
"Doubly_freeing_memory)ë¥¼ ë°©ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/11_destructor.md:110
msgid "Use after drop"
msgstr "ì‚­ì œ í›„ ì‚¬ìš©"

#: src/03_ticket_v1/11_destructor.md:112
msgid "What happens if you try to use a value after it's been dropped?"
msgstr "ê°’ì´ ì‚­ì œëœ í›„ì— ê°’ì„ ì‚¬ìš©í•˜ë ¤ê³  í•˜ë©´ ì–´ë–»ê²Œ ë ê¹Œìš”?"

#: src/03_ticket_v1/11_destructor.md:117 src/03_ticket_v1/11_destructor.md:128
#: src/06_ticket_management/04_iterators.md:10
#: src/06_ticket_management/04_iterators.md:16
#: src/06_ticket_management/04_iterators.md:31
#: src/06_ticket_management/04_iterators.md:92
#: src/06_ticket_management/04_iterators.md:101
#: src/06_ticket_management/09_impl_trait_2.md:9
#: src/06_ticket_management/09_impl_trait_2.md:23
#: src/08_futures/03_runtime.md:85 src/08_futures/04_future.md:40
#: src/08_futures/04_future.md:131
msgid "\"{}\""
msgstr "\"{}\""

#: src/03_ticket_v1/11_destructor.md:120
msgid "If you try to compile this code, you'll get an error:"
msgstr "ì´ ì½”ë“œë¥¼ ì»´íŒŒì¼í•˜ë ¤ê³  í•˜ë©´ ì˜¤ë¥˜ê°€ ë°œìƒí•©ë‹ˆë‹¤:"

#: src/03_ticket_v1/11_destructor.md:132
msgid ""
"Drop **consumes** the value it's called on, meaning that the value is no "
"longer valid after the call.  \n"
"The compiler will therefore prevent you from using it, avoiding [use-after-"
"free bugs](https://owasp.org/www-community/vulnerabilities/"
"Using_freed_memory)."
msgstr ""
"Dropì€ í˜¸ì¶œëœ ê°’ì„ **ì†Œë¹„**í•©ë‹ˆë‹¤. ì¦‰, í˜¸ì¶œ í›„ì—ëŠ” í•´ë‹¹ ê°’ì´ ë” ì´ìƒ ìœ íš¨í•˜ì§€ "
"ì•ŠìŠµë‹ˆë‹¤.  \n"
"ë”°ë¼ì„œ ì»´íŒŒì¼ëŸ¬ëŠ” ì‚¬ìš©ìê°€ ì´ë¥¼ ì‚¬ìš©í•˜ì§€ ëª»í•˜ê²Œ í•˜ì—¬ [use-after-free ë²„ê·¸]"
"(https://owasp.org/www-community/vulnerabilities/Using_freed_memory)ë¥¼ ë°©ì§€í•©"
"ë‹ˆë‹¤."

#: src/03_ticket_v1/11_destructor.md:135
msgid "Dropping references"
msgstr "ì°¸ì¡° ì‚­ì œ"

#: src/03_ticket_v1/11_destructor.md:137
msgid ""
"What if a variable contains a reference?  \n"
"For example:"
msgstr ""
"ë³€ìˆ˜ì— ì°¸ì¡°ê°€ í¬í•¨ë˜ì–´ ìˆìœ¼ë©´ ì–´ë–»ê²Œ ë˜ë‚˜ìš”?  \n"
"ì˜ˆë¥¼ ë“¤ì–´:"

#: src/03_ticket_v1/11_destructor.md:146
msgid ""
"When you call `drop(y)`... nothing happens.  \n"
"If you actually try to compile this code, you'll get a warning:"
msgstr ""
"`drop(y)`ë¥¼ í˜¸ì¶œí•˜ë©´... ì•„ë¬´ ì¼ë„ ì¼ì–´ë‚˜ì§€ ì•ŠìŠµë‹ˆë‹¤.  \n"
"ì‹¤ì œë¡œ ì´ ì½”ë“œë¥¼ ì»´íŒŒì¼í•˜ë ¤ê³  í•˜ë©´ ë‹¤ìŒê³¼ ê°™ì€ ê²½ê³ ê°€ í‘œì‹œë©ë‹ˆë‹¤:"

#: src/03_ticket_v1/11_destructor.md:161
msgid ""
"It goes back to what we said earlier: we only want to call the destructor "
"once.  \n"
"You can have multiple references to the same valueâ€”if we called the "
"destructor for the value they point at when one of them goes out of scope, "
"what would happen to the others? They would refer to a memory location that's "
"no longer valid: a so-called [**dangling pointer**](https://en.wikipedia.org/"
"wiki/Dangling_pointer), a close relative of [**use-after-free bugs**](https://"
"owasp.org/www-community/vulnerabilities/Using_freed_memory). Rust's ownership "
"system rules out these kinds of bugs by design."
msgstr ""
"ì´ì „ì— ë§í•œ ë‚´ìš©ìœ¼ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤. ì†Œë©¸ìë¥¼ í•œ ë²ˆë§Œ í˜¸ì¶œí•˜ë ¤ê³  í•©ë‹ˆë‹¤.  \n"
"ë™ì¼í•œ ê°’ì— ëŒ€í•œ ì°¸ì¡°ê°€ ì—¬ëŸ¬ ê°œ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ ì¤‘ í•˜ë‚˜ê°€ ë²”ìœ„ë¥¼ ë²—ì–´ë‚  "
"ë•Œ ê°€ë¦¬í‚¤ëŠ” ê°’ì— ëŒ€í•´ ì†Œë©¸ìë¥¼ í˜¸ì¶œí•˜ë©´ ë‹¤ë¥¸ ì°¸ì¡°ì—ëŠ” ì–´ë–¤ ì¼ì´ ë°œìƒí• ê¹Œìš”? ê·¸"
"ë“¤ì€ ë” ì´ìƒ ìœ íš¨í•˜ì§€ ì•Šì€ ë©”ëª¨ë¦¬ ìœ„ì¹˜, ì¦‰ [**use-after-free ë²„ê·¸**](https://"
"owasp.org/www-community/vulnerabilities/Using_freed_memory)ì™€ ê°€ê¹Œìš´ ì¹œì²™ì¸ "
"[**ëŒ•ê¸€ë§ í¬ì¸í„°**](https://en.wikipedia.org/wiki/Dangling_pointer)ë¥¼ ì°¸ì¡°í•©ë‹ˆ"
"ë‹¤. Rustì˜ ì†Œìœ ê¶Œ ì‹œìŠ¤í…œì€ ì„¤ê³„ìƒ ì´ëŸ¬í•œ ì¢…ë¥˜ì˜ ë²„ê·¸ë¥¼ ë°°ì œí•©ë‹ˆë‹¤."

#: src/03_ticket_v1/11_destructor.md:168
msgid ""
"Rust doesn't guarantee that destructors will run. They won't, for example, if "
"you explicitly choose to [leak memory](../07_threads/03_leak.md)."
msgstr ""
"RustëŠ” ì†Œë©¸ìê°€ ì‹¤í–‰ëœë‹¤ëŠ” ê²ƒì„ ë³´ì¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ëª…ì‹œì ìœ¼ë¡œ [ë©”ëª¨"
"ë¦¬ ëˆ„ìˆ˜](../07_threads/03_leak.md)ë¥¼ ì„ íƒí•œ ê²½ìš°ì—ëŠ” ê·¸ë ‡ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/03_ticket_v1/11_destructor.md:173
msgid ""
"The exercise for this section is located in [`03_ticket_v1/11_destructor`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/11_destructor)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`03_ticket_v1/11_destructor`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/11_destructor)ì— ìˆìŠµë‹ˆë‹¤"

#: src/03_ticket_v1/12_outro.md:1 src/04_traits/14_outro.md:1
#: src/05_ticket_v2/15_outro.md:1
msgid "Wrapping up"
msgstr "ë§ˆë¬´ë¦¬"

#: src/03_ticket_v1/12_outro.md:3
msgid ""
"We've covered a lot of foundational Rust concepts in this chapter.  \n"
"Before moving on, let's go through one last exercise to consolidate what "
"we've learned. You'll have minimal guidance this timeâ€”just the exercise "
"description and the tests to guide you."
msgstr ""
"ìš°ë¦¬ëŠ” ì´ë²ˆ ì¥ì—ì„œ Rustì˜ ê¸°ì´ˆ ê°œë…ì„ ë§ì´ ë‹¤ë£¨ì—ˆìŠµë‹ˆë‹¤.  \n"
"ê³„ì† ì§„í–‰í•˜ê¸° ì „ì— ë§ˆì§€ë§‰ ì—°ìŠµì„ í†µí•´ ë°°ìš´ ë‚´ìš©ì„ í†µí•©í•´ ë³´ê² ìŠµë‹ˆë‹¤. ì´ë²ˆì—ëŠ” "
"ìµœì†Œí•œì˜ ì§€ì¹¨ë§Œ ì œê³µë©ë‹ˆë‹¤. ì—°ìŠµ ì„¤ëª…ê³¼ ì•ˆë‚´í•  í…ŒìŠ¤íŠ¸ë§Œ ì œê³µë©ë‹ˆë‹¤."

#: src/03_ticket_v1/12_outro.md:9
msgid ""
"The exercise for this section is located in [`03_ticket_v1/12_outro`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/12_outro)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`03_ticket_v1/12_outro`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/12_outro)ì— ìˆìŠµë‹ˆë‹¤"

#: src/04_traits/00_intro.md:3
msgid ""
"In the previous chapter we covered the basics of Rust's type and ownership "
"system.  \n"
"It's time to dig deeper: we'll explore **traits**, Rust's take on interfaces."
msgstr ""
"ì´ì „ ì¥ì—ì„œ ìš°ë¦¬ëŠ” Rustì˜ ìœ í˜•ê³¼ ì†Œìœ ê¶Œ ì‹œìŠ¤í…œì˜ ê¸°ë³¸ì„ ë‹¤ë£¨ì—ˆìŠµë‹ˆë‹¤.  \n"
"ì´ì œ ë” ê¹Šì´ íŒŒê³ ë“¤ ì‹œê°„ì…ë‹ˆë‹¤. Rustì˜ ì¸í„°í˜ì´ìŠ¤, **Trait**ë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤."

#: src/04_traits/00_intro.md:6
msgid ""
"Once you learn about traits, you'll start seeing their fingerprints all over "
"the place.  \n"
"In fact, you've already seen traits in action throughout the previous "
"chapter, e.g. `.into()` invocations as well as operators like `==` and `+`."
msgstr ""
"íŠ¹ì„±ì— ëŒ€í•´ ë°°ìš°ê³  ë‚˜ë©´ ê³³ê³³ì—ì„œ ê·¸ë“¤ì˜ í”ì ì´ ë³´ì¼ê²ë‹ˆë‹¤.  \n"
"ì‚¬ì‹¤, ì´ì „ ì¥ ì „ì²´ì—ì„œ ì´ë¯¸ íŠ¸ë ˆì‡ì´ ì‘ë™í•˜ëŠ” ê²ƒì„ ë³´ì•˜ìŠµë‹ˆë‹¤. `.into()` í˜¸ì¶œ "
"ë° `==`ë‚˜ `+`ì™€ ê°™ì€ ì—°ì‚°ìë“¤ ë§ì…ë‹ˆë‹¤."

#: src/04_traits/00_intro.md:10
msgid ""
"On top of traits as a concept, we'll also cover some of the key traits that "
"are defined in Rust's standard library:"
msgstr ""
"ê°œë…ìœ¼ë¡œì„œì˜ íŠ¸ë ˆì‡ ì™¸ì—ë„ Rustì˜ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ì •ì˜ëœ ì£¼ìš” íŠ¸ë ˆì‡ ì¤‘ ì¼ë¶€"
"ë„ ë‹¤ë£° ê²ƒì…ë‹ˆë‹¤:"

#: src/04_traits/00_intro.md:12
msgid "Operator traits (e.g. `Add`, `Sub`, `PartialEq`, etc.)"
msgstr "ì—°ì‚°ì íŠ¹ì„±(ì˜ˆ: `Add`, `Sub`, `PartialEq` ë“±)"

#: src/04_traits/00_intro.md:13
msgid "`From` and `Into`, for infallible conversions"
msgstr "`From`ê³¼ `Into`, ì˜¤ë¥˜ ì—†ëŠ” ë³€í™˜ì„ ìœ„í•´"

#: src/04_traits/00_intro.md:14
msgid "`Clone` and `Copy`, for copying values"
msgstr "`Clone`ê³¼ `Copy`, ê°’ ë³µì‚¬ë¥¼ ìœ„í•´"

#: src/04_traits/00_intro.md:15
msgid "`Deref` and deref coercion"
msgstr "`Deref`ì™€ deref ë³€í™˜"

#: src/04_traits/00_intro.md:16
msgid "`Sized`, to mark types with a known size"
msgstr "`Sized`, íƒ€ì…ì˜ í¬ê¸°ê°€ ì •í•´ì¡ŒìŒì„ ë‚˜íƒ€ë‚´ê¸°ìœ„í•´"

#: src/04_traits/00_intro.md:17
msgid "`Drop`, for custom cleanup logic"
msgstr "'Drop', ì»¤ìŠ¤í…€ í´ë¦°ì—… ë¡œì§ì„ ìœ„í•´"

#: src/04_traits/00_intro.md:19
msgid ""
"Since we'll be talking about conversions, we'll seize the opportunity to plug "
"some of the \"knowledge gaps\" from the previous chapterâ€”e.g. what is `\"A "
"title\"`, exactly? Time to learn more about slices too!"
msgstr ""
"ë³€í™˜ì— ê´€í•´ ì´ì•¼ê¸°í•  ê²ƒì´ë¯€ë¡œ ì´ì „ ì¥ì˜ \"ì§€ì‹ ê²©ì°¨\"ë¥¼ ë©”ìš¸ ìˆ˜ ìˆëŠ” ì‹œê°„ì„ ê°€"
"ì§€ê² ìŠµë‹ˆë‹¤. ``ì œëª©''ì´ë€ê²Œ ì •í™•íˆ ë¬´ì—‡ì´ì—ˆë‚˜ìš”? ìŠ¬ë¼ì´ìŠ¤ì— ëŒ€í•´ì„œë„ ìì„¸íˆ ì•Œ"
"ì•„ë³´ê² ìŠµë‹ˆë‹¤!"

#: src/04_traits/00_intro.md:24
msgid ""
"The exercise for this section is located in [`04_traits/00_intro`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/00_intro)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`04_traits/00_intro`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/04_traits/00_intro)ì— ìˆìŠµë‹ˆë‹¤"

#: src/04_traits/01_trait.md:3
msgid "Let's look again at our `Ticket` type:"
msgstr "'Ticket' íƒ€ì…ì„ ë‹¤ì‹œ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤."

#: src/04_traits/01_trait.md:13
msgid ""
"All our tests, so far, have been making assertions using `Ticket`'s fields."
msgstr "ì§€ê¸ˆê¹Œì§€ ìš°ë¦¬ì˜ ëª¨ë“  í…ŒìŠ¤íŠ¸ëŠ” `Ticket`ì˜ í•„ë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ë¹„êµí–ˆìŠµë‹ˆë‹¤."

#: src/04_traits/01_trait.md:16
msgid "\"A new title\""
msgstr "\"A new title\""

#: src/04_traits/01_trait.md:19
msgid "What if we wanted to compare two `Ticket` instances directly?"
msgstr ""
"ë§Œì•½ ë‘ ê°œì˜ `Ticket` ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì§ì ‘ ë¹„êµí•˜ê³  ì‹¶ë‹¤ë©´ ì–´ë–»ê²Œ í•´ì•¼ í• ê¹Œìš”?"

#: src/04_traits/01_trait.md:22 src/04_traits/01_trait.md:23
msgid "/* ... */"
msgstr "/* ... */"

#: src/04_traits/01_trait.md:27
msgid "The compiler will stop us:"
msgstr "ì»´íŒŒì¼ëŸ¬ëŠ” ìš°ë¦¬ë¥¼ ë©ˆì¶œ ê²ƒì…ë‹ˆë‹¤:"

#: src/04_traits/01_trait.md:41
msgid ""
"`Ticket` is a new type. Out of the box, there is **no behavior attached to "
"it**.  \n"
"Rust doesn't magically infer how to compare two `Ticket` instances just "
"because they contain `String`s."
msgstr ""
"`Ticket`ì€ ìƒˆë¡œìš´ ìœ í˜•ì…ë‹ˆë‹¤. ê¸°ë³¸ì ìœ¼ë¡œëŠ” **ì—°ê´€ëœ ë™ì‘ì´ ì—†ìŠµë‹ˆë‹¤**.  \n"
"RustëŠ” ë‹¨ì§€ `String`ì„ í¬í•¨í•˜ê³  ìˆë‹¤ëŠ” ì´ìœ ë§Œìœ¼ë¡œ ë‘ ê°œì˜ `Ticket` ì¸ìŠ¤í„´ìŠ¤ë¥¼ "
"ë¹„êµí•˜ëŠ” ë°©ë²•ì„ ë§ˆë²•ì²˜ëŸ¼ ì¶”ë¡ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/04_traits/01_trait.md:44
msgid ""
"The Rust compiler is nudging us in the right direction though: it's "
"suggesting that we might be missing an implementation of `PartialEq`. "
"`PartialEq` is a **trait**!"
msgstr ""
"Rust ì»´íŒŒì¼ëŸ¬ëŠ” ìš°ë¦¬ë¥¼ ì˜¬ë°”ë¥¸ ë°©í–¥ìœ¼ë¡œ ì¸ë„í•˜ê³  ìˆìŠµë‹ˆë‹¤: ì´ëŠ” `PartialEq` êµ¬"
"í˜„ì´ ëˆ„ë½ë˜ì—ˆì„ ìˆ˜ ìˆìŒì„ ì•Œë ¤ì¤ë‹ˆë‹¤. `PartialEq`ëŠ” **íŠ¸ë ˆì‡**ì…ë‹ˆë‹¤!"

#: src/04_traits/01_trait.md:47
msgid "What are traits?"
msgstr "íŠ¸ë ˆì‡ì´ë€ ë¬´ì—‡ì…ë‹ˆê¹Œ?"

#: src/04_traits/01_trait.md:49
msgid ""
"Traits are Rust's way of defining **interfaces**.  \n"
"A trait defines a set of methods that a type must implement to satisfy the "
"trait's contract."
msgstr ""
"íŠ¸ë ˆì‡ì€ **ì¸í„°í˜ì´ìŠ¤**ë¥¼ ì •ì˜í•˜ëŠ” Rustì˜ ë°©ì‹ì…ë‹ˆë‹¤.  \n"
"íŠ¸ë ˆì‡ì€ íŠ¸ë ˆì‡ì˜ ìš”êµ¬ì‚¬í•­ì„ ì¶©ì¡±í•˜ê¸° ìœ„í•´ íƒ€ì…ì´ êµ¬í˜„í•´ì•¼ í•˜ëŠ” ë©”ì„œë“œ ì§‘í•©ì„ "
"ì •ì˜í•©ë‹ˆë‹¤."

#: src/04_traits/01_trait.md:52
msgid "Defining a trait"
msgstr "íŠ¸ë ˆì‡ ì •ì˜"

#: src/04_traits/01_trait.md:54
msgid "The syntax for a trait definition goes like this:"
msgstr "íŠ¸ë ˆì‡ ì •ì˜ì˜ êµ¬ë¬¸ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤."

#: src/04_traits/01_trait.md:62
msgid ""
"We might, for example, define a trait named `MaybeZero` that requires its "
"implementors to define an `is_zero` method:"
msgstr ""
"ì˜ˆë¥¼ ë“¤ì–´, êµ¬í˜„ìê°€ `is_zero` ë©”ì†Œë“œë¥¼ ì •ì˜í•˜ë„ë¡ ìš”êµ¬í•˜ëŠ” `MaybeZero`ë¼ëŠ” íŠ¸"
"ë ˆì‡ì„ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/04_traits/01_trait.md:70
msgid "Implementing a trait"
msgstr "íŠ¸ë ˆì‡ êµ¬í˜„"

#: src/04_traits/01_trait.md:72
msgid ""
"To implement a trait for a type we use the `impl` keyword, just like we do "
"for regular[^inherent] methods, but the syntax is a bit different:"
msgstr ""
"íƒ€ì…ì— ëŒ€í•œ íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ë ¤ë©´ ì¼ë°˜[^inherent] ë©”ì†Œë“œì—ì„œì™€ ë§ˆì°¬ê°€ì§€ë¡œ "
"`impl` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì§€ë§Œ êµ¬ë¬¸ì€ ì•½ê°„ ë‹¤ë¦…ë‹ˆë‹¤."

#: src/04_traits/01_trait.md:78
msgid "// Method body\n"
msgstr "// ë©”ì„œë“œ ë³¸ë¬¸\n"

#: src/04_traits/01_trait.md:83
msgid ""
"For example, to implement the `MaybeZero` trait for a custom number type, "
"`WrappingU32`:"
msgstr ""
"ì˜ˆë¥¼ ë“¤ì–´, ì‚¬ìš©ì ì •ì˜ ìˆ«ì ìœ í˜• `WrappingU32`ì— ëŒ€í•´ `MaybeZero` íŠ¹ì„±ì„ êµ¬í˜„"
"í•˜ë ¤ë©´ ë‹¤ìŒì„ ìˆ˜í–‰í•˜ì„¸ìš”:"

#: src/04_traits/01_trait.md:97
msgid "Invoking a trait method"
msgstr "íŠ¸ë ˆì‡ ë©”ì„œë“œ í˜¸ì¶œ"

#: src/04_traits/01_trait.md:99
msgid ""
"To invoke a trait method, we use the `.` operator, just like we do with "
"regular methods:"
msgstr ""
"íŠ¸ë ˆì‡ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ë ¤ë©´ ì¼ë°˜ ë©”ì„œë“œì™€ ë§ˆì°¬ê°€ì§€ë¡œ `.` ì—°ì‚°ìë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤:"

#: src/04_traits/01_trait.md:106
msgid "To invoke a trait method, two things must be true:"
msgstr "íŠ¸ë ˆì‡ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ë ¤ë©´ ë‹¤ìŒ ë‘ ê°€ì§€ ì‚¬í•­ì´ ì¶©ì¡±ë˜ì–´ì•¼ í•©ë‹ˆë‹¤:"

#: src/04_traits/01_trait.md:108
msgid "The type must implement the trait."
msgstr "íƒ€ì…ì€ íŠ¸ë ˆì‡ì„ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/04_traits/01_trait.md:109
msgid "The trait must be in scope."
msgstr "íŠ¸ë ˆì‡ì€ ìŠ¤ì½”í”„ ë‚´ì— ìˆì–´ì•¼ í•©ë‹ˆë‹¤."

#: src/04_traits/01_trait.md:111
msgid ""
"To satisfy the latter, you may have to add a `use` statement for the trait:"
msgstr "í›„ìë¥¼ ë§Œì¡±ì‹œí‚¤ë ¤ë©´ í•´ë‹¹ íŠ¹ì„±ì— `use` ë¬¸ì„ ì¶”ê°€í•´ì•¼ í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤:"

#: src/04_traits/01_trait.md:117
msgid "This is not necessary if:"
msgstr "ë‹¤ìŒê³¼ ê°™ì€ ê²½ìš°ì—ëŠ” í•„ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤:"

#: src/04_traits/01_trait.md:119
msgid "The trait is defined in the same module where the invocation occurs."
msgstr "íŠ¸ë ˆì‡ì´ í˜¸ì¶œì´ ë°œìƒí•˜ëŠ” ë™ì¼í•œ ëª¨ë“ˆì—ì„œ ì •ì˜ë  ë•Œ."

#: src/04_traits/01_trait.md:120
msgid ""
"The trait is defined in the standard library's **prelude**. The prelude is a "
"set of traits and types that are automatically imported into every Rust "
"program. It's as if `use std::prelude::*;` was added at the beginning of "
"every Rust module."
msgstr ""
"íŠ¸ë ˆì‡ì´ **prelude**ì— ì •ì˜ë˜ì–´ìˆì„ ë•Œ. í”„ë ë¥˜ë“œëŠ” ëª¨ë“  ëŸ¬ìŠ¤íŠ¸ í”„ë¡œê·¸ë¨ì— ìë™"
"ìœ¼ë¡œ ì„í¬íŠ¸ë˜ëŠ” íŠ¸ë ˆì‡ê³¼ íƒ€ì…ì˜ ì§‘í•©ì…ë‹ˆë‹¤. ë§ˆì¹˜ ëª¨ë“  ëŸ¬ìŠ¤íŠ¸ ëª¨ë“ˆì˜ ì‹œì‘ ë¶€ë¶„"
"ì— `use std::prelude::*;`ê°€ ì¶”ê°€ëœ ê²ƒê³¼ ê°™ìŠµë‹ˆë‹¤."

#: src/04_traits/01_trait.md:124
msgid ""
"You can find the list of traits and types in the prelude in the [Rust "
"documentation](https://doc.rust-lang.org/std/prelude/index.html)."
msgstr ""
"[Rust ë¬¸ì„œ](https://doc.rust-lang.org/std/prelude/index.html)ì˜ í”„ë ë¥˜ë“œ ë¶€ë¶„"
"ì—ì„œ íŠ¸ë ˆì‡ê³¼ íƒ€ì…ë“¤ì„ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/04_traits/01_trait.md:127
msgid ""
"A method defined directly on a type, without using a trait, is also known as "
"an **inherent method**."
msgstr ""
"íŠ¸ë ˆì‡ì„ ì‚¬ìš©í•˜ì§€ ì•Šê³  íƒ€ì…ì— ì§ì ‘ ì •ì˜ëœ ë©”ì„œë“œë¥¼ **ê³ ìœ  ë©”ì„œë“œ**ë¼ê³ ë„ í•©ë‹ˆ"
"ë‹¤."

#: src/04_traits/01_trait.md:131
msgid ""
"The exercise for this section is located in [`04_traits/01_trait`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/01_trait)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`04_traits/01_trait`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/04_traits/01_trait)ì— ìˆìŠµë‹ˆë‹¤"

#: src/04_traits/02_orphan_rule.md:1
msgid "Implementing traits"
msgstr "íŠ¸ë ˆì‡ êµ¬í˜„"

#: src/04_traits/02_orphan_rule.md:3
msgid ""
"When a type is defined in another crate (e.g. `u32`, from Rust's standard "
"library), you can't directly define new methods for it. If you try:"
msgstr ""
"ìœ í˜•ì´ ë‹¤ë¥¸ í¬ë ˆì´íŠ¸(ì˜ˆ: Rust í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ `u32`)ì— ì •ì˜ë˜ë©´ í•´ë‹¹ ìœ í˜•ì— "
"ëŒ€í•œ ìƒˆ ë©”ì„œë“œë¥¼ ì§ì ‘ ì •ì˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë‹¤ìŒì˜ ê²½ìš°:"

#: src/04_traits/02_orphan_rule.md:14 src/05_ticket_v2/02_match.md:43
msgid "the compiler will complain:"
msgstr "ì»´íŒŒì¼ëŸ¬ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ë¶ˆí‰í•  ê²ƒì…ë‹ˆë‹¤:"

#: src/04_traits/02_orphan_rule.md:25
msgid "Extension trait"
msgstr "í™•ì¥ íŠ¸ë ˆì‡"

#: src/04_traits/02_orphan_rule.md:27
msgid ""
"An **extension trait** is a trait whose primary purpose is to attach new "
"methods to foreign types, such as `u32`. That's exactly the pattern you "
"deployed in the previous exercise, by defining the `IsEven` trait and then "
"implementing it for `i32` and `u32`. You are then free to call `is_even` on "
"those types as long as `IsEven` is in scope."
msgstr ""
"**í™•ì¥ íŠ¸ë ˆì‡**ì€ `u32`ì™€ ê°™ì€ ì™¸ë¶€ íƒ€ì…ì— ìƒˆë¡œìš´ ë©”ì†Œë“œë¥¼ ì¶”ê°€í•˜ê¸°ìœ„í•œ íŠ¸ë ˆì‡"
"ì…ë‹ˆë‹¤. ì´ê²ƒì´ ë°”ë¡œ ì´ì „ ì˜ˆì œì—ì„œ `IsEven` íŠ¸ë ˆì‡ì„ ì •ì˜í•œ ë‹¤ìŒ `i32` ë° `u32`"
"ì— ëŒ€í•´ êµ¬í˜„í•˜ì—¬ ë°°í¬í•œ íŒ¨í„´ì…ë‹ˆë‹¤. ê·¸ëŸ¬ë©´ `IsEven`ì´ ìŠ¤ì½”í”„ ë‚´ì— ìˆëŠ” í•œ íƒ€ì…"
"ì— ëŒ€í•´ `is_even`ì„ ììœ ë¡­ê²Œ í˜¸ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/04_traits/02_orphan_rule.md:34
msgid "// Bring the trait in scope\n"
msgstr "// íŠ¸ë ˆì‡ì„ ìŠ¤ì½”í”„ë¡œ ê°€ì ¸ì˜µë‹ˆë‹¤\n"

#: src/04_traits/02_orphan_rule.md:38
msgid "// Invoke its method on a type that implements it\n"
msgstr "// ì´ë¥¼ êµ¬í˜„í•˜ëŠ” íƒ€ì…ì—ì„œ í•´ë‹¹ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.\n"

#: src/04_traits/02_orphan_rule.md:45
msgid "One implementation"
msgstr "í•˜ë‚˜ì˜ êµ¬í˜„"

#: src/04_traits/02_orphan_rule.md:47
msgid ""
"There are limitations to the trait implementations you can write.  \n"
"The simplest and most straight-forward one: you can't implement the same "
"trait twice, in a crate, for the same type."
msgstr ""
"íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ëŠ”ë°ì—ëŠ” ì œì•½ì‚¬í•­ì´ ìˆìŠµë‹ˆë‹¤.  \n"
"ê°€ì¥ ê°„ë‹¨í•˜ê³  ë‹¨ìˆœí•œ ê²ƒì€ ë™ì¼í•œ íƒ€ì…ì— ëŒ€í•´ í¬ë ˆì´íŠ¸ì—ì„œ ë™ì¼í•œ íŠ¸ë ˆì‡ì„ ë‘ "
"ë²ˆ êµ¬í˜„í•  ìˆ˜ ì—†ë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/04_traits/02_orphan_rule.md:71
msgid "The compiler will reject it:"
msgstr "ì»´íŒŒì¼ëŸ¬ëŠ” ì´ë¥¼ ê±°ë¶€í•©ë‹ˆë‹¤:"

#: src/04_traits/02_orphan_rule.md:83
msgid ""
"There can be no ambiguity as to what trait implementation should be used when "
"`IsEven::is_even` is invoked on a `u32` value, therefore there can only be "
"one."
msgstr ""
"`IsEven::is_even`ì´ `u32` ê°’ì— ëŒ€í•´ í˜¸ì¶œë  ë•Œ ì–´ë–¤ íŠ¸ë ˆì‡ êµ¬í˜„ì„ ì‚¬ìš©í•´ì•¼ í•˜ëŠ”"
"ì§€ì— ëª¨í˜¸í•˜ê¸°ë•Œë¬¸ì— íŠ¸ë ˆì‡ êµ¬í˜„ì€ í•˜ë‚˜ë§Œ ìˆì–´ì•¼í•©ë‹ˆë‹¤."

#: src/04_traits/02_orphan_rule.md:88
msgid ""
"Things get more nuanced when multiple crates are involved. In particular, at "
"least one of the following must be true:"
msgstr ""
"ì—¬ëŸ¬ í¬ë ˆì´íŠ¸ê°€ ê´€ë ¨ë˜ë©´ ìƒí™©ì´ ë”ìš± ë¯¸ë¬˜í•´ì§‘ë‹ˆë‹¤. íŠ¹íˆ ë‹¤ìŒ ì¤‘ í•˜ë‚˜ ì´ìƒì´ ì¶©"
"ì¡±ë˜ì–´ì•¼ í•©ë‹ˆë‹¤:"

#: src/04_traits/02_orphan_rule.md:91
msgid "The trait is defined in the current crate"
msgstr "íŠ¸ë ˆì‡ì€ í˜„ì¬ í¬ë ˆì´íŠ¸ì— ì •ì˜ë˜ì–´ìˆì–´ì•¼í•©ë‹ˆë‹¤"

#: src/04_traits/02_orphan_rule.md:92
msgid "The implementor type is defined in the current crate"
msgstr "íƒ€ì…ì˜ êµ¬í˜„ì€ í˜„ì¬ í¬ë ˆì´íŠ¸ì—ì„œ ì •ì˜ë˜ì–´ì•¼í•©ë‹ˆë‹¤."

#: src/04_traits/02_orphan_rule.md:94
msgid ""
"This is known as Rust's **orphan rule**. Its goal is to make the method "
"resolution process unambiguous."
msgstr ""
"ì´ê²ƒì€ Rustì˜ **ê³ ì•„ ê·œì¹™**ìœ¼ë¡œ ì•Œë ¤ì ¸ ìˆìŠµë‹ˆë‹¤. ì´ ê·œì¹™ì˜ ëª©ì ì€ ë§¤ì„œë“œ í•´ì„ "
"ê³¼ì •ì„ ëª…í™•í•˜ê²Œ ë§Œë“œëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/04_traits/02_orphan_rule.md:97
msgid "Imagine the following situation:"
msgstr "ë‹¤ìŒ ìƒí™©ì„ ìƒìƒí•´ ë³´ì„¸ìš”:"

#: src/04_traits/02_orphan_rule.md:99
msgid "Crate `A` defines the `IsEven` trait"
msgstr "`A` í¬ë ˆì´íŠ¸ëŠ” `IsEven` íŠ¸ë ˆì‡ì„ ì •ì˜í•©ë‹ˆë‹¤"

#: src/04_traits/02_orphan_rule.md:100
msgid "Crate `B` implements `IsEven` for `u32`"
msgstr "`B` í¬ë ˆì´íŠ¸ëŠ” `u32`ì— ëŒ€í•´ `IsEven`ì„ êµ¬í˜„í•©ë‹ˆë‹¤"

#: src/04_traits/02_orphan_rule.md:101
msgid ""
"Crate `C` provides a (different) implementation of the `IsEven` trait for "
"`u32`"
msgstr "`C` í¬ë ˆì´íŠ¸ëŠ” `u32`ì— ëŒ€í•œ `IsEven` íŠ¸ë ˆì‡ì˜ (ë‹¤ë¥¸) êµ¬í˜„ì„ ì œê³µí•©ë‹ˆë‹¤"

#: src/04_traits/02_orphan_rule.md:102
msgid "Crate `D` depends on both `B` and `C` and calls `1.is_even()`"
msgstr "í¬ë ˆì´íŠ¸ `D`ëŠ” `B`ì™€ `C` ëª¨ë‘ì— ì˜ì¡´í•˜ë©° `1.is_even()`ì„ í˜¸ì¶œí•©ë‹ˆë‹¤"

#: src/04_traits/02_orphan_rule.md:104
msgid ""
"Which implementation should be used? The one defined in `B`? Or the one "
"defined in `C`?  \n"
"There's no good answer, therefore the orphan rule was defined to prevent this "
"scenario. Thanks to the orphan rule, neither crate `B` nor crate `C` would "
"compile."
msgstr ""
"ì–´ë–¤ êµ¬í˜„ì„ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆê¹Œ? `B`ì— ì •ì˜ëœ ê²ƒ? ì•„ë‹ˆë©´ `C`ì— ì •ì˜ëœ ê²ƒì¸ê°€"
"ìš”?  \n"
"ì •ë‹µì´ ì—†ìœ¼ë¯€ë¡œ ì´ ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´ ê³ ì•„ ê·œì¹™ì´ ì •ì˜ë˜ì—ˆìŠµë‹ˆë‹¤. ê³ ì•„ "
"ê·œì¹™ ë•ë¶„ì— `B` ìƒìë‚˜ `C` ìƒìëŠ” ëª¨ë‘ ì»´íŒŒì¼ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/04_traits/02_orphan_rule.md:110
msgid ""
"There are some caveats and exceptions to the orphan rule as stated above. "
"Check out [the reference](https://doc.rust-lang.org/reference/items/"
"implementations.html#trait-implementation-coherence) if you want to get "
"familiar with its nuances."
msgstr ""
"ìœ„ì—ì„œ ì„¤ëª…í•œ ëŒ€ë¡œ ê³ ì•„ ê·œì¹™ì—ëŠ” ëª‡ ê°€ì§€ ì£¼ì˜ ì‚¬í•­ê³¼ ì˜ˆì™¸ê°€ ìˆìŠµë‹ˆë‹¤. ê·¸ ë‰˜ì•™"
"ìŠ¤ì— ìµìˆ™í•´ì§€ê³  ì‹¶ë‹¤ë©´ [ì°¸ê³  ìë£Œ]((https://doc.rust-lang.org/reference/items/"
"implementations.html#trait-implementation-coherence))ë¥¼ í™•ì¸í•˜ì„¸ìš”."

#: src/04_traits/02_orphan_rule.md:116
msgid ""
"The exercise for this section is located in [`04_traits/02_orphan_rule`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/02_orphan_rule)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`04_traits/02_orphan_rule`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/02_orphan_rule)ì— ìˆìŠµë‹ˆë‹¤"

#: src/04_traits/03_operator_overloading.md:3
msgid ""
"Now that we have a basic understanding of what traits are, let's circle back "
"to **operator overloading**. Operator overloading is the ability to define "
"custom behavior for operators like `+`, `-`, `*`, `/`, `==`, `!=`, etc."
msgstr ""
"ì´ì œ íŠ¹ì„±ì´ ë¬´ì—‡ì¸ì§€ ê¸°ë³¸ì ìœ¼ë¡œ ì´í•´í–ˆìœ¼ë¯€ë¡œ **ì—°ì‚°ì ì˜¤ë²„ë¡œë”©**ìœ¼ë¡œ ëŒì•„ê°€ ë³´"
"ê² ìŠµë‹ˆë‹¤. ì—°ì‚°ì ì˜¤ë²„ë¡œë”©ì€ `+`, `-`, `*`, `/`, `==`, `!=` ë“±ê³¼ ê°™ì€ ì—°ì‚°ìì— "
"ëŒ€í•œ ì‚¬ìš©ì ì •ì˜ ë™ì‘ì„ ì •ì˜í•˜ëŠ” ê¸°ëŠ¥ì…ë‹ˆë‹¤."

#: src/04_traits/03_operator_overloading.md:6
msgid "Operators are traits"
msgstr "ì—°ì‚°ìëŠ” íŠ¸ë ˆì‡ì…ë‹ˆë‹¤"

#: src/04_traits/03_operator_overloading.md:8
msgid ""
"In Rust, operators are traits.  \n"
"For each operator, there is a corresponding trait that defines the behavior "
"of that operator. By implementing that trait for your type, you **unlock** "
"the usage of the corresponding operators."
msgstr ""
"Rustì—ì„œ ì—°ì‚°ìëŠ” íŠ¸ë ˆì‡ì…ë‹ˆë‹¤.  \n"
"ê° ì—°ì‚°ìì—ëŠ” í•´ë‹¹ ì—°ì‚°ìì˜ ë™ì‘ì„ ì •ì˜í•˜ëŠ” í•´ë‹¹ íŠ¸ë ˆì‡ì´ ìˆìŠµë‹ˆë‹¤. íƒ€ì…ì— í•´"
"ë‹¹ íŠ¸ë ˆì‡ì„ êµ¬í˜„í•¨ìœ¼ë¡œì¨ í•´ë‹¹ ì—°ì‚°ìì˜ ì‚¬ìš©ì„ **ì ê¸ˆ í•´ì œ**í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/04_traits/03_operator_overloading.md:12
msgid ""
"For example, the [`PartialEq` trait](https://doc.rust-lang.org/std/cmp/trait."
"PartialEq.html) defines the behavior of the `==` and `!=` operators:"
msgstr ""
"ì˜ˆë¥¼ ë“¤ì–´ [`PartialEq` trait](https://doc.rust-lang.org/std/cmp/trait."
"PartialEq.html) íŠ¹ì„±ì€ `==`ì™€ `!=` ì—°ì‚°ìì˜ ë™ì‘ì„ ì •ì˜í•©ë‹ˆë‹¤:"

#: src/04_traits/03_operator_overloading.md:16
msgid ""
"// The `PartialEq` trait definition, from Rust's standard library\n"
"// (It is *slightly* simplified, for now)\n"
msgstr ""
"// Rustì˜ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ìˆëŠ” `PartialEq` íŠ¹ì„± ì •ì˜\n"
"// (ì§€ê¸ˆì€ _ì•½ê°„_ ë‹¨ìˆœí™”ë˜ì—ˆìŠµë‹ˆë‹¤)\n"

#: src/04_traits/03_operator_overloading.md:19
msgid ""
"// Required method\n"
"    //\n"
"    // `Self` is a Rust keyword that stands for \n"
"    // \"the type that is implementing the trait\"\n"
msgstr ""
"// í•„ìˆ˜ ë©”ì„œë“œ\n"
"    //\n"
"    // `Self`ëŠ” \"íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ëŠ” íƒ€ì…\"ì„\n"
"    // ì˜ë¯¸í•˜ëŠ” Rust í‚¤ì›Œë“œì…ë‹ˆë‹¤\n"

#: src/04_traits/03_operator_overloading.md:25
msgid "// Provided method\n"
msgstr "// ì œê³µë˜ëŠ” ë©”ì„œë“œ\n"

#: src/04_traits/03_operator_overloading.md:30
msgid ""
"When you write `x == y` the compiler will look for an implementation of the "
"`PartialEq` trait for the types of `x` and `y` and replace `x == y` with `x."
"eq(y)`. It's syntactic sugar!"
msgstr ""
"`x == y`ë¥¼ ì‘ì„±í•˜ë©´ ì»´íŒŒì¼ëŸ¬ëŠ” `x` ë° `y` íƒ€ì…ì— ëŒ€í•œ `PartialEq` íŠ¸ë ˆì‡ì˜ êµ¬"
"í˜„ì„ ì°¾ê³  `x == y`ë¥¼ `x.eq(y)`ë¡œ ëŒ€ì²´í•©ë‹ˆë‹¤. ì´ëŠ” ë¬¸ë²•ì  ì„¤íƒ•(syntactic sugar)"
"ì…ë‹ˆë‹¤!"

#: src/04_traits/03_operator_overloading.md:33
msgid "This is the correspondence for the main operators:"
msgstr "ì£¼ìš” ì—°ì‚°ìì— ëŒ€í•œ íŠ¸ë ˆì‡ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/04_traits/03_operator_overloading.md:35
msgid "Operator"
msgstr "ì—°ì‚°ì"

#: src/04_traits/03_operator_overloading.md:37
msgid "`+`"
msgstr "`+`"

#: src/04_traits/03_operator_overloading.md:37
msgid "[`Add`](https://doc.rust-lang.org/std/ops/trait.Add.html)"
msgstr "[`Add`](https://doc.rust-lang.org/std/ops/trait.Add.html)"

#: src/04_traits/03_operator_overloading.md:38
msgid "`-`"
msgstr "`-`"

#: src/04_traits/03_operator_overloading.md:38
msgid "[`Sub`](https://doc.rust-lang.org/std/ops/trait.Sub.html)"
msgstr "[`Sub`](https://doc.rust-lang.org/std/ops/trait.Sub.html)"

#: src/04_traits/03_operator_overloading.md:39
msgid "`*`"
msgstr "`*`"

#: src/04_traits/03_operator_overloading.md:39
msgid "[`Mul`](https://doc.rust-lang.org/std/ops/trait.Mul.html)"
msgstr "[`Mul`](https://doc.rust-lang.org/std/ops/trait.Mul.html)"

#: src/04_traits/03_operator_overloading.md:40
msgid "`/`"
msgstr "`/`"

#: src/04_traits/03_operator_overloading.md:40
msgid "[`Div`](https://doc.rust-lang.org/std/ops/trait.Div.html)"
msgstr "[`Div`](https://doc.rust-lang.org/std/ops/trait.Div.html)"

#: src/04_traits/03_operator_overloading.md:41
msgid "`%`"
msgstr "`%`"

#: src/04_traits/03_operator_overloading.md:41
msgid "[`Rem`](https://doc.rust-lang.org/std/ops/trait.Rem.html)"
msgstr "[`Rem`](https://doc.rust-lang.org/std/ops/trait.Rem.html)"

#: src/04_traits/03_operator_overloading.md:42
msgid "`==` and `!=`"
msgstr "`==`ì™€ `!=`"

#: src/04_traits/03_operator_overloading.md:42
msgid "[`PartialEq`](https://doc.rust-lang.org/std/cmp/trait.PartialEq.html)"
msgstr "[`PartialEq`](https://doc.rust-lang.org/std/cmp/trait.PartialEq.html)"

#: src/04_traits/03_operator_overloading.md:43
msgid "`<`, `>`, `<=`, and `>=`"
msgstr "`<`, `>`, `<=` ê·¸ë¦¬ê³  `>=`"

#: src/04_traits/03_operator_overloading.md:43
msgid "[`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html)"
msgstr "[`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html)"

#: src/04_traits/03_operator_overloading.md:45
msgid ""
"Arithmetic operators live in the [`std::ops`](https://doc.rust-lang.org/std/"
"ops/index.html) module, while comparison ones live in the [`std::cmp`]"
"(https://doc.rust-lang.org/std/cmp/index.html) module."
msgstr ""
"ì‚°ìˆ  ì—°ì‚°ìëŠ” [`std::ops`](https://doc.rust-lang.org/std/ops/index.html) ëª¨ë“ˆ"
"ì— ìˆê³ , ë¹„êµ ì—°ì‚°ìëŠ” [`std::cmp`](https://doc.rust-lang.org/std/cmp/index."
"html) ëª¨ë“ˆì— ìˆìŠµë‹ˆë‹¤."

#: src/04_traits/03_operator_overloading.md:48
msgid "Default implementations"
msgstr "ê¸°ë³¸ êµ¬í˜„"

#: src/04_traits/03_operator_overloading.md:50
msgid ""
"The comment on `PartialEq::ne` states that \"`ne` is a provided method\".  \n"
"It means that `PartialEq` provides a **default implementation** for `ne` in "
"the trait definitionâ€”the `{ ... }` elided block in the definition snippet.  \n"
"If we expand the elided block, it looks like this:"
msgstr ""
"`PartialEq::ne`ì— ëŒ€í•œ ì£¼ì„ì—ëŠ” \"`ne`ì´ ì œê³µë˜ëŠ” ë©”ì„œë“œì…ë‹ˆë‹¤\"ë¼ê³  ëª…ì‹œë˜ì–´ "
"ìˆìŠµë‹ˆë‹¤.  \n"
"ì´ëŠ” `PartialEq`ê°€ íŠ¹ì„± ì •ì˜ì˜ `ne`ì— ëŒ€í•œ **ê¸°ë³¸ êµ¬í˜„**ì„ ì œê³µí•œë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆ"
"ë‹¤(ì •ì˜ ì¡°ê°ì—ì„œ ìƒëµëœ `{ ... }` ë¸”ë¡).  \n"
"ìƒëµëœ ë¸”ë¡ì„ í™•ì¥í•˜ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤."

#: src/04_traits/03_operator_overloading.md:65
msgid ""
"It's what you expect: `ne` is the negation of `eq`.  \n"
"Since a default implementation is provided, you can skip implementing `ne` "
"when you implement `PartialEq` for your type. It's enough to implement `eq`:"
msgstr ""
"ì˜ˆìƒí•œ ëŒ€ë¡œì…ë‹ˆë‹¤. 'ne'ì€ 'eq'ì˜ ë¶€ì •ì…ë‹ˆë‹¤.  \n"
"ê¸°ë³¸ êµ¬í˜„ì´ ì œê³µë˜ë¯€ë¡œ ìœ í˜•ì— ëŒ€í•´ `PartialEq`ë¥¼ êµ¬í˜„í•  ë•Œ `ne` êµ¬í˜„ì„ ê±´ë„ˆë›¸ "
"ìˆ˜ ìˆìŠµë‹ˆë‹¤. `eq`ë¥¼ êµ¬í˜„í•˜ëŠ” ê²ƒìœ¼ë¡œ ì¶©ë¶„í•©ë‹ˆë‹¤:"

#: src/04_traits/03_operator_overloading.md:79
msgid "// No `ne` implementation here\n"
msgstr "// ì—¬ê¸°ì—ëŠ” `ne` êµ¬í˜„ì´ ì—†ìŠµë‹ˆë‹¤\n"

#: src/04_traits/03_operator_overloading.md:83
msgid ""
"You are not forced to use the default implementation though. You can choose "
"to override it when you implement the trait:"
msgstr ""
"í•˜ì§€ë§Œ ë¬´ì¡°ê±´ ê¸°ë³¸ êµ¬í˜„ì„ ì‚¬ìš©í•´ì•¼ í•˜ëŠ” ê²ƒì€ ì•„ë‹™ë‹ˆë‹¤. íŠ¸ë ˆì‡ì„ êµ¬í˜„í•  ë•Œ ì´"
"ë¥¼ ì¬ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/04_traits/03_operator_overloading.md:91
#: src/04_traits/03_operator_overloading.md:95
msgid "// Custom implementation\n"
msgstr "// ì‚¬ìš©ì ì •ì˜ êµ¬í˜„\n"

#: src/04_traits/03_operator_overloading.md:102
msgid ""
"The exercise for this section is located in "
"[`04_traits/03_operator_overloading`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/04_traits/03_operator_overloading)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`04_traits/03_operator_overloading`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/03_operator_overloading)ì— ìˆìŠµë‹ˆë‹¤"

#: src/04_traits/04_derive.md:3
msgid ""
"Implementing `PartialEq` for `Ticket` was a bit tedious, wasn't it? You had "
"to manually compare each field of the struct."
msgstr ""
"`Ticket`ì— ëŒ€í•´ `PartialEq`ë¥¼ êµ¬í˜„í•˜ëŠ” ê²ƒì€ ì•½ê°„ ì§€ë£¨í•œ ì¼ì´ì—ˆì£ , ê·¸ë ‡ì£ ? êµ¬ì¡°"
"ì²´ì˜ ê° í•„ë“œë¥¼ ìˆ˜ë™ìœ¼ë¡œ ë¹„êµí•´ì•¼ í–ˆìŠµë‹ˆë‹¤."

#: src/04_traits/04_derive.md:6
msgid "Destructuring syntax"
msgstr "êµ¬ì¡° ë¶„í•´ êµ¬ë¬¸"

#: src/04_traits/04_derive.md:8
msgid ""
"Furthermore, the implementation is brittle: if the struct definition changes "
"(e.g. a new field is added), you have to remember to update the `PartialEq` "
"implementation."
msgstr ""
"êµ¬í˜„ì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. êµ¬ì¡°ì²´ ì •ì˜ê°€ ë³€ê²½ë˜ë©´(ì˜ˆ: ìƒˆ í•„ë“œê°€ ì¶”ê°€ë˜ëŠ” ê²½ìš°) "
"`PartialEq` êµ¬í˜„ì„ ì—…ë°ì´íŠ¸í•´ì¤˜ì•¼í•©ë‹ˆë‹¤."

#: src/04_traits/04_derive.md:11
msgid ""
"You can mitigate the risk by **destructuring** the struct into its fields:"
msgstr "êµ¬ì¡°ì²´ë¥¼ í•´ë‹¹ í•„ë“œë¡œ **êµ¬ì¡° ë¶„í•´**í•˜ì—¬ ìœ„í—˜ì„ ì¤„ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/04_traits/04_derive.md:26
msgid ""
"If the definition of `Ticket` changes, the compiler will error out, "
"complaining that your destructuring is no longer exhaustive.  \n"
"You can also rename struct fields, to avoid variable shadowing:"
msgstr ""
"`Ticket`ì˜ ì •ì˜ê°€ ë³€ê²½ë˜ë©´ ì»´íŒŒì¼ëŸ¬ëŠ” êµ¬ì¡° ë¶„í•´ê°€ ë” ì´ìƒ ì™„ì „í•˜ì§€ ì•Šë‹¤ê³  ë¶ˆí‰"
"í•˜ë©´ì„œ ì˜¤ë¥˜ë¥¼ ë°œìƒì‹œí‚µë‹ˆë‹¤.  \n"
"ë³€ìˆ˜ ì„€ë„ì‰ì„ ë°©ì§€í•˜ê¸° ìœ„í•´ êµ¬ì¡°ì²´ í•„ë“œì˜ ì´ë¦„ì„ ë°”ê¿€ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤:"

#: src/04_traits/04_derive.md:48
msgid ""
"Destructuring is a useful pattern to have in your toolkit, but there's an "
"even more convenient way to do this: **derive macros**."
msgstr ""
"êµ¬ì¡° ë¶„í•´ëŠ” ìì£¼ ì“¸ ìˆ˜ ìˆëŠ” ìœ ìš©í•œ íŒ¨í„´ì´ì§€ë§Œ ì´ ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” í›¨ì”¬ ë” í¸ë¦¬"
"í•œ ë°©ë²•ì´ ìˆìŠµë‹ˆë‹¤: **íŒŒìƒ ë§¤í¬ë¡œ**."

#: src/04_traits/04_derive.md:51
msgid "Macros"
msgstr "ë§¤í¬ë¡œ"

#: src/04_traits/04_derive.md:53
msgid "You've already encountered a few macros in past exercises:"
msgstr "ì§€ë‚œ ì˜ˆì œì—ì„œ ì´ë¯¸ ëª‡ ê°€ì§€ ë§¤í¬ë¡œë¥¼ ì ‘í–ˆìŠµë‹ˆë‹¤:"

#: src/04_traits/04_derive.md:55
msgid "`assert_eq!` and `assert!`, in the test cases"
msgstr "í…ŒìŠ¤íŠ¸ì—ëŠ” `assert_eq!`ì™€ `assert!`"

#: src/04_traits/04_derive.md:56
msgid "`println!`, to print to the console"
msgstr "`println!`, ì½˜ì†”ì— í”„ë¦°íŠ¸ í•  ë•Œ"

#: src/04_traits/04_derive.md:58
msgid ""
"Rust macros are **code generators**.  \n"
"They generate new Rust code based on the input you provide, and that "
"generated code is then compiled alongside the rest of your program. Some "
"macros are built into Rust's standard library, but you can also write your "
"own. We won't be creating our own macro in this course, but you can find some "
"useful pointers in the [\"Further reading\" section](#further-reading)."
msgstr ""
"Rust ë§¤í¬ë¡œëŠ” **ì½”ë“œ ìƒì„±ê¸°**ì…ë‹ˆë‹¤.  \n"
"ê·¸ë“¤ì€ ì—¬ëŸ¬ë¶„ì´ ì œê³µí•œ ì…ë ¥ì„ ê¸°ë°˜ìœ¼ë¡œ ìƒˆë¡œìš´ Rust ì½”ë“œë¥¼ ìƒì„±í•˜ê³ , ìƒì„±ëœ ì½”"
"ë“œëŠ” í”„ë¡œê·¸ë¨ì˜ ë‚˜ë¨¸ì§€ ë¶€ë¶„ê³¼ í•¨ê»˜ ì»´íŒŒì¼ë©ë‹ˆë‹¤. ì¼ë¶€ ë§¤í¬ë¡œëŠ” Rustì˜ í‘œì¤€ ë¼"
"ì´ë¸ŒëŸ¬ë¦¬ì— ë‚´ì¥ë˜ì–´ ìˆì§€ë§Œ ì§ì ‘ ì‘ì„±í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ì´ ê³¼ì •ì—ì„œëŠ” ìì²´ ë§¤í¬"
"ë¡œë¥¼ ìƒì„±í•˜ì§€ ì•Šì§€ë§Œ [\"ì½ì„ê±°ë¦¬\" section](#further-reading)ì„¹ì…˜ì—ì„œ ëª‡ ê°€ì§€ "
"ìœ ìš©í•œ ì§€ì¹¨ì„ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/04_traits/04_derive.md:64
msgid "Inspection"
msgstr "ë¶„ì„"

#: src/04_traits/04_derive.md:66
msgid ""
"Some IDEs let you expand a macro to inspect the generated code. If that's not "
"possible, you can use [`cargo-expand`](https://github.com/dtolnay/cargo-"
"expand)."
msgstr ""
"ì¼ë¶€ IDEì—ì„œëŠ” ë§¤í¬ë¡œë¥¼ í™•ì¥í•˜ì—¬ ìƒì„±ëœ ì½”ë“œë¥¼ ë¶„ì„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ê²Œ ë¶ˆê°€ëŠ¥"
"í•œ ìƒí™©ì´ë¼ë©´ [`cargo-expand`](https://github.com/dtolnay/cargo-expand)ë¥¼ ì‚¬ìš©"
"í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."

#: src/04_traits/04_derive.md:71
msgid ""
"A **derive macro** is a particular flavour of Rust macro. It is specified as "
"an **attribute** on top of a struct."
msgstr ""
"**íŒŒìƒ ë§¤í¬ë¡œ**ëŠ” Rust ë§¤í¬ë¡œì˜ íŠ¹ë³„í•œ íŠ¹ì§•ì…ë‹ˆë‹¤. êµ¬ì¡°ì²´ ìƒë‹¨ì— **ì†ì„±**ìœ¼ë¡œ "
"ì§€ì •ë©ë‹ˆë‹¤."

#: src/04_traits/04_derive.md:82
msgid ""
"Derive macros are used to automate the implementation of common (and "
"\"obvious\") traits for custom types. In the example above, the `PartialEq` "
"trait is automatically implemented for `Ticket`. If you expand the macro, "
"you'll see that the generated code is functionally equivalent to the one you "
"wrote manually, although a bit more cumbersome to read:"
msgstr ""
"íŒŒìƒ ë§¤í¬ë¡œëŠ” ì‚¬ìš©ì ì •ì˜ ìœ í˜•ì— ëŒ€í•œ ì¼ë°˜ì ì¸(ê·¸ë¦¬ê³  \"ëª…ë°±í•œ\") íŠ¹ì„±ì˜ êµ¬í˜„"
"ì„ ìë™í™”í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. ìœ„ì˜ ì˜ˆì—ì„œ `PartialEq` íŠ¹ì„±ì€ `Ticket`ì— ëŒ€í•´ ì"
"ë™ìœ¼ë¡œ êµ¬í˜„ë©ë‹ˆë‹¤. ë§¤í¬ë¡œë¥¼ í™•ì¥í•˜ë©´ ìƒì„±ëœ ì½”ë“œê°€ ìˆ˜ë™ìœ¼ë¡œ ì‘ì„±í•œ ì½”ë“œì™€ ê¸°ëŠ¥"
"ì ìœ¼ë¡œ ë™ì¼í•˜ë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆì§€ë§Œ ì½ê¸°ê°€ ì¢€ ë” ë¶ˆí¸í•©ë‹ˆë‹¤."

#: src/04_traits/04_derive.md:98
msgid "The compiler will nudge you to derive traits when possible."
msgstr "ì»´íŒŒì¼ëŸ¬ëŠ” ê°€ëŠ¥í•˜ë©´ íŠ¸ë ˆì‡ì„ íŒŒìƒí•˜ë„ë¡ ìœ ë„í•©ë‹ˆë‹¤."

#: src/04_traits/04_derive.md:102
msgid "[The little book of Rust macros](https://veykril.github.io/tlborm/)"
msgstr "[Rust ë§¤í¬ë¡œì— ê´€í•œ ì‘ì€ ë¬¸ì„œ]((https://veykril.github.io/tlborm/))"

#: src/04_traits/04_derive.md:103
msgid "[Proc macro workshop](https://github.com/dtolnay/proc-macro-workshop)"
msgstr "[Proc macro workshop](https://github.com/dtolnay/proc-macro-workshop)"

#: src/04_traits/04_derive.md:107
msgid ""
"The exercise for this section is located in [`04_traits/04_derive`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/04_derive)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`04_traits/04_derive`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/04_traits/04_derive)ì— ìˆìŠµë‹ˆë‹¤"

#: src/04_traits/05_trait_bounds.md:3
msgid "We've seen two use cases for traits so far:"
msgstr "ì§€ê¸ˆê¹Œì§€ íŠ¸ë ˆì‡ì— ëŒ€í•œ ë‘ ê°€ì§€ ì‚¬ìš© ì‚¬ë¡€ë¥¼ ì‚´í´ë³´ì•˜ìŠµë‹ˆë‹¤:"

#: src/04_traits/05_trait_bounds.md:5
msgid "Unlocking \"built-in\" behaviour (e.g. operator overloading)"
msgstr "\"ë¹ŒíŠ¸-ì¸\" ë™ì‘ ì ê¸ˆ í•´ì œ(ì˜ˆ: ì—°ì‚°ì ì˜¤ë²„ë¡œë“œ)"

#: src/04_traits/05_trait_bounds.md:6
msgid "Adding new behaviour to existing types (i.e. extension traits)"
msgstr "ê¸°ì¡´ íƒ€ì…ì— ìƒˆë¡œìš´ ë™ì‘ ì¶”ê°€(ì˜ˆ: í™•ì¥ íŠ¹ì„±)"

#: src/04_traits/05_trait_bounds.md:8
msgid "There's a third use case: **generic programming**."
msgstr "ì„¸ ë²ˆì§¸ ì‚¬ìš© ì‚¬ë¡€ëŠ” **ì œë„¤ë¦­ í”„ë¡œê·¸ë˜ë°**ì…ë‹ˆë‹¤."

#: src/04_traits/05_trait_bounds.md:10 src/04_traits/09_from.md:11
msgid "The problem"
msgstr "ë¬¸ì œ"

#: src/04_traits/05_trait_bounds.md:12
msgid ""
"All our functions and methods, so far, have been working with **concrete "
"types**.  \n"
"Code that operates on concrete types is usually straightforward to write and "
"understand. But it's also limited in its reusability.  \n"
"Let's imagine, for example, that we want to write a function that returns "
"`true` if an integer is even. Working with concrete types, we'd have to write "
"a separate function for each integer type we want to support:"
msgstr ""
"ì§€ê¸ˆê¹Œì§€ ìš°ë¦¬ì˜ ëª¨ë“  í•¨ìˆ˜ì™€ ë©”ì„œë“œëŠ” **êµ¬ì²´ì ì¸ íƒ€ì…**ìœ¼ë¡œ ì‘ì—…í•´ ì™”ìŠµë‹ˆ"
"ë‹¤.  \n"
"êµ¬ì²´ì ì¸ íƒ€ì…ì—ì„œ ì‘ë™í•˜ëŠ” ì½”ë“œëŠ” ì¼ë°˜ì ìœ¼ë¡œ ì‘ì„±í•˜ê³  ì´í•´í•˜ê¸° ì‰½ìŠµë‹ˆë‹¤. í•˜ì§€"
"ë§Œ ì¬ì‚¬ìš© ê°€ëŠ¥ì„±ì— í•œê³„ê°€ ìˆìŠµë‹ˆë‹¤.  \n"
"ì˜ˆë¥¼ ë“¤ì–´ ì •ìˆ˜ê°€ ì§ìˆ˜ì´ë©´ `true`ë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ë¥¼ ì‘ì„±í•œë‹¤ê³  ê°€ì •í•´ ë³´ê² ìŠµë‹ˆ"
"ë‹¤. êµ¬ì²´ì ì¸ íƒ€ì…ìœ¼ë¡œ ì‘ì—…í•˜ë ¤ë©´ ì§€ì›í•˜ë ¤ëŠ” ê° ì •ìˆ˜ íƒ€ì…ì— ëŒ€í•´ ë³„ë„ì˜ í•¨ìˆ˜ë¥¼ "
"ì‘ì„±í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/04_traits/05_trait_bounds.md:27 src/04_traits/05_trait_bounds.md:49
msgid "// Etc.\n"
msgstr "// Etc.\n"

#: src/04_traits/05_trait_bounds.md:31
msgid ""
"Alternatively, we could write a single extension trait and then different "
"implementations for each integer type:"
msgstr ""
"ë˜ëŠ” ë‹¨ì¼ í™•ì¥ íŠ¸ë ˆì‡ì„ ì‘ì„±í•œ ë‹¤ìŒ ê° ì •ìˆ˜ íƒ€ì…ì— ëŒ€í•´ ì„œë¡œ ë‹¤ë¥¸ êµ¬í˜„ì„ ì‘ì„±"
"í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/04_traits/05_trait_bounds.md:53
msgid "The duplication remains."
msgstr "ì¤‘ë³µì´ ë°œìƒí•©ë‹ˆë‹¤."

#: src/04_traits/05_trait_bounds.md:55
msgid "Generic programming"
msgstr "ì œë„¤ë¦­ í”„ë¡œê·¸ë˜ë°"

#: src/04_traits/05_trait_bounds.md:57
msgid ""
"We can do better using **generics**.  \n"
"Generics allow us to write code that works with a **type parameter** instead "
"of a concrete type:"
msgstr ""
"**ì œë„¤ë¦­**ì„ ì‚¬ìš©í•˜ë©´ ë” ë‚˜ì€ ê²°ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"ì œë„¤ë¦­ì„ ì‚¬ìš©í•˜ë©´ êµ¬ì²´ì ì¸ íƒ€ì… ëŒ€ì‹  **íƒ€ì… ë§¤ê°œë³€ìˆ˜**ë¡œ ì‘ë™í•˜ëŠ” ì½”ë“œë¥¼ ì‘ì„±"
"í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/04_traits/05_trait_bounds.md:66 src/04_traits/05_trait_bounds.md:89
msgid "\"{n:?} is even\""
msgstr "\"{n:?} is even\""

#: src/04_traits/05_trait_bounds.md:71
msgid ""
"`print_if_even` is a **generic function**.  \n"
"It isn't tied to a specific input type. Instead, it works with any type `T` "
"that:"
msgstr ""
"`print_if_even`ì€ **ì œë„¤ë¦­ í•¨ìˆ˜**ì…ë‹ˆë‹¤.  \n"
"íŠ¹ì • ì…ë ¥ íƒ€ì…ì— ì œí•œë˜ì§€ì•ŠìŠµë‹ˆë‹¤. ëŒ€ì‹  ë‹¤ìŒê³¼ ê°™ì€ ëª¨ë“  íƒ€ì… `T`ì™€ í•¨ê»˜ ì‘ë™"
"í•©ë‹ˆë‹¤."

#: src/04_traits/05_trait_bounds.md:74
msgid "Implements the `IsEven` trait."
msgstr "`IsEven` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•  ë–„."

#: src/04_traits/05_trait_bounds.md:75
msgid "Implements the `Debug` trait."
msgstr "`Debug` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•  ë•Œ."

#: src/04_traits/05_trait_bounds.md:77
msgid ""
"This contract is expressed with a **trait bound**: `T: IsEven + Debug`.  \n"
"The `+` symbol is used to require that `T` implements multiple traits. `T: "
"IsEven + Debug` is equivalent to \"where `T` implements `IsEven` **and** "
"`Debug`\"."
msgstr ""
"ì´ ìš”êµ¬ì‚¬í•­ì€ **íŠ¸ë ˆì‡ ë°”ìš´ë“œ**: `T: IsEven + Debug`ë¡œ í‘œí˜„ë©ë‹ˆë‹¤.  \n"
"`+` ê¸°í˜¸ëŠ” `T`ê°€ ì—¬ëŸ¬ íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ë„ë¡ ìš”êµ¬í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. `T: IsEven "
"+ Debug`ëŠ” \"`T`ê°€ `IsEven` **ê·¸ë¦¬ê³ ** `Debug`ë¥¼ êµ¬í˜„í•  ë•Œ\"ë¼ëŠ” ë§ê³¼ ê°™ìŠµë‹ˆ"
"ë‹¤."

#: src/04_traits/05_trait_bounds.md:83
msgid ""
"What purpose do trait bounds serve in `print_if_even`?  \n"
"To find out, let's try to remove them:"
msgstr ""
"`print_if_even`ì—ì„œ íŠ¸ë ˆì‡ ë°”ìš´ë“œëŠ” ì–´ë–¤ ëª©ì ìœ¼ë¡œ ì‚¬ìš©ë ê¹Œìš”?  \n"
"ì•Œì•„ë³´ê¸° ìœ„í•´ ì´ë¥¼ ì œê±°í•´ ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/04_traits/05_trait_bounds.md:94
msgid "This code won't compile:"
msgstr "ì´ ì½”ë“œëŠ” ì»´íŒŒì¼ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤:"

#: src/04_traits/05_trait_bounds.md:96
msgid ""
"```text\n"
"error[E0599]: no method named `is_even` found for type parameter `T` in the "
"current scope\n"
" --> src/lib.rs:2:10\n"
"  |\n"
"1 | fn print_if_even<T>(n: T) {\n"
"  |                  - method `is_even` not found for this type parameter\n"
"2 |     if n.is_even() {\n"
"  |          ^^^^^^^ method not found in `T`\n"
"\n"
"error[E0277]: `T` doesn't implement `Debug`\n"
" --> src/lib.rs:3:19\n"
"  |\n"
"3 |         println!(\"{n:?} is even\");\n"
"  |                   ^^^^^ `T` cannot be formatted using `{:?}` because it "
"doesn't implement `Debug`\n"
"  |\n"
"help: consider restricting type parameter `T`\n"
"  |\n"
"1 | fn print_if_even<T: std::fmt::Debug>(n: T) {\n"
"  |                   +++++++++++++++++\n"
"```"
msgstr ""
"```text\n"
"error[E0599]: no method named `is_even` found for type parameter `T` in the "
"current scope\n"
" --> src/lib.rs:2:10\n"
"  |\n"
"1 | fn print_if_even<T>(n: T) {\n"
"  |                  - method `is_even` not found for this type parameter\n"
"2 |     if n.is_even() {\n"
"  |          ^^^^^^^ method not found in `T`\n"
"\n"
"error[E0277]: `T` doesn't implement `Debug`\n"
" --> src/lib.rs:3:19\n"
"  |\n"
"3 |         println!(\"{n:?} is even\");\n"
"  |                   ^^^^^ `T` cannot be formatted using `{:?}` because it "
"doesn't implement `Debug`\n"
"  |\n"
"help: consider restricting type parameter `T`\n"
"  |\n"
"1 | fn print_if_even<T: std::fmt::Debug>(n: T) {\n"
"  |                   +++++++++++++++++\n"
"```"

#: src/04_traits/05_trait_bounds.md:117
msgid ""
"Without trait bounds, the compiler doesn't know what `T` **can do**.  \n"
"It doesn't know that `T` has an `is_even` method, and it doesn't know how to "
"format `T` for printing. From the compiler point of view, a bare `T` has no "
"behaviour at all.  \n"
"Trait bounds restrict the set of types that can be used by ensuring that the "
"behaviour required by the function body is present."
msgstr ""
"íŠ¸ë ˆì‡ ë°”ìš´ë“œê°€ ì—†ìœ¼ë©´ ì»´íŒŒì¼ëŸ¬ëŠ” `T`ê°€ **í•  ìˆ˜ ìˆëŠ”** ì‘ì—…ì„ ì•Œ ìˆ˜ ì—†ìŠµë‹ˆ"
"ë‹¤.  \n"
"`T`ì— `is_even` ë©”ì„œë“œê°€ ìˆë‹¤ëŠ” ì‚¬ì‹¤ë„ ëª¨ë¥´ê³ , í”„ë¦°íŠ¸ë¥¼ ìœ„í•´ `T` íƒ€ì…ì„ í¬ë§·íŒ…"
"í•˜ëŠ” ë°©ë²•ë„ ëª¨ë¦…ë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ì˜ ê´€ì ì—ì„œ ë³´ë©´ `T`ë¡œëŠ” ì•„ë¬´ê²ƒë„ í•  ìˆ˜ ì—†ìŠµë‹ˆ"
"ë‹¤.  \n"
"íŠ¸ë ˆì‡ ë°”ìš´ë“œëŠ” í•¨ìˆ˜ ë³¸ë¬¸ì—ì„œ ìš”êµ¬í•˜ëŠ” ë™ì‘ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•˜ì—¬ í•¨ìˆ˜ì— ì‚¬ìš©"
"í•  ìˆ˜ ìˆëŠ” íƒ€ì…ë“¤ì„ ì œí•œí•©ë‹ˆë‹¤."

#: src/04_traits/05_trait_bounds.md:123
msgid "Syntax: inlining trait bounds"
msgstr "êµ¬ë¬¸: ì¸ë¼ì¸ íŠ¸ë ˆì‡ ë°”ìš´ë“œ"

#: src/04_traits/05_trait_bounds.md:125
msgid ""
"All the examples above used a **`where` clause** to specify trait bounds:"
msgstr ""
"ìœ„ì˜ ëª¨ë“  ì˜ˆì—ì„œëŠ” íŠ¸ë ˆì‡ ë°”ìš´ë“œë¥¼ ì§€ì •í•˜ê¸° ìœ„í•´ **`where` ì ˆ**ì„ ì‚¬ìš©í–ˆìŠµë‹ˆ"
"ë‹¤:"

#: src/04_traits/05_trait_bounds.md:130
msgid ""
"//  ^^^^^^^^^^^^^^^^^\n"
"//  This is a `where` clause\n"
msgstr ""
"//  ^^^^^^^^^^^^^^^^^\n"
"//  ì´ê²Œ `where` ì ˆì…ë‹ˆë‹¤\n"

#: src/04_traits/05_trait_bounds.md:138
msgid ""
"If the trait bounds are simple, you can **inline** them directly next to the "
"type parameter:"
msgstr ""
"íŠ¸ë ˆì‡ ë°”ìš´ë“œê°€ ë‹¨ìˆœí•œ ê²½ìš° íƒ€ì… ë§¤ê°œë³€ìˆ˜ ë°”ë¡œ ì˜†ì— **ì¸ë¼ì¸**í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/04_traits/05_trait_bounds.md:142
msgid ""
"//           ^^^^^^^^^^^^^^^^^\n"
"    //           This is an inline trait bound\n"
"    // [...]\n"
msgstr ""
"//           ^^^^^^^^^^^^^^^^^\n"
"    //           ì´ê²Œ ì¸ë¼ì¸ íŠ¸ë ˆì‡ ë°”ìš´ë“œì…ë‹ˆë‹¤\n"
"    // [...]\n"

#: src/04_traits/05_trait_bounds.md:148
msgid "Syntax: meaningful names"
msgstr "êµ¬ë¬¸: ì˜ë¯¸ ìˆëŠ” ì´ë¦„"

#: src/04_traits/05_trait_bounds.md:150
msgid ""
"In the examples above, we used `T` as the type parameter name. This is a "
"common convention when a function has only one type parameter.  \n"
"Nothing stops you from using a more meaningful name, though:"
msgstr ""
"ìœ„ì˜ ì˜ˆì—ì„œëŠ” `T`ë¥¼ íƒ€ì… ë§¤ê°œë³€ìˆ˜ ì´ë¦„ìœ¼ë¡œ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤. ì´ëŠ” í•¨ìˆ˜ì— íƒ€ì… ë§¤ê°œ"
"ë³€ìˆ˜ê°€ í•˜ë‚˜ë§Œ ìˆëŠ” ê²½ìš° ì¼ë°˜ì ì¸ ê·œì¹™ì…ë‹ˆë‹¤.  \n"
"ë” ì˜ë¯¸ ìˆëŠ” ì´ë¦„ì„ ì‚¬ìš©í•˜ì…”ë„ ë©ë‹ˆë‹¤:"

#: src/04_traits/05_trait_bounds.md:160
msgid ""
"It is actually **desirable** to use meaningful names when there are multiple "
"type parameters at play or when the name `T` doesn't convey enough "
"information about the type's role in the function. Maximize clarity and "
"readability when naming type parameters, just as you would with variables or "
"function parameters. Follow Rust's conventions, though: use [upper camel case "
"for type parameter names](https://rust-lang.github.io/api-guidelines/naming."
"html#casing-conforms-to-rfc-430-c-case)."
msgstr ""
"ì‹¤ì œë¡œ ì—¬ëŸ¬ íƒ€ì… ë§¤ê°œë³€ìˆ˜ê°€ ìˆê±°ë‚˜ `T`ë¼ëŠ” ì´ë¦„ì´ í•¨ìˆ˜ì—ì„œ í•´ë‹¹ íƒ€ì…ì˜ ì—­í• ì— "
"ëŒ€í•œ ì¶©ë¶„í•œ ì •ë³´ë¥¼ ì „ë‹¬í•˜ì§€ ëª»í•˜ëŠ” ê²½ìš° ì˜ë¯¸ ìˆëŠ” ì´ë¦„ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ **ë°”ëŒ"
"ì§í•©ë‹ˆë‹¤**. ë³€ìˆ˜ë‚˜ í•¨ìˆ˜ ë§¤ê°œë³€ìˆ˜ì™€ ë§ˆì°¬ê°€ì§€ë¡œ íƒ€ì… ë§¤ê°œë³€ìˆ˜ì˜ ì´ë¦„ì„ ì§€ì •í•  "
"ë•Œ ëª…í™•ì„±ê³¼ ê°€ë…ì„±ì„ ìµœëŒ€í™”í•˜ì„¸ìš”. ë™ì‹œì— Rustì˜ ê·œì¹™ë„ ì§€ì¼œì£¼ì„¸ìš”. [íƒ€ì… ë§¤ê°œ"
"ë³€ìˆ˜ ì´ë¦„ì—ëŠ” ëŒ€ë¬¸ì ì¹´ë©œì¼€ì´ìŠ¤](https://rust-lang.github.io/api-guidelines/"
"naming.html#casing-conforms-to-rfc-430-c-case)ë¥¼ ì‚¬ìš©í•˜ì‹­ì‹œì˜¤."

#: src/04_traits/05_trait_bounds.md:165
msgid "The function signature is king"
msgstr "í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ëŠ” ì™•ì´ë‹¤"

#: src/04_traits/05_trait_bounds.md:167
msgid ""
"You may wonder why we need trait bounds at all. Can't the compiler infer the "
"required traits from the function's body?  \n"
"It could, but it won't.  \n"
"The rationale is the same as for [explicit type annotations on function "
"parameters](../02_basic_calculator/02_variables.md#function-arguments-are-"
"variables): each function signature is a contract between the caller and the "
"callee, and the terms must be explicitly stated. This allows for better error "
"messages, better documentation, less unintentional breakages across versions, "
"and faster compilation times."
msgstr ""
"íŠ¸ë ˆì‡ ë°”ìš´ë“œê°€ ì™œ í•„ìš”í•œì§€ ê¶ê¸ˆí•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ê°€ í•¨ìˆ˜ ë³¸ë¬¸ì—ì„œ í•„"
"ìš”í•œ íŠ¸ë ˆì‡ì„ ì¶”ë¡ í•  ìˆœ ì—†ë‚˜ìš”?  \n"
"ê·¸ëŸ´ ìˆ˜ë„ ìˆê² ì§€ë§Œ ì‹¤ì œë¡  ê·¸ë ‡ì§€ ì•ŠìŠµë‹ˆë‹¤.  \n"
"ê·¸ ê·¼ê±°ëŠ” í•¨ìˆ˜ ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•œ ëª…ì‹œì  íƒ€ì… ì–´ë…¸í…Œì´ì…˜ì˜ ê²½ìš°ì™€ ë™ì¼í•©ë‹ˆë‹¤. ê° "
"í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ëŠ” í˜¸ì¶œìì™€ í˜¸ì¶œ ìˆ˜ì‹ ì ê°„ì˜ ê³„ì•½ì´ë©° ìš©ì–´ê°€ ëª…ì‹œì ìœ¼ë¡œ ëª…ì‹œë˜ì–´"
"ì•¼ í•©ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ë” ë‚˜ì€ ì˜¤ë¥˜ ë©”ì‹œì§€, ë” ë‚˜ì€ ë¬¸ì„œí™”, ë²„ì „ ê°„ ì˜ë„í•˜ì§€ ì•Š"
"ì€ ë¬¸ì œ ê°ì†Œ ê·¸ë¦¬ê³  ë” ë¹ ë¥¸ ì»´íŒŒì¼ì´ ê°€ëŠ¥í•´ì§‘ë‹ˆë‹¤."

#: src/04_traits/05_trait_bounds.md:176
msgid ""
"The exercise for this section is located in [`04_traits/05_trait_bounds`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/05_trait_bounds)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`04_traits/05_trait_bounds`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/05_trait_bounds)ì— ìˆìŠµë‹ˆë‹¤"

#: src/04_traits/06_str_slice.md:3
msgid ""
"Throughout the previous chapters you've seen quite a few **string literals** "
"being used in the code, like `\"To-Do\"` or `\"A ticket description\"`. They "
"were always followed by a call to `.to_string()` or `.into()`. It's time to "
"understand why!"
msgstr ""
"ì´ì „ ì¥ ì „ì²´ì—ì„œ `\"To-Do\"` ë˜ëŠ” `\"A ticket Description\"`ê³¼ ê°™ì€ ì½”ë“œì—ì„œ "
"ì‚¬ìš©ë˜ëŠ” **ë¬¸ìì—´ ë¦¬í„°ëŸ´**ì„ ê½¤ ë§ì´ ë³´ì•˜ìŠµë‹ˆë‹¤. ê·¸ ë’¤ì—ëŠ” í•­ìƒ `."
"to_string()` ë˜ëŠ” `.into()`ì— ëŒ€í•œ í˜¸ì¶œì´ ì´ì–´ì¡ŒìŠµë‹ˆë‹¤. ì´ì œ ê·¸ ì´ìœ ë¥¼ ì´í•´í•  "
"ì‹œê°„ì…ë‹ˆë‹¤!"

#: src/04_traits/06_str_slice.md:7
msgid "String literals"
msgstr "ë¬¸ìì—´ ë¦¬í„°ëŸ´"

#: src/04_traits/06_str_slice.md:9
msgid "You define a string literal by enclosing the raw text in double quotes:"
msgstr "ì›ì‹œ í…ìŠ¤íŠ¸ë¥¼ í°ë”°ì˜´í‘œë¡œ ë¬¶ì–´ ë¬¸ìì—´ ë¦¬í„°ëŸ´ì„ ì •ì˜í•©ë‹ˆë‹¤:"

#: src/04_traits/06_str_slice.md:12
msgid "\"Hello, world!\""
msgstr "\"Hello, world!\""

#: src/04_traits/06_str_slice.md:15
msgid "The type of `s` is `&str`, a **reference to a string slice**."
msgstr "`s`ì˜ ìœ í˜•ì€ **ë¬¸ìì—´ ìŠ¬ë¼ì´ìŠ¤ì— ëŒ€í•œ ì°¸ì¡°**ì¸ `&str`ì…ë‹ˆë‹¤."

#: src/04_traits/06_str_slice.md:19
msgid ""
"`&str` and `String` are different typesâ€”they're not interchangeable.  \n"
"Let's recall the memory layout of a `String` from our [previous exploration]"
"(../03_ticket_v1/09_heap.md). If we run:"
msgstr ""
"`&str`ê³¼ `String`ì€ ì„œë¡œ ë‹¤ë¥¸ ìœ í˜•ì´ë¯€ë¡œ ì„œë¡œ ë°”ê¿” ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.  \n"
"[ì´ì „ ì‹œê°„](../03_ticket_v1/09_heap.md)ì—ì„œ ë³¸ `String`ì˜ ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒì„ ë– "
"ì˜¬ë ¤ ë³´ê² ìŠµë‹ˆë‹¤. ë‹¤ìŒì„ ì‹¤í–‰í•˜ë©´:"

#: src/04_traits/06_str_slice.md:29
msgid "we'll get this scenario in memory:"
msgstr "ìš°ë¦¬ëŠ” ì´ ìƒí™©ì—ì„œ ë©”ëª¨ë¦¬ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/04_traits/06_str_slice.md:44
msgid ""
"If you remember, we've [also examined]"
"(../03_ticket_v1/10_references_in_memory.md) how a `&String` is laid out in "
"memory:"
msgstr ""
"`&String`ì´ ë©”ëª¨ë¦¬ì— ì–´ë–»ê²Œ ë°°ì¹˜ë˜ëŠ”ì§€ë„ [ì‚´í´ë³´ì•˜ìŠµë‹ˆë‹¤]"
"(../03_ticket_v1/10_references_in_memory.md):"

#: src/04_traits/06_str_slice.md:62
msgid ""
"`&String` points to the memory location where the `String`'s metadata is "
"stored.  \n"
"If we follow the pointer, we get to the heap-allocated data. In particular, "
"we get to the first byte of the string, `H`."
msgstr ""
"`&String`ì€ `String`ì˜ ë©”íƒ€ë°ì´í„°ê°€ ì €ì¥ë˜ëŠ” ë©”ëª¨ë¦¬ ìœ„ì¹˜ë¥¼ ê°€ë¦¬í‚µë‹ˆë‹¤.  \n"
"í¬ì¸í„°ë¥¼ ë”°ë¼ê°€ë©´ í™ì— í• ë‹¹ëœ ë°ì´í„°ì— ë„ë‹¬í•©ë‹ˆë‹¤. ì •í™•íˆëŠ”, ë¬¸ìì—´ì˜ ì²« ë²ˆì§¸ "
"ë°”ì´íŠ¸ `H`ì— ë„ë‹¬í•©ë‹ˆë‹¤."

#: src/04_traits/06_str_slice.md:65
msgid ""
"What if we wanted a type that represents a **substring** of `s`? E.g. `ello` "
"in `Hello`?"
msgstr ""
"`s`ì˜ **ì„œë¸ŒìŠ¤íŠ¸ë§**ì„ ë‚˜íƒ€ë‚´ëŠ” íƒ€ì…ì€ ì–´ë–»ê²Œ í‘œí˜„í• ê¹Œìš”? ì˜ˆ: 'Hello'ì˜ "
"'ello'ê°™ì´?"

#: src/04_traits/06_str_slice.md:69
msgid ""
"A `&str` is a **view** into a string, a **reference** to a sequence of UTF-8 "
"bytes stored elsewhere. You can, for example, create a `&str` from a `String` "
"like this:"
msgstr ""
"`&str`ì€ ë¬¸ìì—´ì— ëŒ€í•œ **ë·°**, ë‹¤ë¥¸ ê³³ì— ì €ì¥ëœ UTF-8 ë°”ì´íŠ¸ ì‹œí€€ìŠ¤ì— ëŒ€í•œ **"
"ì°¸ì¡°**ì…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ë‹¤ìŒê³¼ ê°™ì´ `String`ì—ì„œ `&str`ì„ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/04_traits/06_str_slice.md:74 src/04_traits/08_sized.md:13
msgid ""
"// Create a string slice reference from the `String`, skipping the first "
"byte.\n"
msgstr ""
"// `String`ì—ì„œ ë¬¸ìì—´ ìŠ¬ë¼ì´ìŠ¤ ì°¸ì¡°ë¥¼ ìƒì„±í•˜ê³  ì²« ë²ˆì§¸ ë°”ì´íŠ¸ë¥¼ ê±´ë„ˆëœë‹ˆë‹¤.\n"

#: src/04_traits/06_str_slice.md:79
msgid "In memory, it'd look like this:"
msgstr "ë©”ëª¨ë¦¬ì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/04_traits/06_str_slice.md:98
msgid "`slice` stores two pieces of information on the stack:"
msgstr "`slice`ëŠ” ìŠ¤íƒì— ë‘ ê°€ì§€ ì •ë³´ë¥¼ ì €ì¥í•©ë‹ˆë‹¤:"

#: src/04_traits/06_str_slice.md:100
msgid "A pointer to the first byte of the slice."
msgstr "ìŠ¬ë¼ì´ìŠ¤ì˜ ì²« ë²ˆì§¸ ë°”ì´íŠ¸ì— ëŒ€í•œ í¬ì¸í„°."

#: src/04_traits/06_str_slice.md:101
msgid "The length of the slice."
msgstr "ìŠ¬ë¼ì´ìŠ¤ì˜ ê¸¸ì´."

#: src/04_traits/06_str_slice.md:103
msgid ""
"`slice` doesn't own the data, it just points to it: it's a **reference** to "
"the `String`'s heap-allocated data.  \n"
"When `slice` is dropped, the heap-allocated data won't be deallocated, "
"because it's still owned by `s`. That's why `slice` doesn't have a `capacity` "
"field: it doesn't own the data, so it doesn't need to know how much space it "
"was allocated for it; it only cares about the data it references."
msgstr ""

#: src/04_traits/06_str_slice.md:108
msgid "`&str` vs `&String`"
msgstr "`&str` vs `&String`"

#: src/04_traits/06_str_slice.md:110
msgid ""
"As a rule of thumb, use `&str` rather than `&String` whenever you need a "
"reference to textual data.  \n"
"`&str` is more flexible and generally considered more idiomatic in Rust code."
msgstr ""
"ê²½í—˜ìƒ í…ìŠ¤íŠ¸ ë°ì´í„°ì— ëŒ€í•œ ì°¸ì¡°ê°€ í•„ìš”í•  ë•ŒëŠ” `&String` ëŒ€ì‹  `&str`ì„ ì‚¬ìš©í•˜"
"ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.  \n"
"`&str`ì€ ë” ìœ ì—°í•˜ê³  ì¼ë°˜ì ìœ¼ë¡œ Rustì—ì„œ ë” ê´€ìš©ì ì…ë‹ˆë‹¤."

#: src/04_traits/06_str_slice.md:113
msgid ""
"If a method returns a `&String`, you're promising that there is heap-"
"allocated UTF-8 text somewhere that **matches exactly** the one you're "
"returning a reference to.  \n"
"If a method returns a `&str`, instead, you have a lot more freedom: you're "
"just saying that _somewhere_ there's a bunch of text data and that a subset "
"of it matches what you need, therefore you're returning a reference to it."
msgstr ""
"ë©”ì„œë“œê°€ `&String`ì„ ë°˜í™˜í•˜ë©´, í™ì— í• ë‹¹ëœ UTF-8 í…ìŠ¤íŠ¸ê°€ ìˆìœ¼ë©°, í•´ë‹¹ í…ìŠ¤íŠ¸"
"ê°€ ë°˜í™˜ë˜ëŠ” ì°¸ì¡°ì™€ **ì •í™•íˆ ì¼ì¹˜**í•œë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.\n"
"ë°˜ë©´ì— ë©”ì„œë“œê°€ `&str`ì„ ë°˜í™˜í•˜ë©´, í›¨ì”¬ ë” ë§ì€ ììœ ë¥¼ ê°€ì§€ê²Œ ë©ë‹ˆë‹¤: _ì–´ë”˜ê°€"
"ì—_ í…ìŠ¤íŠ¸ ë°ì´í„°ê°€ ìˆìœ¼ë©°, ê·¸ ì¼ë¶€ê°€ í•„ìš”í•œ ê²ƒê³¼ ì¼ì¹˜í•œë‹¤ëŠ” ê²ƒë§Œì„ ë§í•˜ëŠ” ê²ƒ"
"ì´ë¯€ë¡œ ê·¸ ë¶€ë¶„ì— ëŒ€í•œ ì°¸ì¡°ë¥¼ ë°˜í™˜í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/04_traits/06_str_slice.md:120
msgid ""
"The exercise for this section is located in [`04_traits/06_str_slice`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/06_str_slice)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`04_traits/06_str_slice`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/04_traits/06_str_slice)ì— ìˆìŠµë‹ˆë‹¤"

#: src/04_traits/07_deref.md:3
msgid "In the previous exercise you didn't have to do much, did you?"
msgstr "ì´ì „ ì˜ˆì œì—ì„œëŠ” ë§ì€ ì¼ì„ í•  í•„ìš”ê°€ ì—†ì—ˆìŠµë‹ˆë‹¤. ê·¸ë ‡ì£ ?"

#: src/04_traits/07_deref.md:5
msgid "Changing"
msgstr "ì´ê²ƒì„"

#: src/04_traits/07_deref.md:15
msgid "to"
msgstr "ì´ë ‡ê²Œ"

#: src/04_traits/07_deref.md:25
msgid ""
"was all you needed to do to get the code to compile and the tests to pass. "
"Some alarm bells should be ringing in your head though."
msgstr ""
"ë°”ê¾¸ëŠ” ê²ƒì´ ì½”ë“œë¥¼ ì»´íŒŒì¼í•˜ê³  í…ŒìŠ¤íŠ¸ë¥¼ í†µê³¼í•˜ê¸° ìœ„í•´ í•´ì•¼ í•  ì¼ì˜ ì „ë¶€ì˜€ìŠµë‹ˆ"
"ë‹¤. í•˜ì§€ë§Œ ë¨¸ë¦¬ì— ë²ˆëœ© ë– ì˜¤ë¥´ëŠ” ê²ƒì´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤."

#: src/04_traits/07_deref.md:28
msgid "It shouldn't work, but it does"
msgstr "ì‘ë™í•˜ë©´ ì•ˆ ë˜ì§€ë§Œ ì‘ë™í•©ë‹ˆë‹¤"

#: src/04_traits/07_deref.md:30
msgid "Let's review the facts:"
msgstr "ë‹¤ìŒì„ í™•ì¸í•´ë´…ì‹œë‹¤:"

#: src/04_traits/07_deref.md:32
msgid "`self.title` is a `String`"
msgstr "`self.title`ì€ `String`ì…ë‹ˆë‹¤"

#: src/04_traits/07_deref.md:33
msgid "`&self.title` is, therefore, a `&String`"
msgstr "ë”°ë¼ì„œ `&self.title`ì€ `&String`ì…ë‹ˆë‹¤"

#: src/04_traits/07_deref.md:34
msgid "The output of the (modified) `title` method is `&str`"
msgstr "(ìˆ˜ì •ëœ) `title` ë©”ì†Œë“œì˜ ì¶œë ¥ì€ `&str`ì…ë‹ˆë‹¤"

#: src/04_traits/07_deref.md:36
msgid ""
"You would expect a compiler error, wouldn't you? `Expected &String, found "
"&str` or something similar. Instead, it just works. **Why**?"
msgstr ""
"ì»´íŒŒì¼ëŸ¬ ì˜¤ë¥˜ê°€ ë°œìƒí•´ì•¼í•  ê²ƒ ê°™ì§€ ì•Šë‚˜ìš”? `Expected &String, found &str`ê°™ì€ "
"ì˜¤ë¥˜ ë§ì…ë‹ˆë‹¤. ê·¼ë° ì‘ë™í•©ë‹ˆë‹¤. **ì™œ**ê·¸ëŸ´ê¹Œìš”?"

#: src/04_traits/07_deref.md:39
msgid "`Deref` to the rescue"
msgstr "`Deref`ê°€ ë‹¹ì‹ ì„ êµ¬ì›í•©ë‹ˆë‹¤"

#: src/04_traits/07_deref.md:41
msgid ""
"The `Deref` trait is the mechanism behind the language feature known as "
"[**deref coercion**](https://doc.rust-lang.org/std/ops/trait.Deref.html#deref-"
"coercion).  \n"
"The trait is defined in the standard library, in the `std::ops` module:"
msgstr ""
"`Deref` íŠ¸ë ˆì‡ì€ [**deref coercion**](https://doc.rust-lang.org/std/ops/trait."
"Deref.html#deref-coercion)ë¼ê³  ì•Œë ¤ì§„ ì–¸ì–´ ê¸°ëŠ¥ ë’¤ì— ìˆëŠ” ë©”ì»¤ë‹ˆì¦˜ì…ë‹ˆë‹¤.  \n"
"ì´ íŠ¸ë ˆì‡ì€ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ `std::ops` ëª¨ë“ˆì— ì •ì˜ë˜ì–´ ìˆìŠµë‹ˆë‹¤."

#: src/04_traits/07_deref.md:45
msgid ""
"// I've slightly simplified the definition for now.\n"
"// We'll see the full definition later on.\n"
msgstr ""
"// ì§€ê¸ˆì€ ì •ì˜ë¥¼ ì•½ê°„ ë‹¨ìˆœí™”í–ˆìŠµë‹ˆë‹¤.\n"
"// ë‚˜ì¤‘ì— ì „ì²´ ì •ì˜ë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.\n"

#: src/04_traits/07_deref.md:54
msgid ""
"`type Target` is an **associated type**.  \n"
"It's a placeholder for a concrete type that must be specified when the trait "
"is implemented."
msgstr ""
"`type Target`ì€ **ì—°ê´€ëœ íƒ€ì…**ì…ë‹ˆë‹¤.  \n"
"ì´ëŠ” íŠ¸ë ˆì‡ì´ êµ¬í˜„ë  ë•Œ ì§€ì •ë˜ì–´ì•¼ í•˜ëŠ” êµ¬ì²´ì ì¸ íƒ€ì…ì— ëŒ€í•œ í”Œë ˆì´ìŠ¤ í™€ë”ì…ë‹ˆ"
"ë‹¤."

#: src/04_traits/07_deref.md:57
msgid "Deref coercion"
msgstr "Deref coercion"

#: src/04_traits/07_deref.md:59
msgid ""
"By implementing `Deref<Target = U>` for a type `T` you're telling the "
"compiler that `&T` and `&U` are somewhat interchangeable.  \n"
"In particular, you get the following behavior:"
msgstr ""
"`T` íƒ€ì…ì— ëŒ€í•´ `Deref<Target = U>`ë¥¼ êµ¬í˜„í•˜ë©´ ì»´íŒŒì¼ëŸ¬ì—ê²Œ `&T`ì™€ `&U`ê°€ ì–´"
"ëŠ ì •ë„ ìƒí˜¸ êµí™˜ ê°€ëŠ¥í•˜ë‹¤ëŠ” ê²ƒì„ ì•Œë¦¬ê²Œ ë©ë‹ˆë‹¤.  \n"
"íŠ¹íˆ ë‹¤ìŒê³¼ ê°™ì€ ë™ì‘ì´ ë°œìƒí•©ë‹ˆë‹¤:"

#: src/04_traits/07_deref.md:63
msgid ""
"References to `T` are implicitly converted into references to `U` (i.e. `&T` "
"becomes `&U`)"
msgstr ""
"`T`ì— ëŒ€í•œ ì°¸ì¡°ëŠ” ì•”ì‹œì ìœ¼ë¡œ `U`ì— ëŒ€í•œ ì°¸ì¡°ë¡œ ë³€í™˜ë©ë‹ˆë‹¤(ì¦‰: `&T`ëŠ” `&U`ê°€ ë©"
"ë‹ˆë‹¤)."

#: src/04_traits/07_deref.md:64
msgid ""
"You can call on `&T` all the methods defined on `U` that take `&self` as "
"input."
msgstr ""
"`&self`ë¥¼ ì…ë ¥ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” `U`ì— ì •ì˜ëœ ëª¨ë“  ë©”ì„œë“œë¥¼ `&T`ì—ì„œ í˜¸ì¶œí•  ìˆ˜ ìˆìŠµ"
"ë‹ˆë‹¤."

#: src/04_traits/07_deref.md:66
msgid ""
"There is one more thing around the dereference operator, `*`, but we don't "
"need it yet (see `std`'s docs if you're curious)."
msgstr ""
"ì—­ì°¸ì¡° ì—°ì‚°ì `*`ì—ëŠ” í•œ ê°€ì§€ê°€ ë” ìˆì§€ë§Œ ì•„ì§ì€ í•„ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤(ê¶ê¸ˆí•˜ì‹œë©´ "
"`std` ë¬¸ì„œë¥¼ ì°¸ì¡°í•˜ì„¸ìš”)."

#: src/04_traits/07_deref.md:69
msgid "`String` implements `Deref`"
msgstr "`String`ì€ `Deref`ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤"

#: src/04_traits/07_deref.md:71
msgid "`String` implements `Deref` with `Target = str`:"
msgstr "`String`ì€ `Target = str`ì„ ì‚¬ìš©í•˜ì—¬ `Deref`ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤:"

#: src/04_traits/07_deref.md:83
msgid ""
"Thanks to this implementation and deref coercion, a `&String` is "
"automatically converted into a `&str` when needed."
msgstr ""
"ì´ êµ¬í˜„ê³¼ Deref coercion ë•ë¶„ì— `&String`ì€ í•„ìš”í•  ë•Œ ìë™ìœ¼ë¡œ `&str`ë¡œ ë³€í™˜ë©"
"ë‹ˆë‹¤."

#: src/04_traits/07_deref.md:85
msgid "Don't abuse deref coercion"
msgstr "deref coercionì„ ë‚¨ìš©í•˜ì§€ ë§ˆì„¸ìš”"

#: src/04_traits/07_deref.md:87
msgid ""
"Deref coercion is a powerful feature, but it can lead to confusion.  \n"
"Automatically converting types can make the code harder to read and "
"understand. If a method with the same name is defined on both `T` and `U`, "
"which one will be called?"
msgstr ""
"Deref coercionì€ ê°•ë ¥í•œ ê¸°ëŠ¥ì´ì§€ë§Œ í˜¼ë€ì„ ì´ˆë˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"íƒ€ì…ì„ ìë™ìœ¼ë¡œ ë³€í™˜í•˜ë©´ ì½”ë“œë¥¼ ì½ê³  ì´í•´í•˜ê¸°ê°€ ë” ì–´ë ¤ì›Œì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤. `T`"
"ì™€ `U`ì— ë™ì¼í•œ ì´ë¦„ì˜ ë©”ì†Œë“œê°€ ì •ì˜ëœ ê²½ìš° ì–´ëŠ ë©”ì†Œë“œê°€ í˜¸ì¶œë ê¹Œìš”?"

#: src/04_traits/07_deref.md:91
msgid ""
"We'll examine later in the course the \"safest\" use cases for deref "
"coercion: smart pointers."
msgstr ""
"Deref coercionì— ëŒ€í•œ \"ê°€ì¥ ì•ˆì „í•œ\" ì‚¬ìš© ì‚¬ë¡€ì¸ ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°ì— ëŒ€í•´ ë‚˜ì¤‘ì— "
"ê³¼ì •ì—ì„œ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤."

#: src/04_traits/07_deref.md:95
msgid ""
"The exercise for this section is located in [`04_traits/07_deref`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/07_deref)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`04_traits/07_deref`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/04_traits/07_deref)ì— ìˆìŠµë‹ˆë‹¤"

#: src/04_traits/08_sized.md:1
msgid "`Sized`"
msgstr "`Sized`"

#: src/04_traits/08_sized.md:3
msgid ""
"There's more to `&str` than meets the eye, even after having investigated "
"deref coercion.  \n"
"From our previous [discussion on memory layouts]"
"(../03_ticket_v1/10_references_in_memory.md), it would have been reasonable "
"to expect `&str` to be represented as a single `usize` on the stack, a "
"pointer. That's not the case though. `&str` stores some **metadata** next to "
"the pointer: the length of the slice it points to. Going back to the example "
"from [a previous section](06_str_slice.md):"
msgstr ""
"Deref coercionì— ëŒ€í•´ ì•Œì•„ë³¸ í›„ì—ë„ `&str`ì—ëŠ” ëˆˆì— ë³´ì´ëŠ” ê²ƒë³´ë‹¤ ë” ë§ì€ ê²ƒ"
"ì´ ìˆìŠµë‹ˆë‹¤.  \n"
"ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒì— ëŒ€í•œ ì´ì „ ë…¼ì˜ì—ì„œ `&str`ì´ ìŠ¤íƒì—ì„œ ë‹¨ì¼ `usize`ì¸ í¬ì¸í„°"
"ë¡œ í‘œí˜„ë  ê²ƒìœ¼ë¡œ ì˜ˆìƒí•˜ëŠ” ê²ƒì´ í•©ë¦¬ì ì´ì—ˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ê·¸ë ‡ì§€ ì•ŠìŠµë‹ˆë‹¤. "
"`&str`ì€ í¬ì¸í„° ì˜†ì— ì¼ë¶€ **ë©”íƒ€ë°ì´í„°**, ì¦‰ í¬ì¸í„°ê°€ ê°€ë¦¬í‚¤ëŠ” ìŠ¬ë¼ì´ìŠ¤ì˜ ê¸¸ì´"
"ë¥¼ ì €ì¥í•©ë‹ˆë‹¤. ì´ì „ ì„¹ì…˜ì˜ ì˜ˆë¡œ ëŒì•„ê°€ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/04_traits/08_sized.md:18
msgid "In memory, we get:"
msgstr "ë©”ëª¨ë¦¬ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/04_traits/08_sized.md:37
msgid "What's going on?"
msgstr "ë¬´ìŠ¨ ì¼ì¼ê¹Œìš”?"

#: src/04_traits/08_sized.md:39
msgid "Dynamically sized types"
msgstr "ë™ì  í¬ê¸° íƒ€ì…"

#: src/04_traits/08_sized.md:41
msgid ""
"`str` is a **dynamically sized type** (DST).  \n"
"A DST is a type whose size is not known at compile time. Whenever you have a "
"reference to a DST, like `&str`, it has to include additional information "
"about the data it points to. It is a **fat pointer**.  \n"
"In the case of `&str`, it stores the length of the slice it points to. We'll "
"see more examples of DSTs in the rest of the course."
msgstr ""
"`str`ì€ **ë™ì  í¬ê¸° íƒ€ì…**(DST)ì…ë‹ˆë‹¤.  \n"
"DSTëŠ” ì»´íŒŒì¼ íƒ€ì„ì— í¬ê¸°ë¥¼ ì•Œ ìˆ˜ ì—†ëŠ” íƒ€ì…ì…ë‹ˆë‹¤. `&str`ê³¼ ê°™ì€ DSTì— ëŒ€í•œ ì°¸"
"ì¡°ê°€ ìˆì„ ë•Œë§ˆë‹¤ ì°¸ì¡°ê°€ ê°€ë¦¬í‚¤ëŠ” ë°ì´í„°ì— ëŒ€í•œ ì¶”ê°€ ì •ë³´ë¥¼ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤. **"
"íŒ» í¬ì¸í„°**ì…ë‹ˆë‹¤.  \n"
"`&str`ì˜ ê²½ìš° ê°€ë¦¬í‚¤ëŠ” ìŠ¬ë¼ì´ìŠ¤ì˜ ê¸¸ì´ë¥¼ ì €ì¥í•©ë‹ˆë‹¤. ë’¤ì—ì„œëŠ” DSTì˜ ë” ë§ì€ ì˜ˆ"
"ë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤."

#: src/04_traits/08_sized.md:48
msgid "The `Sized` trait"
msgstr "`Sized` íŠ¸ë ˆì‡"

#: src/04_traits/08_sized.md:50
msgid "Rust's `std` library defines a trait called `Sized`."
msgstr "Rustì˜ `std` ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” `Sized`ë¼ëŠ” íŠ¸ë ˆì‡ì„ ì •ì˜í•©ë‹ˆë‹¤."

#: src/04_traits/08_sized.md:54
msgid "// This is an empty trait, no methods to implement.\n"
msgstr "// ì´ê²ƒì€ ë¹ˆ íŠ¹ì„±ì´ë¯€ë¡œ êµ¬í˜„í•  ë©”ì„œë“œê°€ ì—†ìŠµë‹ˆë‹¤.\n"

#: src/04_traits/08_sized.md:58
msgid ""
"A type is `Sized` if its size is known at compile time. In other words, it's "
"not a DST."
msgstr "ì»´íŒŒì¼ íƒ€ì„ì— í¬ê¸°ê°€ ì•Œë ¤ì§€ë©´ ìœ í˜•ì€ `Sized`ì…ë‹ˆë‹¤. ì¦‰, DSTê°€ ì•„ë‹™ë‹ˆë‹¤."

#: src/04_traits/08_sized.md:60
msgid "Marker traits"
msgstr "Marker íŠ¸ë ˆì‡"

#: src/04_traits/08_sized.md:62
msgid ""
"`Sized` is your first example of a **marker trait**.  \n"
"A marker trait is a trait that doesn't require any methods to be implemented. "
"It doesn't define any behavior. It only serves to **mark** a type as having "
"certain properties. The mark is then leveraged by the compiler to enable "
"certain behaviors or optimizations."
msgstr ""
"`Sized`ëŠ” **marker íŠ¸ë ˆì‡**ì˜ ì²« ë²ˆì§¸ ì˜ˆì…ë‹ˆë‹¤.  \n"
"marker íŠ¸ë ˆì‡ì€ êµ¬í˜„í•˜ëŠ” ë° ë©”ì„œë“œê°€ í•„ìš”í•˜ì§€ ì•Šì€ íŠ¹ì„±ì…ë‹ˆë‹¤. ì–´ë–¤ í–‰ë™ë„ ì •"
"ì˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. íŠ¹ì • ì†ì„±ì´ ìˆëŠ” íƒ€ì…ì„ **í‘œì‹œ**í•˜ëŠ” ì—­í• ë§Œ í•©ë‹ˆë‹¤. ê·¸ëŸ° ë‹¤"
"ìŒ ì»´íŒŒì¼ëŸ¬ëŠ” í‘œì‹œë¥¼ í™œìš©í•˜ì—¬ íŠ¹ì • ë™ì‘ì´ë‚˜ ìµœì í™”ë¥¼ í™œì„±í™”í•©ë‹ˆë‹¤."

#: src/04_traits/08_sized.md:67
msgid "Auto traits"
msgstr "Auto íŠ¸ë ˆì‡"

#: src/04_traits/08_sized.md:69
msgid ""
"In particular, `Sized` is also an **auto trait**.  \n"
"You don't need to implement it explicitly; the compiler implements it "
"automatically for you based on the type's definition."
msgstr ""
"ì‚¬ì‹¤, `Sized`ë„ **auto íŠ¸ë ˆì‡**ì…ë‹ˆë‹¤.  \n"
"ëª…ì‹œì ìœ¼ë¡œ êµ¬í˜„í•  í•„ìš”ê°€ ì—†ìœ¼ë©°, ì»´íŒŒì¼ëŸ¬ê°€ íƒ€ì…ì˜ ì •ì˜ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìë™ìœ¼ë¡œ êµ¬"
"í˜„í•´ì¤ë‹ˆë‹¤."

#: src/04_traits/08_sized.md:73
msgid "Examples"
msgstr "ì˜ˆì‹œ"

#: src/04_traits/08_sized.md:75
msgid ""
"All the types we've seen so far are `Sized`: `u32`, `String`, `bool`, etc."
msgstr ""
"ì§€ê¸ˆê¹Œì§€ ìš°ë¦¬ê°€ ë³¸ ëª¨ë“  íƒ€ì…ì€ `Sized`ì…ë‹ˆë‹¤: `u32`, `String`, `bool` ë“±."

#: src/04_traits/08_sized.md:77
msgid ""
"`str`, as we just saw, is not `Sized`.  \n"
"`&str` is `Sized` though! We know its size at compile time: two `usize`s, one "
"for the pointer and one for the length."
msgstr ""
"ë°©ê¸ˆ ë³¸ ê²ƒì²˜ëŸ¼ `str`ì€ `Sized`ê°€ ì•„ë‹™ë‹ˆë‹¤.  \n"
"í•˜ì§€ë§Œ `&str`ì€ `Sized`ì…ë‹ˆë‹¤! ìš°ë¦¬ëŠ” ì»´íŒŒì¼ íƒ€ì„ì— ê·¸ í¬ê¸°ë¥¼ ì•Œê³  ìˆìŠµë‹ˆë‹¤. "
"ë‘ ê°œì˜ `usize`, í•˜ë‚˜ëŠ” í¬ì¸í„°ìš©ì´ê³  ë‹¤ë¥¸ í•˜ë‚˜ëŠ” ê¸¸ì´ìš©ì…ë‹ˆë‹¤."

#: src/04_traits/08_sized.md:83
msgid ""
"The exercise for this section is located in [`04_traits/08_sized`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/08_sized)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`04_traits/08_sized`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/04_traits/08_sized)ì— ìˆìŠµë‹ˆë‹¤"

#: src/04_traits/09_from.md:1 src/04_traits/09_from.md:27
msgid "`From` and `Into`"
msgstr "`From`ê³¼ `Into`"

#: src/04_traits/09_from.md:3
msgid "Let's go back to where our string journey started:"
msgstr "ë¬¸ìì—´ ì—¬í–‰ì´ ì‹œì‘ëœ ê³³ìœ¼ë¡œ ëŒì•„ê°€ ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/04_traits/09_from.md:6 src/04_traits/09_from.md:106
msgid "\"A title\""
msgstr "\"A title\""

#: src/04_traits/09_from.md:6
msgid "\"A description\""
msgstr "\"A description\""

#: src/04_traits/09_from.md:9
msgid "We now know enough to start unpacking what `.into()` is doing here."
msgstr ""
"ì´ì œ ìš°ë¦¬ëŠ” `.into()`ê°€ ì—¬ê¸°ì„œ ë¬´ì—‡ì„ í•˜ëŠ”ì§€ ì´í•´í•  ë§Œí¼ ì¶©ë¶„íˆ ì•Œê³  ìˆìŠµë‹ˆë‹¤."

#: src/04_traits/09_from.md:13
msgid "This is the signature of the `new` method:"
msgstr "ì´ê²ƒì€ `new` ë©”ì„œë“œì˜ ì‹œê·¸ë‹ˆì²˜ì…ë‹ˆë‹¤:"

#: src/04_traits/09_from.md:23
msgid ""
"We've also seen that string literals (such as `\"A title\"`) are of type "
"`&str`.  \n"
"We have a type mismatch here: a `String` is expected, but we have a `&str`. "
"No magical coercion will come to save us this time; we need **to perform a "
"conversion**."
msgstr ""
"ë¬¸ìì—´ ë¦¬í„°ëŸ´(ì˜ˆ: \"A title\")ì´ `&str` íƒ€ì…ì´ë¼ëŠ” ê²ƒë„ ë³´ì•˜ìŠµë‹ˆë‹¤.\n"
"ì—¬ê¸°ì„œ íƒ€ì… ë¶ˆì¼ì¹˜ê°€ ë°œìƒí•©ë‹ˆë‹¤: `String`ì¼ê²ƒìœ¼ë¡œ ì˜ˆìƒí•˜ì§€ë§Œ ìš°ë¦¬ëŠ” `&str`ì„ "
"ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤. ì´ë²ˆì—ëŠ” ë§ˆë²• ê°™ì€ ê°•ì œ ë³€í™˜ì´ ìš°ë¦¬ë¥¼ êµ¬í•´ì£¼ì§€ ì•Šì„ ê²ƒì…ë‹ˆ"
"ë‹¤; ìš°ë¦¬ëŠ” ì§ì ‘ **ë³€í™˜ì„ ìˆ˜í–‰í•´ì•¼ í•©ë‹ˆë‹¤**."

#: src/04_traits/09_from.md:29
msgid ""
"The Rust standard library defines two traits for **infallible conversions**: "
"`From` and `Into`, in the `std::convert` module."
msgstr ""
"Rust í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” `std::convert` ëª¨ë“ˆì—ì„œ **ë¬´ê²°í•œ ë³€í™˜**ì— ëŒ€í•œ ë‘ ê°€ì§€ "
"íŠ¸ë ˆì‡, ì¦‰ `From`ê³¼ `Into`ë¥¼ ì •ì˜í•©ë‹ˆë‹¤."

#: src/04_traits/09_from.md:42
msgid ""
"These trait definitions showcase a few concepts that we haven't seen before: "
"**supertraits** and **implicit trait bounds**. Let's unpack those first."
msgstr ""
"ì´ëŸ¬í•œ íŠ¸ë ˆì‡ ì •ì˜ëŠ” ì´ì „ì— ë³´ì§€ ëª»í•œ ëª‡ ê°€ì§€ ê°œë…ì¸ **ìŠˆí¼ íŠ¸ë ˆì‡** ë° **ì•”ì‹œ"
"ì  íŠ¸ë ˆì‡ ë°”ìš´ë“œ**ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤. ì´ê²ƒë“¤ì„ ë¨¼ì € ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤."

#: src/04_traits/09_from.md:45
msgid "Supertrait / Subtrait"
msgstr "ìŠˆí¼ íŠ¸ë ˆì‡ / ì„œë¸Œ íŠ¸ë ˆì‡"

#: src/04_traits/09_from.md:47
msgid ""
"The `From: Sized` syntax implies that `From` is a **subtrait** of `Sized`: "
"any type that implements `From` must also implement `Sized`. Alternatively, "
"you could say that `Sized` is a **supertrait** of `From`."
msgstr ""
"`From: Sized` êµ¬ë¬¸ì€ `From`ì´ `Sized`ì˜ **ì„œë¸Œ íŠ¸ë ˆì‡**ì„ì„ ì˜ë¯¸í•©ë‹ˆë‹¤. `From`"
"ì„ êµ¬í˜„í•˜ëŠ” ëª¨ë“  íƒ€ì…ì€ `Sized`ë„ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤. ë˜ëŠ” `Sized`ê°€ `From`ì˜ **"
"ìŠˆí¼ íŠ¸ë ˆì‡**ì´ë¼ê³  ë§í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."

#: src/04_traits/09_from.md:51
msgid "Implicit trait bounds"
msgstr "ì•”ì‹œì  íŠ¸ë ˆì‡ ë°”ìš´ë“œ"

#: src/04_traits/09_from.md:53
msgid ""
"Every time you have a generic type parameter, the compiler implicitly assumes "
"that it's `Sized`."
msgstr ""
"ì¼ë°˜ íƒ€ì… ë§¤ê°œë³€ìˆ˜ê°€ ìˆì„ ë•Œë§ˆë‹¤ ì»´íŒŒì¼ëŸ¬ëŠ” ì•”ì‹œì ìœ¼ë¡œ í•´ë‹¹ ë§¤ê°œë³€ìˆ˜ê°€ `Sized`"
"ë¼ê³  ê°€ì •í•©ë‹ˆë‹¤."

#: src/04_traits/09_from.md:63
msgid "is actually equivalent to:"
msgstr "ì‹¤ì œë¡œëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/04_traits/09_from.md:72
msgid "In the case of `From<T>`, the trait definition is equivalent to:"
msgstr "`From<T>`ì˜ ê²½ìš° íŠ¸ë ˆì‡ ì •ì˜ëŠ” ë‹¤ìŒê³¼ ë™ì¼í•©ë‹ˆë‹¤:"

#: src/04_traits/09_from.md:80
msgid ""
"In other words, _both_ `T` and the type implementing `From<T>` must be "
"`Sized`, even though the former bound is implicit."
msgstr ""
"ì¦‰, `T`ì™€ `From<T>`ë¥¼ êµ¬í˜„í•˜ëŠ” ìœ í˜•ì€ _ë‘˜ ë‹¤_ `Sized`ì—¬ì•¼ í•©ë‹ˆë‹¤. ì „ìì˜ ë°”ìš´"
"ë“œê°€ ì•”ì‹œì ì´ë¼ í• ì§€ë¼ë„ ë§ì´ì£ ."

#: src/04_traits/09_from.md:83
msgid "Negative trait bounds"
msgstr "ë„¤ê±°í‹°ë¸Œ íŠ¸ë ˆì‡ ë°”ìš´ë“œ"

#: src/04_traits/09_from.md:85
msgid ""
"You can opt out of the implicit `Sized` bound with a **negative trait bound**:"
msgstr ""
"**ë„¤ê±°í‹°ë¸Œ íŠ¸ë ˆì‡ ë°”ìš´ë“œ**ë¥¼ ì‚¬ìš©í•˜ì—¬ ì•”ì‹œì  `Sized` ë°”ìš´ë“œë¥¼ ì œì™¸í•  ìˆ˜ ìˆìŠµë‹ˆ"
"ë‹¤."

#: src/04_traits/09_from.md:89
msgid ""
"//            ^^^^^^^\n"
"    //            This is a negative trait bound\n"
msgstr ""
"//            ^^^^^^^\n"
"    //            ì´ê²Œ ë„¤ê±°í‹°ë¸Œ íŠ¸ë ˆì‡ ë°”ìš´ë“œì…ë‹ˆë‹¤\n"

#: src/04_traits/09_from.md:95
msgid ""
"This syntax reads as \"`T` may or may not be `Sized`\", and it allows you to "
"bind `T` to a DST (e.g. `Foo<str>`). It is a special case, though: negative "
"trait bounds are exclusive to `Sized`, you can't use them with other traits."
msgstr ""
"ì´ êµ¬ë¬¸ì€ \"`T`ëŠ” `Sized`ì¼ ìˆ˜ë„ ìˆê³  ì•„ë‹ ìˆ˜ë„ ìˆìŒ\"ìœ¼ë¡œ ì½í˜€ì§€ë©°, ì´ë¥¼ í†µ"
"í•´ `T`ë¥¼ DST(ì˜ˆ: `Foo<str>`)ì— ë°”ì¸ë”©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ì´ê²ƒì€ íŠ¹ë³„í•œ ê²½ìš°"
"ì…ë‹ˆë‹¤. ë„¤ê±°í‹°ë¸Œ íŠ¸ë ˆì‡ ë°”ìš´ë“œëŠ” `Sized`ì—ë§Œ ì ìš©ë˜ë©° ë‹¤ë¥¸ íŠ¹ì„±ì—ëŠ” ì‚¬ìš©í•  ìˆ˜ "
"ì—†ìŠµë‹ˆë‹¤."

#: src/04_traits/09_from.md:99
msgid "`&str` to `String`"
msgstr "`&str`ì„ `String`ìœ¼ë¡œ"

#: src/04_traits/09_from.md:101
msgid ""
"In [`std`'s documentation](https://doc.rust-lang.org/std/convert/trait.From."
"html#implementors) you can see which `std` types implement the `From` "
"trait.  \n"
"You'll find that `String` implements `From<&str> for String`. Thus, we can "
"write:"
msgstr ""
"[`std` ë¬¸ì„œ](https://doc.rust-lang.org/std/convert/trait.From."
"html#implementors)ì—ì„œ ì–´ë–¤ `std` íƒ€ì…ì´ `From` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ëŠ”ì§€ í™•ì¸í•  ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤.  \n"
"`String`ì€ `From<&str> for String`ì„ êµ¬í˜„í•œë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ìš°"
"ë¦¬ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì“¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/04_traits/09_from.md:109
msgid ""
"We've been primarily using `.into()`, though.  \n"
"If you check out the [implementors of `Into`](https://doc.rust-lang.org/std/"
"convert/trait.Into.html#implementors) you won't find `Into<&str> for String`. "
"What's going on?"
msgstr ""
"í•˜ì§€ë§Œ ìš°ë¦¬ëŠ” ì£¼ë¡œ `.into()`ë¥¼ ì‚¬ìš©í•´ ì™”ìŠµë‹ˆë‹¤.  \n"
"`Into` êµ¬í˜„ìë¥¼ í™•ì¸í•´ ë³´ë©´ `Into<&str> for String`ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë¬´ìŠ¨ "
"ì¼ì¼ê¹Œìš”?"

#: src/04_traits/09_from.md:113
msgid ""
"`From` and `Into` are **dual traits**.  \n"
"In particular, `Into` is implemented for any type that implements `From` "
"using a **blanket implementation**:"
msgstr ""
"`From`ê³¼ `Into`ëŠ” **ë“€ì–¼ íŠ¸ë ˆì‡**ì…ë‹ˆë‹¤.  \n"
"íŠ¹íˆ `Into`ëŠ” **ë¸”ë­í‚· êµ¬í˜„**ì„ ì‚¬ìš©í•˜ì—¬ `From`ì„ êµ¬í˜„í•˜ëŠ” ëª¨ë“  íƒ€ì…ì— ëŒ€í•´ êµ¬"
"í˜„ë©ë‹ˆë‹¤."

#: src/04_traits/09_from.md:127
msgid ""
"If a type `U` implements `From<T>`, then `Into<U> for T` is automatically "
"implemented. That's why we can write `let title = \"A title\".into();`."
msgstr ""
"íƒ€ì… `U`ê°€ `From<T>`ë¥¼ êµ¬í˜„í•˜ë©´, `Into<U> for T`ëŠ” ìë™ìœ¼ë¡œ êµ¬í˜„ë©ë‹ˆë‹¤. ê·¸ë˜"
"ì„œ `let title = \"A title\".into();`ì™€ ê°™ì´ ì“¸ ìˆ˜ ìˆëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/04_traits/09_from.md:130
msgid "`.into()`"
msgstr "`.into()`"

#: src/04_traits/09_from.md:132
msgid ""
"Every time you see `.into()`, you're witnessing a conversion between "
"types.  \n"
"What's the target type, though?"
msgstr ""
"`.into()`ë¥¼ ë³¼ ë•Œë§ˆë‹¤ íƒ€ì… ê°„ì˜ ë³€í™˜ì„ ëª©ê²©í•˜ê³  ìˆëŠ” ê²ƒì…ë‹ˆë‹¤.  \n"
"ê·¸ëŸ°ë° ëŒ€ìƒ íƒ€ì…ì€ ë¬´ì—‡ì¼ê¹Œìš”?"

#: src/04_traits/09_from.md:135
msgid "In most cases, the target type is either:"
msgstr "ëŒ€ë¶€ë¶„ì˜ ê²½ìš° ëŒ€ìƒ íƒ€ì…ì€ ë‹¤ìŒ ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤:"

#: src/04_traits/09_from.md:137
msgid ""
"Specified by the signature of a function/method (e.g. `Ticket::new` in our "
"example above)"
msgstr "í•¨ìˆ˜/ë©”ì„œë“œì˜ ì‹œê·¸ë‹ˆì²˜ë¡œ ì§€ì •ëœ ê²ƒ(ì˜ˆ: ì´ì „ ì˜ˆì‹œì˜ `Ticket::new`)"

#: src/04_traits/09_from.md:138
msgid ""
"Specified in the variable declaration with a type annotation (e.g. `let "
"title: String = \"A title\".into();`)"
msgstr ""
"ë³€ìˆ˜ ì„ ì–¸ë•Œ íƒ€ì… ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ ëª…ì‹œëœ ê²ƒ (ì˜ˆ:` let title: String = \"A "
"title\".into();`)"

#: src/04_traits/09_from.md:140
msgid ""
"`.into()` will work out of the box as long as the compiler can infer the "
"target type from the context without ambiguity."
msgstr ""
"`.into()`ëŠ” ì»´íŒŒì¼ëŸ¬ê°€ ëª¨í˜¸í•¨ ì—†ì´ ì»¨í…ìŠ¤íŠ¸ì—ì„œ ëŒ€ìƒ íƒ€ì…ì„ ì¶”ë¡ í•  ìˆ˜ ìˆë‹¤ë©´ "
"ì¦‰ì‹œ ì‘ë™í•©ë‹ˆë‹¤."

#: src/04_traits/09_from.md:144
msgid ""
"The exercise for this section is located in [`04_traits/09_from`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/09_from)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`04_traits/09_from`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/04_traits/09_from)ì— ìˆìŠµë‹ˆë‹¤"

#: src/04_traits/10_assoc_vs_generic.md:1
msgid "Generics and associated types"
msgstr "ì œë„¤ë¦­ê³¼ ì—°ê´€ëœ íƒ€ì…"

#: src/04_traits/10_assoc_vs_generic.md:3
msgid ""
"Let's re-examine the definition for two of the traits we studied so far, "
"`From` and `Deref`:"
msgstr ""
"ì§€ê¸ˆê¹Œì§€ ê³µë¶€í•œ ë‘ ê°€ì§€ íŠ¸ë ˆì‡ì¸ `From`ê³¼ `Deref`ì— ëŒ€í•œ ì •ì˜ë¥¼ ë‹¤ì‹œ ì‚´í´ë³´ê² "
"ìŠµë‹ˆë‹¤:"

#: src/04_traits/10_assoc_vs_generic.md:17
msgid ""
"They both feature type parameters.  \n"
"In the case of `From`, it's a generic parameter, `T`.  \n"
"In the case of `Deref`, it's an associated type, `Target`."
msgstr ""
"ë‘˜ ë‹¤ ê¸°ëŠ¥ ìœ í˜• ë§¤ê°œë³€ìˆ˜ì…ë‹ˆë‹¤.  \n"
"`From`ì˜ ê²½ìš°ì—ëŠ” ì œë„¤ë¦­ ë§¤ê°œë³€ìˆ˜ì¸ `T`ì…ë‹ˆë‹¤.  \n"
"`Deref`ì˜ ê²½ìš° ì—°ê´€ëœ íƒ€ì…ì¸ `Target`ì…ë‹ˆë‹¤."

#: src/04_traits/10_assoc_vs_generic.md:21
msgid "What's the difference? Why use one over the other?"
msgstr "ë­ê°€ ë‹¤ë¥¼ê¹Œìš”? ì™œ ë‘ ê°œë¥¼ êµ¬ë¶„í•´ì„œ ì“¸ê¹Œìš”?"

#: src/04_traits/10_assoc_vs_generic.md:23
msgid "At most one implementation"
msgstr "ìµœëŒ€ 1ê°œì˜ êµ¬í˜„"

#: src/04_traits/10_assoc_vs_generic.md:25
msgid ""
"Due to how deref coercion works, there can only be one \"target\" type for a "
"given type. E.g. `String` can only deref to `str`. It's about avoiding "
"ambiguity: if you could implement `Deref` multiple times for a type, which "
"`Target` type should the compiler choose when you call a `&self` method?"
msgstr ""
"Deref coercionê°€ ì‘ë™í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ì¸í•´ íŠ¹ì • íƒ€ì…ì— ëŒ€í•´ í•˜ë‚˜ì˜ \"ëŒ€ìƒ\" íƒ€ì…"
"ë§Œ ì¡´ì¬í•´ì•¼í•©ë‹ˆë‹¤. ì˜ˆ: `String`ì€ `str`ë¡œë§Œ ì—­ì°¸ì¡°ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ëª¨í˜¸í•¨ì„ í”¼"
"í•˜ê¸° ìœ„í•¨ì…ë‹ˆë‹¤. í•œ íƒ€ì…ì— ëŒ€í•´ `Deref`ë¥¼ ì—¬ëŸ¬ ë²ˆ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤ë©´ `&self` ë©”"
"ì„œë“œë¥¼ í˜¸ì¶œí•  ë•Œ ì»´íŒŒì¼ëŸ¬ê°€ ì–´ë–¤ `Target` íƒ€ì…ì„ ì„ íƒí•´ì•¼ í• ê¹Œìš”?"

#: src/04_traits/10_assoc_vs_generic.md:30
msgid ""
"That's why `Deref` uses an associated type, `Target`.  \n"
"An associated type is uniquely determined **by the trait implementation**. "
"Since you can't implement `Deref` more than once, you'll only be able to "
"specify one `Target` for a given type and there won't be any ambiguity."
msgstr ""
"ì´ê²ƒì´ `Deref`ê°€ ì—°ê´€ íƒ€ì…ì¸ `Target`ì„ ì‚¬ìš©í•˜ëŠ” ì´ìœ ì…ë‹ˆë‹¤.  \n"
"ì—°ê´€ íƒ€ì…ì€ **íŠ¹ì„± êµ¬í˜„ì— ì˜í•´** ê³ ìœ í•˜ê²Œ ê²°ì •ë©ë‹ˆë‹¤. `Deref`ë¥¼ ë‘ ë²ˆ ì´ìƒ êµ¬"
"í˜„í•  ìˆ˜ ì—†ê¸° ë•Œë¬¸ì— ì£¼ì–´ì§„ íƒ€ì…ì— ëŒ€í•´ í•˜ë‚˜ì˜ `Target`ë§Œ ì§€ì •í•  ìˆ˜ ìˆìœ¼ë©° ëª¨í˜¸"
"ì„±ì€ ì—†ìŠµë‹ˆë‹¤."

#: src/04_traits/10_assoc_vs_generic.md:35
msgid "Generic traits"
msgstr "ì œë„¤ë¦­ íŠ¸ë ˆì‡"

#: src/04_traits/10_assoc_vs_generic.md:37
msgid ""
"On the other hand, you can implement `From` multiple times for a type, **as "
"long as the input type `T` is different**. For example, you can implement "
"`From` for `WrappingU32` using both `u32` and `u16` as input types:"
msgstr ""
"ë°˜ë©´ì— **ì…ë ¥ íƒ€ì… `T`ê°€ ë‹¤ë¥¸ í•œ** í•œ íƒ€ì…ì— ëŒ€í•´ `From`ì„ ì—¬ëŸ¬ ë²ˆ êµ¬í˜„í•  ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ `u32`ì™€ `u16`ì„ ëª¨ë‘ ì…ë ¥ íƒ€ì…ìœ¼ë¡œ ì‚¬ìš©í•˜ì—¬ `WrappingU32`"
"ì— ëŒ€í•´ `From`ì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/04_traits/10_assoc_vs_generic.md:54
msgid ""
"This works because `From<u16>` and `From<u32>` are considered **different "
"traits**.  \n"
"There is no ambiguity: the compiler can determine which implementation to use "
"based on type of the value being converted."
msgstr ""
"ì´ëŠ” `From<u16>`ê³¼ `From<u32>`ê°€ **ë‹¤ë¥¸ íŠ¸ë ˆì‡**ìœ¼ë¡œ ê°„ì£¼ë˜ê¸° ë•Œë¬¸ì— ì‘ë™í•©ë‹ˆ"
"ë‹¤.  \n"
"ëª¨í˜¸ì„±ì€ ì—†ìŠµë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” ë³€í™˜ë˜ëŠ” ê°’ì˜ íƒ€ì…ì— ë”°ë¼ ì‚¬ìš©í•  êµ¬í˜„ì„ ê²°ì •í•  "
"ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/04_traits/10_assoc_vs_generic.md:57
msgid "Case study: `Add`"
msgstr "ì‚¬ë¡€ ì—°êµ¬: `Add`"

#: src/04_traits/10_assoc_vs_generic.md:59
msgid ""
"As a closing example, consider the `Add` trait from the standard library:"
msgstr "ë§ˆì§€ë§‰ ì˜ˆë¡œ, í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ `Add` íŠ¸ë ˆì‡ì„ ìƒê°í•´ë´…ì‹œë‹¤:"

#: src/04_traits/10_assoc_vs_generic.md:69
msgid "It uses both mechanisms:"
msgstr "ë‘ ê°€ì§€ ë©”ì»¤ë‹ˆì¦˜ì„ ëª¨ë‘ ì‚¬ìš©í•©ë‹ˆë‹¤:"

#: src/04_traits/10_assoc_vs_generic.md:71
msgid ""
"it has a generic parameter, `RHS` (right-hand side), which defaults to `Self`"
msgstr ""
"ì—¬ê¸°ì—ëŠ” `RHS`(ì˜¤ë¥¸ìª½)ë¼ëŠ” ì œë„¤ë¦­ ë§¤ê°œë³€ìˆ˜ê°€ ìˆìœ¼ë©° ê¸°ë³¸ê°’ì€ `Self`ì…ë‹ˆë‹¤"

#: src/04_traits/10_assoc_vs_generic.md:72
msgid ""
"it has an associated type, `Output`, the type of the result of the addition"
msgstr "ì—¬ê¸°ì—ëŠ” ë§ì…ˆì˜ ê²°ê³¼ íƒ€ì…ì¸ `Output`ì´ë¼ëŠ” ì—°ê´€ íƒ€ì…ì´ ìˆìŠµë‹ˆë‹¤."

#: src/04_traits/10_assoc_vs_generic.md:74
msgid "`RHS`"
msgstr "`RHS`"

#: src/04_traits/10_assoc_vs_generic.md:76
msgid ""
"`RHS` is a generic parameter to allow for different types to be added "
"together.  \n"
"For example, you'll find these two implementations in the standard library:"
msgstr ""
"`RHS`ëŠ” ë‹¤ì–‘í•œ íƒ€ì…ì„ í•¨ê»˜ ë”í•  ìˆ˜ ìˆëŠ” ì œë„¤ë¦­ ë§¤ê°œë³€ìˆ˜ì…ë‹ˆë‹¤.  \n"
"ì˜ˆë¥¼ ë“¤ì–´ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ë‹¤ìŒ ë‘ ê°€ì§€ êµ¬í˜„ì„ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/04_traits/10_assoc_vs_generic.md:84
msgid ""
"//                      ^^^\n"
"      // This could be written as `Self::Output` instead.\n"
"      // The compiler doesn't care, as long as the type you\n"
"      // specify here matches the type you assigned to `Output` \n"
"      // right above.\n"
"      // [...]\n"
msgstr ""
"//                      ^^^\n"
"      // ëŒ€ì‹  `Self::Output`ìœ¼ë¡œ ì“¸ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.\n"
"      // ì—¬ê¸°ì— ì§€ì •í•œ íƒ€ì…ì´\n"
"      // ë°”ë¡œ ìœ„ì˜ `Output`ì— í• ë‹¹í•œ \n"
"      // íƒ€ì…ê³¼ ì¼ì¹˜í•˜ëŠ” í•œ ì»´íŒŒì¼ëŸ¬ëŠ” ìƒê´€í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n"
"      // [...]\n"

#: src/04_traits/10_assoc_vs_generic.md:102
msgid "This allows the following code to compile:"
msgstr "ì´ë¥¼ í†µí•´ ë‹¤ìŒ ì½”ë“œë¥¼ ì»´íŒŒì¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/04_traits/10_assoc_vs_generic.md:108
msgid "because `u32` implements `Add<&u32>` _as well as_ `Add<u32>`."
msgstr ""
"ì™œëƒí•˜ë©´ `u32`ëŠ” `Add<u32>` _ë¿ë§Œ ì•„ë‹ˆë¼_ `Add<&u32>`ë„ êµ¬í˜„í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/04_traits/10_assoc_vs_generic.md:110
msgid "`Output`"
msgstr "`Output`"

#: src/04_traits/10_assoc_vs_generic.md:112
msgid "`Output` represents the type of the result of the addition."
msgstr "'Output'ì€ ë§ì…ˆ ê²°ê³¼ì˜ íƒ€ì…ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤."

#: src/04_traits/10_assoc_vs_generic.md:114
msgid ""
"Why do we need `Output` in the first place? Can't we just use `Self` as "
"output, the type implementing `Add`? We could, but it would limit the "
"flexibility of the trait. In the standard library, for example, you'll find "
"this implementation:"
msgstr ""
"ì• ì´ˆì— `Output`ì´ í•„ìš”í•œ ì´ìœ ëŠ” ë¬´ì—‡ì…ë‹ˆê¹Œ? `Self`ë¥¼ ì•„ì›ƒí’‹ìœ¼ë¡œ `Add`ë¥¼ êµ¬í˜„í•˜"
"ëŠ” íƒ€ì…ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ëŠ” ì—†ë‚˜ìš”? í•  ìˆ˜ëŠ” ìˆì§€ë§Œ íŠ¸ë ˆì‡ì˜ ìœ ì—°ì„±ì´ ì œí•œë©ë‹ˆë‹¤. "
"ì˜ˆë¥¼ ë“¤ì–´ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ êµ¬í˜„ì„ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/04_traits/10_assoc_vs_generic.md:128
msgid ""
"The type they're implementing the trait for is `&u32`, but the result of the "
"addition is `u32`.  \n"
"It would be impossible[^flexible] to provide this implementation if `add` had "
"to return `Self`, i.e. `&u32` in this case. `Output` lets `std` decouple the "
"implementor from the return type, thus supporting this case."
msgstr ""
"íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ëŠ” íƒ€ì…ì€ `&u32`ì´ì§€ë§Œ ë§ì…ˆ ê²°ê³¼ëŠ” `u32`ì…ë‹ˆë‹¤.  \n"
"`add`ê°€ `Self`ë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤ë©´(ì˜ˆ: ì´ ê²½ìš° `&u32`) ì´ êµ¬í˜„ì„ ì œê³µí•˜ëŠ” ê²ƒì€ "
"ë¶ˆê°€ëŠ¥[^flexible]í•©ë‹ˆë‹¤. `Output`ì„ ì‚¬ìš©í•˜ë©´ `std`ê°€ êµ¬í˜„ìë¥¼ ë°˜í™˜ íƒ€ì…ì—ì„œ ë¶„"
"ë¦¬í•˜ì—¬ ì´ ì¼€ì´ìŠ¤ë¥¼ ì§€ì›í•©ë‹ˆë‹¤."

#: src/04_traits/10_assoc_vs_generic.md:132
msgid ""
"On the other hand, `Output` can't be a generic parameter. The output type of "
"the operation **must** be uniquely determined once the types of the operands "
"are known. That's why it's an associated type: for a given combination of "
"implementor and generic parameters, there is only one `Output` type."
msgstr ""
"ë°˜ë©´ì— `Output`ì€ ì œë„¤ë¦­ ë§¤ê°œë³€ìˆ˜ê°€ ë  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì—°ì‚°ì˜ ì¶œë ¥ íƒ€ì…ì€ í”¼ì—°ì‚°"
"ìì˜ íƒ€ì…ì„ ì•Œê³  ë‚˜ë©´ **ë°˜ë“œì‹œ** ê³ ìœ í•˜ê²Œ ê²°ì •ë˜ì–´ì•¼ í•©ë‹ˆë‹¤. ì´ê²ƒì´ ì—°ê´€ íƒ€ì…"
"ì¸ ì´ìœ ì…ë‹ˆë‹¤. êµ¬í˜„ìì™€ ì œë„¤ë¦­ ë§¤ê°œë³€ìˆ˜ì˜ íŠ¹ì • ì¡°í•©ì— ëŒ€í•´ `Output` íƒ€ì…ì€ í•˜"
"ë‚˜ë§Œ ì¡´ì¬í•©ë‹ˆë‹¤."

#: src/04_traits/10_assoc_vs_generic.md:136
msgid "Conclusion"
msgstr "ê²°ë¡ "

#: src/04_traits/10_assoc_vs_generic.md:138
msgid "To recap:"
msgstr "ìš”ì•½í•˜ìë©´:"

#: src/04_traits/10_assoc_vs_generic.md:140
msgid ""
"Use an **associated type** when the type must be uniquely determined for a "
"given trait implementation."
msgstr ""
"íŠ¹ì • íŠ¸ë ˆì‡ êµ¬í˜„ì— ëŒ€í•´ íƒ€ì…ì„ ê³ ìœ í•˜ê²Œ ê²°ì •í•´ì•¼ í•˜ëŠ” ê²½ìš° **ì—°ê´€ íƒ€ì…**ì„ ì‚¬"
"ìš©í•˜ì„¸ìš”."

#: src/04_traits/10_assoc_vs_generic.md:141
msgid ""
"Use a **generic parameter** when you want to allow multiple implementations "
"of the trait for the same type, with different input types."
msgstr ""
"ë‹¤ì–‘í•œ ì…ë ¥ íƒ€ì…ì„ ì‚¬ìš©í•˜ì—¬ ë™ì¼í•œ íƒ€ì…ì— ëŒ€í•œ íŠ¸ë ˆì‡ì˜ ì—¬ëŸ¬ êµ¬í˜„ì„ í—ˆìš©í•˜ë ¤"
"ë©´ **ì œë„¤ë¦­ ë§¤ê°œë³€ìˆ˜**ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”."

#: src/04_traits/10_assoc_vs_generic.md:144
msgid ""
"Flexibility is rarely free: the trait definition is more complex due to "
"`Output`, and implementors have to reason about what they want to return. The "
"trade-off is only justified if that flexibility is actually needed. Keep that "
"in mind when designing your own traits."
msgstr ""
"ìœ ì—°ì„±ì´ ê³µì§œì¸ ê²½ìš°ëŠ” ê±°ì˜ ì—†ìŠµë‹ˆë‹¤. íŠ¸ë ˆì‡ ì •ì˜ëŠ” 'Output'ìœ¼ë¡œ ì¸í•´ ë” ë³µì¡"
"í•˜ë©° êµ¬í˜„ìëŠ” ë°˜í™˜í•˜ë ¤ëŠ” í•­ëª©ì— ëŒ€í•´ ì¶”ë¡ í•´ì•¼ í•©ë‹ˆë‹¤. ìœ ì—°ì„±ì´ ì‹¤ì œë¡œ í•„ìš”í•œ "
"ê²½ìš°ì—ë§Œ ì ˆì¶©ì´ ì •ë‹¹í™”ë©ë‹ˆë‹¤. ìì‹ ë§Œì˜ íŠ¸ë ˆì‡ì„ ë””ìì¸í•  ë•Œ ì´ ì ì„ ëª…ì‹¬í•˜ì„¸"
"ìš”."

#: src/04_traits/10_assoc_vs_generic.md:150
msgid ""
"The exercise for this section is located in [`04_traits/10_assoc_vs_generic`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/10_assoc_vs_generic)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`04_traits/10_assoc_vs_generic`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/10_assoc_vs_generic)ì— ìˆìŠµë‹ˆë‹¤"

#: src/04_traits/11_clone.md:1
msgid "Copying values, pt. 1"
msgstr "ê°’ ë³µì‚¬, pt. 1"

#: src/04_traits/11_clone.md:3
msgid ""
"In the previous chapter we introduced ownership and borrowing.  \n"
"We stated, in particular, that:"
msgstr ""
"ì´ì „ ì¥ì—ì„œëŠ” ì†Œìœ ê¶Œê³¼ ì°¨ìš©ì— ëŒ€í•´ ì†Œê°œí–ˆìŠµë‹ˆë‹¤.  \n"
"ìš°ë¦¬ëŠ” íŠ¹íˆ ë‹¤ìŒê³¼ ê°™ì´ ë§í–ˆìŠµë‹ˆë‹¤:"

#: src/04_traits/11_clone.md:6
msgid "Every value in Rust has a single owner at any given time."
msgstr "Rustì˜ ëª¨ë“  ê°’ì€ ì–¸ì œë“ ì§€ ë‹¨ì¼ ì†Œìœ ìë¥¼ ê°–ìŠµë‹ˆë‹¤."

#: src/04_traits/11_clone.md:7
msgid ""
"When a function takes ownership of a value (\"it consumes it\"), the caller "
"can't use that value anymore."
msgstr ""
"í•¨ìˆ˜ê°€ ê°’ì˜ ì†Œìœ ê¶Œì„ ê°€ì ¸ì˜¤ë©´(\"ì‚¬ìš©í•¨\") í˜¸ì¶œìëŠ” ë” ì´ìƒ í•´ë‹¹ ê°’ì„ ì‚¬ìš©í•  "
"ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/04_traits/11_clone.md:9
msgid ""
"These restrictions can be somewhat limiting.  \n"
"Sometimes we might have to call a function that takes ownership of a value, "
"but we still need to use that value afterward."
msgstr ""
"ì´ëŸ¬í•œ ì œí•œì€ ë‹¤ì†Œ ì œí•œì ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"ë•Œë¡œëŠ” ê°’ì˜ ì†Œìœ ê¶Œì„ ê°–ëŠ” í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ì•¼ í•  ìˆ˜ë„ ìˆì§€ë§Œ ë‚˜ì¤‘ì— ê·¸ ê°’ì„ ì‚¬ìš©í•´"
"ì•¼ í•˜ëŠ” ê²½ìš°ë„ ìˆìŠµë‹ˆë‹¤."

#: src/04_traits/11_clone.md:14 src/04_traits/11_clone.md:42
#: src/04_traits/12_copy.md:6 src/05_ticket_v2/03_variants_with_data.md:42
#: src/08_futures/03_runtime.md:52 src/08_futures/04_future.md:12
#: src/08_futures/07_cancellation.md:35 src/08_futures/07_cancellation.md:36
msgid "/* */"
msgstr "/* */"

#: src/04_traits/11_clone.md:17 src/04_traits/11_clone.md:45
msgid "\"hello\""
msgstr "\"hello\""

#: src/04_traits/11_clone.md:19 src/04_traits/11_clone.md:48
msgid "\", world!\""
msgstr "\", world!\""

#: src/04_traits/11_clone.md:19
msgid "// error: value borrowed here after move\n"
msgstr "// ì˜¤ë¥˜: ì†Œìœ ê¶Œ ì´ì „ í›„ ë¹Œë¦° ê°’\n"

#: src/04_traits/11_clone.md:23
msgid "That's where `Clone` comes in."
msgstr "ì´ê³³ì´ ë°”ë¡œ `Clone`ì´ í•„ìš”í•œ ê³³ì…ë‹ˆë‹¤."

#: src/04_traits/11_clone.md:25
msgid "`Clone`"
msgstr "`Clone`"

#: src/04_traits/11_clone.md:27
msgid "`Clone` is a trait defined in Rust's standard library:"
msgstr "`Clone`ì€ Rustì˜ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ì •ì˜ëœ íŠ¸ë ˆì‡ì…ë‹ˆë‹¤:"

#: src/04_traits/11_clone.md:35
msgid ""
"Its method, `clone`, takes a reference to `self` and returns a new **owned** "
"instance of the same type."
msgstr ""
"í•´ë‹¹ ë©”ì„œë“œ `clone`ì€ `self`ì— ëŒ€í•œ ì°¸ì¡°ë¥¼ ê°€ì ¸ì™€ ë™ì¼í•œ íƒ€ì…ì˜ ìƒˆë¡œìš´ **ì†Œìœ "
"** ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."

#: src/04_traits/11_clone.md:37
msgid "In action"
msgstr "ì‚¬ìš© ì‚¬ë¡€"

#: src/04_traits/11_clone.md:39
msgid ""
"Going back to the example above, we can use `clone` to create a new `String` "
"instance before calling `consumer`:"
msgstr ""
"ìœ„ì˜ ì˜ˆì‹œë¡œ ëŒì•„ê°€ì„œ, `consumer`ë¥¼ í˜¸ì¶œí•˜ê¸° ì „ì— `clone`ì„ ì‚¬ìš©í•˜ì—¬ ìƒˆë¡œìš´ "
"`String` ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/04_traits/11_clone.md:48
msgid "// no error\n"
msgstr "// ì˜¤ë¥˜ ì—†ìŒ\n"

#: src/04_traits/11_clone.md:52
msgid ""
"Instead of giving ownership of `s` to `consumer`, we create a new `String` "
"(by cloning `s`) and give that to `consumer` instead.  \n"
"`s` remains valid and usable after the call to `consumer`."
msgstr ""
"`s`ì˜ ì†Œìœ ê¶Œì„ `consumer`ì— ë¶€ì—¬í•˜ëŠ” ëŒ€ì‹ , ìƒˆë¡œìš´ `String`ì„ ìƒì„±í•˜ê³ (`s`ë¥¼ ë³µ"
"ì œí•˜ì—¬) ì´ë¥¼ ëŒ€ì‹  `consumer`ì— ì œê³µí•©ë‹ˆë‹¤.  \n"
"`s`ëŠ” `consumer`ë¥¼ í˜¸ì¶œí•œ í›„ì—ë„ ìœ íš¨í•˜ê³  ì‚¬ìš© ê°€ëŠ¥í•œ ìƒíƒœë¡œ ìœ ì§€ë©ë‹ˆë‹¤."

#: src/04_traits/11_clone.md:56
msgid "In memory"
msgstr "ë©”ëª¨ë¦¬ì—ì„œëŠ”"

#: src/04_traits/11_clone.md:58
msgid ""
"Let's look at what happened in memory in the example above. When `let mut s: "
"String::from(\"hello\");` is executed, the memory looks like this:"
msgstr ""
"ìœ„ ì˜ˆì œì—ì„œ ë©”ëª¨ë¦¬ì—ì„œ ë¬´ìŠ¨ ì¼ì´ ì¼ì–´ë‚¬ëŠ”ì§€ ì‚´í´ë´…ì‹œë‹¤. `let mut s: String::"
"from(\"hello\");`ê°€ ì‹¤í–‰ë˜ë©´, ë©”ëª¨ë¦¬ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/04_traits/11_clone.md:75
msgid ""
"When `let t = s.clone()` is executed, a whole new region is allocated on the "
"heap to store a copy of the data:"
msgstr ""
"`let t = s.clone()`ì´ ì‹¤í–‰ë˜ë©´ ë°ì´í„° ë³µì‚¬ë³¸ì„ ì €ì¥í•˜ê¸° ìœ„í•´ ì™„ì „íˆ ìƒˆë¡œìš´ ì˜"
"ì—­ì´ í™ì— í• ë‹¹ë©ë‹ˆë‹¤:"

#: src/04_traits/11_clone.md:91
msgid ""
"If you're coming from a language like Java, you can think of `clone` as a way "
"to create a deep copy of an object."
msgstr ""
"Javaì™€ ê°™ì€ ì–¸ì–´ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš° `clone`ì„ ê°ì²´ì˜ ì „ì²´ ë³µì‚¬ë³¸ì„ ë§Œë“œëŠ” ë°©ë²•ìœ¼"
"ë¡œ ìƒê°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/04_traits/11_clone.md:93
msgid "Implementing `Clone`"
msgstr "`Clone` êµ¬í˜„"

#: src/04_traits/11_clone.md:95
msgid ""
"To make a type `Clone`\\-able, we have to implement the `Clone` trait for "
"it.  \n"
"You almost always implement `Clone` by deriving it:"
msgstr ""
"`Clone` íƒ€ì…ì„ ê°€ëŠ¥í•˜ê²Œ ë§Œë“¤ë ¤ë©´ `Clone` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤.  \n"
"ê±°ì˜ í•­ìƒ `Clone`ì€ íŒŒìƒ ë§¤í¬ë¡œë¡œ êµ¬í˜„í•©ë‹ˆë‹¤."

#: src/04_traits/11_clone.md:101
msgid "// fields\n"
msgstr "// í•„ë“œ\n"

#: src/04_traits/11_clone.md:105
msgid ""
"The compiler implements `Clone` for `MyType` as you would expect: it clones "
"each field of `MyType` individually and then constructs a new `MyType` "
"instance using the cloned fields.  \n"
"Remember that you can use `cargo expand` (or your IDE) to explore the code "
"generated by `derive` macros."
msgstr ""
"ì»´íŒŒì¼ëŸ¬ëŠ” ì˜ˆìƒëŒ€ë¡œ `MyType`ì— ëŒ€í•´ `Clone`ì„ êµ¬í˜„í•©ë‹ˆë‹¤. ì¦‰, `MyType`ì˜ ê° í•„"
"ë“œë¥¼ ê°œë³„ì ìœ¼ë¡œ ë³µì œí•œ ë‹¤ìŒ ë³µì œëœ í•„ë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒˆë¡œìš´ `MyType` ì¸ìŠ¤í„´ìŠ¤ë¥¼ "
"êµ¬ì„±í•©ë‹ˆë‹¤.  \n"
"`cargo expand`(ë˜ëŠ” IDE)ë¥¼ ì‚¬ìš©í•˜ì—¬ `íŒŒìƒ` ë§¤í¬ë¡œì— ì˜í•´ ìƒì„±ëœ ì½”ë“œë¥¼ íƒìƒ‰í•  "
"ìˆ˜ ìˆë‹¤ëŠ” ì ì„ ê¸°ì–µí•˜ì„¸ìš”."

#: src/04_traits/11_clone.md:111
msgid ""
"The exercise for this section is located in [`04_traits/11_clone`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/11_clone)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`04_traits/11_clone`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/04_traits/11_clone)ì— ìˆìŠµë‹ˆë‹¤"

#: src/04_traits/12_copy.md:1
msgid "Copying values, pt. 2"
msgstr "ê°’ ë³µì‚¬, pt. 2"

#: src/04_traits/12_copy.md:3
msgid ""
"Let's consider the same example as before, but with a slight twist: using "
"`u32` rather than `String` as a type."
msgstr ""
"ì´ì „ê³¼ ë™ì¼í•œ ì˜ˆë¥¼ ì•½ê°„ ë³€í˜•í•˜ì—¬ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤. íƒ€ì…ìœ¼ë¡œ `String` ëŒ€ì‹  `u32`"
"ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/04_traits/12_copy.md:15
msgid ""
"It'll compile without errors! What's going on here? What's the difference "
"between `String` and `u32` that makes the latter work without `.clone()`?"
msgstr ""
"ì˜¤ë¥˜ ì—†ì´ ì»´íŒŒì¼ë©ë‹ˆë‹¤! ì—¬ê¸°ì„œ ë¬´ìŠ¨ ì¼ì´ ì¼ì–´ë‚˜ê³  ìˆëŠ” ê±¸ê¹Œìš”? `.clone()` ì—†ì´"
"ë„ ì‘ë™í•˜ë„ë¡ í•˜ëŠ” `String`ê³¼ `u32`ì˜ ì°¨ì´ì ì€ ë¬´ì—‡ì¼ê¹Œìš”?"

#: src/04_traits/12_copy.md:18
msgid "`Copy`"
msgstr "`Copy`"

#: src/04_traits/12_copy.md:20
msgid "`Copy` is another trait defined in Rust's standard library:"
msgstr "`Copy`ëŠ” Rustì˜ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ì •ì˜ëœ ë˜ ë‹¤ë¥¸ íŠ¸ë ˆì‡ì…ë‹ˆë‹¤:"

#: src/04_traits/12_copy.md:26
msgid "It is a marker trait, just like `Sized`."
msgstr "ì´ëŠ” `Sized`ì™€ ë§ˆì°¬ê°€ì§€ë¡œ ë§ˆì»¤ íŠ¸ë ˆì‡ì…ë‹ˆë‹¤."

#: src/04_traits/12_copy.md:28
msgid ""
"If a type implements `Copy`, there's no need to call `.clone()` to create a "
"new instance of the type: Rust does it **implicitly** for you.  \n"
"`u32` is an example of a type that implements `Copy`, which is why the "
"example above compiles without errors: when `consumer(s)` is called, Rust "
"creates a new `u32` instance by performing a **bitwise copy** of `s`, and "
"then passes that new instance to `consumer`. It all happens behind the "
"scenes, without you having to do anything."
msgstr ""
"íƒ€ì…ì´ `Copy`ë¥¼ êµ¬í˜„í•˜ëŠ” ê²½ìš° í•´ë‹¹ íƒ€ì…ì˜ ìƒˆ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ê¸° ìœ„í•´ `."
"clone()`ì„ í˜¸ì¶œí•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤. Rustê°€ ì´ë¥¼ **ì•”ì‹œì ìœ¼ë¡œ** ìˆ˜í–‰í•©ë‹ˆë‹¤.  \n"
"`u32`ëŠ” `Copy`ë¥¼ êµ¬í˜„í•˜ëŠ” íƒ€ì…ì˜ ì˜ˆì…ë‹ˆë‹¤. ì´ê²ƒì´ ìœ„ì˜ ì˜ˆê°€ ì˜¤ë¥˜ ì—†ì´ ì»´íŒŒì¼ë˜"
"ëŠ” ì´ìœ ì…ë‹ˆë‹¤. `consumer(s)`ê°€ í˜¸ì¶œë˜ë©´ Rustê°€ `s`ë¥¼ **ë¹„íŠ¸ ë‹¨ìœ„ ë³µì‚¬**í•´ ìƒˆë¡œ"
"ìš´ `u32` ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•©ë‹ˆë‹¤. ê·¸ë¦¬ê³  ê·¸ ìƒˆ ì¸ìŠ¤í„´ìŠ¤ë¥¼ `consumer`ì— ì „ë‹¬í•©ë‹ˆ"
"ë‹¤. ì´ ëª¨ë“  ì¼ì€ ì‚¬ìš©ìê°€ ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•Šì•„ë„ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤."

#: src/04_traits/12_copy.md:34
msgid "What can be `Copy`?"
msgstr "`Copy`ë€ ë¬´ì—‡ì¼ê¹Œìš”?"

#: src/04_traits/12_copy.md:36
msgid ""
"`Copy` is not equivalent to \"automatic cloning\", although it implies it.  \n"
"Types must meet a few requirements in order to be allowed to implement `Copy`."
msgstr ""
"`Copy`ëŠ” \"ìë™ ë³µì œ\"ë¥¼ ì˜ë¯¸í•˜ì§€ë§Œ \"ìë™ ë³µì œ\"ì™€ ë™ì¼í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.  \n"
"`Copy` êµ¬í˜„ì„ í—ˆìš©í•˜ë ¤ë©´ íƒ€ì…ì´ ëª‡ ê°€ì§€ ìš”êµ¬ ì‚¬í•­ì„ ì¶©ì¡±í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/04_traits/12_copy.md:39
msgid ""
"First of all, it must implement `Clone`, since `Copy` is a subtrait of "
"`Clone`. This makes sense: if Rust can create a new instance of a type "
"_implicitly_, it should also be able to create a new instance _explicitly_ by "
"calling `.clone()`."
msgstr ""
"ìš°ì„  `Copy`ëŠ” `Clone`ì˜ í•˜ìœ„ íŠ¹ì„±ì´ë¯€ë¡œ `Clone`ì„ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤. ì´ëŠ” ë§ì´ "
"ë©ë‹ˆë‹¤: Rustê°€ _ì•”ì‹œì ìœ¼ë¡œ_ íƒ€ì…ì˜ ìƒˆ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•  ìˆ˜ ìˆë‹¤ë©´ `.clone()`"
"ì„ í˜¸ì¶œí•˜ì—¬ _ëª…ì‹œì ìœ¼ë¡œ_ ìƒˆ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•  ìˆ˜ë„ ìˆì–´ì•¼ í•©ë‹ˆë‹¤."

#: src/04_traits/12_copy.md:43
msgid "That's not all, though. A few more conditions must be met:"
msgstr "í•˜ì§€ë§Œ ê·¸ê²Œ ì „ë¶€ëŠ” ì•„ë‹™ë‹ˆë‹¤. ëª‡ ê°€ì§€ ì¡°ê±´ì´ ë” ì¶©ì¡±ë˜ì–´ì•¼ í•©ë‹ˆë‹¤:"

#: src/04_traits/12_copy.md:45
msgid ""
"The type doesn't manage any _additional_ resources (e.g. heap memory, file "
"handles, etc.) beyond the `std::mem::size_of` bytes that it occupies in "
"memory."
msgstr ""
"íƒ€ì…ì´ ë©”ëª¨ë¦¬ì—ì„œ ì°¨ì§€í•˜ëŠ” `std::mem::size_of` ë°”ì´íŠ¸ë¥¼ ì´ˆê³¼í•˜ëŠ” _ì¶”ê°€_ ë¦¬ì†ŒìŠ¤"
"(ì˜ˆ: í™ ë©”ëª¨ë¦¬, íŒŒì¼ í•¸ë“¤ ë“±)ë¥¼ ê´€ë¦¬í•˜ì§€ ì•Šì•„ì•¼í•©ë‹ˆë‹¤."

#: src/04_traits/12_copy.md:47
msgid "The type is not a mutable reference (`&mut T`)."
msgstr "íƒ€ì…ì´ ë³€ê²½ ê°€ëŠ¥í•œ ì°¸ì¡°(`&mut T`)ê°€ ì•„ë‹ˆì–´ì•¼í•©ë‹ˆë‹¤."

#: src/04_traits/12_copy.md:49
msgid ""
"If both conditions are met, then Rust can safely create a new instance of the "
"type by performing a **bitwise copy** of the original instanceâ€”this is often "
"referred to as a `memcpy` operation, after the C standard library function "
"that performs the bitwise copy."
msgstr ""
"ë‘ ì¡°ê±´ì´ ëª¨ë‘ ì¶©ì¡±ë˜ë©´ RustëŠ” ì›ë˜ ì¸ìŠ¤í„´ìŠ¤ì˜ **ë¹„íŠ¸ ë³µì‚¬**ë¥¼ ìˆ˜í–‰í•˜ì—¬ í•´ë‹¹ "
"íƒ€ì…ì˜ ìƒˆ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì•ˆì „í•˜ê²Œ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” C í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ "
"`memcpy` ì‘ì—…ì´ë¼ê³ ë„ í•©ë‹ˆë‹¤. ë¹„íŠ¸ ë‹¨ìœ„ ë³µì‚¬ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤."

#: src/04_traits/12_copy.md:53
msgid "Case study 1: `String`"
msgstr "ì‚¬ë¡€ ì—°êµ¬ 1: `String`"

#: src/04_traits/12_copy.md:55
msgid ""
"`String` is a type that doesn't implement `Copy`.  \n"
"Why? Because it manages an additional resource: the heap-allocated memory "
"buffer that stores the string's data."
msgstr ""
"`String`ì€ `Copy`ë¥¼ êµ¬í˜„í•˜ì§€ ì•ŠëŠ” íƒ€ì…ì…ë‹ˆë‹¤.  \n"
"ì™œì¼ê¹Œìš”? ì¶”ê°€ ë¦¬ì†ŒìŠ¤, ì¦‰ ë¬¸ìì—´ì˜ ë°ì´í„°ë¥¼ ì €ì¥í•˜ëŠ” í™ í• ë‹¹ ë©”ëª¨ë¦¬ ë²„í¼ë¥¼ ê´€"
"ë¦¬í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/04_traits/12_copy.md:58
msgid ""
"Let's imagine that Rust allowed `String` to implement `Copy`.  \n"
"Then, when a new `String` instance is created by performing a bitwise copy of "
"the original instance, both the original and the new instance would point to "
"the same memory buffer:"
msgstr ""
"Rustê°€ `String`ì´ `Copy`ë¥¼ êµ¬í˜„í•˜ë„ë¡ í—ˆìš©í–ˆë‹¤ê³  ìƒìƒí•´ ë´…ì‹œë‹¤.  \n"
"ê·¸ëŸ° ë‹¤ìŒ ì›ë³¸ ì¸ìŠ¤í„´ìŠ¤ì˜ ë¹„íŠ¸ ë‹¨ìœ„ ë³µì‚¬ë¥¼ ìˆ˜í–‰í•˜ì—¬ ìƒˆ `String` ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒ"
"ì„±ë˜ë©´ ì›ë³¸ ì¸ìŠ¤í„´ìŠ¤ì™€ ìƒˆ ì¸ìŠ¤í„´ìŠ¤ ëª¨ë‘ ë™ì¼í•œ ë©”ëª¨ë¦¬ ë²„í¼ë¥¼ ê°€ë¦¬í‚µë‹ˆë‹¤:"

#: src/04_traits/12_copy.md:79
msgid ""
"This is bad! Both `String` instances would try to free the memory buffer when "
"they go out of scope, leading to a double-free error. You could also create "
"two distinct `&mut String` references that point to the same memory buffer, "
"violating Rust's borrowing rules."
msgstr ""
"ì´ê±´ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤! ë‘ `String` ì¸ìŠ¤í„´ìŠ¤ ëª¨ë‘ ìŠ¤ì½”í”„ë¥¼ ë²—ì–´ë‚  ë•Œ ë©”ëª¨ë¦¬ ë²„í¼"
"ë¥¼ í•´ì œí•˜ë ¤ê³  ì‹œë„í•˜ì—¬ ë”ë¸” í”„ë¦¬ ì˜¤ë¥˜ê°€ ë°œìƒí•©ë‹ˆë‹¤. ë˜í•œ ë™ì¼í•œ ë©”ëª¨ë¦¬ ë²„í¼ë¥¼ "
"ê°€ë¦¬í‚¤ëŠ” ë‘ ê°œì˜ ì„œë¡œ ë‹¤ë¥¸ `&mut String` ì°¸ì¡°ë¥¼ ìƒì„±í•˜ì—¬ Rustì˜ ì°¨ìš© ê·œì¹™ì„ ìœ„"
"ë°˜í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."

#: src/04_traits/12_copy.md:85
msgid "Case study 2: `u32`"
msgstr "ì‚¬ë¡€ ì—°êµ¬ 2: `u32`"

#: src/04_traits/12_copy.md:87
msgid ""
"`u32` implements `Copy`. All integer types do, in fact.  \n"
"An integer is \"just\" the bytes that represent the number in memory. There's "
"nothing more! If you copy those bytes, you get another perfectly valid "
"integer instance. Nothing bad can happen, so Rust allows it."
msgstr ""
"`u32`ëŠ” `Copy`ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤. ì‹¤ì œë¡œ ëª¨ë“  ì •ìˆ˜ íƒ€ì…ì´ ê·¸ë ‡ìŠµë‹ˆë‹¤.  \n"
"ì •ìˆ˜ëŠ” ë©”ëª¨ë¦¬ì˜ ìˆ«ìë¥¼ ë‚˜íƒ€ë‚´ëŠ” \"ê·¸ëƒ¥\" ë°”ì´íŠ¸ì…ë‹ˆë‹¤. ê·¸ê²Œ ì „ë¶€ì…ë‹ˆë‹¤! í•´ë‹¹ "
"ë°”ì´íŠ¸ë¥¼ ë³µì‚¬í•˜ë©´ ì™„ë²½í•˜ê²Œ ìœ íš¨í•œ ë˜ ë‹¤ë¥¸ ì •ìˆ˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì–»ê²Œ ë©ë‹ˆë‹¤. ë‚˜ìœ ì¼"
"ì€ ì¼ì–´ë‚  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ RustëŠ” ê·¸ê²ƒì„ í—ˆìš©í•©ë‹ˆë‹¤."

#: src/04_traits/12_copy.md:92
msgid "Case study 3: `&mut u32`"
msgstr "ì‚¬ë¡€ ì—°êµ¬ 3: `&mut u32`"

#: src/04_traits/12_copy.md:94
msgid ""
"When we introduced ownership and mutable borrows, we stated one rule quite "
"clearly: there can only ever be _one_ mutable borrow of a value at any given "
"time.  \n"
"That's why `&mut u32` doesn't implement `Copy`, even though `u32` does."
msgstr ""
"ì†Œìœ ê¶Œê³¼ ë³€ê²½ ê°€ëŠ¥í•œ ì°¨ìš©ì„ ì†Œê°œí•  ë•Œ ìš°ë¦¬ëŠ” í•œ ê°€ì§€ ê·œì¹™ì„ ì•„ì£¼ ëª…í™•í•˜ê²Œ ëª…ì‹œ"
"í–ˆìŠµë‹ˆë‹¤. ì¦‰, ì£¼ì–´ì§„ ì‹œê°„ì— ê°’ì˜ ë³€ê²½ ê°€ëŠ¥í•œ ì°¨ìš©ì€ _í•˜ë‚˜_ë§Œ ìˆì„ ìˆ˜ ìˆë‹¤ëŠ” ê²ƒ"
"ì…ë‹ˆë‹¤.  \n"
"ì´ê²ƒì´ `u32`ê°€ `Copy`ë¥¼ êµ¬í˜„í•˜ë”ë¼ë„ `&mut u32`ëŠ” `Copy`ë¥¼ êµ¬í˜„í•˜ì§€ ì•ŠëŠ” ì´ìœ "
"ì…ë‹ˆë‹¤."

#: src/04_traits/12_copy.md:98
msgid ""
"If `&mut u32` implemented `Copy`, you could create multiple mutable "
"references to the same value and modify it in multiple places at the same "
"time. That'd be a violation of Rust's borrowing rules! It follows that `&mut "
"T` never implements `Copy`, no matter what `T` is."
msgstr ""
"`&mut u32`ê°€ `Copy`ë¥¼ êµ¬í˜„í•œ ê²½ìš° ë™ì¼í•œ ê°’ì— ëŒ€í•œ ì—¬ëŸ¬ ê°œì˜ ë³€ê²½ ê°€ëŠ¥í•œ ì°¸ì¡°"
"ë¥¼ ìƒì„±í•˜ê³  ë™ì‹œì— ì—¬ëŸ¬ ìœ„ì¹˜ì—ì„œ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ê²ƒì€ Rustì˜ ì°¨ìš© ê·œì¹™"
"ì„ ìœ„ë°˜í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤! ë”°ë¼ì„œ `&mut T`ëŠ” `T`ê°€ ë¬´ì—‡ì´ë“  ê´€ê³„ì—†ì´ `Copy`ë¥¼ êµ¬í˜„"
"í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/04_traits/12_copy.md:103
msgid "Implementing `Copy`"
msgstr "`Copy` êµ¬í˜„"

#: src/04_traits/12_copy.md:105
msgid ""
"In most cases, you don't need to manually implement `Copy`. You can just "
"derive it, like this:"
msgstr ""
"ëŒ€ë¶€ë¶„ì˜ ê²½ìš° `Copy`ë¥¼ ìˆ˜ë™ìœ¼ë¡œ êµ¬í˜„í•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤. ë‹¤ìŒê³¼ ê°™ì´ íŒŒìƒì‹œí‚¬ "
"ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/04_traits/12_copy.md:117
msgid ""
"The exercise for this section is located in [`04_traits/12_copy`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/12_copy)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`04_traits/12_copy`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/04_traits/12_copy)ì— ìˆìŠµë‹ˆë‹¤"

#: src/04_traits/13_drop.md:1
msgid "The `Drop` trait"
msgstr "`Drop` íŠ¸ë ˆì‡"

#: src/04_traits/13_drop.md:3
msgid ""
"When we introduced [destructors](../03_ticket_v1/11_destructor.md), we "
"mentioned that the `drop` function:"
msgstr ""
"[ì†Œë©¸ì](../03_ticket_v1/11_destructor.md)ë¥¼ ì†Œê°œí–ˆì„ ë•Œ `drop` í•¨ìˆ˜ì— ëŒ€í•´ ì–¸"
"ê¸‰í–ˆìŠµë‹ˆë‹¤."

#: src/04_traits/13_drop.md:6
msgid ""
"reclaims the memory occupied by the type (i.e. `std::mem::size_of` bytes)"
msgstr ""
"í•´ë‹¹ íƒ€ì…ì´ ì°¨ì§€í•˜ëŠ” ë©”ëª¨ë¦¬ë¥¼ íšŒìˆ˜í•©ë‹ˆë‹¤(ì˜ˆ: `std::mem::size_of` ë°”ì´íŠ¸)."

#: src/04_traits/13_drop.md:7
msgid ""
"cleans up any additional resources that the value might be managing (e.g. the "
"heap buffer of a `String`)"
msgstr "ê°’ì´ ê´€ë¦¬í•  ìˆ˜ ìˆëŠ” ì¶”ê°€ ë¦¬ì†ŒìŠ¤ë¥¼ ì •ë¦¬í•©ë‹ˆë‹¤(ì˜ˆ: `String`ì˜ í™ ë²„í¼)."

#: src/04_traits/13_drop.md:9
msgid "Step 2. is where the `Drop` trait comes in."
msgstr "Step 2.ëŠ” `Drop` íŠ¸ë ˆì‡ì´ í•„ìš”í•œ ê³³ì…ë‹ˆë‹¤."

#: src/04_traits/13_drop.md:17
msgid ""
"The `Drop` trait is a mechanism for you to define _additional_ cleanup logic "
"for your types, beyond what the compiler does for you automatically.  \n"
"Whatever you put in the `drop` method will be executed when the value goes "
"out of scope."
msgstr ""
"`Drop` íŠ¸ë ˆì‡ì€ ì»´íŒŒì¼ëŸ¬ê°€ ìë™ìœ¼ë¡œ ìˆ˜í–‰í•˜ëŠ” ê²ƒ ì´ìƒìœ¼ë¡œ íƒ€ì…ì— ëŒ€í•œ _ì¶”ê°€_ ì •"
"ë¦¬ ë…¼ë¦¬ë¥¼ ì •ì˜í•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜ì…ë‹ˆë‹¤.  \n"
"'drop' ë©”ì„œë“œì— ë¬´ì—‡ì„ ë„£ì—ˆë“  ê°’ì´ ìŠ¤ì½”í”„ë¥¼ ë²—ì–´ë‚˜ë©´ ì‹¤í–‰ë©ë‹ˆë‹¤."

#: src/04_traits/13_drop.md:21
msgid "`Drop` and `Copy`"
msgstr "`Drop`ê³¼ `Copy`"

#: src/04_traits/13_drop.md:23
msgid ""
"When talking about the `Copy` trait, we said that a type can't implement "
"`Copy` if it manages additional resources beyond the `std::mem::size_of` "
"bytes that it occupies in memory."
msgstr ""
"`Copy` íŠ¸ë ˆì‡ì— ëŒ€í•´ ì´ì•¼ê¸°í•  ë•Œ, ë©”ëª¨ë¦¬ì—ì„œ ì°¨ì§€í•˜ëŠ” `std::mem::size_of` ë°”ì´"
"íŠ¸ë¥¼ ì´ˆê³¼í•˜ëŠ” ì¶”ê°€ ë¦¬ì†ŒìŠ¤ë¥¼ ê´€ë¦¬í•˜ëŠ” ê²½ìš° íƒ€ì…ì€ `Copy`ë¥¼ êµ¬í˜„í•  ìˆ˜ ì—†ë‹¤ê³  ë§"
"í–ˆìŠµë‹ˆë‹¤."

#: src/04_traits/13_drop.md:26
msgid ""
"You might wonder: how does the compiler know if a type manages additional "
"resources? That's right: `Drop` trait implementations!  \n"
"If your type has an explicit `Drop` implementation, the compiler will assume "
"that your type has additional resources attached to it and won't allow you to "
"implement `Copy`."
msgstr ""
"íƒ€ì…ì´ ì¶”ê°€ ë¦¬ì†ŒìŠ¤ë¥¼ ê´€ë¦¬í•˜ëŠ”ì§€ ì—¬ë¶€ë¥¼ ì»´íŒŒì¼ëŸ¬ê°€ ì–´ë–»ê²Œ ì•Œ ìˆ˜ ìˆëŠ”ì§€ ê¶ê¸ˆí•  "
"ê²ƒì…ë‹ˆë‹¤. ë§ìŠµë‹ˆë‹¤: `Drop` íŠ¸ë ˆì‡ êµ¬í˜„ì…ë‹ˆë‹¤!  \n"
"íƒ€ì…ì— ëª…ì‹œì ì¸ `Drop` êµ¬í˜„ì´ ìˆëŠ” ê²½ìš° ì»´íŒŒì¼ëŸ¬ëŠ” íƒ€ì…ì— ì¶”ê°€ ë¦¬ì†ŒìŠ¤ê°€ ì²¨ë¶€ë˜"
"ì–´ ìˆë‹¤ê³  ê°€ì •í•˜ê³  `Copy` êµ¬í˜„ì„ í—ˆìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/04_traits/13_drop.md:32
msgid "// This is a unit struct, i.e. a struct with no fields.\n"
msgstr "// ì´ê²ƒì€ ë‹¨ìœ„ êµ¬ì¡°ì²´, ì¦‰ í•„ë“œê°€ ì—†ëŠ” êµ¬ì¡°ì²´ì…ë‹ˆë‹¤.\n"

#: src/04_traits/13_drop.md:38
msgid ""
"// We don't need to do anything here,\n"
"       // it's enough to have an \"empty\" Drop implementation\n"
msgstr ""
"// ì—¬ê¸°ì„œëŠ” ì•„ë¬´ê²ƒë„ í•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤.\n"
"       // \"ë¹ˆ\" Drop êµ¬í˜„ë§Œ ìˆìœ¼ë©´ ì¶©ë¶„í•©ë‹ˆë‹¤.\n"

#: src/04_traits/13_drop.md:44
msgid "The compiler will complain with this error message:"
msgstr "ì»´íŒŒì¼ëŸ¬ëŠ” ë‹¤ìŒ ì˜¤ë¥˜ ë©”ì‹œì§€ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤:"

#: src/04_traits/13_drop.md:56
msgid ""
"The exercise for this section is located in [`04_traits/13_drop`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/13_drop)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`04_traits/13_drop`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/04_traits/13_drop)ì— ìˆìŠµë‹ˆë‹¤"

#: src/04_traits/14_outro.md:3
msgid ""
"We've covered quite a few different traits in this chapterâ€”and we've only "
"scratched the surface! It may feel like you have a lot to remember, but don't "
"worry: you'll bump into these traits so often when writing Rust code that "
"they'll soon become second nature."
msgstr ""
"ìš°ë¦¬ëŠ” ì´ë²ˆ ì¥ì—ì„œ ê½¤ ë§ì€ ë‹¤ë¥¸ íŠ¸ë ˆì‡ë“¤ì„ ë‹¤ë£¨ì—ˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ìš°ë¦¬ëŠ” í‘œë©´ì "
"ì¸ ë¶€ë¶„ë§Œ ì‚´í´ë´¤ìŠµë‹ˆë‹¤! ê¸°ì–µí•  ê²ƒì´ ë§ë‹¤ê³  ëŠê»´ì§ˆ ìˆ˜ë„ ìˆì§€ë§Œ ê±±ì •í•˜ì§€ ë§ˆì‹­ì‹œ"
"ì˜¤. Rust ì½”ë“œë¥¼ ì‘ì„±í•  ë•Œ ì´ëŸ¬í•œ íŠ¸ë ˆì‡ì„ ì•„ì£¼ ë§ì´ ì ‘í•˜ê²Œ ë˜ë¯€ë¡œ ê³§ ë³¸ëŠ¥ì´ "
"ë  ê²ƒì…ë‹ˆë‹¤."

#: src/04_traits/14_outro.md:7
msgid "Closing thoughts"
msgstr "ìƒê° ì •ë¦¬"

#: src/04_traits/14_outro.md:9
msgid ""
"Traits are powerful, but don't overuse them.  \n"
"A few guidelines to keep in mind:"
msgstr ""
"íŠ¸ë ˆì‡ì€ ê°•ë ¥í•˜ì§€ë§Œ ë‚¨ìš©í•˜ì§€ ë§ˆì‹­ì‹œì˜¤.  \n"
"ëª…ì‹¬í•´ì•¼ í•  ëª‡ ê°€ì§€ ì§€ì¹¨:"

#: src/04_traits/14_outro.md:12
msgid ""
"Don't make a function generic if it is always invoked with a single type. It "
"introduces indirection in your codebase, making it harder to understand and "
"maintain."
msgstr ""
"í•­ìƒ ë‹¨ì¼ íƒ€ì…ìœ¼ë¡œ í˜¸ì¶œë˜ëŠ” í•¨ìˆ˜ë¥¼ ì œë„¤ë¦­ í•¨ìˆ˜ë¡œ ë§Œë“¤ì§€ ë§ˆì‹­ì‹œì˜¤. ì½”ë“œë² ì´ìŠ¤"
"ì— ê°„ì ‘ ì°¸ì¡°ê°€ ë„ì…ë˜ì–´ ì´í•´í•˜ê³  ìœ ì§€ ê´€ë¦¬ê°€ ë” ì–´ë ¤ì›Œì§‘ë‹ˆë‹¤."

#: src/04_traits/14_outro.md:14
msgid ""
"Don't create a trait if you only have one implementation. It's a sign that "
"the trait is not needed."
msgstr ""
"êµ¬í˜„ì´ í•˜ë‚˜ë§Œ ìˆëŠ” ê²½ìš° íŠ¸ë ˆì‡ì„ ìƒì„±í•˜ì§€ ë§ˆì„¸ìš”. íŠ¸ë ˆì‡ì´ í•„ìš”í•˜ì§€ ì•Šë‹¤ëŠ” ì‹ "
"í˜¸ì…ë‹ˆë‹¤."

#: src/04_traits/14_outro.md:15
msgid ""
"Implement standard traits for your types (`Debug`, `PartialEq`, etc.) "
"whenever it makes sense. It will make your types more idiomatic and easier to "
"work with, unlocking a lot of functionality provided by the standard library "
"and ecosystem crates."
msgstr ""
"í•„ìš”í•  ë•Œë§ˆë‹¤ íƒ€ì…ì— ëŒ€í•œ í‘œì¤€ íŠ¹ì„±ì„ êµ¬í˜„í•˜ì‹­ì‹œì˜¤(`Debug`, `PartialEq` ë“±). "
"ì´ëŠ” íƒ€ì…ì„ ë”ìš± ê´€ìš©ì ì´ê³  ì‘ì—…í•˜ê¸° ì‰½ê²Œ ë§Œë“¤ì–´ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë° ìƒíƒœê³„ ìƒ"
"ìì—ì„œ ì œê³µí•˜ëŠ” ë§ì€ ê¸°ëŠ¥ì„ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•©ë‹ˆë‹¤."

#: src/04_traits/14_outro.md:18
msgid ""
"Implement traits from third-party crates if you need the functionality they "
"unlock within their ecosystem."
msgstr "ì™¸ë¶€ ìƒíƒœê³„ì˜ ê¸°ëŠ¥ì´ í•„ìš”í•œ ê²½ìš° ì™¸ë¶€ í¬ë ˆì´íŠ¸ì˜ íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ì„¸ìš”."

#: src/04_traits/14_outro.md:19
msgid ""
"Beware of making code generic solely to use mocks in your tests. The "
"maintainability cost of this approach can be high, and it's often better to "
"use a different testing strategy. Check out the [testing masterclass](https://"
"github.com/mainmatter/rust-advanced-testing-workshop) for details on high-"
"fidelity testing."
msgstr ""
"í…ŒìŠ¤íŠ¸ì—ì„œ mockë§Œì„ ìœ„í•´ ì½”ë“œë¥¼ ì¼ë°˜í™”í•˜ì§€ ì•Šë„ë¡ ì£¼ì˜í•˜ì„¸ìš”. ì´ ì ‘ê·¼ ë°©ì‹ì˜ "
"ìœ ì§€ ê´€ë¦¬ ë¹„ìš©ì€ ë†’ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë‹¤ë¥¸ í…ŒìŠ¤íŠ¸ ì „ëµì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ë” ë‚˜ì€ ê²½"
"ìš°ê°€ ë§ìŠµë‹ˆë‹¤. ê³ ì¶©ì‹¤ë„ í…ŒìŠ¤íŠ¸ì— ëŒ€í•œ ìì„¸í•œ ë‚´ìš©ì€ [testing masterclass]"
"(https://github.com/mainmatter/rust-advanced-testing-workshop)ë¥¼ í™•ì¸í•˜ì„¸ìš”."

#: src/04_traits/14_outro.md:24
msgid "Testing your knowledge"
msgstr "ì§€ì‹ í…ŒìŠ¤íŠ¸"

#: src/04_traits/14_outro.md:26
msgid ""
"Before moving on, let's go through one last exercise to consolidate what "
"we've learned. You'll have minimal guidance this timeâ€”just the exercise "
"description and the tests to guide you."
msgstr ""
"ê³„ì† ì§„í–‰í•˜ê¸° ì „ì— ë§ˆì§€ë§‰ ì˜ˆì œì„ í†µí•´ ë°°ìš´ ë‚´ìš©ì„ í†µí•©í•´ ë³´ê² ìŠµë‹ˆë‹¤. ì´ë²ˆì—ëŠ” "
"ìµœì†Œí•œì˜ ì§€ì¹¨ë§Œ ì œê³µë©ë‹ˆë‹¤. ì˜ˆì œ ì„¤ëª…ê³¼ ê°€ì´ë“œí•  í…ŒìŠ¤íŠ¸ë§Œ ì œê³µë©ë‹ˆë‹¤."

#: src/04_traits/14_outro.md:31
msgid ""
"The exercise for this section is located in [`04_traits/14_outro`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/14_outro)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`04_traits/14_outro`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/04_traits/14_outro)ì— ìˆìŠµë‹ˆë‹¤"

#: src/05_ticket_v2/00_intro.md:1
msgid "Modelling A Ticket, pt. 2"
msgstr "Ticket ëª¨ë¸ë§, pt. 2"

#: src/05_ticket_v2/00_intro.md:3
msgid ""
"The `Ticket` struct we worked on in the previous chapters is a good start, "
"but it still screams \"I'm a beginner Rustacean!\"."
msgstr ""
"ì´ì „ ì¥ì—ì„œ ì‘ì—…í•œ `Ticket` êµ¬ì¡°ì²´ëŠ” ì¢‹ì€ ì‹œì‘ì´ì§€ë§Œ ì—¬ì „íˆ \"ë‚˜ëŠ” ì´ˆë³´ì "
"Rustaceanì…ë‹ˆë‹¤!\"ë¼ê³  í‹°ë¥¼ ëƒ…ë‹ˆë‹¤."

#: src/05_ticket_v2/00_intro.md:6
msgid ""
"We'll use this chapter to refine our Rust domain modelling skills. We'll need "
"to introduce a few more concepts along the way:"
msgstr ""
"ìš°ë¦¬ëŠ” ì´ ì¥ì—ì„œ Rust ë„ë©”ì¸ ëª¨ë¸ë§ ê¸°ìˆ ì„ ê°œì„ í•  ê²ƒì…ë‹ˆë‹¤. ê·¸ ê³¼ì •ì—ì„œ ëª‡ ê°€"
"ì§€ ê°œë…ì„ ë” ì†Œê°œí•´ì•¼ í•©ë‹ˆë‹¤:"

#: src/05_ticket_v2/00_intro.md:9
msgid "`enum`s, one of Rust's most powerful features for data modeling"
msgstr "ë°ì´í„° ëª¨ë¸ë§ì„ ìœ„í•œ Rustì˜ ê°€ì¥ ê°•ë ¥í•œ ê¸°ëŠ¥ ì¤‘ í•˜ë‚˜ì¸ `enum`"

#: src/05_ticket_v2/00_intro.md:10
msgid "The `Option` type, to model nullable values"
msgstr "Null í—ˆìš© ê°’ì„ ëª¨ë¸ë§í•˜ëŠ” `Option` íƒ€ì…"

#: src/05_ticket_v2/00_intro.md:11
msgid "The `Result` type, to model recoverable errors"
msgstr "ë³µêµ¬ ê°€ëŠ¥í•œ ì˜¤ë¥˜ë¥¼ ëª¨ë¸ë§í•˜ê¸° ìœ„í•œ `Result` íƒ€ì…"

#: src/05_ticket_v2/00_intro.md:12
msgid "The `Debug` and `Display` traits, for printing"
msgstr "í”„ë¦°íŠ¸ìš© `Debug` ë° `Display` íŠ¸ë ˆì‡"

#: src/05_ticket_v2/00_intro.md:13
msgid "The `Error` trait, to mark error types"
msgstr "ì˜¤ë¥˜ íƒ€ì…ì„ í‘œì‹œí•˜ëŠ” `Error` íŠ¸ë ˆì‡"

#: src/05_ticket_v2/00_intro.md:14
msgid "The `TryFrom` and `TryInto` traits, for fallible conversions"
msgstr "ì˜¤ë¥˜ê°€ ìˆëŠ” ë³€í™˜ì„ ìœ„í•œ `TryFrom`ê³¼ `TryInto` íŠ¸ë ˆì‡"

#: src/05_ticket_v2/00_intro.md:15
msgid ""
"Rust's package system, explaining what's a library, what's a binary, how to "
"use third-party crates"
msgstr ""
"Rustì˜ íŒ¨í‚¤ì§€ ì‹œìŠ¤í…œ, ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ë¬´ì—‡ì¸ì§€, ë°”ì´ë„ˆë¦¬ê°€ ë¬´ì—‡ì¸ì§€, ì™¸ë¶€ í¬ë ˆì´"
"íŠ¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì„ ì„¤ëª…í•©ë‹ˆë‹¤"

#: src/05_ticket_v2/00_intro.md:19
msgid ""
"The exercise for this section is located in [`05_ticket_v2/00_intro`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/00_intro)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`05_ticket_v2/00_intro`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/00_intro)ì— ìˆìŠµë‹ˆë‹¤"

#: src/05_ticket_v2/01_enum.md:1
msgid "Enumerations"
msgstr "ì—´ê±°"

#: src/05_ticket_v2/01_enum.md:3
msgid ""
"Based on the validation logic you wrote [in a previous chapter]"
"(../03_ticket_v1/02_validation.md), there are only a few valid statuses for a "
"ticket: `To-Do`, `InProgress` and `Done`.  \n"
"This is not obvious if we look at the `status` field in the `Ticket` struct "
"or at the type of the `status` parameter in the `new` method:"
msgstr ""
"[ì´ì „ ì¥ì—ì„œ](../03_ticket_v1/02_validation.md) ì‘ì„±í•œ ìœ íš¨ì„± ê²€ì‚¬ ë¡œì§ì— ë”°ë¥´"
"ë©´ í‹°ì¼“ì—ëŠ” `To-Do`, `InProgress`, `Done` ë“± ëª‡ ê°€ì§€ ìœ íš¨í•œ ìƒíƒœë§Œ ìˆìŠµë‹ˆ"
"ë‹¤.  \n"
"`Ticket` êµ¬ì¡°ì²´ì˜ `status` í•„ë“œë‚˜ `new` ë©”ì†Œë“œì˜ `status` ë§¤ê°œë³€ìˆ˜ íƒ€ì…ì„ ë³´"
"ë©´ ì´ëŠ” ëª…í™•í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/01_enum.md:23
msgid ""
"In both cases we're using `String` to represent the `status` field. `String` "
"is a very general typeâ€”it doesn't immediately convey the information that the "
"`status` field has a limited set of possible values. Even worse, the caller "
"of `Ticket::new` will only find out **at runtime** if the status they "
"provided is valid or not."
msgstr ""
"ë‘ ê²½ìš° ëª¨ë‘ `status` í•„ë“œë¥¼ ë‚˜íƒ€ë‚´ê¸° ìœ„í•´ `String`ì„ ì‚¬ìš©í•˜ê³  ìˆìŠµë‹ˆë‹¤. "
"`String`ì€ ë§¤ìš° ì¼ë°˜ì ì¸ íƒ€ì…ì…ë‹ˆë‹¤. `status` í•„ë“œì— ê°€ëŠ¥í•œ ê°’ì´ ì œí•œë˜ì–´ ìˆë‹¤"
"ëŠ” ì •ë³´ë¥¼ ì§ê´€ì ìœ¼ë¡œ ì•Œë ¤ì£¼ì§€ ì•ŠìŠµë‹ˆë‹¤. ë” ë‚˜ìœ ê²ƒì€ `Ticket::new` í˜¸ì¶œìëŠ” ì"
"ì‹ ì´ ì œê³µí•œ ìƒíƒœê°€ ìœ íš¨í•œì§€ **ëŸ°íƒ€ì„**ì—ì„œë§Œ ì•Œì•„ë‚¼ ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/05_ticket_v2/01_enum.md:28
msgid "We can do better than that with **enumerations**."
msgstr "**ì—´ê±°**ë¥¼ ì‚¬ìš©í•˜ë©´ ê·¸ë³´ë‹¤ ë” ë‚˜ì€ ì‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/01_enum.md:30
msgid "`enum`"
msgstr "`enum`"

#: src/05_ticket_v2/01_enum.md:32
msgid ""
"An enumeration is a type that can have a fixed set of values, called "
"**variants**.  \n"
"In Rust, you define an enumeration using the `enum` keyword:"
msgstr ""
"ì—´ê±°í˜•ì€ **variants**ì´ë¼ê³  ë¶ˆë¦¬ëŠ” ê³ ì •ëœ ê°’ ì§‘í•©ì„ ê°€ì§ˆ ìˆ˜ ìˆëŠ” íƒ€ì…ì…ë‹ˆ"
"ë‹¤.  \n"
"Rustì—ì„œëŠ” `enum` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ì—´ê±°í˜•ì„ ì •ì˜í•©ë‹ˆë‹¤:"

#: src/05_ticket_v2/01_enum.md:43
msgid "`enum`, just like `struct`, defines **a new Rust type**."
msgstr "`enum`ì€ `struct`ì™€ ë§ˆì°¬ê°€ì§€ë¡œ **ìƒˆë¡œìš´ Rust íƒ€ì…**ì„ ì •ì˜í•©ë‹ˆë‹¤."

#: src/05_ticket_v2/01_enum.md:47
msgid ""
"The exercise for this section is located in [`05_ticket_v2/01_enum`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/01_enum)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`05_ticket_v2/01_enum`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/01_enum)ì— ìˆìŠµë‹ˆë‹¤"

#: src/05_ticket_v2/02_match.md:1
msgid "`match`"
msgstr "`match`"

#: src/05_ticket_v2/02_match.md:3
msgid ""
"You may be wonderingâ€”what can you actually **do** with an enum?  \n"
"The most common operation is to **match** on it."
msgstr ""
"ì—´ê±°í˜•ì„ ì‚¬ìš©í•˜ì—¬ ì‹¤ì œë¡œ **í•  ìˆ˜ ìˆëŠ”** ì‘ì—…ì´ ë¬´ì—‡ì¸ì§€ ê¶ê¸ˆí•˜ì‹¤ ê²ƒì…ë‹ˆë‹¤.  \n"
"ê°€ì¥ ì¼ë°˜ì ì¸ ì‘ì—…ì€ **match**ì…ë‹ˆë‹¤."

#: src/05_ticket_v2/02_match.md:17
msgid ""
"// The `|` operator lets you match multiple patterns.\n"
"            // It reads as \"either `Status::ToDo` or `Status::"
"InProgress`\".\n"
msgstr ""
"// `|` ì—°ì‚°ìë¥¼ ì‚¬ìš©í•˜ë©´ ì—¬ëŸ¬ íŒ¨í„´ì„ ì¼ì¹˜ì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"            // \"`Status::ToDo` ë˜ëŠ” `Status::InProgress`\"ë¡œ ì¸ì‹í•©ë‹ˆë‹¤.\n"

#: src/05_ticket_v2/02_match.md:25
msgid ""
"A `match` statement that lets you compare a Rust value against a series of "
"**patterns**.  \n"
"You can think of it as a type-level `if`. If `status` is a `Done` variant, "
"execute the first block; if it's a `InProgress` or `ToDo` variant, execute "
"the second block."
msgstr ""
"`match` ë¬¸ì€ ëŸ¬ìŠ¤íŠ¸ ê°’ì„ ì—¬ëŸ¬ íŒ¨í„´ê³¼ ë¹„êµí•  ìˆ˜ ìˆëŠ” êµ¬ë¬¸ì…ë‹ˆë‹¤.\n"
"íƒ€ì… ìˆ˜ì¤€ì—ì„œ ë³¼ ë•Œ, ì´ëŠ” ifë¬¸ìœ¼ë¡œ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë§Œì•½ `status`ê°€ `Done` ë°°ë¦¬"
"ì–¸íŠ¸ë¼ë©´ ì²« ë²ˆì§¸ ë¸”ë¡ì„ ì‹¤í–‰í•˜ê³ , `InProgress` ë˜ëŠ” `ToDo` ë°°ë¦¬ì–¸íŠ¸ë¼ë©´ ë‘ ë²ˆ"
"ì§¸ ë¸”ë¡ì„ ì‹¤í–‰í•©ë‹ˆë‹¤."

#: src/05_ticket_v2/02_match.md:29
msgid "Exhaustiveness"
msgstr "ì² ì €í•¨"

#: src/05_ticket_v2/02_match.md:31
msgid ""
"There's one key detail here: `match` is **exhaustive**. You must handle all "
"enum variants.  \n"
"If you forget to handle a variant, Rust will stop you **at compile-time** "
"with an error."
msgstr ""
"ì—¬ê¸°ì—ëŠ” í•œ ê°€ì§€ ì¤‘ìš”í•œ ì„¸ë¶€ ì‚¬í•­ì´ ìˆìŠµë‹ˆë‹¤: `match`ëŠ” **ì™„ì „**í•˜ë‹¤ëŠ” ê²ƒì…ë‹ˆ"
"ë‹¤. ëª¨ë“  ì—´ê±°í˜• ë°°ë¦¬ì–¸íŠ¸ë¥¼ ì²˜ë¦¬í•´ì•¼ í•©ë‹ˆë‹¤.  \n"
"ë°°ë¦¬ì–¸íŠ¸ ì²˜ë¦¬ë¥¼ ê¹œë¹¡í•˜ë©´ RustëŠ” **ì»´íŒŒì¼ íƒ€ì„**ì— ì˜¤ë¥˜ë¡œ ì¸í•´ ì¤‘ì§€ë©ë‹ˆë‹¤."

#: src/05_ticket_v2/02_match.md:34
msgid "E.g. if we forget to handle the `ToDo` variant:"
msgstr "ì˜ˆ: `ToDo` ë°°ë¦¬ì–¸íŠ¸ë¥¼ ì²˜ë¦¬í•˜ëŠ” ê²ƒì„ ê¹œë¹¡í•œ ê²½ìš°:"

#: src/05_ticket_v2/02_match.md:53
msgid ""
"This is a big deal!  \n"
"Codebases evolve over timeâ€”you might add a new status down the line, e.g. "
"`Blocked`. The Rust compiler will emit an error for every single `match` "
"statement that's missing logic for the new variant. That's why Rust "
"developers often sing the praises of \"compiler-driven refactoring\"â€”the "
"compiler tells you what to do next, you just have to fix what it reports."
msgstr ""
"ì´ê±´ í°ì¼ì´ì—ìš”!  \n"
"ì½”ë“œë² ì´ìŠ¤ëŠ” ì‹œê°„ì´ ì§€ë‚¨ì— ë”°ë¼ ë°œì „í•©ë‹ˆë‹¤. `Blocked`ê°™ì€ ìƒˆë¡œìš´ ìƒíƒœë¥¼ ì¶”ê°€"
"í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. Rust ì»´íŒŒì¼ëŸ¬ëŠ” ìƒˆë¡œìš´ ë°°ë¦¬ì–¸íŠ¸ì— ëŒ€í•œ ë¡œì§ì´ ëˆ„ë½ëœ ëª¨ë“  "
"`match` ë¬¸ì— ëŒ€í•´ ì˜¤ë¥˜ë¥¼ ë‚´ë³´ëƒ…ë‹ˆë‹¤. ì´ê²ƒì´ ë°”ë¡œ Rust ê°œë°œìë“¤ì´ ì¢…ì¢… \"ì»´íŒŒì¼"
"ëŸ¬ ì¤‘ì‹¬ ë¦¬íŒ©í† ë§\"ì„ ì¹­ì°¬í•˜ëŠ” ì´ìœ ì…ë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” ë‹¤ìŒì— ìˆ˜í–‰í•  ì‘ì—…ì„ ì•Œë ¤"
"ì£¼ê³ , ì•Œë ¤ì¤€ ì‘ì—…ì„ ìˆ˜í–‰í•˜ê¸°ë§Œ í•˜ë©´ ë©ë‹ˆë‹¤."

#: src/05_ticket_v2/02_match.md:59
msgid "Catch-all"
msgstr "Catch-all"

#: src/05_ticket_v2/02_match.md:61
msgid ""
"If you don't care about one or more variants, you can use the `_` pattern as "
"a catch-all:"
msgstr ""
"í•˜ë‚˜ ì´ìƒì˜ ë°°ë¦¬ì–¸íŠ¸ì— ê´€ì‹¬ì´ ì—†ë‹¤ë©´ `_` íŒ¨í„´ì„ í¬ê´„ì ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/02_match.md:70
msgid ""
"The `_` pattern matches anything that wasn't matched by the previous patterns."
msgstr "`_` íŒ¨í„´ì€ ì´ì „ íŒ¨í„´ê³¼ ì¼ì¹˜í•˜ì§€ ì•ŠëŠ” ëª¨ë“  í•­ëª©ê³¼ ì¼ì¹˜í•©ë‹ˆë‹¤."

#: src/05_ticket_v2/02_match.md:74
msgid ""
"The exercise for this section is located in [`05_ticket_v2/02_match`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/02_match)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`05_ticket_v2/02_match`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/02_match)ì— ìˆìŠµë‹ˆë‹¤"

#: src/05_ticket_v2/03_variants_with_data.md:1
msgid "Variants can hold data"
msgstr "ë°°ë¦¬ì–¸íŠ¸ëŠ” ë°ì´í„°ë¥¼ ê°€ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤"

#: src/05_ticket_v2/03_variants_with_data.md:11
msgid ""
"Our `Status` enum is what's usually called a **C-style enum**.  \n"
"Each variant is a simple label, a bit like a named constant. You can find "
"this kind of enum in many programming languages, like C, C++, Java, C#, "
"Python, etc."
msgstr ""
"ìš°ë¦¬ì˜ `Status` ì—´ê±°í˜•ì€ ì¼ë°˜ì ìœ¼ë¡œ **C ìŠ¤íƒ€ì¼ ì—´ê±°í˜•**ì´ë¼ê³  ë¶ˆë¦¬ëŠ” ê²ƒì…ë‹ˆ"
"ë‹¤.  \n"
"ê° ë³€í˜•ì€ ëª…ëª…ëœ ìƒìˆ˜ì™€ ì•½ê°„ ìœ ì‚¬í•œ ê°„ë‹¨í•œ ë ˆì´ë¸”ì…ë‹ˆë‹¤. C, C++, Java, C#, "
"Python ë“±ê³¼ ê°™ì€ ë§ì€ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì—ì„œ ì´ëŸ¬í•œ ì¢…ë¥˜ì˜ ì—´ê±°í˜•ì„ ì°¾ì„ ìˆ˜ ìˆìŠµ"
"ë‹ˆë‹¤."

#: src/05_ticket_v2/03_variants_with_data.md:15
msgid ""
"Rust enums can go further though. We can **attach data to each variant**."
msgstr ""
"Rust ì—´ê±°í˜•ì€ ë” ë‚˜ì•„ê°ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤. **ê° ë°°ë¦¬ì–¸íŠ¸ì— ë°ì´í„°ë¥¼ ì²¨ë¶€**í•  ìˆ˜ ìˆìŠµ"
"ë‹ˆë‹¤."

#: src/05_ticket_v2/03_variants_with_data.md:17
msgid "Variants"
msgstr "ë°°ë¦¬ì–¸íŠ¸"

#: src/05_ticket_v2/03_variants_with_data.md:19
msgid ""
"Let's say that we want to store the name of the person who's currently "
"working on a ticket.  \n"
"We would only have this information if the ticket is in progress. It wouldn't "
"be there for a to-do ticket or a done ticket. We can model this by attaching "
"a `String` field to the `InProgress` variant:"
msgstr ""
"í˜„ì¬ í‹°ì¼“ ì‘ì—…ì„ í•˜ê³  ìˆëŠ” ì‚¬ëŒì˜ ì´ë¦„ì„ ì €ì¥í•˜ê³  ì‹¶ë‹¤ê³  ê°€ì •í•´ ë³´ê² ìŠµë‹ˆ"
"ë‹¤.  \n"
"í‹°ì¼“ì´ ì§„í–‰ ì¤‘ì¸ ê²½ìš°ì—ë§Œ ì´ ì •ë³´ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•  ì¼ í‹°ì¼“ì´ë‚˜ ì™„ë£Œëœ í‹°"
"ì¼“ì—ëŠ” ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. `InProgress` ë°°ë¦¬ì–¸íŠ¸ì— `String` í•„ë“œë¥¼ ì—°ê²°í•˜ì—¬ ì´"
"ë¥¼ ëª¨ë¸ë§í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/05_ticket_v2/03_variants_with_data.md:34
msgid ""
"`InProgress` is now a **struct-like variant**.  \n"
"The syntax mirrors, in fact, the one we used to define a structâ€”it's just "
"\"inlined\" inside the enum, as a variant."
msgstr ""
"`InProgress`ëŠ” ì´ì œ **êµ¬ì¡°ì²´ ìœ ì‚¬ ë°°ë¦¬ì–¸íŠ¸**ì…ë‹ˆë‹¤.  \n"
"ì‹¤ì œë¡œ êµ¬ë¬¸ì€ êµ¬ì¡°ì²´ë¥¼ ì •ì˜í•˜ëŠ” ë° ì‚¬ìš©í•œ êµ¬ë¬¸ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. ì¦‰, ë°°ë¦¬ì–¸íŠ¸ë¡œ ì—´"
"ê±°í˜• ë‚´ë¶€ì— \"ì¸ë¼ì¸\"ë˜ì–´ ìˆì„ ë¿ì…ë‹ˆë‹¤."

#: src/05_ticket_v2/03_variants_with_data.md:37
msgid "Accessing variant data"
msgstr "ë°°ë¦¬ì–¸íŠ¸ ë°ì´í„°ì— ì•¡ì„¸ìŠ¤"

#: src/05_ticket_v2/03_variants_with_data.md:39
msgid "If we try to access `assigned_to` on a `Status` instance,"
msgstr "`Status` ì¸ìŠ¤í„´ìŠ¤ì˜ `assigned_to`ì— ì•¡ì„¸ìŠ¤í•˜ë ¤ê³  í•˜ë©´,"

#: src/05_ticket_v2/03_variants_with_data.md:43
msgid "// This won't compile\n"
msgstr "// ì»´íŒŒì¼ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤\n"

#: src/05_ticket_v2/03_variants_with_data.md:45
#: src/05_ticket_v2/03_variants_with_data.md:64
#: src/05_ticket_v2/03_variants_with_data.md:82
msgid "\"Assigned to: {}\""
msgstr "\"Assigned to: {}\""

#: src/05_ticket_v2/03_variants_with_data.md:48
msgid "the compiler will stop us:"
msgstr "ì»´íŒŒì¼ëŸ¬ê°€ ìš°ë¦¬ë¥¼ ë§‰ì„ ê²ƒì…ë‹ˆë‹¤:"

#: src/05_ticket_v2/03_variants_with_data.md:50
msgid ""
"```text\n"
"error[E0609]: no field `assigned_to` on type `Status`\n"
" --> src/main.rs:5:40\n"
"  |\n"
"5 |     println!(\"Assigned to: {}\", status.assigned_to);\n"
"  |                                        ^^^^^^^^^^^ unknown field\n"
"```"
msgstr ""
"```text\n"
"error[E0609]: no field `assigned_to` on type `Status`\n"
" --> src/main.rs:5:40\n"
"  |\n"
"5 |     println!(\"Assigned to: {}\", status.assigned_to);\n"
"  |                                        ^^^^^^^^^^^ unknown field\n"
"```"

#: src/05_ticket_v2/03_variants_with_data.md:58
msgid ""
"`assigned_to` is **variant-specific**, it's not available on all `Status` "
"instances.  \n"
"To access `assigned_to`, we need to use **pattern matching**:"
msgstr ""
"`assigned_to`ëŠ” **íŠ¹ì • ë°°ë¦¬ì–¸íŠ¸**ì— ëŒ€í•œ ê²ƒì´ë¯€ë¡œ ëª¨ë“  `Status` ì¸ìŠ¤í„´ìŠ¤ì—ì„œ "
"ì‚¬ìš©í•  ìˆ˜ëŠ” ì—†ìŠµë‹ˆë‹¤.  \n"
"`assigned_to`ì— ì•¡ì„¸ìŠ¤í•˜ë ¤ë©´ **íŒ¨í„´ ë§¤ì¹­**ì„ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/05_ticket_v2/03_variants_with_data.md:67
#: src/05_ticket_v2/03_variants_with_data.md:85
msgid "\"Done\""
msgstr "\"Done\""

#: src/05_ticket_v2/03_variants_with_data.md:72
msgid "Bindings"
msgstr "ë°”ì¸ë”©"

#: src/05_ticket_v2/03_variants_with_data.md:74
msgid ""
"In the match pattern `Status::InProgress { assigned_to }`, `assigned_to` is a "
"**binding**.  \n"
"We're **destructuring** the `Status::InProgress` variant and binding the "
"`assigned_to` field to a new variable, also named `assigned_to`.  \n"
"If we wanted, we could bind the field to a different variable name:"
msgstr ""
"`Status::InProgress { assigned_to }`ë§¤ì¹˜ íŒ¨í„´ì—ì„œ, `assigned_to`ëŠ” **ë°”ì¸ë”©**"
"ì…ë‹ˆë‹¤.   \n"
"ìš°ë¦¬ëŠ” `Status::InProgress` ë°°ë¦¬ì–¸íŠ¸ë¥¼ **êµ¬ì¡° ë¶„í•´**í•˜ê³  `assigned_to` í•„ë“œë¥¼ "
"`assigned_to`ë¼ëŠ” ìƒˆ ë³€ìˆ˜ì— ë°”ì¸ë”©í•©ë‹ˆë‹¤.  \n"
"ì›í•œë‹¤ë©´ í•„ë“œë¥¼ ë‹¤ë¥¸ ë³€ìˆ˜ ì´ë¦„ì— ë°”ì¸ë”©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/05_ticket_v2/03_variants_with_data.md:92
msgid ""
"The exercise for this section is located in "
"[`05_ticket_v2/03_variants_with_data`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/03_variants_with_data)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`05_ticket_v2/03_variants_with_data`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/03_variants_with_data)ì— ìˆìŠµë‹ˆë‹¤"

#: src/05_ticket_v2/04_if_let.md:1
msgid "Concise branching"
msgstr "ê°„ê²°í•œ ë¶„ê¸°"

#: src/05_ticket_v2/04_if_let.md:3
msgid "Your solution to the previous exercise probably looks like this:"
msgstr "ì´ì „ ì˜ˆì œì— ëŒ€í•œ ì†”ë£¨ì…˜ì€ ì•„ë§ˆë„ ë‹¤ìŒê³¼ ê°™ì„ ê²ƒì…ë‹ˆë‹¤:"

#: src/05_ticket_v2/04_if_let.md:11 src/05_ticket_v2/04_if_let.md:36
#: src/05_ticket_v2/04_if_let.md:51
msgid "\"Only `In-Progress` tickets can be assigned to someone\""
msgstr "\"`In-Progress` í‹°ì¼“ë§Œ ëˆ„êµ°ê°€ì—ê²Œ í• ë‹¹ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤\""

#: src/05_ticket_v2/04_if_let.md:18
msgid ""
"You only care about the `Status::InProgress` variant. Do you really need to "
"match on all the other variants?"
msgstr ""
"ìš°ë¦° `Status::InProgress` ë°°ë¦¬ì–¸íŠ¸ì—ë§Œ ê´€ì‹¬ì´ ìˆìŠµë‹ˆë‹¤. ê¼­ ë‹¤ë¥¸ ëª¨ë“  ë°°ë¦¬ì–¸íŠ¸"
"ë¥¼ ë§¤ì¹­í•´ì•¼í• ê¹Œìš”?"

#: src/05_ticket_v2/04_if_let.md:21
msgid "New constructs to the rescue!"
msgstr "ìš°ë¦¬ë¥¼ êµ¬ì›í•  ìƒˆë¡œìš´ ì¹œêµ¬ì…ë‹ˆë‹¤!"

#: src/05_ticket_v2/04_if_let.md:23
msgid "`if let`"
msgstr "`if let`"

#: src/05_ticket_v2/04_if_let.md:25
msgid ""
"The `if let` construct allows you to match on a single variant of an enum, "
"without having to handle all the other variants."
msgstr ""
"`if let` êµ¬ì¡°ë¥¼ ì‚¬ìš©í•˜ë©´ ë‹¤ë¥¸ ëª¨ë“  ë°°ë¦¬ì–¸íŠ¸ë¥¼ ì²˜ë¦¬í•  í•„ìš” ì—†ì´ ì—´ê±°í˜•ì˜ ë‹¨ì¼ "
"ë°°ë¦¬ì–¸íŠ¸ë¥¼ ë§¤ì¹­í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/04_if_let.md:28
msgid "Here's how you can use `if let` to simplify the `assigned_to` method:"
msgstr ""
"`assigned_to` ë©”ì„œë“œë¥¼ ë‹¨ìˆœí™”í•˜ê¸° ìœ„í•´ `if let`ì„ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì€ ë‹¤ìŒê³¼ ê°™ìŠµ"
"ë‹ˆë‹¤:"

#: src/05_ticket_v2/04_if_let.md:42
msgid "`let/else`"
msgstr "`let/else`"

#: src/05_ticket_v2/04_if_let.md:44
msgid ""
"If the `else` branch is meant to return early (a panic counts as returning "
"early!), you can use the `let/else` construct:"
msgstr ""
"`else` ë¶„ê¸°ê°€ ì¼ì° ë°˜í™˜ë˜ë„ë¡ ì˜ë„ëœ ê²½ìš°(íŒ¨ë‹‰ì€ ì¡°ê¸° ë°˜í™˜ìœ¼ë¡œ ê°„ì£¼ë©ë‹ˆë‹¤!) "
"`let/else` êµ¬ë¬¸ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/05_ticket_v2/04_if_let.md:58
msgid ""
"It allows you to assign the destructured variable without incurring any "
"\"right drift\", i.e. the variable is assigned at the same indentation level "
"as the code that precedes it."
msgstr ""
"ì´ë¥¼ í†µí•´ \"ì˜¤ë¥¸ìª½ ë“œë¦¬í”„íŠ¸\"ë¥¼ ë°œìƒì‹œí‚¤ì§€ ì•Šê³  êµ¬ì¡° í•´ì œëœ ë³€ìˆ˜ë¥¼ í• ë‹¹í•  ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤. ì¦‰, ë³€ìˆ˜ëŠ” ì´ì „ ì½”ë“œì™€ ë™ì¼í•œ ë“¤ì—¬ì“°ê¸° ìˆ˜ì¤€ì—ì„œ í• ë‹¹ë©ë‹ˆë‹¤."

#: src/05_ticket_v2/04_if_let.md:62
msgid "Style"
msgstr "ìŠ¤íƒ€ì¼"

#: src/05_ticket_v2/04_if_let.md:64
msgid ""
"Both `if let` and `let/else` are idiomatic Rust constructs.  \n"
"Use them as you see fit to improve the readability of your code, but don't "
"overdo it: `match` is always there when you need it."
msgstr ""
"`if let`ê³¼ `let/else`ëŠ” ë‘˜ ë‹¤ ê´€ìš©ì ì¸ Rust êµ¬ë¬¸ì…ë‹ˆë‹¤.  \n"
"ì½”ë“œì˜ ê°€ë…ì„±ì„ ë†’ì´ê¸° ìœ„í•´ ì ì ˆí•˜ë‹¤ê³  ìƒê°ë˜ëŠ” ëŒ€ë¡œ ì‚¬ìš©í•˜ë˜, ë„ˆë¬´ ê³¼ë„í•˜ê²Œ "
"ì‚¬ìš©í•˜ì§€ ë§ˆì„¸ìš”. `match`ëŠ” í•­ìƒ í•„ìš”í•  ë•Œ ê·¸ ìë¦¬ì— ìˆìœ¼ë‹ˆê¹Œìš”."

#: src/05_ticket_v2/04_if_let.md:70
msgid ""
"The exercise for this section is located in [`05_ticket_v2/04_if_let`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/04_if_let)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`05_ticket_v2/04_if_let`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/04_if_let)ì— ìˆìŠµë‹ˆë‹¤"

#: src/05_ticket_v2/05_nullability.md:3
msgid ""
"Our implementation of the `assigned` method is fairly blunt: panicking for to-"
"do and done tickets is far from ideal.  \n"
"We can do better using **Rust's `Option` type**."
msgstr ""
"`assigned` ë©”ì†Œë“œì˜ êµ¬í˜„ì€ ìƒë‹¹íˆ ë¬´ëšëší•©ë‹ˆë‹¤. to-do ìƒíƒœì˜ í‹°ì¼“ê³¼ ì™„ë£Œëœ í‹°"
"ì¼“ì— ëŒ€í•´ íŒ¨ë‹‰í•˜ëŠ” ê²ƒì€ ì´ìƒì ì´ì§€ ì•ŠìŠµë‹ˆë‹¤.  \n"
"**Rustì˜ `Option` íƒ€ì…**ì„ ì‚¬ìš©í•˜ë©´ ë” ë‚˜ì€ ê²°ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/05_nullability.md:6
msgid "`Option`"
msgstr "`Option`"

#: src/05_ticket_v2/05_nullability.md:8
msgid ""
"`Option` is a Rust type that represents **nullable values**.  \n"
"It is an enum, defined in Rust's standard library:"
msgstr ""
"`Option`ì€ **nullable ê°’**ì„ ë‚˜íƒ€ë‚´ëŠ” Rust íƒ€ì…ì…ë‹ˆë‹¤.  \n"
"ì´ê²ƒì€ Rustì˜ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ì •ì˜ëœ ì—´ê±°í˜•ì…ë‹ˆë‹¤:"

#: src/05_ticket_v2/05_nullability.md:18
msgid ""
"`Option` encodes the idea that a value might be present (`Some(T)`) or absent "
"(`None`).  \n"
"It also forces you to **explicitly handle both cases**. You'll get a compiler "
"error if you are working with a nullable value and you forget to handle the "
"`None` case.  \n"
"This is a significant improvement over \"implicit\" nullability in other "
"languages, where you can forget to check for `null` and thus trigger a "
"runtime error."
msgstr ""
"`Option`ì€ ê°’ì´ ì¡´ì¬í•  ìˆ˜ë„ ìˆê³ (`Some(T)`) ì—†ì„ ìˆ˜ë„ ìˆë‹¤ëŠ”(`None`) ì•„ì´ë””ì–´"
"ë¥¼ ì¸ì½”ë”©í•©ë‹ˆë‹¤.  \n"
"ë˜í•œ **ë‘ ê²½ìš°ë¥¼ ëª¨ë‘ ëª…ì‹œì ìœ¼ë¡œ ì²˜ë¦¬**í•´ì•¼ í•©ë‹ˆë‹¤. Null í—ˆìš© ê°’ìœ¼ë¡œ ì‘ì—…í•˜ê³  "
"`None` ì‚¬ë¡€ë¥¼ ì²˜ë¦¬í•˜ëŠ” ê²ƒì„ ìŠì€ ê²½ìš° ì»´íŒŒì¼ëŸ¬ ì˜¤ë¥˜ê°€ ë°œìƒí•©ë‹ˆë‹¤.  \n"
"ì´ëŠ” `null` í™•ì¸ì„ ìŠì–´ë²„ë ¤ ëŸ°íƒ€ì„ ì˜¤ë¥˜ë¥¼ ìœ ë°œí•  ìˆ˜ ìˆëŠ” ë‹¤ë¥¸ ì–¸ì–´ì˜ \"ì•”ì‹œì "
"\" null í—ˆìš© ì—¬ë¶€ì— ë¹„í•´ í¬ê²Œ ê°œì„ ëœ ê²ƒì…ë‹ˆë‹¤."

#: src/05_ticket_v2/05_nullability.md:24
msgid "`Option`'s definition"
msgstr "`Option`ì˜ ì •ì˜"

#: src/05_ticket_v2/05_nullability.md:26
msgid ""
"`Option`'s definition uses a Rust construct that you haven't seen before: "
"**tuple-like variants**."
msgstr ""
"`Option`ì˜ ì •ì˜ëŠ” ì´ì „ì— ë³¸ ì ì´ ì—†ëŠ” Rust êµ¬ì„±ì¸ **íŠœí”Œ ìœ ì‚¬ ë°°ë¦¬ì–¸íŠ¸**ë¥¼ ì‚¬"
"ìš©í•©ë‹ˆë‹¤."

#: src/05_ticket_v2/05_nullability.md:28
msgid "Tuple-like variants"
msgstr "íŠœí”Œ ìœ ì‚¬ ë°°ë¦¬ì–¸íŠ¸"

#: src/05_ticket_v2/05_nullability.md:30
msgid ""
"`Option` has two variants: `Some(T)` and `None`.  \n"
"`Some` is a **tuple-like variant**: it's a variant that holds **unnamed "
"fields**."
msgstr ""
"`Option`ì—ëŠ” `Some(T)`ê³¼ `None`ì´ë¼ëŠ” ë‘ ê°€ì§€ ë°°ë¦¬ì–¸íŠ¸ê°€ ìˆìŠµë‹ˆë‹¤.  \n"
"`Some`ì€ **íŠœí”Œ ìœ ì‚¬ ë°°ë¦¬ì–¸íŠ¸**ì…ë‹ˆë‹¤. ì´ëŠ” **ì´ë¦„ì´ ì§€ì •ë˜ì§€ ì•Šì€ í•„ë“œ**ë¥¼ ê°€"
"ì§€ëŠ” ë°°ë¦¬ì–¸íŠ¸ì…ë‹ˆë‹¤."

#: src/05_ticket_v2/05_nullability.md:33
msgid ""
"Tuple-like variants are often used when there is a single field to store, "
"especially when we're looking at a \"wrapper\" type like `Option`."
msgstr ""
"íŠœí”Œí˜• ë°°ë¦¬ì–¸íŠ¸ëŠ” ì €ì¥í•  ë‹¨ì¼ í•„ë“œê°€ ìˆì„ ë•Œ, íŠ¹íˆ `Option`ê³¼ ê°™ì€ \"ë˜í¼\" íƒ€"
"ì…ì— ìì£¼ ì‚¬ìš©ë©ë‹ˆë‹¤."

#: src/05_ticket_v2/05_nullability.md:36
msgid "Tuple-like structs"
msgstr "íŠœí”Œ ìœ ì‚¬ êµ¬ì¡°ì²´"

#: src/05_ticket_v2/05_nullability.md:38
msgid "They're not specific to enumsâ€”you can define tuple-like structs too:"
msgstr ""
"ì´ëŠ” ì—´ê±°í˜•ì—ë§Œ êµ­í•œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. íŠœí”Œ ìœ ì‚¬ êµ¬ì¡°ì²´ë„ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/05_ticket_v2/05_nullability.md:44
msgid ""
"You can then access the two fields of a `Point` instance using their "
"positional index:"
msgstr ""
"ê·¸ëŸ° ë‹¤ìŒ ìœ„ì¹˜ ì¸ë±ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ `Point` ì¸ìŠ¤í„´ìŠ¤ì˜ ë‘ í•„ë“œì— ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆìŠµ"
"ë‹ˆë‹¤:"

#: src/05_ticket_v2/05_nullability.md:52
msgid "Tuples"
msgstr "íŠœí”Œ"

#: src/05_ticket_v2/05_nullability.md:54
msgid ""
"It's weird to say that something is tuple-like when we haven't seen tuples "
"yet!  \n"
"Tuples are another example of a primitive Rust type. They group together a "
"fixed number of values with (potentially different) types:"
msgstr ""
"ì•„ì§ íŠœí”Œì„ ë³¸ ì ì´ ì—†ëŠ”ë° ë­”ê°€ê°€ íŠœí”Œê³¼ ë¹„ìŠ·í•˜ë‹¤ê³  ë§í•˜ëŠ” ê²ƒì€ ì´ìƒí•©ë‹ˆ"
"ë‹¤!  \n"
"íŠœí”Œì€ ì›ì‹œ Rust íƒ€ì…ì˜ ë˜ ë‹¤ë¥¸ ì˜ˆì…ë‹ˆë‹¤. (ì ì¬ì ìœ¼ë¡œ ë‹¤ë¥¸) íƒ€ì…ì„ ì‚¬ìš©í•˜ì—¬ ê³ "
"ì •ëœ ê°œìˆ˜ì˜ ê°’ì„ ê·¸ë£¹í™”í•©ë‹ˆë‹¤."

#: src/05_ticket_v2/05_nullability.md:59
msgid "// Two values, same type\n"
msgstr "// ë‘ ê°œì˜ ê°’, ë™ì¼í•œ íƒ€ì…\n"

#: src/05_ticket_v2/05_nullability.md:60
msgid "// Three values, different types\n"
msgstr "// ì„¸ ê°€ì§€ ê°’, ë‹¤ë¥¸ íƒ€ì…\n"

#: src/05_ticket_v2/05_nullability.md:65
msgid ""
"The syntax is simple: you list the types of the values between parentheses, "
"separated by commas. You can access the fields of a tuple using the dot "
"notation and the field index:"
msgstr ""
"ë¬¸ë²•ì€ ê°„ë‹¨í•©ë‹ˆë‹¤. ê´„í˜¸ ì•ˆì— ê°’ íƒ€ì…ì„ ì‰¼í‘œë¡œ êµ¬ë¶„í•˜ì—¬ ë‚˜ì—´í•©ë‹ˆë‹¤. ì  í‘œê¸°ë²•"
"ê³¼ í•„ë“œ ì¸ë±ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ íŠœí”Œì˜ í•„ë“œì— ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/05_nullability.md:74
msgid ""
"Tuples are a convenient way of grouping values together when you can't be "
"bothered to define a dedicated struct type."
msgstr ""
"íŠœí”Œì€ ì „ìš© êµ¬ì¡°ì²´ íƒ€ì…ì„ ì •ì˜í•  í•„ìš”ê°€ ì—†ì„ ë•Œ ê°’ì„ ê·¸ë£¹í™”í•˜ëŠ” í¸ë¦¬í•œ ë°©ë²•ì…"
"ë‹ˆë‹¤."

#: src/05_ticket_v2/05_nullability.md:78
msgid ""
"The exercise for this section is located in [`05_ticket_v2/05_nullability`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/05_nullability)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`05_ticket_v2/05_nullability`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/05_nullability)ì— ìˆìŠµë‹ˆë‹¤"

#: src/05_ticket_v2/06_fallibility.md:3
msgid "Let's revisit the `Ticket::new` function from the previous exercise:"
msgstr "ì´ì „ ì˜ˆì œì˜ `Ticket::new` í•¨ìˆ˜ë¥¼ ë‹¤ì‹œ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/06_fallibility.md:9
msgid "\"Title cannot be empty\""
msgstr "\"Title cannot be empty\""

#: src/05_ticket_v2/06_fallibility.md:12
msgid "\"Title cannot be longer than 50 bytes\""
msgstr "\"Title cannot be longer than 50 bytes\""

#: src/05_ticket_v2/06_fallibility.md:15
msgid "\"Description cannot be empty\""
msgstr "\"Description cannot be empty\""

#: src/05_ticket_v2/06_fallibility.md:18
msgid "\"Description cannot be longer than 500 bytes\""
msgstr "\"Description cannot be longer than 500 bytes\""

#: src/05_ticket_v2/06_fallibility.md:30
msgid ""
"As soon as one of the checks fails, the function panics. This is not ideal, "
"as it doesn't give the caller a chance to **handle the error**."
msgstr ""
"ê²€ì‚¬ ì¤‘ í•˜ë‚˜ê°€ ì‹¤íŒ¨í•˜ìë§ˆì í•¨ìˆ˜ëŠ” íŒ¨ë‹‰ ìƒíƒœê°€ ë©ë‹ˆë‹¤. ì´ëŠ” í˜¸ì¶œìì—ê²Œ **ì˜¤ë¥˜"
"ë¥¼ ì²˜ë¦¬**í•  ê¸°íšŒë¥¼ ì£¼ì§€ ì•Šê¸° ë•Œë¬¸ì— ì´ìƒì ì´ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/06_fallibility.md:33
msgid ""
"It's time to introduce the `Result` type, Rust's primary mechanism for error "
"handling."
msgstr ""
"ì´ì œ ì˜¤ë¥˜ ì²˜ë¦¬ë¥¼ ìœ„í•œ Rustì˜ ì£¼ìš” ë©”ì»¤ë‹ˆì¦˜ì¸ `Result` íƒ€ì…ì„ ì†Œê°œí•  ì‹œê°„ì…ë‹ˆ"
"ë‹¤."

#: src/05_ticket_v2/06_fallibility.md:35
msgid "The `Result` type"
msgstr "`Result` íƒ€ì…"

#: src/05_ticket_v2/06_fallibility.md:37
msgid "The `Result` type is an enum defined in the standard library:"
msgstr "`Result` íƒ€ì…ì€ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ì •ì˜ëœ ì—´ê±°í˜•ì…ë‹ˆë‹¤."

#: src/05_ticket_v2/06_fallibility.md:46
msgid "It has two variants:"
msgstr "ì—¬ê¸°ì—ëŠ” ë‘ ê°€ì§€ ë°°ë¦¬ì–¸íŠ¸ê°€ ìˆìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/06_fallibility.md:48
msgid ""
"`Ok(T)`: represents a successful operation. It holds `T`, the output of the "
"operation."
msgstr "`Ok(T)`: ì„±ê³µì ì¸ ì‘ì—…ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ì—°ì‚°ì˜ ê²°ê³¼ì¸ `T`ë¥¼ ê°€ì§‘ë‹ˆë‹¤."

#: src/05_ticket_v2/06_fallibility.md:49
msgid ""
"`Err(E)`: represents a failed operation. It holds `E`, the error that "
"occurred."
msgstr "`Err(E)`: ì‹¤íŒ¨í•œ ì‘ì—…ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ë°œìƒí•œ ì˜¤ë¥˜ì¸ `E`ë¥¼ ê°€ì§‘ë‹ˆë‹¤."

#: src/05_ticket_v2/06_fallibility.md:51
msgid ""
"Both `Ok` and `Err` are generic, allowing you to specify your own types for "
"the success and error cases."
msgstr ""
"`Ok`ì™€ `Err`ì€ ëª¨ë‘ ì¼ë°˜ì ì´ë¯€ë¡œ ì„±ê³µ ë° ì˜¤ë¥˜ ì‚¬ë¡€ì— ëŒ€í•´ ê³ ìœ í•œ íƒ€ì…ì„ ì§€ì •"
"í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/06_fallibility.md:53
msgid "No exceptions"
msgstr "ì˜ˆì™¸ ì—†ìŒ"

#: src/05_ticket_v2/06_fallibility.md:55
msgid ""
"Recoverable errors in Rust are **represented as values**.  \n"
"They're just an instance of a type, being passed around and manipulated like "
"any other value. This is a significant difference from other languages, such "
"as Python or C#, where **exceptions** are used to signal errors."
msgstr ""
"Rustì—ì„œ ë³µêµ¬ ê°€ëŠ¥í•œ ì˜¤ë¥˜ëŠ” **ê°’ìœ¼ë¡œ í‘œì‹œ**ë©ë‹ˆë‹¤.  \n"
"ì´ëŠ” ë‹¨ì§€ íƒ€ì…ì˜ ì¸ìŠ¤í„´ìŠ¤ì¼ ë¿ì´ë©° ë‹¤ë¥¸ ê°’ì²˜ëŸ¼ ì „ë‹¬ë˜ê³  ì¡°ì‘ë©ë‹ˆë‹¤. ì´ëŠ” ì˜¤ë¥˜"
"ë¥¼ ì•Œë¦¬ê¸° ìœ„í•´ **ì˜ˆì™¸**ë¥¼ ì‚¬ìš©í•˜ëŠ” Pythonì´ë‚˜ C# ë“±ì˜ ë‹¤ë¥¸ ì–¸ì–´ì™€ëŠ” ìƒë‹¹í•œ ì°¨"
"ì´ê°€ ìˆìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/06_fallibility.md:59
msgid ""
"Exceptions create a separate control flow path that can be hard to reason "
"about.  \n"
"You don't know, just by looking at a function's signature, if it can throw an "
"exception or not. You don't know, just by looking at a function's signature, "
"**which** exception types it can throw.  \n"
"You must either read the function's documentation or look at its "
"implementation to find out."
msgstr ""
"ì˜ˆì™¸ëŠ” ì¶”ë¡ í•˜ê¸° ì–´ë ¤ìš¸ ìˆ˜ ìˆëŠ” ë³„ë„ì˜ ì œì–´ íë¦„ ê²½ë¡œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.  \n"
"í•¨ìˆ˜ì˜ ì‹œê·¸ë‹ˆì²˜ë§Œ ë³´ë©´ ì˜ˆì™¸ê°€ ë°œìƒí•  ìˆ˜ ìˆëŠ”ì§€ ì—¬ë¶€ë¥¼ ì•Œ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. í•¨ìˆ˜ì˜ "
"ì‹œê·¸ë‹ˆì²˜ë§Œ ë³´ë©´ **ì–´ë–¤** ì˜ˆì™¸ íƒ€ì…ì´ ë°œìƒí•  ìˆ˜ ìˆëŠ”ì§€ ì•Œ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.  \n"
"ì•Œì•„ë‚´ë ¤ë©´ í•¨ìˆ˜ì˜ ë¬¸ì„œë¥¼ ì½ê±°ë‚˜ êµ¬í˜„ì„ ì‚´í´ë´ì•¼ í•©ë‹ˆë‹¤."

#: src/05_ticket_v2/06_fallibility.md:64
msgid ""
"Exception handling logic has very poor locality: the code that throws the "
"exception is far removed from the code that catches it, and there's no direct "
"link between the two."
msgstr ""
"ì˜ˆì™¸ ì²˜ë¦¬ ë¡œì§ì€ ì§€ì—­ì„±ì´ ë§¤ìš° ë‚®ìŠµë‹ˆë‹¤. ì˜ˆì™¸ë¥¼ ë°œìƒì‹œí‚¤ëŠ” ì½”ë“œëŠ” ì˜ˆì™¸ë¥¼ í¬ì°©"
"í•˜ëŠ” ì½”ë“œì—ì„œ ë©€ë¦¬ ë–¨ì–´ì ¸ ìˆìœ¼ë©° ë‘˜ ì‚¬ì´ì—ëŠ” ì§ì ‘ì ì¸ ë§í¬ê°€ ì—†ìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/06_fallibility.md:67
msgid "Fallibility is encoded in the type system"
msgstr "ì˜¤ë¥˜ ê°€ëŠ¥ì„±ì€ íƒ€ì… ì‹œìŠ¤í…œì— ì¸ì½”ë”©ë˜ì–´ ìˆìŠµë‹ˆë‹¤"

#: src/05_ticket_v2/06_fallibility.md:69
msgid ""
"Rust, with `Result`, forces you to **encode fallibility in the function's "
"signature**.  \n"
"If a function can fail (and you want the caller to have a shot at handling "
"the error), it must return a `Result`."
msgstr ""
"RustëŠ” `Result`ë¥¼ ì‚¬ìš©í•˜ì—¬ **í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ì˜ ì˜¤ë¥˜ ê°€ëŠ¥ì„±**ì„ ì¸ì½”ë”©í•˜ë„ë¡ ê°•ì œ"
"í•©ë‹ˆë‹¤.  \n"
"í•¨ìˆ˜ê°€ ì‹¤íŒ¨í•  ìˆ˜ ìˆëŠ” ê²½ìš°(ê·¸ë¦¬ê³  í˜¸ì¶œìê°€ ì˜¤ë¥˜ë¥¼ ì²˜ë¦¬í•˜ë„ë¡ í•˜ë ¤ëŠ” ê²½ìš°) "
"`Result`ë¥¼ ë°˜í™˜í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/05_ticket_v2/06_fallibility.md:73
msgid ""
"// Just by looking at the signature, you know that this function can fail.\n"
"// You can also inspect `ParseIntError` to see what kind of failures to "
"expect.\n"
msgstr ""
"// ì‹œê·¸ë‹ˆì²˜ë§Œ ë´ë„ ì´ í•¨ìˆ˜ê°€ ì‹¤íŒ¨í•  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
"// `ParseIntError`ë¥¼ í™•ì¸í•´ ì–´ë–¤ ì¢…ë¥˜ì˜ ì‹¤íŒ¨ê°€ ì˜ˆìƒë˜ëŠ”ì§€ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"

#: src/05_ticket_v2/06_fallibility.md:76 src/05_ticket_v2/07_unwrap.md:13
msgid "// ...\n"
msgstr "// ...\n"

#: src/05_ticket_v2/06_fallibility.md:80
msgid "That's the big advantage of `Result`: it makes fallibility explicit."
msgstr ""
"ì´ê²ƒì´ `Result`ì˜ ê°€ì¥ í° ì¥ì ì…ë‹ˆë‹¤. ì¦‰, ì˜¤ë¥˜ ê°€ëŠ¥ì„±ì„ ëª…ì‹œì ìœ¼ë¡œ ë§Œë“¤ì–´ì¤ë‹ˆ"
"ë‹¤."

#: src/05_ticket_v2/06_fallibility.md:82
msgid ""
"Keep in mind, though, that panics exist. They aren't tracked by the type "
"system, just like exceptions in other languages. But they're meant for "
"**unrecoverable errors** and should be used sparingly."
msgstr ""
"í•˜ì§€ë§Œ íŒ¨ë‹‰ì´ ì¡´ì¬í•œë‹¤ëŠ” ì ì„ ëª…ì‹¬í•˜ì‹­ì‹œì˜¤. ë‹¤ë¥¸ ì–¸ì–´ì˜ ì˜ˆì™¸ì™€ ë§ˆì°¬ê°€ì§€ë¡œ íƒ€"
"ì… ì‹œìŠ¤í…œìœ¼ë¡œ ì¶”ì ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ **ë³µêµ¬í•  ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜**ë¥¼ ìœ„í•œ ê²ƒì´ë¯€"
"ë¡œ ë“œë¬¼ê²Œ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/05_ticket_v2/06_fallibility.md:87
msgid ""
"The exercise for this section is located in [`05_ticket_v2/06_fallibility`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/06_fallibility)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`05_ticket_v2/06_fallibility`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/06_fallibility)ì— ìˆìŠµë‹ˆë‹¤"

#: src/05_ticket_v2/07_unwrap.md:1
msgid "Unwrapping"
msgstr "ì–¸ë©í•‘"

#: src/05_ticket_v2/07_unwrap.md:3
msgid ""
"`Ticket::new` now returns a `Result` instead of panicking on invalid "
"inputs.  \n"
"What does this mean for the caller?"
msgstr ""
"`Ticket::new`ëŠ” ì´ì œ ìœ íš¨í•˜ì§€ ì•Šì€ ì…ë ¥ì— íŒ¨ë‹‰í•˜ëŠ” ëŒ€ì‹  `Result`ë¥¼ ë°˜í™˜í•©ë‹ˆ"
"ë‹¤.  \n"
"ì´ëŠ” í˜¸ì¶œí•˜ëŠ” ì…ì¥ì—ì„œ ë¬´ì—‡ì„ ì˜ë¯¸í• ê¹Œìš”?"

#: src/05_ticket_v2/07_unwrap.md:6
msgid "Failures can't be (implicitly) ignored"
msgstr "ì‹¤íŒ¨ëŠ” (ì•”ì‹œì ìœ¼ë¡œ) ë¬´ì‹œë  ìˆ˜ ì—†ìŠµë‹ˆë‹¤"

#: src/05_ticket_v2/07_unwrap.md:8
msgid ""
"Unlike exceptions, Rust's `Result` forces you to **handle errors at the call "
"site**.  \n"
"If you call a function that returns a `Result`, Rust won't allow you to "
"implicitly ignore the error case."
msgstr ""
"ì˜ˆì™¸ì™€ ë‹¬ë¦¬ Rustì˜ `Result`ëŠ” **í˜¸ì¶œí•œ ê³³ì—ì„œ ì˜¤ë¥˜ë¥¼ ì²˜ë¦¬**í•˜ë„ë¡ ê°•ì œí•©ë‹ˆ"
"ë‹¤.  \n"
"`Result`ë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ë©´ RustëŠ” ì—ëŸ¬ ì¼€ì´ìŠ¤ë¥¼ ì•”ì‹œì ìœ¼ë¡œ ë¬´ì‹œí•˜ëŠ” "
"ê²ƒì„ í—ˆìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/07_unwrap.md:15
msgid ""
"// This won't compile: we're not handling the error case.\n"
"// We must either use `match` or one of the combinators provided by `Result`\n"
"// to \"unwrap\" the success value or handle the error.\n"
msgstr ""
"// ì»´íŒŒì¼ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì—ëŸ¬ ì¼€ì´ìŠ¤ë¥¼ ì²˜ë¦¬í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n"
"// ì„±ê³µ ê°’ì„ \"ì–¸ë©\"í•˜ê±°ë‚˜ ì˜¤ë¥˜ë¥¼ ì²˜ë¦¬í•˜ë ¤ë©´ `match` ë˜ëŠ” `Result`ì—ì„œ ì œê³µí•˜"
"ëŠ”\n"
"// ê²°í•©ì ì¤‘ í•˜ë‚˜ë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.\n"

#: src/05_ticket_v2/07_unwrap.md:19 src/05_ticket_v2/07_unwrap.md:30
#: src/05_ticket_v2/07_unwrap.md:32 src/05_ticket_v2/07_unwrap.md:36
msgid "\"42\""
msgstr "\"42\""

#: src/05_ticket_v2/07_unwrap.md:22
msgid "You got a `Result`. Now what?"
msgstr "`Result`ê°€ ë‚˜ì™”ìŠµë‹ˆë‹¤. ì´ê±¸ë¡œ ë­˜ í•  ìˆ˜ ìˆì„ê¹Œìš”?"

#: src/05_ticket_v2/07_unwrap.md:24
msgid ""
"When you call a function that returns a `Result`, you have two key options:"
msgstr "`Result`ë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ë•Œ ë‘ ê°€ì§€ ì£¼ìš” ì˜µì…˜ì´ ìˆìŠµë‹ˆë‹¤:"

#: src/05_ticket_v2/07_unwrap.md:26
msgid ""
"Panic if the operation failed. This is done using either the `unwrap` or "
"`expect` methods."
msgstr ""
"ì‘ì—…ì´ ì‹¤íŒ¨í•˜ë©´ íŒ¨ë‹‰ì´ ë°œìƒí•©ë‹ˆë‹¤. ì´ëŠ” `unwrap` ë˜ëŠ” `expect` ë©”ì†Œë“œë¥¼ ì‚¬ìš©í•˜"
"ì—¬ ìˆ˜í–‰ë©ë‹ˆë‹¤."

#: src/05_ticket_v2/07_unwrap.md:29
msgid "// Panics if `parse_int` returns an `Err`.\n"
msgstr "// `parse_int`ê°€ `Err`ì„ ë°˜í™˜í•˜ë©´ íŒ¨ë‹‰ì´ ë°œìƒí•©ë‹ˆë‹¤.\n"

#: src/05_ticket_v2/07_unwrap.md:31
msgid "// `expect` lets you specify a custom panic message.\n"
msgstr "// `expect`ë¥¼ ì‚¬ìš©í•˜ë©´ ì‚¬ìš©ì ì •ì˜ íŒ¨ë‹‰ ë©”ì‹œì§€ë¥¼ ì§€ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"

#: src/05_ticket_v2/07_unwrap.md:32
msgid "\"Failed to parse integer\""
msgstr "\"Failed to parse integer\""

#: src/05_ticket_v2/07_unwrap.md:34
msgid ""
"Destructure the `Result` using a `match` expression to deal with the error "
"case explicitly."
msgstr ""
"ì—ëŸ¬ ì¼€ì´ìŠ¤ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì²˜ë¦¬í•˜ë ¤ë©´ `match` í‘œí˜„ì‹ì„ ì‚¬ìš©í•˜ì—¬ `Result`ë¥¼ êµ¬ì¡° "
"í•´ì œí•˜ì„¸ìš”."

#: src/05_ticket_v2/07_unwrap.md:37
msgid "\"Parsed number: {}\""
msgstr "\"Parsed number: {}\""

#: src/05_ticket_v2/07_unwrap.md:38
msgid "\"Error: {}\""
msgstr "\"Error: {}\""

#: src/05_ticket_v2/07_unwrap.md:44
msgid ""
"The exercise for this section is located in [`05_ticket_v2/07_unwrap`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/07_unwrap)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`05_ticket_v2/07_unwrap`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/07_unwrap)ì— ìˆìŠµë‹ˆë‹¤"

#: src/05_ticket_v2/08_error_enums.md:3
msgid ""
"Your solution to the previous exercise may have felt awkward: matching on "
"strings is not ideal!  \n"
"A colleague might rework the error messages returned by `Ticket::new` (e.g. "
"to improve readability) and, all of a sudden, your calling code would break."
msgstr ""
"ì´ì „ ì˜ˆì œì— ëŒ€í•œ ì†”ë£¨ì…˜ì´ ì–´ìƒ‰í•˜ê²Œ ëŠê»´ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë¬¸ìì—´ ë§¤ì¹­ì€ ì´ìƒì ì´"
"ì§€ ì•ŠìŠµë‹ˆë‹¤!  \n"
"ë™ë£Œê°€ `Ticket::new`ì—ì„œ ë°˜í™˜ëœ ì˜¤ë¥˜ ë©”ì‹œì§€ë¥¼ ì¬ì‘ì—…í•  ìˆ˜ ìˆìœ¼ë©°(ì˜ˆ: ê°€ë…ì„±ì„ "
"ë†’ì´ê¸° ìœ„í•´) ê°‘ìê¸° í˜¸ì¶œí•˜ëŠ” ì½”ë“œê°€ ì¤‘ë‹¨ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/08_error_enums.md:7
msgid "You already know the machinery required to fix this: enums!"
msgstr ""
"ë‹¹ì‹ ì€ ì´ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ë° í•„ìš”í•œ ë©”ì»¤ë‹ˆì¦˜ì„ ì´ë¯¸ ì•Œê³  ìˆìŠµë‹ˆë‹¤: ì—´ê±°í˜•!"

#: src/05_ticket_v2/08_error_enums.md:9
msgid "Reacting to errors"
msgstr "ì˜¤ë¥˜ ì²˜ë¦¬"

#: src/05_ticket_v2/08_error_enums.md:11
msgid ""
"When you want to allow the caller to behave differently based on the specific "
"error that occurred, you can use an enum to represent the different error "
"cases:"
msgstr ""
"ë°œìƒí•œ íŠ¹ì • ì˜¤ë¥˜ì— ë”°ë¼ í˜¸ì¶œìê°€ ë‹¤ë¥´ê²Œ ë™ì‘í•˜ë„ë¡ í—ˆìš©í•˜ë ¤ë©´ ì—´ê±°í˜•ì„ ì‚¬ìš©í•˜"
"ì—¬ ë‹¤ì–‘í•œ ì˜¤ë¥˜ ì‚¬ë¡€ë¥¼ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/05_ticket_v2/08_error_enums.md:15
msgid ""
"// An error enum to represent the different error cases\n"
"// that may occur when parsing a `u32` from a string.\n"
msgstr ""
"// ë¬¸ìì—´ì—ì„œ `u32`ë¥¼ êµ¬ë¬¸ ë¶„ì„í•  ë•Œ ë°œìƒí•  ìˆ˜ ìˆëŠ”\n"
"// ë‹¤ì–‘í•œ ì—ëŸ¬ ì¼€ì´ìŠ¤ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì˜¤ë¥˜ ì—´ê±°í˜•ì…ë‹ˆë‹¤.\n"

#: src/05_ticket_v2/08_error_enums.md:24
msgid ""
"Using an error enum, you're encoding the different error cases in the type "
"systemâ€”they become part of the signature of the fallible function.  \n"
"This simplifies error handling for the caller, as they can use a `match` "
"expression to react to the different error cases:"
msgstr ""
"ì˜¤ë¥˜ ì—´ê±°í˜•ì„ ì‚¬ìš©í•˜ì—¬ íƒ€ì… ì‹œìŠ¤í…œì˜ ë‹¤ì–‘í•œ ì—ëŸ¬ ì¼€ì´ìŠ¤ë¥¼ ì¸ì½”ë”©í•©ë‹ˆë‹¤. ì´ëŠ” "
"ì˜¤ë¥˜ê°€ ìˆëŠ” í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ì˜ ì¼ë¶€ê°€ ë©ë‹ˆë‹¤.  \n"
"ì´ë ‡ê²Œ í•˜ë©´ í˜¸ì¶œìê°€ `match` í‘œí˜„ì‹ì„ ì‚¬ìš©í•˜ì—¬ ë‹¤ì–‘í•œ ì—ëŸ¬ ì¼€ì´ìŠ¤ì— ëŒ€ì‘í•  ìˆ˜ "
"ìˆìœ¼ë¯€ë¡œ í˜¸ì¶œìì˜ ì˜¤ë¥˜ ì²˜ë¦¬ê°€ ë‹¨ìˆœí™”ë©ë‹ˆë‹¤."

#: src/05_ticket_v2/08_error_enums.md:35
msgid "\"Not a number: {}\""
msgstr "\"Not a number: {}\""

#: src/05_ticket_v2/08_error_enums.md:42
msgid ""
"The exercise for this section is located in [`05_ticket_v2/08_error_enums`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/08_error_enums)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`05_ticket_v2/08_error_enums`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/08_error_enums)ì— ìˆìŠµë‹ˆë‹¤"

#: src/05_ticket_v2/09_error_trait.md:1
msgid "Error trait"
msgstr "Error íŠ¸ë ˆì‡"

#: src/05_ticket_v2/09_error_trait.md:3
msgid "Error reporting"
msgstr "ì˜¤ë¥˜ ë³´ê³ "

#: src/05_ticket_v2/09_error_trait.md:5
msgid ""
"In the previous exercise you had to destructure the `TitleError` variant to "
"extract the error message and pass it to the `panic!` macro.  \n"
"This is a (rudimentary) example of **error reporting**: transforming an error "
"type into a representation that can be shown to a user, a service operator, "
"or a developer."
msgstr ""
"ì´ì „ ì˜ˆì œì—ì„œëŠ” ì˜¤ë¥˜ ë©”ì‹œì§€ë¥¼ ì¶”ì¶œí•˜ê³  ì´ë¥¼ `panic!` ë§¤í¬ë¡œì— ì „ë‹¬í•˜ê¸° ìœ„í•´ "
"`TitleError` ë°°ë¦¬ì–¸íŠ¸ë¥¼ ë¶„í•´í•´ì•¼ í–ˆìŠµë‹ˆë‹¤.  \n"
"ì´ëŠ” **ì˜¤ë¥˜ ë³´ê³ **ì˜ (ì´ˆë³´ì ì¸) ì˜ˆì…ë‹ˆë‹¤. ì˜¤ë¥˜ íƒ€ì…ì„ ì‚¬ìš©ì, ì„œë¹„ìŠ¤ ìš´ì˜ì ë˜"
"ëŠ” ê°œë°œìì—ê²Œ í‘œì‹œë  ìˆ˜ ìˆëŠ” í‘œí˜„ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤."

#: src/05_ticket_v2/09_error_trait.md:10
msgid ""
"It's not practical for each Rust developer to come up with their own error "
"reporting strategy: it'd be a waste of time and it wouldn't compose well "
"across projects. That's why Rust provides the `std::error::Error` trait."
msgstr ""
"ê° Rust ê°œë°œìê°€ ìì‹ ë§Œì˜ ì˜¤ë¥˜ ë³´ê³  ì „ëµì„ ìƒê°í•´ë‚´ëŠ” ê²ƒì€ ì‹¤ìš©ì ì´ì§€ ì•ŠìŠµë‹ˆ"
"ë‹¤. ì´ëŠ” ì‹œê°„ ë‚­ë¹„ì¼ ë¿ ì•„ë‹ˆë¼ í”„ë¡œì íŠ¸ ì „ë°˜ì— ê±¸ì³ ì˜ êµ¬ì„±ë˜ì§€ ì•Šì„ ê²ƒì…ë‹ˆ"
"ë‹¤. ì´ê²ƒì´ Rustê°€ `std::error::Error` íŠ¸ë ˆì‡ì„ ì œê³µí•˜ëŠ” ì´ìœ ì…ë‹ˆë‹¤."

#: src/05_ticket_v2/09_error_trait.md:14
msgid "The `Error` trait"
msgstr "'Error' íŠ¸ë ˆì‡"

#: src/05_ticket_v2/09_error_trait.md:16
msgid ""
"There are no constraints on the type of the `Err` variant in a `Result`, but "
"it's a good practice to use a type that implements the `Error` trait. `Error` "
"is the cornerstone of Rust's error handling story:"
msgstr ""
"`Result`ì˜ `Err` ë°°ë¦¬ì–¸íŠ¸ íƒ€ì…ì—ëŠ” ì œí•œì´ ì—†ì§€ë§Œ `Error` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ëŠ” íƒ€"
"ì…ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤. `Error`ëŠ” Rustì˜ ì˜¤ë¥˜ ì²˜ë¦¬ ì´ì•¼ê¸°ì˜ ì´ˆì„ì…ë‹ˆë‹¤:"

#: src/05_ticket_v2/09_error_trait.md:21
msgid "// Slightly simplified definition of the `Error` trait\n"
msgstr "// `Error` íŠ¸ë ˆì‡ì˜ ì •ì˜ë¥¼ ì•½ê°„ ë‹¨ìˆœí™”í–ˆìŠµë‹ˆë‹¤\n"

#: src/05_ticket_v2/09_error_trait.md:25
msgid ""
"You might recall the `:` syntax from [the `Sized` trait]"
"(../04_traits/08_sized.md)â€”it's used to specify **supertraits**. For `Error`, "
"there are two supertraits: `Debug` and `Display`. If a type wants to "
"implement `Error`, it must also implement `Debug` and `Display`."
msgstr ""
"`Sized` íŠ¸ë ˆì‡ì—ì„œ `:` êµ¬ë¬¸ì„ ê¸°ì–µí•˜ì‹¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” **ìŠˆí¼ íŠ¸ë ˆì‡**ì„ ì§€"
"ì •í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. `Error`ì—ëŠ” `Debug`ì™€ `Display`ë¼ëŠ” ë‘ ê°€ì§€ ìŠˆí¼ íŠ¸ë ˆì‡"
"ì´ ìˆìŠµë‹ˆë‹¤. íƒ€ì…ì´ `Error`ë¥¼ êµ¬í˜„í•˜ë ¤ëŠ” ê²½ìš° `Debug` ë° `Display`ë„ êµ¬í˜„í•´ì•¼ "
"í•©ë‹ˆë‹¤."

#: src/05_ticket_v2/09_error_trait.md:29
msgid "`Display` and `Debug`"
msgstr "`Display`ì™€ `Debug`"

#: src/05_ticket_v2/09_error_trait.md:31
msgid ""
"We've already encountered the `Debug` trait in [a previous exercise]"
"(../04_traits/04_derive.md)â€”it's the trait used by `assert_eq!` to display "
"the values of the variables it's comparing when the assertion fails."
msgstr ""
"ìš°ë¦¬ëŠ” ì´ì „ ì˜ˆì œì—ì„œ ì´ë¯¸ `Debug` íŠ¸ë ˆì‡ì„ ì ‘í–ˆìŠµë‹ˆë‹¤. ì´ëŠ” ì–´ì„¤ì…˜ì´ ì‹¤íŒ¨í•  "
"ë•Œ ë¹„êµí•˜ëŠ” ë³€ìˆ˜ì˜ ê°’ì„ í‘œì‹œí•˜ê¸° ìœ„í•´ `assert_eq!`ì—ì„œ ì‚¬ìš©í•˜ëŠ” íŠ¸ë ˆì‡ì…ë‹ˆë‹¤."

#: src/05_ticket_v2/09_error_trait.md:34
msgid ""
"From a \"mechanical\" perspective, `Display` and `Debug` are identicalâ€”they "
"encode how a type should be converted into a string-like representation:"
msgstr ""
"\"ë©”ì¹´ë‹ˆì»¬í•œ\" ê´€ì ì—ì„œ `Display`ì™€ `Debug`ëŠ” ë™ì¼í•©ë‹ˆë‹¤. ì¦‰, íƒ€ì…ì„ ë¬¸ìì—´ê³¼ "
"ê°™ì€ í‘œí˜„ìœ¼ë¡œ ë³€í™˜í•˜ëŠ” ë°©ë²•ì„ ì¸ì½”ë”©í•©ë‹ˆë‹¤."

#: src/05_ticket_v2/09_error_trait.md:38
msgid "// `Debug`\n"
msgstr "// `Debug`\n"

#: src/05_ticket_v2/09_error_trait.md:42
msgid "// `Display`\n"
msgstr "// `Display`\n"

#: src/05_ticket_v2/09_error_trait.md:49
msgid ""
"The difference is in their _purpose_: `Display` returns a representation "
"that's meant for \"end-users\", while `Debug` provides a low-level "
"representation that's more suitable to developers and service operators.  \n"
"That's why `Debug` can be automatically implemented using the "
"`#[derive(Debug)]` attribute, while `Display` **requires** a manual "
"implementation."
msgstr ""
"ì°¨ì´ì ì€ _ëª©ì _ì— ìˆìŠµë‹ˆë‹¤. `Display`ëŠ” \"ìµœì¢… ì‚¬ìš©ì\"ë¥¼ ìœ„í•œ í‘œí˜„ì„ ë°˜í™˜í•˜"
"ëŠ” ë°˜ë©´, `Debug`ëŠ” ê°œë°œìì™€ ì„œë¹„ìŠ¤ ìš´ì˜ìì—ê²Œ ë” ì í•©í•œ ë‚®ì€ ìˆ˜ì¤€ì˜ í‘œí˜„ì„ ì œ"
"ê³µí•©ë‹ˆë‹¤.  \n"
"ì´ê²ƒì´ ë°”ë¡œ `Debug`ê°€ `#[derive(Debug)]` ì†ì„±ì„ ì‚¬ìš©í•˜ì—¬ ìë™ìœ¼ë¡œ êµ¬í˜„ë  ìˆ˜ ìˆ"
"ëŠ” ë°˜ë©´, `Display`ëŠ” ìˆ˜ë™ êµ¬í˜„ì´ **í•„ìš”**í•œ ì´ìœ ì…ë‹ˆë‹¤."

#: src/05_ticket_v2/09_error_trait.md:56
msgid ""
"The exercise for this section is located in [`05_ticket_v2/09_error_trait`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/09_error_trait)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`05_ticket_v2/09_error_trait`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/09_error_trait)ì— ì‡ìŠµë‹ˆë‹¤"

#: src/05_ticket_v2/10_packages.md:1
msgid "Libraries and binaries"
msgstr "ë¼ì´ë¸ŒëŸ¬ë¦¬ì™€ ë°”ì´ë„ˆë¦¬"

#: src/05_ticket_v2/10_packages.md:3
msgid ""
"It took a bit of code to implement the `Error` trait for `TicketNewError`, "
"didn't it?  \n"
"A manual `Display` implementation, plus an `Error` impl block."
msgstr ""
"`TicketNewError`ì— ëŒ€í•œ `Error` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ë ¤ë©´ ì•½ê°„ì˜ ì½”ë“œê°€ í•„ìš”í•˜ì§€ ì•Š"
"ìŠµë‹ˆê¹Œ?  \n"
"ìˆ˜ë™ `Display` êµ¬í˜„ê³¼ `Error` impl ë¸”ë¡."

#: src/05_ticket_v2/10_packages.md:6
msgid ""
"We can remove some of the boilerplate by using [`thiserror`](https://docs.rs/"
"thiserror/latest/thiserror/), a Rust crate that provides a **procedural "
"macro** to simplify the creation of custom error types.  \n"
"But we're getting ahead of ourselves: `thiserror` is a third-party crate, "
"it'd be our first dependency!"
msgstr ""
"ì‚¬ìš©ì ì •ì˜ ì˜¤ë¥˜ íƒ€ì… ìƒì„±ì„ ë‹¨ìˆœí™”í•˜ê¸° ìœ„í•´ **ì ˆì°¨ì  ë§¤í¬ë¡œ**ë¥¼ ì œê³µí•˜ëŠ” "
"Rust í¬ë ˆì´íŠ¸ì¸ `thiserror`ë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒìš©êµ¬ ì¤‘ ì¼ë¶€ë¥¼ ì œê±°í•  ìˆ˜ ìˆìŠµë‹ˆ"
"ë‹¤.  \n"
"í•˜ì§€ë§Œ ìš°ë¦¬ëŠ” ì•ì„œ ë‚˜ê°€ê³  ìˆìŠµë‹ˆë‹¤. `thiserror`ëŠ” ì„œë“œíŒŒí‹° í¬ë ˆì´íŠ¸ì´ë©°, ì´ê²ƒ"
"ì´ ìš°ë¦¬ì˜ ì²« ë²ˆì§¸ ë””íœë˜ì‹œê°€ ë  ê²ƒì…ë‹ˆë‹¤!"

#: src/05_ticket_v2/10_packages.md:10
msgid ""
"Let's take a step back to talk about Rust's packaging system before we dive "
"into dependencies."
msgstr ""
"ë””íœë˜ì‹œì— ëŒ€í•´ ìì„¸íˆ ì•Œì•„ë³´ê¸° ì „ì— í•œ ê±¸ìŒ ë¬¼ëŸ¬ë‚˜ Rustì˜ íŒ¨í‚¤ì§• ì‹œìŠ¤í…œì— ëŒ€"
"í•´ ì´ì•¼ê¸°í•´ ë³´ê² ìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/10_packages.md:12
msgid "What is a package?"
msgstr "íŒ¨í‚¤ì§€ë€?"

#: src/05_ticket_v2/10_packages.md:14
msgid ""
"A Rust package is defined by the `[package]` section in a `Cargo.toml` file, "
"also known as its **manifest**. Within `[package]` you can set the package's "
"metadata, such as its name and version."
msgstr ""
"Rust íŒ¨í‚¤ì§€ëŠ” **ë§¤ë‹ˆí˜ìŠ¤íŠ¸**ë¼ê³ ë„ ì•Œë ¤ì§„ `Cargo.toml` íŒŒì¼ì˜ `[package]` ì„¹ì…˜"
"ì— ì˜í•´ ì •ì˜ë©ë‹ˆë‹¤. `[package]` ë‚´ì—ì„œ ì´ë¦„ì´ë‚˜ ë²„ì „ê³¼ ê°™ì€ íŒ¨í‚¤ì§€ì˜ ë©”íƒ€ë°ì´"
"í„°ë¥¼ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/10_packages.md:17
msgid ""
"Go check the `Cargo.toml` file in the directory of this section's exercise!"
msgstr "ì´ ì„¹ì…˜ì˜ ì˜ˆì œ ë””ë ‰í† ë¦¬ì— ìˆëŠ” `Cargo.toml` íŒŒì¼ì„ í™•ì¸í•´ë³´ì„¸ìš”!"

#: src/05_ticket_v2/10_packages.md:19
msgid "What is a crate?"
msgstr "í¬ë ˆì´íŠ¸ë€?"

#: src/05_ticket_v2/10_packages.md:21
msgid ""
"Inside a package, you can have one or more **crates**, also known as "
"**targets**.  \n"
"The two most common crate types are **binary crates** and **library crates**."
msgstr ""
"íŒ¨í‚¤ì§€ ë‚´ë¶€ì—ëŠ” **targets**ë¼ê³  í•˜ëŠ” í•˜ë‚˜ ì´ìƒì˜ **í¬ë ˆì´íŠ¸**ê°€ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆ"
"ë‹¤.  \n"
"ê°€ì¥ ì¼ë°˜ì ì¸ ë‘ ê°€ì§€ í¬ë ˆì´íŠ¸ íƒ€ì…ì€ **ë°”ì´ë„ˆë¦¬ í¬ë ˆì´íŠ¸**ì™€ **ë¼ì´ë¸ŒëŸ¬ë¦¬ í¬"
"ë ˆì´íŠ¸**ì…ë‹ˆë‹¤."

#: src/05_ticket_v2/10_packages.md:24
msgid "Binaries"
msgstr "ë°”ì´ë„ˆë¦¬"

#: src/05_ticket_v2/10_packages.md:26
msgid ""
"A binary is a program that can be compiled to an **executable file**.  \n"
"It must include a function named `main`â€”the program's entry point. `main` is "
"invoked when the program is executed."
msgstr ""
"ë°”ì´ë„ˆë¦¬ëŠ” **ì‹¤í–‰ íŒŒì¼**ë¡œ ì»´íŒŒì¼ë  ìˆ˜ ìˆëŠ” í”„ë¡œê·¸ë¨ì…ë‹ˆë‹¤.  \n"
"ì—¬ê¸°ì—ëŠ” í”„ë¡œê·¸ë¨ì˜ ì§„ì…ì ì¸ `main`ì´ë¼ëŠ” í•¨ìˆ˜ê°€ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤. í”„ë¡œê·¸ë¨"
"ì´ ì‹¤í–‰ë  ë•Œ `main`ì´ í˜¸ì¶œë©ë‹ˆë‹¤."

#: src/05_ticket_v2/10_packages.md:29
msgid "Libraries"
msgstr "ë¼ì´ë¸ŒëŸ¬ë¦¬"

#: src/05_ticket_v2/10_packages.md:31
msgid ""
"Libraries, on the other hand, are not executable on their own. You can't "
"_run_ a library, but you can _import its code_ from another package that "
"depends on it.  \n"
"A library groups together code (i.e. functions, types, etc.) that can be "
"leveraged by other packages as a **dependency**."
msgstr ""
"ë°˜ë©´ì— ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ìì²´ì ìœ¼ë¡œ ì‹¤í–‰ë  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ _ì‹¤í–‰_í•  ìˆ˜ëŠ” "
"ì—†ì§€ë§Œ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ì˜ì¡´í•˜ëŠ” ë‹¤ë¥¸ íŒ¨í‚¤ì§€ì—ì„œ _í•´ë‹¹ ì½”ë“œ_ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŠµë‹ˆ"
"ë‹¤.  \n"
"ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ë‹¤ë¥¸ íŒ¨í‚¤ì§€ì—ì„œ **ë””íœë˜ì‹œ**ìœ¼ë¡œ í™œìš©í•  ìˆ˜ ìˆëŠ” ì½”ë“œ(ì˜ˆ: í•¨ìˆ˜, íƒ€"
"ì… ë“±)ë¥¼ ê·¸ë£¹í™”í•©ë‹ˆë‹¤."

#: src/05_ticket_v2/10_packages.md:35
msgid ""
"All the exercises you've solved so far have been structured as libraries, "
"with a test suite attached to them."
msgstr ""
"ì§€ê¸ˆê¹Œì§€ í•´ê²°í•œ ëª¨ë“  ì—°ìŠµ ë¬¸ì œëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ë¡œ êµ¬ì„±ë˜ì–´ ìˆìœ¼ë©° í…ŒìŠ¤íŠ¸ ëª¨ìŒì´ ì²¨"
"ë¶€ë˜ì–´ ìˆìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/10_packages.md:37
msgid "Conventions"
msgstr "ì»¨ë²¤ì…˜"

#: src/05_ticket_v2/10_packages.md:39
msgid ""
"There are some conventions around Rust packages that you need to keep in mind:"
msgstr "Rust íŒ¨í‚¤ì§€ì™€ ê´€ë ¨í•˜ì—¬ ì—¼ë‘ì— ë‘ì–´ì•¼ í•  ëª‡ ê°€ì§€ ê·œì¹™ì´ ìˆìŠµë‹ˆë‹¤:"

#: src/05_ticket_v2/10_packages.md:41
msgid "The package's source code is usually located in the `src` directory."
msgstr "íŒ¨í‚¤ì§€ì˜ ì†ŒìŠ¤ ì½”ë“œëŠ” ì¼ë°˜ì ìœ¼ë¡œ `src` ë””ë ‰í† ë¦¬ì— ìˆìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/10_packages.md:42
msgid ""
"If there's a `src/lib.rs` file, `cargo` will infer that the package contains "
"a library crate."
msgstr ""
"`src/lib.rs` íŒŒì¼ì´ ìˆìœ¼ë©´ `cargo`ëŠ” íŒ¨í‚¤ì§€ì— ë¼ì´ë¸ŒëŸ¬ë¦¬ í¬ë ˆì´íŠ¸ê°€ í¬í•¨ë˜ì–´ "
"ìˆë‹¤ê³  ì¶”ë¡ í•©ë‹ˆë‹¤."

#: src/05_ticket_v2/10_packages.md:43
msgid ""
"If there's a `src/main.rs` file, `cargo` will infer that the package contains "
"a binary crate."
msgstr ""
"`src/main.rs` íŒŒì¼ì´ ìˆìœ¼ë©´ `cargo`ëŠ” íŒ¨í‚¤ì§€ì— ë°”ì´ë„ˆë¦¬ í¬ë ˆì´íŠ¸ê°€ í¬í•¨ë˜ì–´ ìˆ"
"ë‹¤ê³  ì¶”ë¡ í•©ë‹ˆë‹¤."

#: src/05_ticket_v2/10_packages.md:45
msgid ""
"You can override these defaults by explicitly declaring your targets in the "
"`Cargo.toml` fileâ€”see [`cargo`'s documentation](https://doc.rust-lang.org/"
"cargo/reference/cargo-targets.html#cargo-targets) for more details."
msgstr ""
"`Cargo.toml` íŒŒì¼ì—ì„œ ëŒ€ìƒì„ ëª…ì‹œì ìœ¼ë¡œ ì„ ì–¸í•˜ì—¬ ì´ëŸ¬í•œ ê¸°ë³¸ê°’ì„ ì¬ì •ì˜í•  ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤. ìì„¸í•œ ë‚´ìš©ì€ [`cargo` ë¬¸ì„œ](https://doc.rust-lang.org/cargo/"
"reference/cargo-targets.html#cargo-targets)ë¥¼ ì°¸ì¡°í•˜ì„¸ìš”."

#: src/05_ticket_v2/10_packages.md:48
msgid ""
"Keep in mind that while a package can contain multiple crates, it can only "
"contain one library crate."
msgstr ""
"íŒ¨í‚¤ì§€ì—ëŠ” ì—¬ëŸ¬ í¬ë ˆì´íŠ¸ê°€ í¬í•¨ë  ìˆ˜ ìˆì§€ë§Œ ë¼ì´ë¸ŒëŸ¬ë¦¬ í¬ë ˆì´íŠ¸ëŠ” í•˜ë‚˜ë§Œ í¬í•¨"
"ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/10_packages.md:50
msgid "Scaffolding a new package"
msgstr "ìƒˆ íŒ¨í‚¤ì§€ ìŠ¤ìºí´ë”©í•˜ê¸°"

#: src/05_ticket_v2/10_packages.md:52
msgid "You can use `cargo` to scaffold a new package:"
msgstr "ìƒˆë¡œìš´ íŒ¨í‚¤ì§€ë¥¼ ìƒì„±í•˜ê¸° ìœ„í•´ `cargo`ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/05_ticket_v2/10_packages.md:58
msgid ""
"This will create a new folder, `my-binary`, containing a new Rust package "
"with the same name and a single binary crate inside. If you want to create a "
"library crate instead, you can use the `--lib` flag:"
msgstr ""
"ê·¸ëŸ¬ë©´ ì´ë¦„ì´ ê°™ì€ ìƒˆ Rust íŒ¨í‚¤ì§€ì™€ ë‚´ë¶€ì— ë‹¨ì¼ ë°”ì´ë„ˆë¦¬ ìƒìê°€ í¬í•¨ëœ `my-"
"binary`ë¼ëŠ” ìƒˆ í´ë”ê°€ ìƒì„±ë©ë‹ˆë‹¤. ëŒ€ì‹  ë¼ì´ë¸ŒëŸ¬ë¦¬ í¬ë ˆì´íŠ¸ë¥¼ ìƒì„±í•˜ë ¤ë©´ `--"
"lib` í”Œë˜ê·¸ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/05_ticket_v2/10_packages.md:67
msgid ""
"The exercise for this section is located in [`05_ticket_v2/10_packages`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/10_packages)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`05_ticket_v2/10_packages`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/10_packages)ì— ìˆìŠµë‹ˆë‹¤"

#: src/05_ticket_v2/11_dependencies.md:3
msgid ""
"A package can depend on other packages by listing them in the "
"`[dependencies]` section of its `Cargo.toml` file.  \n"
"The most common way to specify a dependency is by providing its name and "
"version:"
msgstr ""
"íŒ¨í‚¤ì§€ëŠ” `Cargo.toml` íŒŒì¼ì˜ `[dependencies]` ì„¹ì…˜ì— ë‚˜ì—´í•˜ì—¬ ë‹¤ë¥¸ íŒ¨í‚¤ì§€ì— ì˜"
"ì¡´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"ë””íœë˜ì‹œë¥¼ ì§€ì •í•˜ëŠ” ê°€ì¥ ì¼ë°˜ì ì¸ ë°©ë²•ì€ í•´ë‹¹ ì´ë¦„ê³¼ ë²„ì „ì„ ì œê³µí•˜ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/05_ticket_v2/11_dependencies.md:6
msgid ""
"```toml\n"
"[dependencies]\n"
"thiserror = \"1\"\n"
"```"
msgstr ""
"```toml\n"
"[dependencies]\n"
"thiserror = \"1\"\n"
"```"

#: src/05_ticket_v2/11_dependencies.md:11
msgid ""
"This will add `thiserror` as a dependency to your package, with a **minimum** "
"version of `1.0.0`. `thiserror` will be pulled from [crates.io](https://"
"crates.io), Rust's official package registry. When you run `cargo build`, "
"`cargo` will go through a few stages:"
msgstr ""
"ì´ë ‡ê²Œ í•˜ë©´ **ìµœì†Œ** ë²„ì „ `1.0.0`ê³¼ í•¨ê»˜ `thiserror`ê°€ íŒ¨í‚¤ì§€ì— ëŒ€í•œ ë””íœë˜ì‹œ"
"ë¡œ ì¶”ê°€ë©ë‹ˆë‹¤. `thiserror`ëŠ” Rustì˜ ê³µì‹ íŒ¨í‚¤ì§€ ë ˆì§€ìŠ¤íŠ¸ë¦¬ì¸ [crates.io]"
"(https://crates.io)ì—ì„œ ê°€ì ¸ì˜µë‹ˆë‹¤. `cargo build`ë¥¼ ì‹¤í–‰í•˜ë©´ `cargo`ëŠ” ëª‡ ê°€"
"ì§€ ë‹¨ê³„ë¥¼ ê±°ì¹©ë‹ˆë‹¤:"

#: src/05_ticket_v2/11_dependencies.md:15
msgid "Dependency resolution"
msgstr "ì˜ì¡´ì„± í•´ê²°"

#: src/05_ticket_v2/11_dependencies.md:16
msgid "Downloading the dependencies"
msgstr "ë””íœë˜ì‹œ ë‹¤ìš´ë¡œë“œ"

#: src/05_ticket_v2/11_dependencies.md:17
msgid "Compiling your project (your own code and the dependencies)"
msgstr "í”„ë¡œì íŠ¸ ì»´íŒŒì¼(ìì‹ ì˜ ì½”ë“œì™€ ë””íœë˜ì‹œ)"

#: src/05_ticket_v2/11_dependencies.md:19
msgid ""
"Dependency resolution is skipped if your project has a `Cargo.lock` file and "
"your manifest files are unchanged. A lockfile is automatically generated by "
"`cargo` after a successful round of dependency resolution: it contains the "
"exact versions of all dependencies used in your project, and is used to "
"ensure that the same versions are consistently used across different builds "
"(e.g. in CI). If you're working on a project with multiple developers, you "
"should commit the `Cargo.lock` file to your version control system."
msgstr ""
"í”„ë¡œì íŠ¸ì— `Cargo.lock` íŒŒì¼ì´ ìˆê³  ë§¤ë‹ˆí˜ìŠ¤íŠ¸ íŒŒì¼ì´ ë³€ê²½ë˜ì§€ ì•Šì€ ê²½ìš° ì¢…ì†"
"ì„± í•´ê²°ì„ ê±´ë„ˆëœë‹ˆë‹¤. lockfileì€ ì¢…ì†ì„± í•´ê²°ì´ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œëœ í›„ `cargo`ì— "
"ì˜í•´ ìë™ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤. ì—¬ê¸°ì—ëŠ” í”„ë¡œì íŠ¸ì— ì‚¬ìš©ëœ ëª¨ë“  ì¢…ì†ì„±ì˜ ì •í™•í•œ ë²„ì „"
"ì´ í¬í•¨ë˜ì–´ ìˆìœ¼ë©° ë™ì¼í•œ ë²„ì „ì´ ë‹¤ì–‘í•œ ë¹Œë“œ(ì˜ˆ: CI)ì—ì„œ ì¼ê´€ë˜ê²Œ ì‚¬ìš©ë˜ë„ë¡ "
"í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. . ì—¬ëŸ¬ ê°œë°œìì™€ í•¨ê»˜ í”„ë¡œì íŠ¸ë¥¼ ì§„í–‰í•˜ëŠ” ê²½ìš° `Cargo."
"lock` íŒŒì¼ì„ ë²„ì „ ì œì–´ ì‹œìŠ¤í…œì— ì»¤ë°‹í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/05_ticket_v2/11_dependencies.md:25
msgid ""
"You can use `cargo update` to update the `Cargo.lock` file with the latest "
"(compatible) versions of all your dependencies."
msgstr ""
"`cargo update`ë¥¼ ì‚¬ìš©í•˜ì—¬ `Cargo.lock` íŒŒì¼ì„ ëª¨ë“  ë””íœë˜ì‹œì˜ ìµœì‹ (í˜¸í™˜) ë²„ì „"
"ìœ¼ë¡œ ì—…ë°ì´íŠ¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/11_dependencies.md:27
msgid "Path dependencies"
msgstr "ê²½ë¡œ ë””íœë˜ì‹œ"

#: src/05_ticket_v2/11_dependencies.md:29
msgid ""
"You can also specify a dependency using a **path**. This is useful when "
"you're working on multiple local packages."
msgstr ""
"**ê²½ë¡œ**ë¥¼ ì‚¬ìš©í•˜ì—¬ ë””íœë˜ì‹œë¥¼ ì§€ì •í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” ì—¬ëŸ¬ ë¡œì»¬ íŒ¨í‚¤ì§€ë¥¼ "
"ì‘ì—…í•  ë•Œ ìœ ìš©í•©ë‹ˆë‹¤."

#: src/05_ticket_v2/11_dependencies.md:31
msgid ""
"```toml\n"
"[dependencies]\n"
"my-library = { path = \"../my-library\" }\n"
"```"
msgstr ""
"```toml\n"
"[dependencies]\n"
"my-library = { path = \"../my-library\" }\n"
"```"

#: src/05_ticket_v2/11_dependencies.md:36
msgid ""
"The path is relative to the `Cargo.toml` file of the package that's declaring "
"the dependency."
msgstr "ê²½ë¡œëŠ” ë””íœë˜ì‹œë¥¼ ì„ ì–¸í•˜ëŠ” íŒ¨í‚¤ì§€ì˜ `Cargo.toml` íŒŒì¼ì˜ ìƒëŒ€ê²½ë¡œì…ë‹ˆë‹¤."

#: src/05_ticket_v2/11_dependencies.md:38
msgid "Other sources"
msgstr "ê¸°íƒ€ ì†ŒìŠ¤"

#: src/05_ticket_v2/11_dependencies.md:40
msgid ""
"Check out the [Cargo documentation](https://doc.rust-lang.org/cargo/reference/"
"specifying-dependencies.html) for more details on where you can get "
"dependencies from and how to specify them in your `Cargo.toml` file."
msgstr ""
"ì¢…ì†ì„±ì„ ê°€ì ¸ì˜¬ ìˆ˜ ìˆëŠ” ìœ„ì¹˜ì™€ ì´ë¥¼ `Cargo.toml` íŒŒì¼ì— ì§€ì •í•˜ëŠ” ë°©ë²•ì— ëŒ€í•œ "
"ìì„¸í•œ ë‚´ìš©ì€ [Cargo ë¬¸ì„œ](https://doc.rust-lang.org/cargo/reference/"
"specifying-dependencies.html)ë¥¼ í™•ì¸í•˜ì„¸ìš”."

#: src/05_ticket_v2/11_dependencies.md:43
msgid "Dev dependencies"
msgstr "ê°œë°œìš© ë””íœë˜ì‹œ"

#: src/05_ticket_v2/11_dependencies.md:45
msgid ""
"You can also specify dependencies that are only needed for developmentâ€”i.e. "
"they only get pulled in when you're running `cargo test`.  \n"
"They go in the `[dev-dependencies]` section of your `Cargo.toml` file:"
msgstr ""
"ê°œë°œì—ë§Œ í•„ìš”í•œ ë””íœë˜ì‹œì„ ì§€ì •í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ì´ê²ƒë“¤ì€ `cargo test`ë¥¼ ì‹¤í–‰"
"í•  ë•Œë§Œ ë°›ì•„ì˜µë‹ˆë‹¤.  \n"
"`Cargo.toml` íŒŒì¼ì˜ `[dev-dependents]` ì„¹ì…˜ì— ë“¤ì–´ê°‘ë‹ˆë‹¤:"

#: src/05_ticket_v2/11_dependencies.md:49
msgid ""
"```toml\n"
"[dev-dependencies]\n"
"static_assertions = \"1.1.0\"\n"
"```"
msgstr ""
"```toml\n"
"[dev-dependencies]\n"
"static_assertions = \"1.1.0\"\n"
"```"

#: src/05_ticket_v2/11_dependencies.md:54
msgid ""
"We've been using a few of these throughout the book to shorten our tests."
msgstr ""
"ìš°ë¦¬ëŠ” í…ŒìŠ¤íŠ¸ë¥¼ ë‹¨ì¶•í•˜ê¸° ìœ„í•´ ì±… ì „ë°˜ì— ê±¸ì³ ì´ë“¤ ì¤‘ ëª‡ ê°€ì§€ë¥¼ ì‚¬ìš©í•´ ì™”ìŠµë‹ˆ"
"ë‹¤."

#: src/05_ticket_v2/11_dependencies.md:58
msgid ""
"The exercise for this section is located in [`05_ticket_v2/11_dependencies`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/11_dependencies)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`05_ticket_v2/11_dependencies`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/11_dependencies)ì— ìˆìŠµë‹ˆë‹¤"

#: src/05_ticket_v2/12_thiserror.md:3
msgid ""
"That was a bit of detour, wasn't it? But a necessary one!  \n"
"Let's get back on track now: custom error types and `thiserror`."
msgstr ""
"ì¢€ ë¹™ ë‘˜ëŸ¬ì™”ì–´ìš”, ê·¸ë ‡ì£ ? í•˜ì§€ë§Œ ê¼­ í•„ìš”í•œ ê²ƒì´ì—ˆì–´ìš”!  \n"
"ì´ì œ ë‹¤ì‹œ ì›ë˜ëŒ€ë¡œ ëŒì•„ê°€ ë³´ê² ìŠµë‹ˆë‹¤: ì»¤ìŠ¤í…€ ì—ëŸ¬ íƒ€ì…ê³¼ `thiserror`."

#: src/05_ticket_v2/12_thiserror.md:6
msgid "Custom error types"
msgstr "ì»¤ìŠ¤í…€ ì—ëŸ¬ íƒ€ì…"

#: src/05_ticket_v2/12_thiserror.md:8
msgid ""
"We've seen how to implement the `Error` trait \"manually\" for a custom error "
"type.  \n"
"Imagine that you have to do this for most error types in your codebase. "
"That's a lot of boilerplate, isn't it?"
msgstr ""
"ìš°ë¦¬ëŠ” ì»¤ìŠ¤í…€ ì—ëŸ¬ íƒ€ì…ì— ëŒ€í•´ `Error` íŠ¸ë ˆì‡ì„ \"ìˆ˜ë™ìœ¼ë¡œ\" êµ¬í˜„í•˜ëŠ” ë°©ë²•ì„ "
"ì‚´í´ë³´ì•˜ìŠµë‹ˆë‹¤.  \n"
"ì½”ë“œë² ì´ìŠ¤ì— ìˆëŠ” ëŒ€ë¶€ë¶„ì˜ ì—ëŸ¬ íƒ€ì…ì— ëŒ€í•´ ì´ ì‘ì—…ì„ ìˆ˜í–‰í•´ì•¼ í•œë‹¤ê³  ìƒìƒí•´ "
"ë³´ì„¸ìš”. ìƒìš©êµ¬ê°€ ë„ˆë¬´ ë§ì£ , ê·¸ë ‡ì§€ì•Šë‚˜ìš”?"

#: src/05_ticket_v2/12_thiserror.md:11
msgid ""
"We can remove some of the boilerplate by using [`thiserror`](https://docs.rs/"
"thiserror/latest/thiserror/), a Rust crate that provides a **procedural "
"macro** to simplify the creation of custom error types."
msgstr ""
"ì»¤ìŠ¤í…€ ì—ëŸ¬ íƒ€ì… ìƒì„±ì„ ë‹¨ìˆœí™”í•˜ê¸° ìœ„í•´ **ì ˆì°¨ì  ë§¤í¬ë¡œ**ë¥¼ ì œê³µí•˜ëŠ” Rust í¬ë ˆ"
"ì´íŠ¸ì¸ `thiserror`ë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒìš©êµ¬ ì¤‘ ì¼ë¶€ë¥¼ ì œê±°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/12_thiserror.md:17 src/05_ticket_v2/12_thiserror.md:19
msgid "\"{0}\""
msgstr "\"{0}\""

#: src/05_ticket_v2/12_thiserror.md:24
msgid "You can write your own macros"
msgstr "ë§¤í¬ë¡œë¥¼ ì§ì ‘ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤"

#: src/05_ticket_v2/12_thiserror.md:26
msgid ""
"All the `derive` macros we've seen so far were provided by the Rust standard "
"library.  \n"
"`thiserror::Error` is the first example of a **third-party** `derive` macro."
msgstr ""
"ì§€ê¸ˆê¹Œì§€ ë³¸ ëª¨ë“  `derive` ë§¤í¬ë¡œëŠ” Rust í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ì œê³µë˜ì—ˆìŠµë‹ˆ"
"ë‹¤.  \n"
"`thiserror::Error`ëŠ” **íƒ€ì‚¬** `derive` ë§¤í¬ë¡œì˜ ì²« ë²ˆì§¸ ì˜ˆì…ë‹ˆë‹¤."

#: src/05_ticket_v2/12_thiserror.md:29
msgid ""
"`derive` macros are a subset of **procedural macros**, a way to generate Rust "
"code at compile time. We won't get into the details of how to write a "
"procedural macro in this course, but it's important to know that you can "
"write your own!  \n"
"A topic to approach in a more advanced Rust course."
msgstr ""
"`derive` ë§¤í¬ë¡œëŠ” ì»´íŒŒì¼ íƒ€ì„ì— Rust ì½”ë“œë¥¼ ìƒì„±í•˜ëŠ” ë°©ë²•ì¸ **ì ˆì°¨ì  ë§¤í¬ë¡œ**"
"ì˜ í•˜ìœ„ ì§‘í•©ì…ë‹ˆë‹¤. ì´ ê³¼ì •ì—ì„œëŠ” ì ˆì°¨ì  ë§¤í¬ë¡œë¥¼ ì‘ì„±í•˜ëŠ” ë°©ë²•ì— ëŒ€í•´ ìì„¸íˆ "
"ì„¤ëª…í•˜ì§€ ì•Šì§€ë§Œ ì§ì ‘ ì‘ì„±í•  ìˆ˜ ìˆë‹¤ëŠ” ì ì„ ì•„ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤!  \n"
"ì¢€ ë” ê³ ê¸‰ Rust ì½”ìŠ¤ì—ì„œ ë‹¤ë¤„ë³¼ë§Œí•œ ì£¼ì œì…ë‹ˆë‹¤."

#: src/05_ticket_v2/12_thiserror.md:34
msgid "Custom syntax"
msgstr "ì»¤ìŠ¤í…€ ë¬¸ë²•"

#: src/05_ticket_v2/12_thiserror.md:36
msgid ""
"Each procedural macro can define its own syntax, which is usually explained "
"in the crate's documentation. In the case of `thiserror`, we have:"
msgstr ""
"ê° ì ˆì°¨ì  ë§¤í¬ë¡œëŠ” ìì²´ ë¬¸ë²•ì„ ì •ì˜í•  ìˆ˜ ìˆìœ¼ë©° ì´ëŠ” ì¼ë°˜ì ìœ¼ë¡œ í¬ë ˆì´íŠ¸ ë¬¸ì„œ"
"ì— ì„¤ëª…ë˜ì–´ ìˆìŠµë‹ˆë‹¤. `thiserror`ì˜ ê²½ìš° ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/05_ticket_v2/12_thiserror.md:39
msgid ""
"`#[derive(thiserror::Error)]`: this is the syntax to derive the `Error` trait "
"for a custom error type, helped by `thiserror`."
msgstr ""
"`#[derive(thiserror::Error)]`: ì´ê²ƒì€ `thiserror`ì˜ ë„ì›€ì„ ë°›ì•„ ì‚¬ìš©ì ì •ì˜ ì˜¤"
"ë¥˜ ìœ í˜•ì— ëŒ€í•œ `Error` íŠ¸ë ˆì‡ì„ íŒŒìƒì‹œí‚¤ëŠ” êµ¬ë¬¸ì…ë‹ˆë‹¤."

#: src/05_ticket_v2/12_thiserror.md:40
msgid ""
"`#[error(\"{0}\")]`: this is the syntax to define a `Display` implementation "
"for each variant of the custom error type. `{0}` is replaced by the zero-th "
"field of the variant (`String`, in this case) when the error is displayed."
msgstr ""
"`#[error(\"{0}\")]`: ì´ëŠ” ì»¤ìŠ¤í…€ ì—ëŸ¬ íƒ€ì…ì˜ ê° ë°°ë¦¬ì–¸íŠ¸ì— ëŒ€í•´ `Display` êµ¬í˜„"
"ì„ ì •ì˜í•˜ëŠ” êµ¬ë¬¸ì…ë‹ˆë‹¤. ì˜¤ë¥˜ê°€ í‘œì‹œë˜ë©´ `{0}`ì€ ë°°ë¦¬ì–¸íŠ¸(ì´ ê²½ìš° `String`)ì˜ 0"
"ë²ˆì§¸ í•„ë“œë¡œ ëŒ€ì²´ë©ë‹ˆë‹¤."

#: src/05_ticket_v2/12_thiserror.md:45
msgid ""
"The exercise for this section is located in [`05_ticket_v2/12_thiserror`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/12_thiserror)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`05_ticket_v2/12_thiserror`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/12_thiserror)ì— ìˆìŠµë‹ˆë‹¤"

#: src/05_ticket_v2/13_try_from.md:1 src/05_ticket_v2/13_try_from.md:10
msgid "`TryFrom` and `TryInto`"
msgstr "`TryFrom`ê³¼ `TryInto`"

#: src/05_ticket_v2/13_try_from.md:3
msgid ""
"In the previous chapter we looked at the [`From` and `Into` traits]"
"(../04_traits/09_from.md), Rust's idiomatic interfaces for **infallible** "
"type conversions.  \n"
"But what if the conversion is not guaranteed to succeed?"
msgstr ""
"ì´ì „ ì¥ì—ì„œ ìš°ë¦¬ëŠ” **ë¬´ê²°í•œ** íƒ€ì… ë³€í™˜ì„ ìœ„í•œ Rustì˜ ê´€ìš©ì  ì¸í„°í˜ì´ìŠ¤ì¸ "
"[`From`ê³¼ `Into` íŠ¸ë ˆì‡](../04_traits/09_from.md)ì„ ì‚´í´ë³´ì•˜ìŠµë‹ˆë‹¤.  \n"
"í•˜ì§€ë§Œ ë³€í™˜ ì„±ê³µì´ ë³´ì¥ë˜ì§€ ì•Šìœ¼ë©´ ì–´ë–»ê²Œ ë ê¹Œìš”?"

#: src/05_ticket_v2/13_try_from.md:7
msgid ""
"We now know enough about errors to discuss the **fallible** counterparts of "
"`From` and `Into`: `TryFrom` and `TryInto`."
msgstr ""
"ì´ì œ ìš°ë¦¬ëŠ” `From`ê³¼ `Into`ì— í•´ë‹¹í•˜ëŠ” **ì˜¤ë¥˜ê°€ ìˆëŠ”** ëŒ€ì‘ ìš”ì†Œì¸ `TryFrom`"
"ê³¼ `TryInto`ë¥¼ ë…¼ì˜í•  ë§Œí¼ ì˜¤ë¥˜ì— ëŒ€í•´ ì¶©ë¶„íˆ ì•Œê³  ìˆìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/13_try_from.md:12
msgid ""
"Both `TryFrom` and `TryInto` are defined in the `std::convert` module, just "
"like `From` and `Into`."
msgstr ""
"`TryFrom`ê³¼ `TryInto`ëŠ” `From`ê³¼ `Into`ì²˜ëŸ¼ `std::convert` ëª¨ë“ˆì— ì •ì˜ë©ë‹ˆë‹¤."

#: src/05_ticket_v2/13_try_from.md:26
msgid ""
"The main difference between `From`/`Into` and `TryFrom`/`TryInto` is that the "
"latter return a `Result` type.  \n"
"This allows the conversion to fail, returning an error instead of panicking."
msgstr ""
"`From`/`Into`ì™€ `TryFrom`/`TryInto`ì˜ ì£¼ìš” ì°¨ì´ì ì€ í›„ìê°€ `Result` ìœ í˜•ì„ ë°˜"
"í™˜í•œë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤.  \n"
"ì´ë ‡ê²Œ í•˜ë©´ ë³€í™˜ì´ ì‹¤íŒ¨í–ˆì„ ë•Œ íŒ¨ë‹‰í•˜ëŠ” ëŒ€ì‹  ì˜¤ë¥˜ê°€ ë°˜í™˜ë©ë‹ˆë‹¤."

#: src/05_ticket_v2/13_try_from.md:29
msgid "`Self::Error`"
msgstr "`Self::Error`"

#: src/05_ticket_v2/13_try_from.md:31
msgid ""
"Both `TryFrom` and `TryInto` have an associated `Error` type. This allows "
"each implementation to specify its own error type, ideally the most "
"appropriate for the conversion being attempted."
msgstr ""
"`TryFrom`ê³¼ `TryInto` ëª¨ë‘ ì—°ê´€ `Error` íƒ€ì…ì´ ìˆìŠµë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ê° êµ¬í˜„ì€ "
"ì´ìƒì ìœ¼ë¡œëŠ” ì‹œë„ ì¤‘ì¸ ë³€í™˜ì— ê°€ì¥ ì í•©í•œ ìì²´ ì—ëŸ¬ íƒ€ì…ì„ ì§€ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/13_try_from.md:35
msgid ""
"`Self::Error` is a way to refer to the `Error` associated type defined in the "
"trait itself."
msgstr ""
"`Self::Error`ëŠ” íŠ¸ë ˆì‡ ìì²´ì— ì •ì˜ëœ `Error` ê´€ë ¨ íƒ€ì…ì„ ì°¸ì¡°í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤."

#: src/05_ticket_v2/13_try_from.md:37
msgid "Duality"
msgstr "ì´ì¤‘ì„±"

#: src/05_ticket_v2/13_try_from.md:39
msgid ""
"Just like `From` and `Into`, `TryFrom` and `TryInto` are dual traits.  \n"
"If you implement `TryFrom` for a type, you get `TryInto` for free."
msgstr ""
"`From` ë° `Into`ì™€ ë§ˆì°¬ê°€ì§€ë¡œ `TryFrom`ê³¼ `TryInto`ëŠ” ì´ì¤‘ íŠ¸ë ˆì‡ì…ë‹ˆë‹¤.  \n"
"íƒ€ì…ì— ëŒ€í•´ `TryFrom`ì„ êµ¬í˜„í•˜ë©´ `TryInto`ë¥¼ ìë™ìœ¼ë¡œ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/13_try_from.md:44
msgid ""
"The exercise for this section is located in [`05_ticket_v2/13_try_from`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/13_try_from)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`05_ticket_v2/13_try_from`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/13_try_from)ì— ìˆìŠµë‹ˆë‹¤"

#: src/05_ticket_v2/14_source.md:3
msgid ""
"There's one more thing we need to talk about to complete our coverage of the "
"`Error` trait: the `source` method."
msgstr ""
"`Error` íŠ¸ë ˆì‡ì„ ì™„ì „íˆ ë‹¤ë£¨ê¸° ìœ„í•´ ì´ì•¼ê¸°í•´ì•¼ í•  ê²ƒì´ í•˜ë‚˜ ë” ìˆìŠµë‹ˆë‹¤: "
"`source` ë©”ì„œë“œì…ë‹ˆë‹¤."

#: src/05_ticket_v2/14_source.md:6
msgid "// Full definition this time!\n"
msgstr "// ì´ë²ˆì—ëŠ” ì™„ì „í•œ ì •ì˜!\n"

#: src/05_ticket_v2/14_source.md:14
msgid ""
"The `source` method is a way to access the **error cause**, if any.  \n"
"Errors are often chained, meaning that one error is the cause of another: you "
"have a high-level error (e.g. cannot connect to the database) that is caused "
"by a lower-level error (e.g. can't resolve the database hostname). The "
"`source` method allows you to \"walk\" the full chain of errors, often used "
"when capturing error context in logs."
msgstr ""
"`source` ë©”ì„œë“œëŠ” **ì˜¤ë¥˜ ì›ì¸**(ìˆëŠ” ê²½ìš°)ì— ì•¡ì„¸ìŠ¤í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.  \n"
"ì˜¤ë¥˜ëŠ” í”íˆ ì—°ì‡„ì ìœ¼ë¡œ ë°œìƒí•©ë‹ˆë‹¤. ì¦‰, í•˜ë‚˜ì˜ ì˜¤ë¥˜ê°€ ë‹¤ë¥¸ ì˜¤ë¥˜ì˜ ì›ì¸ì´ ëœë‹¤"
"ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤. ì¦‰, ë‚®ì€ ìˆ˜ì¤€ì˜ ì˜¤ë¥˜(ì˜ˆ: ë°ì´í„°ë² ì´ìŠ¤ í˜¸ìŠ¤íŠ¸ ì´ë¦„ì„ í™•ì¸í•  ìˆ˜ "
"ì—†ìŒ)ë¡œ ì¸í•´ ë°œìƒí•œ ë†’ì€ ìˆ˜ì¤€ì˜ ì˜¤ë¥˜(ì˜ˆ: ë°ì´í„°ë² ì´ìŠ¤ì— ì—°ê²°í•  ìˆ˜ ì—†ìŒ)ê°€ ë°œìƒ"
"í•œë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. `source`ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ë©´ ë¡œê·¸ì—ì„œ ì—ëŸ¬ ì»¨í…ìŠ¤íŠ¸ë¥¼ ìº¡ì²˜í•  ë•Œ "
"ìì£¼ ì‚¬ìš©ë˜ëŠ” ì „ì²´ ì—ëŸ¬ ì²´ì¸ì„ `íƒìƒ‰`í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/14_source.md:19
msgid "Implementing `source`"
msgstr "`source` êµ¬í˜„"

#: src/05_ticket_v2/14_source.md:21
msgid ""
"The `Error` trait provides a default implementation that always returns "
"`None` (i.e. no underlying cause). That's why you didn't have to care about "
"`source` in the previous exercises.  \n"
"You can override this default implementation to provide a cause for your "
"error type."
msgstr ""
"`Error` íŠ¸ë ˆì‡ì€ í•­ìƒ `None`(ì¦‰, ê·¼ë³¸ì ì¸ ì›ì¸ì´ ì—†ìŒ)ì„ ë°˜í™˜í•˜ëŠ” ê¸°ë³¸ êµ¬í˜„ì„ "
"ì œê³µí•©ë‹ˆë‹¤. ê·¸ë ‡ê¸° ë•Œë¬¸ì— ì´ì „ ì—°ìŠµì—ì„œëŠ” `source`ì— ì‹ ê²½ ì“¸ í•„ìš”ê°€ ì—†ì—ˆìŠµë‹ˆ"
"ë‹¤.  \n"
"ì´ ê¸°ë³¸ êµ¬í˜„ì„ ì¬ì •ì˜í•˜ì—¬ ì—ëŸ¬ íƒ€ì…ì˜ ì›ì¸ì„ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/14_source.md:35 src/05_ticket_v2/14_source.md:73
#: src/05_ticket_v2/14_source.md:85 src/05_ticket_v2/14_source.md:99
msgid "\"Failed to connect to the database\""
msgstr "\"Failed to connect to the database\""

#: src/05_ticket_v2/14_source.md:46
msgid ""
"In this example, `DatabaseError` wraps an `std::io::Error` as its source. We "
"then override the `source` method to return this source when called."
msgstr ""
"ì´ ì˜ˆì‹œì—ì„œ `DatabaseError`ëŠ” `std::io::Error`ë¥¼ ì†ŒìŠ¤ë¡œ ë˜í•‘í•©ë‹ˆë‹¤. ê·¸ëŸ° ë‹¤ìŒ "
"`source` ë©”ì„œë“œë¥¼ ì¬ì •ì˜í•˜ì—¬ í˜¸ì¶œ ì‹œ ì´ ì†ŒìŠ¤ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."

#: src/05_ticket_v2/14_source.md:49
msgid "`&(dyn Error + 'static)`"
msgstr "`&(dyn Error + 'static)`"

#: src/05_ticket_v2/14_source.md:51
msgid ""
"What's this `&(dyn Error + 'static)` type?  \n"
"Let's unpack it:"
msgstr ""
"ì´ `&(dyn Error + 'static)` íƒ€ì…ì€ ë¬´ì—‡ì¸ê°€ìš”?  \n"
"í•œë²ˆ ê¹Œë´…ì‹œë‹¤:"

#: src/05_ticket_v2/14_source.md:54
msgid ""
"`dyn Error` is a **trait object**. It's a way to refer to any type that "
"implements the `Error` trait."
msgstr ""
"`dyn Error`ëŠ” **íŠ¸ë ˆì‡ ê°œì²´**ì…ë‹ˆë‹¤. ì´ëŠ” `Error` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ëŠ” ëª¨ë“  íƒ€ì…"
"ì„ ì°¸ì¡°í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤."

#: src/05_ticket_v2/14_source.md:55
msgid ""
"`'static` is a special **lifetime specifier**. `'static` implies that the "
"reference is valid for \"as long as we need it\", i.e. the entire program "
"execution."
msgstr ""
"`'static`ì€ íŠ¹ë³„í•œ **ìˆ˜ëª… ì§€ì •ì**ì…ë‹ˆë‹¤. `'static`ì€ ì°¸ì¡°ê°€ \"í•„ìš”í•œ í•œ\", "
"ì¦‰ ì „ì²´ í”„ë¡œê·¸ë¨ ì‹¤í–‰ ë™ì•ˆ ìœ íš¨í•¨ì„ ì˜ë¯¸í•©ë‹ˆë‹¤."

#: src/05_ticket_v2/14_source.md:58
msgid ""
"Combined: `&(dyn Error + 'static)` is a reference to a trait object that "
"implements the `Error` trait and is valid for the entire program execution."
msgstr ""
"`&(dyn Error + 'static)`ì˜ ì¡°í•©ì€ `Error` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ëŠ” íŠ¸ë ˆì‡ ê°œì²´ì— ëŒ€"
"í•œ ì°¸ì¡°ì´ë©° ì „ì²´ í”„ë¡œê·¸ë¨ ì‹¤í–‰ë™ì•ˆì— ìœ íš¨í•©ë‹ˆë‹¤."

#: src/05_ticket_v2/14_source.md:61
msgid ""
"Don't worry too much about either of these concepts for now. We'll cover them "
"in more detail in future chapters."
msgstr ""
"ì§€ê¸ˆì€ ì´ëŸ¬í•œ ê°œë… ì¤‘ í•˜ë‚˜ì— ëŒ€í•´ ë„ˆë¬´ ê±±ì •í•˜ì§€ ë§ˆì„¸ìš”. ìš°ë¦¬ëŠ” ì´í›„ ì¥ì—ì„œ ì´"
"ì— ëŒ€í•´ ë” ìì„¸íˆ ë‹¤ë£° ê²ƒì…ë‹ˆë‹¤."

#: src/05_ticket_v2/14_source.md:63
msgid "Implementing `source` using `thiserror`"
msgstr "`thiserror`ë¥¼ ì‚¬ìš©í•˜ì—¬ `source` êµ¬í˜„"

#: src/05_ticket_v2/14_source.md:65
msgid ""
"`thiserror` provides three ways to automatically implement `source` for your "
"error types:"
msgstr ""
"`thiserror`ëŠ” ì—ëŸ¬ íƒ€ì…ì— ëŒ€í•´ `source`ë¥¼ ìë™ìœ¼ë¡œ êµ¬í˜„í•˜ëŠ” ì„¸ ê°€ì§€ ë°©ë²•ì„ ì œ"
"ê³µí•©ë‹ˆë‹¤:"

#: src/05_ticket_v2/14_source.md:67
msgid ""
"A field named `source` will automatically be used as the source of the error."
msgstr "`source`ë¼ëŠ” í•„ë“œê°€ ìë™ìœ¼ë¡œ ì—ëŸ¬ ì†ŒìŠ¤ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤."

#: src/05_ticket_v2/14_source.md:79
msgid ""
"A field annotated with the `#[source]` attribute will automatically be used "
"as the source of the error."
msgstr ""
"`#[source]` ì†ì„±ì˜ ì–´ë…¸í…Œì´ì…˜ì´ ë‹¬ë¦° í•„ë“œëŠ” ìë™ìœ¼ë¡œ ì˜¤ë¥˜ ì†ŒìŠ¤ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤."

#: src/05_ticket_v2/14_source.md:92
msgid ""
"A field annotated with the `#[from]` attribute will automatically be used as "
"the source of the error **and** `thiserror` will automatically generate a "
"`From` implementation to convert the annotated type into your error type."
msgstr ""
"`#[from]` ì†ì„±ìœ¼ë¡œ ì£¼ì„ì´ ë‹¬ë¦° í•„ë“œëŠ” ìë™ìœ¼ë¡œ ì˜¤ë¥˜ì˜ ì†ŒìŠ¤ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤ **ê·¸ë¦¬"
"ê³ ** `thiserror`ëŠ” ì–´ë…¸í…Œì´ì…˜ì´ ë‹¬ë¦° íƒ€ì…ì„ ì—ëŸ¬ íƒ€ì…ìœ¼ë¡œ ë³€í™˜í•˜ê¸° ìœ„í•´ ìë™ìœ¼"
"ë¡œ `From` êµ¬í˜„ì„ ìƒì„±í•©ë‹ˆë‹¤."

#: src/05_ticket_v2/14_source.md:107
msgid "The `?` operator"
msgstr "`?` ì—°ì‚°ì"

#: src/05_ticket_v2/14_source.md:109
msgid ""
"The `?` operator is a shorthand for propagating errors.  \n"
"When used in a function that returns a `Result`, it will return early with an "
"error if the `Result` is `Err`."
msgstr ""
"`?` ì—°ì‚°ìëŠ” ì˜¤ë¥˜ ì „íŒŒë¥¼ ì¤„ì—¬ì„œ í‘œí˜„í•œ ê²ƒì…ë‹ˆë‹¤.  \n"
"`Result`ë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ì— ì‚¬ìš©ë  ë•Œ `Result`ê°€ `Err`ì¸ ê²½ìš° ì˜¤ë¥˜ì™€ í•¨ê»˜ ì¡°ê¸°"
"ì— ë°˜í™˜ë©ë‹ˆë‹¤."

#: src/05_ticket_v2/14_source.md:118 src/05_ticket_v2/14_source.md:131
msgid "\"file.txt\""
msgstr "\"file.txt\""

#: src/05_ticket_v2/14_source.md:125
msgid "is equivalent to:"
msgstr "ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/05_ticket_v2/14_source.md:148
msgid ""
"You can use the `?` operator to shorten your error handling code "
"significantly.  \n"
"In particular, the `?` operator will automatically convert the error type of "
"the fallible operation into the error type of the function, if a conversion "
"is possible (i.e. if there is a suitable `From` implementation)"
msgstr ""
"`?` ì—°ì‚°ìë¥¼ ì‚¬ìš©í•˜ë©´ ì˜¤ë¥˜ ì²˜ë¦¬ ì½”ë“œë¥¼ ëŒ€í­ ë‹¨ì¶•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"íŠ¹íˆ `?` ì—°ì‚°ìëŠ” ë³€í™˜ì´ ê°€ëŠ¥í•œ ê²½ìš°(ì¦‰, ì ì ˆí•œ `From` êµ¬í˜„ì´ ìˆëŠ” ê²½ìš°) ì˜¤ë¥˜"
"ê°€ ìˆëŠ” ì—°ì‚°ì˜ ì—ëŸ¬ íƒ€ì…ì„ í•¨ìˆ˜ì˜ ì—ëŸ¬ íƒ€ì…ìœ¼ë¡œ ìë™ ë³€í™˜í•©ë‹ˆë‹¤."

#: src/05_ticket_v2/14_source.md:154
msgid ""
"The exercise for this section is located in [`05_ticket_v2/14_source`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/14_source)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`05_ticket_v2/14_source`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/14_source)ì— ìˆìŠµë‹ˆë‹¤"

#: src/05_ticket_v2/15_outro.md:3
msgid ""
"When it comes to domain modelling, the devil is in the details.  \n"
"Rust offers a wide range of tools to help you represent the constraints of "
"your domain directly in the type system, but it takes some practice to get it "
"right and write code that looks idiomatic."
msgstr ""
"ë„ë©”ì¸ ëª¨ë¸ë§ì— ìˆì–´ì„œ ì•…ë§ˆëŠ” ë””í…Œì¼ì— ìˆìŠµë‹ˆë‹¤.  \n"
"RustëŠ” íƒ€ì… ì‹œìŠ¤í…œì—ì„œ ë„ë©”ì¸ì˜ ì œì•½ ì¡°ê±´ì„ ì§ì ‘ í‘œí˜„í•˜ëŠ” ë° ë„ì›€ì´ ë˜ëŠ” ë‹¤ì–‘"
"í•œ ë„êµ¬ë¥¼ ì œê³µí•˜ì§€ë§Œ ì´ë¥¼ ì˜¬ë°”ë¥´ê²Œ êµ¬í˜„í•˜ê³  ê´€ìš©ì ìœ¼ë¡œ ë³´ì´ëŠ” ì½”ë“œë¥¼ ì‘ì„±í•˜ë ¤"
"ë©´ ì•½ê°„ì˜ ì—°ìŠµì´ í•„ìš”í•©ë‹ˆë‹¤."

#: src/05_ticket_v2/15_outro.md:7
msgid ""
"Let's close the chapter with one final refinement of our `Ticket` model.  \n"
"We'll introduce a new type for each of the fields in `Ticket` to encapsulate "
"the respective constraints.  \n"
"Every time someone accesses a `Ticket` field, they'll get back a value that's "
"guaranteed to be validâ€”i.e. a `TicketTitle` instead of a `String`. They won't "
"have to worry about the title being empty elsewhere in the code: as long as "
"they have a `TicketTitle`, they know it's valid **by construction**."
msgstr ""
"`Ticket` ëª¨ë¸ì„ ë§ˆì§€ë§‰ìœ¼ë¡œ ê°œì„ í•˜ë©´ì„œ ì¥ì„ ë§ˆë¬´ë¦¬í•˜ê² ìŠµë‹ˆë‹¤.  \n"
"ê° ì œì•½ ì¡°ê±´ì„ ìº¡ìŠí™”í•˜ê¸° ìœ„í•´ `Ticket`ì˜ ê° í•„ë“œì— ìƒˆë¡œìš´ íƒ€ì…ì„ ë„ì…í•˜ê² ìŠµë‹ˆ"
"ë‹¤.  \n"
"ëˆ„êµ°ê°€ `Ticket` í•„ë“œì— ì•¡ì„¸ìŠ¤í•  ë•Œë§ˆë‹¤ ìœ íš¨í•˜ë‹¤ê³  ë³´ì¥ëœ ê°’ì„ ëŒë ¤ë°›ê²Œ ë©ë‹ˆ"
"ë‹¤. `String` ëŒ€ì‹  `TicketTitle`. ì½”ë“œì˜ ë‹¤ë¥¸ ê³³ì—ì„œ ì œëª©ì´ ë¹„ì–´ ìˆëŠ” ê²ƒì— ëŒ€"
"í•´ ê±±ì •í•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤. `TicketTitle`ì´ ìˆëŠ” í•œ í•´ë‹¹ ì œëª©ì´ **êµ¬ì¡°ìƒ** ìœ íš¨"
"í•˜ë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/05_ticket_v2/15_outro.md:13
msgid ""
"This is just an example of how you can use Rust's type system to make your "
"code safer and more expressive."
msgstr ""
"ì´ê²ƒì€ Rustì˜ íƒ€ì… ì‹œìŠ¤í…œì„ ì‚¬ìš©í•˜ì—¬ ì½”ë“œë¥¼ ë”ìš± ì•ˆì „í•˜ê³  í‘œí˜„ë ¥ ìˆê²Œ ë§Œë“œëŠ” "
"ë°©ë²•ì— ëŒ€í•œ ì˜ˆì¼ ë¿ì…ë‹ˆë‹¤."

#: src/05_ticket_v2/15_outro.md:17
msgid ""
"[Parse, don't validate](https://lexi-lambda.github.io/blog/2019/11/05/parse-"
"don-t-validate/)"
msgstr ""
"[Parse, don't validate](https://lexi-lambda.github.io/blog/2019/11/05/parse-"
"don-t-validate/)"

#: src/05_ticket_v2/15_outro.md:18
msgid ""
"[Using types to guarantee domain invariants](https://www.lpalmieri.com/"
"posts/2020-12-11-zero-to-production-6-domain-modelling/)"
msgstr ""
"[Using types to guarantee domain invariants](https://www.lpalmieri.com/"
"posts/2020-12-11-zero-to-production-6-domain-modelling/)"

#: src/05_ticket_v2/15_outro.md:22
msgid ""
"The exercise for this section is located in [`05_ticket_v2/15_outro`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/15_outro)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`05_ticket_v2/15_outro`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/15_outro)ì— ìˆìŠµë‹ˆë‹¤"

#: src/06_ticket_management/00_intro.md:1 src/07_threads/00_intro.md:1
msgid "Intro"
msgstr "ì†Œê°œ"

#: src/06_ticket_management/00_intro.md:3
msgid ""
"In the previous chapter we modelled `Ticket` in a vacuum: we defined its "
"fields and their constraints, we learned how to best represent them in Rust, "
"but we didn't consider how `Ticket` fits into a larger system. We'll use this "
"chapter to build a simple workflow around `Ticket`, introducing a "
"(rudimentary) management system to store and retrieve tickets."
msgstr ""
"ì´ì „ ì¥ì—ì„œ ìš°ë¦¬ëŠ” `Ticket`ì„ ì§„ê³µ ìƒíƒœì—ì„œ ëª¨ë¸ë§í–ˆìŠµë‹ˆë‹¤. í•„ë“œì™€ ì œì•½ ì¡°ê±´"
"ì„ ì •ì˜í•˜ê³  Rustì—ì„œ ì´ë¥¼ ê°€ì¥ ì˜ í‘œí˜„í•˜ëŠ” ë°©ë²•ì„ ë°°ì› ì§€ë§Œ `Ticket`ì´ ë” í° ì‹œ"
"ìŠ¤í…œì— ì–´ë–»ê²Œ ì í•©í•œì§€ëŠ” ê³ ë ¤í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ìš°ë¦¬ëŠ” ì´ ì¥ì„ ì‚¬ìš©í•˜ì—¬ í‹°ì¼“ì„ "
"ì €ì¥í•˜ê³  ê²€ìƒ‰í•˜ëŠ” (ê¸°ë³¸) ê´€ë¦¬ ì‹œìŠ¤í…œì„ ì†Œê°œí•˜ëŠ” `Ticket`ì— ëŒ€í•œ ê°„ë‹¨í•œ ì‘ì—… í"
"ë¦„ì„ êµ¬ì¶•í•  ê²ƒì…ë‹ˆë‹¤."

#: src/06_ticket_management/00_intro.md:8
msgid ""
"The task will give us an opportunity to explore new Rust concepts, such as:"
msgstr ""
"ì´ ì‘ì—…ì€ ìš°ë¦¬ì—ê²Œ ë‹¤ìŒê³¼ ê°™ì€ ìƒˆë¡œìš´ Rust ê°œë…ì„ íƒêµ¬í•  ìˆ˜ ìˆëŠ” ê¸°íšŒë¥¼ ì œê³µ"
"í•  ê²ƒì…ë‹ˆë‹¤:"

#: src/06_ticket_management/00_intro.md:10
msgid "Stack-allocated arrays"
msgstr "ìŠ¤íƒ í• ë‹¹ ë°°ì—´"

#: src/06_ticket_management/00_intro.md:11
msgid "`Vec`, a growable array type, and slices"
msgstr "í™•ì¥ ê°€ëŠ¥í•œ ë°°ì—´ ìœ í˜•ì¸ `Vec`ì™€ ìŠ¬ë¼ì´ìŠ¤"

#: src/06_ticket_management/00_intro.md:12
msgid "`Iterator` and `IntoIterator`, for iterating over collections"
msgstr "ì»¬ë ‰ì…˜ ë°˜ë³µì„ ìœ„í•œ `Iterator`ì™€ `IntoIterator`"

#: src/06_ticket_management/00_intro.md:13
msgid "Slices (`&[T]`), to work with parts of a collection"
msgstr "ì»¬ë ‰ì…˜ì˜ ì¼ë¶€ ì‘ì—…ì„ ìœ„í•œ ìŠ¬ë¼ì´ìŠ¤(`&[T]`)"

#: src/06_ticket_management/00_intro.md:14
msgid "Lifetimes, to describe how long references are valid"
msgstr "ì°¸ì¡°ê°€ ìœ íš¨í•œ ê¸°ê°„ì„ ì„¤ëª…í•˜ê¸° ìœ„í•œ ìˆ˜ëª…"

#: src/06_ticket_management/00_intro.md:15
msgid "`HashMap` and `BTreeMap`, two key-value data structures"
msgstr "`HashMap`ì™€ `BTreeMap`, í‚¤-ê°’ ë°ì´í„° êµ¬ì¡°ì²´"

#: src/06_ticket_management/00_intro.md:16
msgid "`Eq` and `Hash`, to compare keys in a `HashMap`"
msgstr "`HashMap`ì˜ í‚¤ë¥¼ ë¹„êµí•˜ê¸° ìœ„í•œ `Eq`ì™€ `Hash`"

#: src/06_ticket_management/00_intro.md:17
msgid "`Ord` and `PartialOrd`, to work with a `BTreeMap`"
msgstr "`BTreeMap`ê³¼ í•¨ê»˜ ì‘ë™í•˜ëŠ” `Ord`ì™€ `PartialOrd`"

#: src/06_ticket_management/00_intro.md:18
msgid "`Index` and `IndexMut`, to access elements in a collection"
msgstr "ì»¬ë ‰ì…˜ì˜ ìš”ì†Œì— ì•¡ì„¸ìŠ¤í•˜ê¸° ìœ„í•œ `Index`ì™€ `IndexMut`"

#: src/06_ticket_management/00_intro.md:22
msgid ""
"The exercise for this section is located in [`06_ticket_management/00_intro`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/00_intro)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`06_ticket_management/00_intro`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/00_intro)ì— ìˆìŠµë‹ˆë‹¤"

#: src/06_ticket_management/01_arrays.md:3
msgid ""
"As soon as we start talking about \"ticket management\" we need to think "
"about a way to store _multiple_ tickets. In turn, this means we need to think "
"about collections. In particular, homogeneous collections: we want to store "
"multiple instances of the same type."
msgstr ""
"\"í‹°ì¼“ ê´€ë¦¬\"ì— ëŒ€í•´ ì´ì•¼ê¸°ë¥¼ ì‹œì‘í•˜ìë§ˆì _ë‹¤ì¤‘_ í‹°ì¼“ì„ ì €ì¥í•˜ëŠ” ë°©ë²•ì— ëŒ€í•´ "
"ìƒê°í•´ì•¼ í•©ë‹ˆë‹¤. ê²°ê³¼ì ìœ¼ë¡œ ì´ëŠ” ì»¬ë ‰ì…˜ì— ëŒ€í•´ ìƒê°í•´ì•¼ í•¨ì„ ì˜ë¯¸í•©ë‹ˆë‹¤. íŠ¹"
"íˆ, ë™ì¢… ì»¬ë ‰ì…˜: ë™ì¼í•œ íƒ€ì…ì˜ ì—¬ëŸ¬ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì €ì¥í•˜ë ¤ê³  í•©ë‹ˆë‹¤."

#: src/06_ticket_management/01_arrays.md:7
msgid "What does Rust have to offer in this regard?"
msgstr "ì´ì™€ ê´€ë ¨í•˜ì—¬ RustëŠ” ë¬´ì—‡ì„ ì œê³µí•´ì•¼ í•©ë‹ˆê¹Œ?"

#: src/06_ticket_management/01_arrays.md:11
msgid ""
"A first attempt could be to use an **array**.  \n"
"Arrays in Rust are fixed-size collections of elements of the same type."
msgstr ""
"ì²« ë²ˆì§¸ ì‹œë„ëŠ” **ë°°ì—´**ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"Rustì˜ ë°°ì—´ì€ ë™ì¼í•œ íƒ€ì…ì˜ ìš”ì†Œë¡œ êµ¬ì„±ëœ ê³ ì • í¬ê¸° ì»¬ë ‰ì…˜ì…ë‹ˆë‹¤."

#: src/06_ticket_management/01_arrays.md:14
msgid "Here's how you can define an array:"
msgstr "ë°°ì—´ì„ ì •ì˜í•˜ëŠ” ë°©ë²•ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/01_arrays.md:17
msgid "// Array type syntax: [ <type> ; <number of elements> ]\n"
msgstr "// Array type syntax: [ <type> ; <number of elements> ]\n"

#: src/06_ticket_management/01_arrays.md:21
msgid ""
"This creates an array of 3 integers, initialized with the values `1`, `2`, "
"and `3`.  \n"
"The type of the array is `[u32; 3]`, which reads as \"an array of `u32`s with "
"a length of 3\"."
msgstr ""
"ì´ ì½”ë“œëŠ” ê°’ `1`, `2`, ê·¸ë¦¬ê³  `3`ìœ¼ë¡œ ì´ˆê¸°í™”ëœ ì •ìˆ˜ 3ê°œë¥¼ í¬í•¨í•˜ëŠ” ë°°ì—´ì„ ìƒì„±"
"í•©ë‹ˆë‹¤.\n"
"ì´ ë°°ì—´ì˜ íƒ€ì…ì€ `[u32; 3]`ì´ë©°, ì´ëŠ” \"ê¸¸ì´ê°€ 3ì¸ `u32` ë°°ì—´\"ì„ ì˜ë¯¸í•©ë‹ˆë‹¤."

#: src/06_ticket_management/01_arrays.md:24
#: src/06_ticket_management/02_vec.md:47
msgid "Accessing elements"
msgstr "ìš”ì†Œì— ì ‘ê·¼í•˜ê¸°"

#: src/06_ticket_management/01_arrays.md:26
msgid "You can access elements of an array using square brackets:"
msgstr "ëŒ€ê´„í˜¸ë¥¼ ì‚¬ìš©í•˜ì—¬ ë°°ì—´ ìš”ì†Œì— ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/01_arrays.md:34
msgid ""
"The index must be of type `usize`.  \n"
"Arrays are **zero-indexed**, like everything in Rust. You've seen this before "
"with string slices and field indexing in tuples/tuple-like variants."
msgstr ""
"ì¸ë±ìŠ¤ëŠ” `usize` íƒ€ì…ì´ì–´ì•¼ í•©ë‹ˆë‹¤.  \n"
"ë°°ì—´ì€ Rustì˜ ëª¨ë“  ê²ƒê³¼ ë§ˆì°¬ê°€ì§€ë¡œ **ì œë¡œ ì¸ë±ìŠ¤**ì…ë‹ˆë‹¤. ì´ì „ì— ë¬¸ìì—´ ì¡°ê°"
"ê³¼ íŠœí”Œ/íŠœí”Œ ìœ ì‚¬ ë°°ë¦¬ì–¸íŠ¸ì˜ í•„ë“œ ì¸ë±ì‹±ì„ í†µí•´ ì´ë¥¼ ë³¸ ì ì´ ìˆìŠµë‹ˆë‹¤."

#: src/06_ticket_management/01_arrays.md:38
msgid "Out-of-bounds access"
msgstr "ë²”ìœ„ ë°– ì ‘ê·¼"

#: src/06_ticket_management/01_arrays.md:40
msgid "If you try to access an element that's out of bounds, Rust will panic:"
msgstr "ë²”ìœ„ë¥¼ ë²—ì–´ë‚œ ìš”ì†Œì— ì ‘ê·¼í•˜ë ¤ê³  í•˜ë©´ RustëŠ” íŒ¨ë‹‰ì„ ì¼ìœ¼í‚¬ ê²ƒì…ë‹ˆë‹¤:"

#: src/06_ticket_management/01_arrays.md:44
msgid "// This will panic\n"
msgstr "// íŒ¨ë‹‰ ìƒíƒœê°€ ë©ë‹ˆë‹¤\n"

#: src/06_ticket_management/01_arrays.md:47
msgid ""
"This is enforced at runtime using **bounds checking**. It comes with a small "
"performance overhead, but it's how Rust prevents buffer overflows.  \n"
"In some scenarios the Rust compiler can optimize away bounds checks, "
"especially if iterators are involvedâ€”we'll speak more about this later on."
msgstr ""
"ì´ëŠ” **ê²½ê³„ ê²€ì‚¬**ë¥¼ ì‚¬ìš©í•˜ì—¬ ëŸ°íƒ€ì„ì— ì ìš©ë©ë‹ˆë‹¤. ì•½ê°„ì˜ ì„±ëŠ¥ ì˜¤ë²„í—¤ë“œê°€ ìˆì§€"
"ë§Œ Rustê°€ ë²„í¼ ì˜¤ë²„í”Œë¡œë¥¼ ë°©ì§€í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.  \n"
"ì¼ë¶€ ì‹œë‚˜ë¦¬ì˜¤ì—ì„œëŠ” Rust ì»´íŒŒì¼ëŸ¬ê°€ ê²½ê³„ ê²€ì‚¬ë¥¼ ìµœì í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. íŠ¹íˆ ë°˜"
"ë³µìê°€ ê´€ë ¨ëœ ê²½ìš°ì—ëŠ” ë”ìš± ê·¸ë ‡ìŠµë‹ˆë‹¤. ì´ì— ëŒ€í•´ì„œëŠ” ë‚˜ì¤‘ì— ìì„¸íˆ ì„¤ëª…í•˜ê² ìŠµ"
"ë‹ˆë‹¤."

#: src/06_ticket_management/01_arrays.md:52
msgid ""
"If you don't want to panic, you can use the `get` method, which returns an "
"`Option<&T>`:"
msgstr ""
"íŒ¨ë‹‰í•˜ì§€ ì•Šìœ¼ë ¤ë©´ `Option<&T>`ë¥¼ ë°˜í™˜í•˜ëŠ” `get` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/01_arrays.md:56
#: src/06_ticket_management/02_vec.md:63
msgid ""
"// You get a `None` if you try to access an out-of-bounds index\n"
"// rather than a panic.\n"
msgstr ""
"// ë²”ìœ„ë¥¼ ë²—ì–´ë‚œ ì¸ë±ìŠ¤ì— ì•¡ì„¸ìŠ¤í•˜ë ¤ê³  í•˜ë©´\n"
"// íŒ¨ë‹‰ì´ ì•„ë‹Œ `None`ì´ ë°˜í™˜ë©ë‹ˆë‹¤.\n"

#: src/06_ticket_management/01_arrays.md:64
msgid ""
"Since the size of an array is known at compile-time, the compiler can "
"allocate the array on the stack. If you run the following code:"
msgstr ""
"ë°°ì—´ì˜ í¬ê¸°ëŠ” ì»´íŒŒì¼ íƒ€ì„ì— ì•Œë ¤ì§€ê¸° ë•Œë¬¸ì— ì»´íŒŒì¼ëŸ¬ëŠ” ë°°ì—´ì„ ìŠ¤íƒì— í• ë‹¹í•  "
"ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ë©´:"

#: src/06_ticket_management/01_arrays.md:71
msgid "You'll get the following memory layout:"
msgstr "ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒì€ ë‹¤ìŒê³¼ ê°™ì´ ë©ë‹ˆë‹¤:"

#: src/06_ticket_management/01_arrays.md:79
msgid ""
"In other words, the size of an array is `std::mem::size_of::<T>() * N`, where "
"`T` is the type of the elements and `N` is the number of elements.  \n"
"You can access and replace each element in `O(1)` time."
msgstr ""
"ì¦‰, ë°°ì—´ì˜ í¬ê¸°ëŠ” `std::mem::size_of::<T>() * N`ì…ë‹ˆë‹¤. ì—¬ê¸°ì„œ `T`ëŠ” ìš”ì†Œì˜ íƒ€"
"ì…ì´ê³  `N`ì€ ìš”ì†Œì˜ ìˆ˜ì…ë‹ˆë‹¤.  \n"
"`O(1)` ì‹œê°„ ì•ˆì— ê° ìš”ì†Œì— ì•¡ì„¸ìŠ¤í•˜ê³  êµì²´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/06_ticket_management/01_arrays.md:85
msgid ""
"The exercise for this section is located in [`06_ticket_management/01_arrays`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/01_arrays)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`06_ticket_management/01_arrays`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/01_arrays)ì— ìˆìŠµë‹ˆë‹¤"

#: src/06_ticket_management/02_vec.md:3
msgid ""
"Arrays' strength is also their weakness: their size must be known upfront, at "
"compile-time. If you try to create an array with a size that's only known at "
"runtime, you'll get a compilation error:"
msgstr ""
"ë°°ì—´ì˜ ì¥ì ì€ ì•½ì ì´ê¸°ë„ í•©ë‹ˆë‹¤. ë°°ì—´ì˜ í¬ê¸°ëŠ” ì»´íŒŒì¼ íƒ€ì„ì— ë¯¸ë¦¬ ì•Œë ¤ì•¼ í•©ë‹ˆ"
"ë‹¤. ëŸ°íƒ€ì„ì—ë§Œ ì•Œë ¤ì§„ í¬ê¸°ì˜ ë°°ì—´ì„ ë§Œë“¤ë ¤ê³  í•˜ë©´ ì»´íŒŒì¼ ì˜¤ë¥˜ê°€ ë°œìƒí•©ë‹ˆë‹¤:"

#: src/06_ticket_management/02_vec.md:20
msgid ""
"Arrays wouldn't work for our ticket management systemâ€”we don't know how many "
"tickets we'll need to store at compile-time. This is where `Vec` comes in."
msgstr ""
"ë°°ì—´ì€ í‹°ì¼“ ê´€ë¦¬ ì‹œìŠ¤í…œì—ì„œ ì‘ë™í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì»´íŒŒì¼ íƒ€ì„ì— ì–¼ë§ˆë‚˜ ë§ì€ í‹°ì¼“"
"ì„ ì €ì¥í•´ì•¼ í•˜ëŠ”ì§€ ì•Œ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì—¬ê¸°ê°€ `Vec`ì´ í•„ìš”í•œ ì‹œì ì…ë‹ˆë‹¤."

#: src/06_ticket_management/02_vec.md:23
msgid "`Vec`"
msgstr "`Vec`"

#: src/06_ticket_management/02_vec.md:25
msgid ""
"`Vec` is a growable array type, provided by the standard library.  \n"
"You can create an empty array using the `Vec::new` function:"
msgstr ""
"`Vec`ì€ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ì œê³µí•˜ëŠ” í™•ì¥ ê°€ëŠ¥í•œ ë°°ì—´ íƒ€ì…ì…ë‹ˆë‹¤.  \n"
"`Vec::new` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ë¹ˆ ë°°ì—´ì„ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/02_vec.md:32
msgid "You would then push elements into the vector using the `push` method:"
msgstr "ê·¸ëŸ° ë‹¤ìŒ `push` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ìš”ì†Œë¥¼ ë²¡í„°ì— ë°€ì–´ ë„£ìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/02_vec.md:40
msgid ""
"New values are added to the end of the vector.  \n"
"You can also create an initialized vector using the `vec!` macro, if you know "
"the values at creation time:"
msgstr ""
"ë²¡í„° ëì— ìƒˆ ê°’ì´ ì¶”ê°€ë©ë‹ˆë‹¤.  \n"
"ìƒì„± ì‹œ ê°’ì„ ì•Œê³  ìˆëŠ” ê²½ìš° `vec!` ë§¤í¬ë¡œë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ˆê¸°í™”ëœ ë²¡í„°ë¥¼ ìƒì„±í•  ìˆ˜"
"ë„ ìˆìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/02_vec.md:49
msgid "The syntax for accessing elements is the same as with arrays:"
msgstr "ìš”ì†Œì— ì•¡ì„¸ìŠ¤í•˜ëŠ” êµ¬ë¬¸ì€ ë°°ì—´ê³¼ ë™ì¼í•©ë‹ˆë‹¤:"

#: src/06_ticket_management/02_vec.md:58
msgid ""
"The index must be of type `usize`.  \n"
"You can also use the `get` method, which returns an `Option<&T>`:"
msgstr ""
"ì¸ë±ìŠ¤ëŠ” `usize` íƒ€ì…ì´ì–´ì•¼ í•©ë‹ˆë‹¤.  \n"
"`Option<&T>`ë¥¼ ë°˜í™˜í•˜ëŠ” `get` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/02_vec.md:69
msgid ""
"Access is bounds-checked, just like element access with arrays. It has O(1) "
"complexity."
msgstr ""
"ë°°ì—´ì„ ì‚¬ìš©í•œ ìš”ì†Œ ì•¡ì„¸ìŠ¤ì™€ ë§ˆì°¬ê°€ì§€ë¡œ ì•¡ì„¸ìŠ¤ ë²”ìœ„ê°€ ê²€ì‚¬ë©ë‹ˆë‹¤. O(1) ë³µì¡ë„"
"ë¥¼ ê°–ìŠµë‹ˆë‹¤."

#: src/06_ticket_management/02_vec.md:73
msgid ""
"`Vec` is a heap-allocated data structure.  \n"
"When you create a `Vec`, it allocates memory on the heap to store the "
"elements."
msgstr ""
"`Vec`ì€ í™ì— í• ë‹¹ëœ ë°ì´í„° êµ¬ì¡°ì…ë‹ˆë‹¤.  \n"
"`Vec`ì„ ìƒì„±í•˜ë©´ ìš”ì†Œë¥¼ ì €ì¥í•˜ê¸° ìœ„í•´ í™ì— ë©”ëª¨ë¦¬ë¥¼ í• ë‹¹í•©ë‹ˆë‹¤."

#: src/06_ticket_management/02_vec.md:76
msgid "If you run the following code:"
msgstr "ë‹¤ìŒ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ë©´:"

#: src/06_ticket_management/02_vec.md:84
msgid "you'll get the following memory layout:"
msgstr "ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/02_vec.md:99
msgid "`Vec` keeps track of three things:"
msgstr "`Vec`ì€ ì„¸ ê°€ì§€ë¥¼ ì¶”ì í•©ë‹ˆë‹¤:"

#: src/06_ticket_management/02_vec.md:102
msgid "The **length** of the vector, i.e. how many elements are in the vector."
msgstr "ë²¡í„°ì˜ **ê¸¸ì´**, ì¦‰ ë²¡í„°ì— í¬í•¨ëœ ìš”ì†Œ ìˆ˜."

#: src/06_ticket_management/02_vec.md:103
msgid ""
"The **capacity** of the vector, i.e. the number of elements that can fit in "
"the space reserved on the heap."
msgstr "ë²¡í„°ì˜ **ìš©ëŸ‰**, ì¦‰ í™ì— ì˜ˆì•½ëœ ê³µê°„ì— ë“¤ì–´ê°ˆ ìˆ˜ ìˆëŠ” ìš”ì†Œì˜ ìˆ˜."

#: src/06_ticket_management/02_vec.md:105
msgid ""
"This layout should look familiar: it's exactly the same as `String`!  \n"
"That's not a coincidence: `String` is defined as a vector of bytes, "
"`Vec<u8>`, under the hood:"
msgstr ""
"ì´ ë ˆì´ì•„ì›ƒì€ ì¹œìˆ™í•´ ë³´ì¼ ê²ƒì…ë‹ˆë‹¤. `String`ê³¼ ì •í™•íˆ ë™ì¼í•©ë‹ˆë‹¤!  \n"
"ì´ëŠ” ìš°ì—°ì´ ì•„ë‹™ë‹ˆë‹¤. `String`ì€ ë‚´ë¶€ì ìœ¼ë¡œ ë°”ì´íŠ¸ ë²¡í„° `Vec<u8>`ë¡œ ì •ì˜ë©ë‹ˆ"
"ë‹¤:"

#: src/06_ticket_management/02_vec.md:116
msgid ""
"The exercise for this section is located in [`06_ticket_management/02_vec`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/02_vec)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`06_ticket_management/02_vec`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/02_vec)ì— ìˆìŠµë‹ˆë‹¤"

#: src/06_ticket_management/03_resizing.md:3
msgid ""
"We said that `Vec` is a \"growable\" vector type, but what does that mean? "
"What happens if you try to insert an element into a `Vec` that's already at "
"maximum capacity?"
msgstr ""
"ìš°ë¦¬ëŠ” `Vec`ì´ \"ëŠ˜ì–´ë‚  ìˆ˜ ìˆëŠ”\" ë²¡í„° íƒ€ì…ì´ë¼ê³  ë§í–ˆëŠ”ë°, ê·¸ê²Œ ë¬´ìŠ¨ ëœ»ì¼ê¹Œ"
"ìš”? ì´ë¯¸ ìµœëŒ€ ìš©ëŸ‰ì— ë„ë‹¬í•œ `Vec`ì— ìš”ì†Œë¥¼ ì‚½ì…í•˜ë ¤ê³  í•˜ë©´ ì–´ë–»ê²Œ ë ê¹Œìš”?"

#: src/06_ticket_management/03_resizing.md:10
msgid "// Max capacity reached\n"
msgstr "// ìµœëŒ€ ìš©ëŸ‰ ë„ë‹¬\n"

#: src/06_ticket_management/03_resizing.md:11
msgid "// What happens here?\n"
msgstr "// ì—¬ê¸°ì„œëŠ” ì–´ë–»ê²Œ ë ê¹Œìš”?\n"

#: src/06_ticket_management/03_resizing.md:14
msgid ""
"The `Vec` will **resize** itself.  \n"
"It will ask the allocator for a new (larger) chunk of heap memory, copy the "
"elements over, and deallocate the old memory."
msgstr ""
"`Vec`ì€ ìì²´ì ìœ¼ë¡œ **í¬ê¸° ì¡°ì •**ë©ë‹ˆë‹¤.  \n"
"í• ë‹¹ìì—ê²Œ ìƒˆë¡œìš´(ë” í°) í™ ë©”ëª¨ë¦¬ ì²­í¬ë¥¼ ìš”ì²­í•˜ê³  ìš”ì†Œë¥¼ ë³µì‚¬í•œ ë‹¤ìŒ ì´ì „ ë©”"
"ëª¨ë¦¬ í• ë‹¹ì„ ì·¨ì†Œí•©ë‹ˆë‹¤."

#: src/06_ticket_management/03_resizing.md:17
msgid ""
"This operation can be expensive, as it involves a new memory allocation and "
"copying all existing elements."
msgstr ""
"ì´ ì‘ì—…ì—ëŠ” ìƒˆë¡œìš´ ë©”ëª¨ë¦¬ í• ë‹¹ê³¼ ëª¨ë“  ê¸°ì¡´ ìš”ì†Œ ë³µì‚¬ê°€ í¬í•¨ë˜ë¯€ë¡œ ë¹„ìš©ì´ ë§ì´ "
"ë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/06_ticket_management/03_resizing.md:19
msgid "`Vec::with_capacity`"
msgstr "`Vec::with_capacity`"

#: src/06_ticket_management/03_resizing.md:21
msgid ""
"If you have a rough idea of how many elements you'll store in a `Vec`, you "
"can use the `Vec::with_capacity` method to pre-allocate enough memory "
"upfront.  \n"
"This can avoid a new allocation when the `Vec` grows, but it may waste memory "
"if you overestimate actual usage."
msgstr ""
"`Vec`ì— ì €ì¥í•  ìš”ì†Œ ìˆ˜ë¥¼ ëŒ€ëµì ìœ¼ë¡œ ì•Œê³  ìˆë‹¤ë©´ `Vec::with_capacity` ë©”ì„œë“œë¥¼ "
"ì‚¬ìš©í•˜ì—¬ ì¶©ë¶„í•œ ë©”ëª¨ë¦¬ë¥¼ ë¯¸ë¦¬ í• ë‹¹í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"ì´ë ‡ê²Œ í•˜ë©´ `Vec`ì´ ì»¤ì§ˆ ë•Œ ìƒˆë¡œìš´ í• ë‹¹ì„ í”¼í•  ìˆ˜ ìˆì§€ë§Œ ì‹¤ì œ ì‚¬ìš©ëŸ‰ì„ ê³¼ëŒ€í‰"
"ê°€í•˜ë©´ ë©”ëª¨ë¦¬ê°€ ë‚­ë¹„ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/06_ticket_management/03_resizing.md:25
msgid "Evaluate on a case-by-case basis."
msgstr "ìƒí™©ì— ë§ê²Œ ì‚¬ìš©í•˜ì„¸ìš”."

#: src/06_ticket_management/03_resizing.md:29
msgid ""
"The exercise for this section is located in "
"[`06_ticket_management/03_resizing`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/06_ticket_management/03_resizing)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`06_ticket_management/03_resizing`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/03_resizing)ì— ìˆìŠµë‹ˆë‹¤"

#: src/06_ticket_management/04_iterators.md:1
msgid "Iteration"
msgstr "ë°˜ë³µ"

#: src/06_ticket_management/04_iterators.md:3
msgid ""
"During the very first exercises, you learned that Rust lets you iterate over "
"collections using `for` loops. We were looking at ranges at that point (e.g. "
"`0..5`), but the same holds true for collections like arrays and vectors."
msgstr ""
"ì²« ë²ˆì§¸ ì˜ˆì œì—ì„œ Rustë¥¼ ì‚¬ìš©í•˜ë©´ `for` ë£¨í”„ë¥¼ ì‚¬ìš©í•˜ì—¬ ì»¬ë ‰ì…˜ì„ ë°˜ë³µí•  ìˆ˜ ìˆë‹¤"
"ëŠ” ê²ƒì„ ë°°ì› ìŠµë‹ˆë‹¤. ìš°ë¦¬ëŠ” ê·¸ ì‹œì ì—ì„œ ë²”ìœ„(ì˜ˆ: `0..5`)ë¥¼ ë‹¤ë£¨ê³  ìˆì—ˆì§€ë§Œ ë°°ì—´"
"ì´ë‚˜ ë²¡í„°ì™€ ê°™ì€ ì»¬ë ‰ì…˜ì—ë„ ë§ˆì°¬ê°€ì§€ì…ë‹ˆë‹¤."

#: src/06_ticket_management/04_iterators.md:7
msgid "// It works for `Vec`s\n"
msgstr "// `Vec`ì—ì„œë„ ì‘ë™í•©ë‹ˆë‹¤\n"

#: src/06_ticket_management/04_iterators.md:12
msgid "// It also works for arrays\n"
msgstr "// ë°°ì—´ì—ì„œë„ ì‘ë™í•©ë‹ˆë‹¤\n"

#: src/06_ticket_management/04_iterators.md:20
msgid "It's time to understand how this works under the hood."
msgstr "ì´ì œ ì´ê²ƒì´ ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ëŠ”ì§€ ì´í•´í•  ì‹œê°„ì…ë‹ˆë‹¤."

#: src/06_ticket_management/04_iterators.md:22
msgid "`for` desugaring"
msgstr "`for` ë””ìŠˆê°€ë§"

#: src/06_ticket_management/04_iterators.md:24
msgid ""
"Every time you write a `for` loop in Rust, the compiler _desugars_ it into "
"the following code:"
msgstr ""
"Rustì—ì„œ `for` ë£¨í”„ë¥¼ ì‘ì„±í•  ë•Œë§ˆë‹¤ ì»´íŒŒì¼ëŸ¬ëŠ” ì´ë¥¼ ë‹¤ìŒ ì½”ë“œì²˜ëŸ¼ _ë””ìŠˆê°€ë§_í•©"
"ë‹ˆë‹¤:"

#: src/06_ticket_management/04_iterators.md:38
msgid ""
"`loop` is another looping construct, on top of `for` and `while`.  \n"
"A `loop` block will run forever, unless you explicitly `break` out of it."
msgstr ""
"`loop`ëŠ” `for`ì™€ `while` ìœ„ì— ìˆëŠ” ë˜ ë‹¤ë¥¸ ë°˜ë³µ êµ¬ì¡°ì…ë‹ˆë‹¤.  \n"
"`loop` ë¸”ë¡ì€ ëª…ì‹œì ìœ¼ë¡œ `break`í•˜ì§€ ì•ŠëŠ” í•œ ì˜ì›íˆ ì‹¤í–‰ë©ë‹ˆë‹¤."

#: src/06_ticket_management/04_iterators.md:41
msgid "`Iterator` trait"
msgstr "`Iterator` íŠ¸ë ˆì‡"

#: src/06_ticket_management/04_iterators.md:43
msgid ""
"The `next` method in the previous code snippet comes from the `Iterator` "
"trait. The `Iterator` trait is defined in Rust's standard library and "
"provides a shared interface for types that can produce a sequence of values:"
msgstr ""
"ì´ì „ ì½”ë“œ ì¡°ê°ì˜ `next` ë©”ì„œë“œëŠ” `Iterator` íŠ¸ë ˆì‡ì—ì„œ ë‚˜ì™”ìŠµë‹ˆë‹¤. `Iterator` "
"íŠ¸ë ˆì‡ì€ Rustì˜ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ì •ì˜ë˜ì–´ ìˆìœ¼ë©°ì¼ë ¨ì˜ ê°’ì„ ìƒì„±í•  ìˆ˜ ìˆëŠ” íƒ€"
"ì…ì— ëŒ€í•œ ê³µìœ  ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤:"

#: src/06_ticket_management/04_iterators.md:54
msgid ""
"The `Item` associated type specifies the type of the values produced by the "
"iterator."
msgstr "`Item` ê´€ë ¨ íƒ€ì…ì€ ë°˜ë³µìê°€ ìƒì„±í•˜ëŠ” ê°’ì˜ íƒ€ì…ì„ ì§€ì •í•©ë‹ˆë‹¤."

#: src/06_ticket_management/04_iterators.md:56
msgid ""
"`next` returns the next value in the sequence.  \n"
"It returns `Some(value)` if there's a value to return, and `None` when there "
"isn't."
msgstr ""
"`next`ëŠ” ì‹œí€€ìŠ¤ì˜ ë‹¤ìŒ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.  \n"
"ë°˜í™˜í•  ê°’ì´ ìˆìœ¼ë©´ `Some(value)`ë¥¼ ë°˜í™˜í•˜ê³ , ì—†ìœ¼ë©´ `None`ì„ ë°˜í™˜í•©ë‹ˆë‹¤."

#: src/06_ticket_management/04_iterators.md:59
msgid ""
"Be careful: there is no guarantee that an iterator is exhausted when it "
"returns `None`. That's only guaranteed if the iterator implements the (more "
"restrictive) [`FusedIterator`](https://doc.rust-lang.org/std/iter/trait."
"FusedIterator.html) trait."
msgstr ""
"ì£¼ì˜í•˜ì„¸ìš”: `None`ì„ ë°˜í™˜í•  ë•Œ ë°˜ë³µìê°€ ì†Œì§„ëœë‹¤ëŠ” ë³´ì¥ì€ ì—†ìŠµë‹ˆë‹¤. ì´ëŠ” ë°˜ë³µ"
"ìê°€ (ë” ì œí•œì ì¸) [`FusedIterator`](https://doc.rust-lang.org/std/iter/trait."
"FusedIterator.html) íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ëŠ” ê²½ìš°ì—ë§Œ ë³´ì¥ë©ë‹ˆë‹¤."

#: src/06_ticket_management/04_iterators.md:63
msgid "`IntoIterator` trait"
msgstr "`IntoIterator` íŠ¸ë ˆì‡"

#: src/06_ticket_management/04_iterators.md:65
msgid ""
"Not all types implement `Iterator`, but many can be converted into a type "
"that does.  \n"
"That's where the `IntoIterator` trait comes in:"
msgstr ""
"ëª¨ë“  íƒ€ì…ì´ `Iterator`ë¥¼ êµ¬í˜„í•˜ëŠ” ê²ƒì€ ì•„ë‹ˆì§€ë§Œ ë§ì€ íƒ€ì…ì´ ì´ë¥¼ êµ¬í˜„í•˜ëŠ” íƒ€ì…"
"ìœ¼ë¡œ ë³€í™˜ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"ì—¬ê¸°ê°€ `IntoIterator` íŠ¸ë ˆì‡ì´ í•„ìš”í•œ ì‹œì ì…ë‹ˆë‹¤:"

#: src/06_ticket_management/04_iterators.md:76
msgid ""
"The `into_iter` method consumes the original value and returns an iterator "
"over its elements.  \n"
"A type can only have one implementation of `IntoIterator`: there can be no "
"ambiguity as to what `for` should desugar to."
msgstr ""
"`into_iter` ë©”ì„œë“œëŠ” ì›ë˜ ê°’ì„ ì‚¬ìš©í•˜ê³  í•´ë‹¹ ìš”ì†Œì— ëŒ€í•œ ë°˜ë³µìë¥¼ ë°˜í™˜í•©ë‹ˆ"
"ë‹¤.  \n"
"íƒ€ì…ì€ `IntoIterator`ì˜ êµ¬í˜„ì„ í•˜ë‚˜ë§Œ ê°€ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤. `for`ê°€ ë¬´ì—‡ì„ ë””ìŠˆê°€"
"ë§ í•˜ëŠ”ì§€ì— ëŒ€í•œ ëª¨í˜¸ì„±ì€ ì—†ìŠµë‹ˆë‹¤."

#: src/06_ticket_management/04_iterators.md:79
msgid ""
"One detail: every type that implements `Iterator` automatically implements "
"`IntoIterator` as well. They just return themselves from `into_iter`!"
msgstr ""
"í•œ ê°€ì§€ ì„¸ë¶€ ì‚¬í•­: `Iterator`ë¥¼ êµ¬í˜„í•˜ëŠ” ëª¨ë“  íƒ€ì…ì€ ìë™ìœ¼ë¡œ `IntoIterator`"
"ë„ êµ¬í˜„í•©ë‹ˆë‹¤. ê·¸ë“¤ì€ ë‹¨ì§€ `into_iter`ì—ì„œ ìŠ¤ìŠ¤ë¡œ ëŒì•„ì˜µë‹ˆë‹¤!"

#: src/06_ticket_management/04_iterators.md:82
msgid "Bounds checks"
msgstr "ê²½ê³„ í™•ì¸"

#: src/06_ticket_management/04_iterators.md:84
msgid ""
"Iterating over iterators has a nice side effect: you can't go out of bounds, "
"by design.  \n"
"This allows Rust to remove bounds checks from the generated machine code, "
"making iteration faster."
msgstr ""
"ë°˜ë³µìë¥¼ ë°˜ë³µí•˜ë©´ ì¢‹ì€ ë¶€ì‘ìš©ì´ ìˆìŠµë‹ˆë‹¤. ì„¤ê³„ìƒ ë²”ìœ„ë¥¼ ë²—ì–´ë‚  ìˆ˜ ì—†ìŠµë‹ˆ"
"ë‹¤.  \n"
"ì´ë¥¼ í†µí•´ RustëŠ” ìƒì„±ëœ ê¸°ê³„ì–´ ì½”ë“œì—ì„œ ê²½ê³„ ê²€ì‚¬ë¥¼ ì œê±°í•˜ì—¬ ë°˜ë³µ ì‘ì—…ì„ ë” ë¹ "
"ë¥´ê²Œ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/06_ticket_management/04_iterators.md:87
msgid "In other words,"
msgstr "ë‹¤ì‹œ ë§í•´ì„œ,"

#: src/06_ticket_management/04_iterators.md:96
msgid "is usually faster than"
msgstr "ìœ„ ì½”ë“œê°€ ì¼ë°˜ì ìœ¼ë¡œ ë‹¤ìŒë³´ë‹¤ ë¹ ë¦…ë‹ˆë‹¤"

#: src/06_ticket_management/04_iterators.md:105
msgid ""
"There are exceptions to this rule: the compiler can sometimes prove that "
"you're not going out of bounds even with manual indexing, thus removing the "
"bounds checks anyway. But in general, prefer iteration to indexing where "
"possible."
msgstr ""
"ì´ ê·œì¹™ì—ëŠ” ì˜ˆì™¸ê°€ ìˆìŠµë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” ë•Œë•Œë¡œ ìˆ˜ë™ ì¸ë±ì‹±ì„ ì‚¬ìš©í•´ë„ ë²”ìœ„ë¥¼ "
"ë²—ì–´ë‚˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ê²ƒì„ ì¦ëª…í•˜ì—¬ ì–´ì¨Œë“  ë²”ìœ„ ê²€ì‚¬ë¥¼ ì œê±°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ "
"ì¼ë°˜ì ìœ¼ë¡œ ê°€ëŠ¥í•œ ê²½ìš° ì¸ë±ì‹±ë³´ë‹¤ ë°˜ë³µì„ ì„ í˜¸í•©ë‹ˆë‹¤."

#: src/06_ticket_management/04_iterators.md:111
msgid ""
"The exercise for this section is located in "
"[`06_ticket_management/04_iterators`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/06_ticket_management/04_iterators)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`06_ticket_management/04_iterators`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/04_iterators)ì— ìˆìŠµë‹ˆë‹¤"

#: src/06_ticket_management/05_iter.md:1
msgid "`.iter()`"
msgstr "`.iter()`"

#: src/06_ticket_management/05_iter.md:3
msgid "`IntoIterator` **consumes** `self` to create an iterator."
msgstr "`IntoIterator` **ëŠ” `self`ë¥¼ ì‚¬ìš©í•˜ì—¬ ë°˜ë³µìë¥¼ ìƒì„±í•©ë‹ˆë‹¤."

#: src/06_ticket_management/05_iter.md:5
msgid ""
"This has its benefits: you get **owned** values from the iterator. For "
"example: if you call `.into_iter()` on a `Vec<Ticket>` you'll get an iterator "
"that returns `Ticket` values."
msgstr ""
"ì—¬ê¸°ì—ëŠ” ì¥ì ì´ ìˆìŠµë‹ˆë‹¤. ë°˜ë³µìì—ì„œ **ì†Œìœ ** ê°’ì„ ì–»ìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, "
"`Vec<Ticket>`ì—ì„œ `.into_iter()`ë¥¼ í˜¸ì¶œí•˜ë©´ `Ticket` ê°’ì„ ë°˜í™˜í•˜ëŠ” ë°˜ë³µìë¥¼ ì–»"
"ê²Œ ë©ë‹ˆë‹¤."

#: src/06_ticket_management/05_iter.md:8
msgid ""
"That's also its downside: you can no longer use the original collection after "
"calling `.into_iter()` on it. Quite often you want to iterate over a "
"collection without consuming it, looking at **references** to the values "
"instead. In the case of `Vec<Ticket>`, you'd want to iterate over `&Ticket` "
"values."
msgstr ""
"ê·¸ê²ƒì€ ë˜í•œ ë‹¨ì ì´ê¸°ë„ í•©ë‹ˆë‹¤. `.into_iter()`ë¥¼ í˜¸ì¶œí•œ í›„ì—ëŠ” ë” ì´ìƒ ì›ë³¸ ì»¬"
"ë ‰ì…˜ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì»¬ë ‰ì…˜ì„ ì‚¬ìš©í•˜ì§€ ì•Šê³  ì»¬ë ‰ì…˜ì„ ë°˜ë³µí•˜ê³  ëŒ€ì‹  ê°’ì— "
"ëŒ€í•œ **ì°¸ì¡°**ë¥¼ ì‚´í´ë³´ê³  ì‹¶ì€ ê²½ìš°ê°€ ë§ìŠµë‹ˆë‹¤. `Vec<Ticket>`ì˜ ê²½ìš° `&Ticket` "
"ê°’ì„ ë°˜ë³µí•˜ê³  ì‹¶ì„ ê²ƒì…ë‹ˆë‹¤."

#: src/06_ticket_management/05_iter.md:12
msgid ""
"Most collections expose a method called `.iter()` that returns an iterator "
"over references to the collection's elements. For example:"
msgstr ""
"ëŒ€ë¶€ë¶„ì˜ ì»¬ë ‰ì…˜ì€ ì»¬ë ‰ì…˜ ìš”ì†Œì— ëŒ€í•œ ì°¸ì¡°ì— ëŒ€í•œ ë°˜ë³µìë¥¼ ë°˜í™˜í•˜ëŠ” `.iter()`ë¼"
"ëŠ” ë©”ì„œë“œë¥¼ ë…¸ì¶œí•©ë‹ˆë‹¤. ì˜ˆì‹œ:"

#: src/06_ticket_management/05_iter.md:16
msgid "// `n` has type `&u32` here\n"
msgstr "// `n`ì—ëŠ” `&u32` íƒ€ì…ì´ ìˆìŠµë‹ˆë‹¤.\n"

#: src/06_ticket_management/05_iter.md:23
msgid ""
"This pattern can be simplified by implementing `IntoIterator` for a "
"**reference to the collection**. In our example above, that would be "
"`&Vec<Ticket>`.  \n"
"The standard library does this, that's why the following code works:"
msgstr ""
"ì´ íŒ¨í„´ì€ **ì»¬ë ‰ì…˜ì— ëŒ€í•œ ì°¸ì¡°**ì— ëŒ€í•´ `IntoIterator`ë¥¼ êµ¬í˜„í•˜ì—¬ ë‹¨ìˆœí™”í•  ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤. ìœ„ì˜ ì˜ˆì—ì„œëŠ” `&Vec<Ticket>`ì´ ë©ë‹ˆë‹¤.  \n"
"í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì´ë¥¼ ìˆ˜í–‰í•˜ë¯€ë¡œ ë‹¤ìŒ ì½”ë“œê°€ ì‘ë™í•©ë‹ˆë‹¤:"

#: src/06_ticket_management/05_iter.md:28
msgid ""
"// `n` has type `&u32` here\n"
"// We didn't have to call `.iter()` explicitly\n"
"// It was enough to use `&numbers` in the `for` loop\n"
msgstr ""
"// ì—¬ê¸°ì„œ `n`ì—ëŠ” `&u32` íƒ€ì…ì´ ìˆìŠµë‹ˆë‹¤.\n"
"// ëª…ì‹œì ìœ¼ë¡œ `.iter()`ë¥¼ í˜¸ì¶œí•  í•„ìš”ëŠ” ì—†ìŠµë‹ˆë‹¤\n"
"// `for` ë£¨í”„ì—ì„œ `&numbers`ë¥¼ ì‚¬ìš©í•˜ë©´ ì¶©ë¶„í•©ë‹ˆë‹¤\n"

#: src/06_ticket_management/05_iter.md:37
msgid "It's idiomatic to provide both options:"
msgstr "ë‘ ê°€ì§€ ì˜µì…˜ì„ ëª¨ë‘ ì œê³µí•˜ëŠ” ê²ƒì´ ê´€ìš©ì ì…ë‹ˆë‹¤:"

#: src/06_ticket_management/05_iter.md:39
msgid "An implementation of `IntoIterator` for a reference to the collection."
msgstr "ì»¬ë ‰ì…˜ì— ëŒ€í•œ ì°¸ì¡°ë¥¼ ìœ„í•œ `IntoIterator` êµ¬í˜„."

#: src/06_ticket_management/05_iter.md:40
msgid ""
"An `.iter()` method that returns an iterator over references to the "
"collection's elements."
msgstr "ì»¬ë ‰ì…˜ì˜ ìš”ì†Œì— ëŒ€í•œ ì°¸ì¡°ì— ëŒ€í•œ ë°˜ë³µìë¥¼ ë°˜í™˜í•˜ëŠ” `.iter()` ë©”ì„œë“œ."

#: src/06_ticket_management/05_iter.md:42
msgid ""
"The former is convenient in `for` loops, the latter is more explicit and can "
"be used in other contexts."
msgstr ""
"ì „ìëŠ” `for` ë£¨í”„ì—ì„œ í¸ë¦¬í•˜ê³ , í›„ìëŠ” ë” ëª…ì‹œì ì´ë©° ë‹¤ë¥¸ ì»¨í…ìŠ¤íŠ¸ì—ì„œ ì‚¬ìš©ë  "
"ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/06_ticket_management/05_iter.md:46
msgid ""
"The exercise for this section is located in [`06_ticket_management/05_iter`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/05_iter)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`06_ticket_management/05_iter`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/05_iter)ì— ìˆìŠµë‹ˆë‹¤"

#: src/06_ticket_management/06_lifetimes.md:3
msgid ""
"Let's try to complete the previous exercise by adding an implementation of "
"`IntoIterator` for `&TicketStore`, for maximum convenience in `for` loops."
msgstr ""
"`for` ë£¨í”„ì˜ í¸ì˜ì„±ì„ ê·¹ëŒ€í™”í•˜ê¸° ìœ„í•´ `&TicketStore`ì— ëŒ€í•œ `IntoIterator` êµ¬"
"í˜„ì„ ì¶”ê°€í•˜ì—¬ ì´ì „ ì˜ˆì œë¥¼ ì™„ë£Œí•´ ë³´ê² ìŠµë‹ˆë‹¤."

#: src/06_ticket_management/06_lifetimes.md:6
msgid ""
"Let's start by filling in the most \"obvious\" parts of the implementation:"
msgstr "êµ¬í˜„ì˜ ê°€ì¥ \"ëª…í™•í•œ\" ë¶€ë¶„ì„ ì±„ìš°ëŠ” ê²ƒë¶€í„° ì‹œì‘í•´ ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/06_lifetimes.md:11
msgid "// What goes here?\n"
msgstr "// ì—¬ê¸°ì— ë¬´ì—‡ì´ ë“¤ì–´ê°ˆê¹Œìš”?\n"

#: src/06_ticket_management/06_lifetimes.md:19
msgid ""
"What should `type IntoIter` be set to?  \n"
"Intuitively, it should be the type returned by `self.tickets.iter()`, i.e. "
"the type returned by `Vec::iter()`.  \n"
"If you check the standard library documentation, you'll find that `Vec::"
"iter()` returns an `std::slice::Iter`. The definition of `Iter` is:"
msgstr ""
"`type IntoIter`ëŠ” ë¬´ì—‡ìœ¼ë¡œ ì„¤ì •ë˜ì–´ì•¼ í• ê¹Œìš”?  \n"
"ì§ê´€ì ìœ¼ë¡œ ì´ê²ƒì€ `self.tickets.iter()`ì— ì˜í•´ ë°˜í™˜ëœ íƒ€ì…, ì¦‰ `Vec::iter()`"
"ì— ì˜í•´ ë°˜í™˜ëœ íƒ€ì…ì´ì–´ì•¼ í•©ë‹ˆë‹¤.  \n"
"í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¬¸ì„œë¥¼ í™•ì¸í•˜ë©´ `Vec::iter()`ê°€ `std::slice::Iter`ë¥¼ ë°˜í™˜í•œë‹¤"
"ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤. Iterì˜ ì •ì˜ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/06_lifetimes.md:25
#: src/06_ticket_management/08_impl_trait.md:25
msgid "/* fields omitted */"
msgstr "/* í•„ë“œ ìƒëµ */"

#: src/06_ticket_management/06_lifetimes.md:28
msgid "`'a` is a **lifetime parameter**."
msgstr "``a`ëŠ” **ìˆ˜ëª… ë§¤ê°œë³€ìˆ˜**ì…ë‹ˆë‹¤."

#: src/06_ticket_management/06_lifetimes.md:30
msgid "Lifetime parameters"
msgstr "ìˆ˜ëª… ë§¤ê°œë³€ìˆ˜"

#: src/06_ticket_management/06_lifetimes.md:32
msgid ""
"Lifetimes are **labels** used by the Rust compiler to keep track of how long "
"a reference (either mutable or immutable) is valid.  \n"
"The lifetime of a reference is constrained by the scope of the value it "
"refers to. Rust always makes sure, at compile-time, that references are not "
"used after the value they refer to has been dropped, to avoid dangling "
"pointers and use-after-free bugs."
msgstr ""
"ìˆ˜ëª…ì€ ì°¸ì¡°(ë³€ê²½ ê°€ëŠ¥ ë˜ëŠ” ë¶ˆë³€)ê°€ ì–¼ë§ˆë‚˜ ì˜¤ë«ë™ì•ˆ ìœ íš¨í•œì§€ ì¶”ì í•˜ê¸° ìœ„í•´ "
"Rust ì»´íŒŒì¼ëŸ¬ì—ì„œ ì‚¬ìš©í•˜ëŠ” **ë ˆì´ë¸”**ì…ë‹ˆë‹¤.  \n"
"ì°¸ì¡°ì˜ ìˆ˜ëª…ì€ ì°¸ì¡°í•˜ëŠ” ê°’ì˜ ë²”ìœ„ì— ë”°ë¼ ì œí•œë©ë‹ˆë‹¤. RustëŠ” ëŒ•ê¸€ë§ í¬ì¸í„°ì™€ "
"use-after-free ë²„ê·¸ë¥¼ í”¼í•˜ê¸° ìœ„í•´ ì»´íŒŒì¼ íƒ€ì„ì— ì°¸ì¡°ê°€ ì°¸ì¡°í•˜ëŠ” ê°’ì´ ì‚­ì œëœ í›„"
"ì— ì°¸ì¡°ê°€ ì‚¬ìš©ë˜ì§€ ì•Šë„ë¡ í•­ìƒ í™•ì¸í•©ë‹ˆë‹¤."

#: src/06_ticket_management/06_lifetimes.md:37
msgid ""
"This should sound familiar: we've already seen these concepts in action when "
"we discussed ownership and borrowing. Lifetimes are just a way to **name** "
"how long a specific reference is valid."
msgstr ""
"ì´ëŠ” ì¹œìˆ™í•˜ê²Œ ë“¤ë¦´ ê²ƒì…ë‹ˆë‹¤. ìš°ë¦¬ëŠ” ì†Œìœ ê¶Œê³¼ ì°¨ìš©ì— ëŒ€í•´ ë…¼ì˜í•  ë•Œ ì´ë¯¸ ì´ëŸ¬"
"í•œ ê°œë…ì´ ì‹¤ì œë¡œ ì‹¤í–‰ë˜ëŠ” ê²ƒì„ ë³´ì•˜ìŠµë‹ˆë‹¤. ìˆ˜ëª…ì€ íŠ¹ì • ì°¸ì¡°ê°€ ìœ íš¨í•œ ê¸°ê°„ì„ **"
"ëª…ì¹­**í•˜ëŠ” ë°©ë²•ì¼ ë¿ì…ë‹ˆë‹¤."

#: src/06_ticket_management/06_lifetimes.md:40
msgid ""
"Naming becomes important when you have multiple references and you need to "
"clarify how they **relate to each other**. Let's look at the signature of "
"`Vec::iter()`:"
msgstr ""
"ì—¬ëŸ¬ ì°¸ì¡°ê°€ ìˆê³  í•´ë‹¹ ì°¸ì¡°ê°€ **ì„œë¡œ ê´€ë ¨**ë˜ëŠ” ë°©ì‹ì„ ëª…í™•íˆ í•´ì•¼ í•  ë•Œ ì´ë¦„ "
"ì§€ì •ì´ ì¤‘ìš”í•´ì§‘ë‹ˆë‹¤. `Vec::iter()`ì˜ ì‹œê·¸ë‹ˆì²˜ë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/06_lifetimes.md:45
#: src/06_ticket_management/13_index.md:20
#: src/06_ticket_management/14_index_mut.md:11
#: src/06_ticket_management/15_hashmap.md:34
msgid "// Slightly simplified\n"
msgstr "// ì•½ê°„ ë‹¨ìˆœí™”ë¨\n"

#: src/06_ticket_management/06_lifetimes.md:52
msgid ""
"`Vec::iter()` is generic over a lifetime parameter, named `'a`.  \n"
"`'a` is used to **tie together** the lifetime of the `Vec` and the lifetime "
"of the `Iter` returned by `iter()`. In plain English: the `Iter` returned by "
"`iter()` cannot outlive the `Vec` reference (`&self`) it was created from."
msgstr ""
"`Vec::iter()`ëŠ” `'a`ë¼ëŠ” ì´ë¦„ì˜ ìˆ˜ëª… ë§¤ê°œë³€ìˆ˜ë¡œ ì¼ë°˜í™”ë©ë‹ˆë‹¤.  \n"
"`'a`ëŠ” `Vec`ì˜ ìˆ˜ëª…ê³¼ `iter()`ì— ì˜í•´ ë°˜í™˜ëœ `Iter`ì˜ ìˆ˜ëª…ì„ **ì—°ê²°**í•˜ëŠ” ë° "
"ì‚¬ìš©ë©ë‹ˆë‹¤. ì‚¬ëŒ ë§ë¡œ ë§í•˜ë©´, `iter()`ì— ì˜í•´ ë°˜í™˜ëœ `Iter`ëŠ” ê·¸ê²ƒì´ ìƒì„±ëœ "
"`Vec` ì°¸ì¡°(`&self`)ë³´ë‹¤ ì˜¤ë˜ ì‚´ì•„ìˆì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/06_ticket_management/06_lifetimes.md:56
msgid ""
"This is important because `Vec::iter`, as we discussed, returns an iterator "
"over **references** to the `Vec`'s elements. If the `Vec` is dropped, the "
"references returned by the iterator would be invalid. Rust must make sure "
"this doesn't happen, and lifetimes are the tool it uses to enforce this rule."
msgstr ""
"ì´ëŠ” ìš°ë¦¬ê°€ ë…¼ì˜í•œ ê²ƒì²˜ëŸ¼ `Vec::iter`ê°€ `Vec` ìš”ì†Œì— ëŒ€í•œ **ì°¸ì¡°**ì— ëŒ€í•œ ë°˜ë³µ"
"ìë¥¼ ë°˜í™˜í•˜ê¸° ë•Œë¬¸ì— ì¤‘ìš”í•©ë‹ˆë‹¤. `Vec`ê°€ ì‚­ì œë˜ë©´ ë°˜ë³µìê°€ ë°˜í™˜í•œ ì°¸ì¡°ê°€ ìœ íš¨"
"í•˜ì§€ ì•Šê²Œ ë©ë‹ˆë‹¤. RustëŠ” ì´ëŸ° ì¼ì´ ë°œìƒí•˜ì§€ ì•Šë„ë¡ í•´ì•¼ í•˜ë©° ìˆ˜ëª…ì€ ì´ ê·œì¹™ì„ "
"ì‹œí–‰í•˜ëŠ” ë° ì‚¬ìš©í•˜ëŠ” ë„êµ¬ì…ë‹ˆë‹¤."

#: src/06_ticket_management/06_lifetimes.md:60
msgid "Lifetime elision"
msgstr "ìˆ˜ëª… ì œê±°"

#: src/06_ticket_management/06_lifetimes.md:62
msgid ""
"Rust has a set of rules, called **lifetime elision rules**, that allow you to "
"omit explicit lifetime annotations in many cases. For example, `Vec::iter`'s "
"definition looks like this in `std`'s source code:"
msgstr ""
"Rustì—ëŠ” **ìˆ˜ëª… ì œê±° ê·œì¹™**ì´ë¼ëŠ” ì¼ë ¨ì˜ ê·œì¹™ì´ ìˆëŠ”ë°, ì´ë¥¼ í†µí•´ ë§ì€ ê²½ìš°ì— "
"ëª…ì‹œì ì¸ ìˆ˜ëª… ì–´ë…¸í…Œì´ì…˜ì„ ìƒëµí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, `Vec::iter`ì˜ ì •ì˜"
"ëŠ” `std`ì˜ ì†ŒìŠ¤ ì½”ë“œì—ì„œ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/06_lifetimes.md:73
msgid ""
"No explicit lifetime parameter is present in the signature of `Vec::iter()`. "
"Elision rules imply that the lifetime of the `Iter` returned by `iter()` is "
"tied to the lifetime of the `&self` reference. You can think of `'_` as a "
"**placeholder** for the lifetime of the `&self` reference."
msgstr ""
"`Vec::iter()`ì˜ ì‹œê·¸ë‹ˆì²˜ì—ëŠ” ëª…ì‹œì ì¸ ìˆ˜ëª… ë§¤ê°œë³€ìˆ˜ê°€ ì—†ìŠµë‹ˆë‹¤. ì œê±° ê·œì¹™ì€ "
"`iter()`ì— ì˜í•´ ë°˜í™˜ëœ `Iter`ì˜ ìˆ˜ëª…ì´ `&self` ì°¸ì¡°ì˜ ìˆ˜ëª…ê³¼ ì—°ê²°ë˜ì–´ ìˆìŒì„ "
"ì˜ë¯¸í•©ë‹ˆë‹¤. `'_`ëŠ” `&self` ì°¸ì¡°ì˜ ìˆ˜ëª… ë™ì•ˆ **í”Œë ˆì´ìŠ¤ í™€ë”**ë¡œ ìƒê°í•˜ë©´ ë©ë‹ˆ"
"ë‹¤."

#: src/06_ticket_management/06_lifetimes.md:77
msgid ""
"See the [References](#references) section for a link to the official "
"documentation on lifetime elision.  \n"
"In most cases, you can rely on the compiler telling you when you need to add "
"explicit lifetime annotations."
msgstr ""
"ìˆ˜ëª… ì œê±°ì— ëŒ€í•œ ê³µì‹ ë¬¸ì„œ ë§í¬ëŠ” [ì°¸ì¡°](#ì°¸ì¡°) ì„¹ì…˜ì„ ì°¸ì¡°í•˜ì„¸ìš”.  \n"
"ëŒ€ë¶€ë¶„ì˜ ê²½ìš° ì»´íŒŒì¼ëŸ¬ê°€ ëª…ì‹œì ì¸ ìˆ˜ëª… ì–´ë…¸í…Œì´ì…˜ì„ ì¶”ê°€í•´ì•¼ í•  ë•Œë¥¼ ì•Œë ¤ì£¼ê¸°"
"ë•Œë¬¸ì— ì»´íŒŒì¼ëŸ¬ë¥¼ ë¯¿ìœ¼ë©´ ë©ë‹ˆë‹¤."

#: src/06_ticket_management/06_lifetimes.md:82
msgid ""
"[std::vec::Vec::iter](https://doc.rust-lang.org/std/vec/struct.Vec."
"html#method.iter)"
msgstr ""
"[std::vec::Vec::iter](https://doc.rust-lang.org/std/vec/struct.Vec."
"html#method.iter)"

#: src/06_ticket_management/06_lifetimes.md:83
msgid "[std::slice::Iter](https://doc.rust-lang.org/std/slice/struct.Iter.html)"
msgstr ""
"[std::slice::Iter](https://doc.rust-lang.org/std/slice/struct.Iter.html)"

#: src/06_ticket_management/06_lifetimes.md:84
msgid ""
"[Lifetime elision rules](https://doc.rust-lang.org/reference/lifetime-elision."
"html)"
msgstr ""
"[Lifetime elision rules](https://doc.rust-lang.org/reference/lifetime-elision."
"html)"

#: src/06_ticket_management/06_lifetimes.md:88
msgid ""
"The exercise for this section is located in "
"[`06_ticket_management/06_lifetimes`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/06_ticket_management/06_lifetimes)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`06_ticket_management/06_lifetimes`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/06_lifetimes)ì— ìˆìŠµë‹ˆë‹¤"

#: src/06_ticket_management/07_combinators.md:3
msgid ""
"Iterators can do so much more than `for` loops!  \n"
"If you look at the documentation for the `Iterator` trait, you'll find a "
"**vast** collections of methods that you can leverage to transform, filter, "
"and combine iterators in various ways."
msgstr ""
"ë°˜ë³µìëŠ” `for` ë£¨í”„ë³´ë‹¤ í›¨ì”¬ ë” ë§ì€ ì¼ì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!  \n"
"`Iterator` íŠ¸ë ˆì‡ì— ëŒ€í•œ ë¬¸ì„œë¥¼ ë³´ë©´ ë‹¤ì–‘í•œ ë°©ë²•ìœ¼ë¡œ ë°˜ë³µìë¥¼ ë³€í™˜, í•„í„°ë§ ë° "
"ê²°í•©í•˜ëŠ” ë° í™œìš©í•  ìˆ˜ ìˆëŠ” **ê´‘ë²”ìœ„í•œ** ë©”ì„œë“œ ì»¬ë ‰ì…˜ì„ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/06_ticket_management/07_combinators.md:7
msgid "Let's mention the most common ones:"
msgstr "ê°€ì¥ ì¼ë°˜ì ì¸ ê²ƒì„ ì–¸ê¸‰ í•´ ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/07_combinators.md:9
msgid "`map` applies a function to each element of the iterator."
msgstr "`map`ì€ ë°˜ë³µìì˜ ê° ìš”ì†Œì— í•¨ìˆ˜ë¥¼ ì ìš©í•©ë‹ˆë‹¤."

#: src/06_ticket_management/07_combinators.md:10
msgid "`filter` keeps only the elements that satisfy a predicate."
msgstr "`filter`ëŠ” ì¡°ê±´ìë¥¼ ë§Œì¡±í•˜ëŠ” ìš”ì†Œë§Œ ìœ ì§€í•©ë‹ˆë‹¤."

#: src/06_ticket_management/07_combinators.md:11
msgid "`filter_map` combines `filter` and `map` in one step."
msgstr "`filter_map`ì€ `filter`ì™€ `map`ì„ í•œ ë‹¨ê³„ë¡œ ê²°í•©í•©ë‹ˆë‹¤."

#: src/06_ticket_management/07_combinators.md:12
msgid ""
"`cloned` converts an iterator of references into an iterator of values, "
"cloning each element."
msgstr "'cloned'ëŠ” ì°¸ì¡° ë°˜ë³µìë¥¼ ê°’ ë°˜ë³µìë¡œ ë³€í™˜í•˜ì—¬ ê° ìš”ì†Œë¥¼ ë³µì œí•©ë‹ˆë‹¤."

#: src/06_ticket_management/07_combinators.md:13
msgid "`enumerate` returns a new iterator that yields `(index, value)` pairs."
msgstr ""
"`enumerate`ëŠ” `(index, value)` ìŒì„ ìƒì„±í•˜ëŠ” ìƒˆë¡œìš´ ë°˜ë³µìë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."

#: src/06_ticket_management/07_combinators.md:14
msgid "`skip` skips the first `n` elements of the iterator."
msgstr "`skip`ì€ ë°˜ë³µìì˜ ì²˜ìŒ `n`ê°œì˜ ìš”ì†Œë¥¼ ê±´ë„ˆëœë‹ˆë‹¤."

#: src/06_ticket_management/07_combinators.md:15
msgid "`take` stops the iterator after `n` elements."
msgstr "`take`ëŠ” `n`ê°œì˜ ìš”ì†Œ ë‹¤ìŒì— ë°˜ë³µìë¥¼ ì¤‘ì§€ì‹œí‚µë‹ˆë‹¤."

#: src/06_ticket_management/07_combinators.md:16
msgid "`chain` combines two iterators into one."
msgstr "`chain`ì€ ë‘ ê°œì˜ ë°˜ë³µìë¥¼ í•˜ë‚˜ë¡œ ê²°í•©í•©ë‹ˆë‹¤."

#: src/06_ticket_management/07_combinators.md:18
msgid ""
"These methods are called **combinators**.  \n"
"They are usually **chained** together to create complex transformations in a "
"concise and readable way:"
msgstr ""
"ì´ëŸ¬í•œ ë©”ì„œë“œë¥¼ **ê²°í•©ì**ë¼ê³  í•©ë‹ˆë‹¤.  \n"
"ì¼ë°˜ì ìœ¼ë¡œ ê°„ê²°í•˜ê³  ì½ê¸° ì‰¬ìš´ ë°©ì‹ìœ¼ë¡œ ë³µì¡í•œ ë³€í™˜ì„ ìƒì„±í•˜ê¸° ìœ„í•´ í•¨ê»˜ **ì²´ì¸"
"**ë©ë‹ˆë‹¤:"

#: src/06_ticket_management/07_combinators.md:22
msgid "// The sum of the squares of the even numbers\n"
msgstr "// ì§ìˆ˜ì˜ ì œê³±ì˜ í•©\n"

#: src/06_ticket_management/07_combinators.md:30
msgid "Closures"
msgstr "í´ë¡œì €"

#: src/06_ticket_management/07_combinators.md:32
msgid ""
"What's going on with the `filter` and `map` methods above?  \n"
"They take **closures** as arguments."
msgstr ""
"ìœ„ì˜ `filter` ë° `map` ë©”ì†Œë“œì—ì„œëŠ” ë¬´ìŠ¨ ì¼ì´ ì¼ì–´ë‚˜ê³  ìˆì„ê¹Œìš”?  \n"
"ê·¸ë“¤ì€ **í´ë¡œì €**ë¥¼ ì¸ìˆ˜ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/06_ticket_management/07_combinators.md:35
msgid ""
"Closures are **anonymous functions**, i.e. functions that are not defined "
"using the `fn` syntax we are used to.  \n"
"They are defined using the `|args| body` syntax, where `args` are the "
"arguments and `body` is the function body. `body` can be a block of code or a "
"single expression. For example:"
msgstr ""
"í´ë¡œì €ëŠ” **ìµëª… í•¨ìˆ˜**, ì¦‰ ìš°ë¦¬ì—ê²Œ ìµìˆ™í•œ `fn` êµ¬ë¬¸ì„ ì‚¬ìš©í•˜ì—¬ ì •ì˜ë˜ì§€ ì•Šì€ "
"í•¨ìˆ˜ì…ë‹ˆë‹¤.  \n"
"`|args| body`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì •ì˜ë©ë‹ˆë‹¤. ì—¬ê¸°ì„œ `args`ëŠ” ì¸ìˆ˜ì´ê³  `body`ëŠ” í•¨ìˆ˜ ë³¸"
"ë¬¸ì…ë‹ˆë‹¤. `body`ëŠ” ì½”ë“œ ë¸”ë¡ì´ê±°ë‚˜ ë‹¨ì¼ í‘œí˜„ì‹ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆì‹œ:"

#: src/06_ticket_management/07_combinators.md:41
msgid "// An anonymous function that adds 1 to its argument\n"
msgstr "// ì¸ìˆ˜ì— 1ì„ ë”í•˜ëŠ” ìµëª… í•¨ìˆ˜\n"

#: src/06_ticket_management/07_combinators.md:42
msgid "// Could be written with a block too:\n"
msgstr "// ë¸”ë¡ìœ¼ë¡œë„ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:\n"

#: src/06_ticket_management/07_combinators.md:47
msgid "Closures can take more than one argument:"
msgstr "í´ë¡œì €ëŠ” í•˜ë‚˜ ì´ìƒì˜ ì¸ìˆ˜ë¥¼ ì·¨í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/07_combinators.md:54
msgid "They can also capture variables from their environment:"
msgstr "ë˜í•œ ë³€ìˆ˜ë¥¼ ìº¡ì²˜í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/07_combinators.md:62
msgid ""
"If necessary, you can specify the types of the arguments and/or the return "
"type:"
msgstr "í•„ìš”í•œ ê²½ìš° ì¸ìˆ˜ íƒ€ì…ì´ë‚˜ ë°˜í™˜ íƒ€ì…ì„ ì§€ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/07_combinators.md:65
msgid "// Just the input type\n"
msgstr "// ì…ë ¥ íƒ€ì…ë§Œ\n"

#: src/06_ticket_management/07_combinators.md:66
msgid "// Or both input and output types, using the `fn` syntax\n"
msgstr "// ë˜ëŠ” `fn` êµ¬ë¬¸ì„ ì‚¬ìš©í•˜ì—¬ ì…ë ¥ ë° ì¶œë ¥ íƒ€ì… ëª¨ë‘\n"

#: src/06_ticket_management/07_combinators.md:71
msgid "`collect`"
msgstr "`collect`"

#: src/06_ticket_management/07_combinators.md:73
msgid ""
"What happens when you're done transforming an iterator using combinators?  \n"
"You either iterate over the transformed values using a `for` loop, or you "
"collect them into a collection."
msgstr ""
"ê²°í•©ìë¥¼ ì‚¬ìš©í•˜ì—¬ ë°˜ë³µì ë³€í™˜ì„ ì™„ë£Œí•˜ë©´ ì´ì œ ë­˜ í•´ì•¼ í• ê¹Œìš”?  \n"
"`for` ë£¨í”„ë¥¼ ì‚¬ìš©í•˜ì—¬ ë³€í™˜ëœ ê°’ì„ ë°˜ë³µí•˜ê±°ë‚˜ ì»¬ë ‰ì…˜ìœ¼ë¡œ ìˆ˜ì§‘í•´ì•¼í•©ë‹ˆë‹¤."

#: src/06_ticket_management/07_combinators.md:76
msgid ""
"The latter is done using the `collect` method.  \n"
"`collect` consumes the iterator and collects its elements into a collection "
"of your choice."
msgstr ""
"í›„ìëŠ” `collect` ë©”ì†Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ìˆ˜í–‰ë©ë‹ˆë‹¤.  \n"
"`collect`ëŠ” ë°˜ë³µìë¥¼ ì‚¬ìš©í•˜ê³  í•´ë‹¹ ìš”ì†Œë¥¼ ì„ íƒí•œ ì»¬ë ‰ì…˜ìœ¼ë¡œ ìˆ˜ì§‘í•©ë‹ˆë‹¤."

#: src/06_ticket_management/07_combinators.md:79
msgid ""
"For example, you can collect the squares of the even numbers into a `Vec`:"
msgstr "ì˜ˆë¥¼ ë“¤ì–´ ì§ìˆ˜ì˜ ì œê³±ì„ `Vec`ìœ¼ë¡œ ìˆ˜ì§‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/07_combinators.md:89
msgid ""
"`collect` is generic over its **return type**.  \n"
"Therefore you usually need to provide a type hint to help the compiler infer "
"the correct type. In the example above, we annotated the type of "
"`squares_of_evens` to be `Vec<u32>`. Alternatively, you can use the "
"**turbofish syntax** to specify the type:"
msgstr ""
"`collect`ëŠ” **ë°˜í™˜ íƒ€ì…**ì— ì¼ë°˜í™”ë©ë‹ˆë‹¤.  \n"
"ë”°ë¼ì„œ ì¼ë°˜ì ìœ¼ë¡œ ì»´íŒŒì¼ëŸ¬ê°€ ì˜¬ë°”ë¥¸ íƒ€ì…ì„ ìœ ì¶”í•˜ëŠ” ë° ë„ì›€ì´ ë˜ëŠ” ìœ í˜• íŒíŠ¸"
"ë¥¼ ì œê³µí•´ì•¼ í•©ë‹ˆë‹¤. ìœ„ì˜ ì˜ˆì—ì„œëŠ” `squares_of_evens` íƒ€ì…ì„ `Vec<u32>`ë¡œ ì–´ë…¸"
"í…Œì´ì…˜í–ˆìŠµë‹ˆë‹¤. ë˜ëŠ” **turbofish êµ¬ë¬¸**ì„ ì‚¬ìš©í•˜ì—¬ íƒ€ì…ì„ ì§€ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/07_combinators.md:98
msgid ""
"// Turbofish syntax: `<method_name>::<type>()`\n"
"    // It's called turbofish because `::<>` looks like a fish\n"
msgstr ""
"// Turbofish êµ¬ë¬¸: `<method_name>::<type>()`\n"
"    // `::<>`ì´ ë¬¼ê³ ê¸°ì²˜ëŸ¼ ë³´ì´ê¸° ë•Œë¬¸ì— í„°ë³´í”¼ì‹œë¼ê³  í•©ë‹ˆë‹¤\n"

#: src/06_ticket_management/07_combinators.md:105
msgid ""
"[`Iterator`'s documentation](https://doc.rust-lang.org/std/iter/trait."
"Iterator.html) gives you an overview of the methods available for iterators "
"in `std`."
msgstr ""
"[`Iterator` ë¬¸ì„œ](https://doc.rust-lang.org/std/iter/trait.Iterator.html)ëŠ” "
"`std`ì˜ ë°˜ë³µìì— ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë©”ì„œë“œì— ëŒ€í•œ ê°œìš”ë¥¼ ì œê³µí•©ë‹ˆë‹¤."

#: src/06_ticket_management/07_combinators.md:107
msgid ""
"[The `itertools` crate](https://docs.rs/itertools/) defines even **more** "
"combinators for iterators."
msgstr "`itertools` í¬ë ˆì´íŠ¸ëŠ” ë°˜ë³µìë¥¼ ìœ„í•œ **ë” ë§ì€** ê²°í•©ìë¥¼ ì •ì˜í•©ë‹ˆë‹¤."

#: src/06_ticket_management/07_combinators.md:111
msgid ""
"The exercise for this section is located in "
"[`06_ticket_management/07_combinators`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/07_combinators)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`06_ticket_management/07_combinators`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/07_combinators)ì— ìˆìŠµë‹ˆë‹¤"

#: src/06_ticket_management/08_impl_trait.md:3
msgid ""
"`TicketStore::to_dos` returns a `Vec<&Ticket>`.  \n"
"That signature introduces a new heap allocation every time `to_dos` is "
"called, which may be unnecessary depending on what the caller needs to do "
"with the result. It'd be better if `to_dos` returned an iterator instead of a "
"`Vec`, thus empowering the caller to decide whether to collect the results "
"into a `Vec` or just iterate over them."
msgstr ""
"`TicketStore::to_dos`ëŠ” `Vec<&Ticket>`ì„ ë°˜í™˜í•©ë‹ˆë‹¤.  \n"
"í•´ë‹¹ ì‹œê·¸ë‹ˆì²˜ëŠ” `to_dos`ê°€ í˜¸ì¶œë  ë•Œë§ˆë‹¤ ìƒˆë¡œìš´ í™ í• ë‹¹ì„ ì‹œí–‰í•˜ëŠ”ë°, ì´ëŠ” í˜¸"
"ì¶œìê°€ ì¶œë ¥ê°’ìœ¼ë¡œ ìˆ˜í–‰í•´ì•¼ í•˜ëŠ” ì‘ì—…ì— ë”°ë¼ ë¶ˆí•„ìš”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `to_dos`ê°€ "
"`Vec` ëŒ€ì‹  ë°˜ë³µìë¥¼ ë°˜í™˜í•˜ì—¬ í˜¸ì¶œìê°€ ê²°ê³¼ë¥¼ `Vec`ë¡œ ìˆ˜ì§‘í• ì§€ ì•„ë‹ˆë©´ ê·¸ëƒ¥ ë°˜ë³µ"
"í• ì§€ ê²°ì •í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ê²ƒì´ ë” ì¢‹ìŠµë‹ˆë‹¤."

#: src/06_ticket_management/08_impl_trait.md:9
msgid ""
"That's tricky though! What's the return type of `to_dos`, as implemented "
"below?"
msgstr "ê·¸ë˜ë„ ê¹Œë‹¤ë¡­ìŠµë‹ˆë‹¤! ì•„ë˜ì— êµ¬í˜„ëœ `to_dos`ì˜ ë°˜í™˜ íƒ€ì…ì€ ë¬´ì—‡ì¼ê¹Œìš”?"

#: src/06_ticket_management/08_impl_trait.md:20
msgid "Unnameable types"
msgstr "ì´ë¦„ì„ ì§€ì •í•  ìˆ˜ ì—†ëŠ” íƒ€ì…"

#: src/06_ticket_management/08_impl_trait.md:22
msgid ""
"The `filter` method returns an instance of `std::iter::Filter`, which has the "
"following definition:"
msgstr ""
"`filter` ë©”ì†Œë“œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì •ì˜ë¥¼ ê°–ëŠ” `std::iter::Filter`ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜"
"í™˜í•©ë‹ˆë‹¤:"

#: src/06_ticket_management/08_impl_trait.md:28
msgid ""
"where `I` is the type of the iterator being filtered on and `P` is the "
"predicate used to filter the elements.  \n"
"We know that `I` is `std::slice::Iter<'_, Ticket>` in this case, but what "
"about `P`?  \n"
"`P` is a closure, an **anonymous function**. As the name suggests, closures "
"don't have a name, so we can't write them down in our code."
msgstr ""
"ì—¬ê¸°ì„œ `I`ëŠ” í•„í„°ë§ë˜ëŠ” ë°˜ë³µìì˜ íƒ€ì…ì´ê³  `P`ëŠ” ìš”ì†Œë¥¼ í•„í„°ë§í•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” "
"ì¡°ê±´ìì…ë‹ˆë‹¤.  \n"
"ì´ ê²½ìš° `I`ëŠ” `std::slice::Iter<'_, Ticket>`ì´ë¼ëŠ” ê²ƒì„ ì•Œê³  ìˆì§€ë§Œ `P`ëŠ” ì–´ë–¤"
"ê°€ìš”?  \n"
"`P`ëŠ” í´ë¡œì €, **ìµëª… í•¨ìˆ˜**ì…ë‹ˆë‹¤. ì´ë¦„ì—ì„œ ì•Œ ìˆ˜ ìˆë“¯ì´ í´ë¡œì €ì—ëŠ” ì´ë¦„ì´ ì—†"
"ìœ¼ë¯€ë¡œ ì½”ë“œì— ì ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/06_ticket_management/08_impl_trait.md:33
msgid "Rust has a solution for this: **impl Trait**."
msgstr "Rustì—ëŠ” ì´ì— ëŒ€í•œ í•´ê²°ì±…ì´ ìˆìŠµë‹ˆë‹¤: **impl Trait**."

#: src/06_ticket_management/08_impl_trait.md:37
msgid ""
"`impl Trait` is a feature that allows you to return a type without specifying "
"its name. You just declare what trait(s) the type implements, and Rust "
"figures out the rest."
msgstr ""
"`impl Trait`ì€ ì´ë¦„ì„ ì§€ì •í•˜ì§€ ì•Šê³  íƒ€ì…ì„ ë°˜í™˜í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì…ë‹ˆë‹¤. í•´ë‹¹ íƒ€"
"ì…ì´ êµ¬í˜„í•˜ëŠ” íŠ¸ë˜ì‡(ë“¤)ì„ ì„ ì–¸í•˜ë©´ Rustê°€ ë‚˜ë¨¸ì§€ë¥¼ ì•Œì•„ëƒ…ë‹ˆë‹¤."

#: src/06_ticket_management/08_impl_trait.md:40
msgid "In this case, we want to return an iterator of references to `Ticket`s:"
msgstr "ì´ ê²½ìš° `Ticket`ì— ëŒ€í•œ ì°¸ì¡°ì˜ ë°˜ë³µìë¥¼ ë°˜í™˜í•˜ë ¤ê³  í•©ë‹ˆë‹¤:"

#: src/06_ticket_management/08_impl_trait.md:50
msgid "That's it!"
msgstr "ì´ê²Œ ì „ë¶€ì…ë‹ˆë‹¤!"

#: src/06_ticket_management/08_impl_trait.md:52
msgid "Generic?"
msgstr "ì œë„¤ë¦­?"

#: src/06_ticket_management/08_impl_trait.md:54
msgid "`impl Trait` in return position is **not** a generic parameter."
msgstr "ë°˜í™˜ ìœ„ì¹˜ì˜ `impl Trait`ì€ ì¼ë°˜ ë§¤ê°œë³€ìˆ˜ê°€ **ì•„ë‹™ë‹ˆë‹¤**."

#: src/06_ticket_management/08_impl_trait.md:56
msgid ""
"Generics are placeholders for types that are filled in by the caller of the "
"function. A function with a generic parameter is **polymorphic**: it can be "
"called with different types, and the compiler will generate a different "
"implementation for each type."
msgstr ""
"ì œë„¤ë¦­ì€ í•¨ìˆ˜ í˜¸ì¶œìê°€ ì±„ìš°ëŠ” íƒ€ì…ì— ëŒ€í•œ í”Œë ˆì´ìŠ¤ í™€ë”ì…ë‹ˆë‹¤. ì¼ë°˜ ë§¤ê°œë³€ìˆ˜"
"ê°€ ìˆëŠ” í•¨ìˆ˜ëŠ” **ë‹¤í˜•ì„±**ì…ë‹ˆë‹¤. ì¦‰, ë‹¤ì–‘í•œ íƒ€ì…ìœ¼ë¡œ í˜¸ì¶œë  ìˆ˜ ìˆìœ¼ë©° ì»´íŒŒì¼ëŸ¬"
"ëŠ” ê° íƒ€ì…ì— ëŒ€í•´ ë‹¤ë¥¸ êµ¬í˜„ì„ ìƒì„±í•©ë‹ˆë‹¤."

#: src/06_ticket_management/08_impl_trait.md:60
msgid ""
"That's not the case with `impl Trait`. The return type of a function with "
"`impl Trait` is **fixed** at compile time, and the compiler will generate a "
"single implementation for it. This is why `impl Trait` is also called "
"**opaque return type**: the caller doesn't know the exact type of the return "
"value, only that it implements the specified trait(s). But the compiler knows "
"the exact type, there is no polymorphism involved."
msgstr ""
"`impl Trait`ì˜ ê²½ìš°ëŠ” ê·¸ë ‡ì§€ ì•ŠìŠµë‹ˆë‹¤. `impl Trait`ì´ ìˆëŠ” í•¨ìˆ˜ì˜ ë°˜í™˜ íƒ€ì…ì€ "
"ì»´íŒŒì¼ íƒ€ì„ì— **ê³ ì •**ë˜ë©°, ì»´íŒŒì¼ëŸ¬ëŠ” ì´ì— ëŒ€í•œ ë‹¨ì¼ êµ¬í˜„ì„ ìƒì„±í•©ë‹ˆë‹¤. ì´ê²ƒ"
"ì´ `impl Trait`ì„ **ë¶ˆíˆ¬ëª… ë°˜í™˜ íƒ€ì…**ì´ë¼ê³ ë„ ë¶€ë¥´ëŠ” ì´ìœ ì…ë‹ˆë‹¤. í˜¸ì¶œìëŠ” ë°˜"
"í™˜ ê°’ì˜ ì •í™•í•œ íƒ€ì…ì„ ëª¨ë¥´ê³  ì§€ì •ëœ íŠ¸ë ˆì‡ì„ êµ¬í˜„í•œë‹¤ëŠ” ê²ƒë§Œ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤. "
"ê·¸ëŸ¬ë‚˜ ì»´íŒŒì¼ëŸ¬ëŠ” ì •í™•í•œ íƒ€ì…ì„ ì•Œê³  ìˆìœ¼ë¯€ë¡œ ë‹¤í˜•ì„±ì´ ê´€ë ¨ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/06_ticket_management/08_impl_trait.md:66
msgid "RPIT"
msgstr "RPIT"

#: src/06_ticket_management/08_impl_trait.md:68
msgid ""
"If you read RFCs or deep-dives about Rust, you might come across the acronym "
"**RPIT**.  \n"
"It stands for **\"Return Position Impl Trait\"** and refers to the use of "
"`impl Trait` in return position."
msgstr ""
"Rustì— ëŒ€í•œ RFCë‚˜ ì‹¬ì¸µ ë¶„ì„ì„ ì½ìœ¼ë©´ **RPIT**ë¼ëŠ” ì•½ì–´ë¥¼ ì ‘í•˜ê²Œ ë  ê²ƒì…ë‹ˆ"
"ë‹¤.  \n"
"**\"Return Position Impl Trait\"**ì˜ ì•½ìë¡œ ë¦¬í„´ í¬ì§€ì…˜ì—ì„œ `impl Trait`ì„ ì‚¬"
"ìš©í•˜ëŠ” ê²ƒì„ ë§í•©ë‹ˆë‹¤."

#: src/06_ticket_management/08_impl_trait.md:73
msgid ""
"The exercise for this section is located in "
"[`06_ticket_management/08_impl_trait`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/08_impl_trait)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`06_ticket_management/08_impl_trait`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/08_impl_trait)ì— ìˆìŠµë‹ˆë‹¤"

#: src/06_ticket_management/09_impl_trait_2.md:1
msgid "`impl Trait` in argument position"
msgstr "ì¸ìˆ˜ ìœ„ì¹˜ì˜ `impl Trait`"

#: src/06_ticket_management/09_impl_trait_2.md:3
msgid ""
"In the previous section, we saw how `impl Trait` can be used to return a type "
"without specifying its name.  \n"
"The same syntax can also be used in **argument position**:"
msgstr ""
"ì´ì „ ì„¹ì…˜ì—ì„œ `impl Trait`ì„ ì‚¬ìš©í•˜ì—¬ ì´ë¦„ì„ ì§€ì •í•˜ì§€ ì•Šê³  íƒ€ì…ì„ ë°˜í™˜í•˜ëŠ” ë°©"
"ë²•ì„ ì‚´í´ë³´ì•˜ìŠµë‹ˆë‹¤.  \n"
"**ì¸ìˆ˜ ìœ„ì¹˜**ì—ë„ ë™ì¼í•œ êµ¬ë¬¸ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/06_ticket_management/09_impl_trait_2.md:14
msgid ""
"`print_iter` takes an iterator of `i32`s and prints each element.  \n"
"When used in **argument position**, `impl Trait` is equivalent to a generic "
"parameter with a trait bound:"
msgstr ""
"`print_iter`ëŠ” `i32`ì˜ ë°˜ë³µìë¥¼ ê°€ì ¸ì™€ ê° ìš”ì†Œë¥¼ í”„ë¦°íŠ¸í•©ë‹ˆë‹¤.  \n"
"**ì¸ìˆ˜ ìœ„ì¹˜**ì—ì„œ ì‚¬ìš©ë  ë•Œ `impl Trait`ì€ íŠ¸ë ˆì‡ ë°”ìš´ë“œê°€ ìˆëŠ” ì¼ë°˜ ë§¤ê°œë³€ìˆ˜"
"ì™€ ë™ì¼í•©ë‹ˆë‹¤:"

#: src/06_ticket_management/09_impl_trait_2.md:28
#: src/08_futures/06_async_aware_primitives.md:115
msgid "Downsides"
msgstr "ë‹¨ì "

#: src/06_ticket_management/09_impl_trait_2.md:30
msgid ""
"As a rule of thumb, prefer generics over `impl Trait` in argument "
"position.  \n"
"Generics allow the caller to explicitly specify the type of the argument, "
"using the turbofish syntax (`::<>`), which can be useful for disambiguation. "
"That's not the case with `impl Trait`."
msgstr ""
"ê²½í—˜ìƒ ì¸ìˆ˜ ìœ„ì¹˜ì—ì„œëŠ” `impl Trait`ë³´ë‹¤ ì œë„¤ë¦­ì„ ì„ í˜¸í•©ë‹ˆë‹¤.  \n"
"ì œë„¤ë¦­ì„ ì‚¬ìš©í•˜ë©´ í˜¸ì¶œìê°€ ëª…í™•ì„±ì— ìœ ìš©í•  ìˆ˜ ìˆëŠ” í„°ë³´í”¼ì‹œ êµ¬ë¬¸(`::<>`)ì„ ì‚¬"
"ìš©í•˜ì—¬ ì¸ìˆ˜ íƒ€ì…ì„ ëª…ì‹œì ìœ¼ë¡œ ì§€ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `impl Trait`ì˜ ê²½ìš°ëŠ” ê·¸ë ‡"
"ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/06_ticket_management/09_impl_trait_2.md:36
msgid ""
"The exercise for this section is located in "
"[`06_ticket_management/09_impl_trait_2`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/09_impl_trait_2)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`06_ticket_management/09_impl_trait_2`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/09_impl_trait_2)ì— ìˆìŠµë‹ˆë‹¤"

#: src/06_ticket_management/10_slices.md:3
msgid "Let's go back to the memory layout of a `Vec`:"
msgstr "`Vec`ì˜ ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒìœ¼ë¡œ ëŒì•„ê°€ ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/10_slices.md:24
msgid ""
"We already remarked how `String` is just a `Vec<u8>` in disguise.  \n"
"The similarity should prompt you to ask: \"What's the equivalent of `&str` "
"for `Vec`?\""
msgstr ""
"ìš°ë¦¬ëŠ” `String`ì´ ì–´ë–»ê²Œ ìœ„ì¥ëœ `Vec<u8>`ì¸ì§€ ì´ë¯¸ ì–¸ê¸‰í–ˆìŠµë‹ˆë‹¤.  \n"
"ì´ ìœ ì‚¬ì„±ì„ ë³´ë©´ ì•„ë§ˆ ì´ëŸ° ì§ˆë¬¸ì´ ë– ì˜¤ë¥¼ê²ë‹ˆë‹¤: \"`Vec`ë²„ì „ì˜ `&str`ëŠ” ë­ì§€?\""

#: src/06_ticket_management/10_slices.md:27
msgid "`&[T]`"
msgstr "`&[T]`"

#: src/06_ticket_management/10_slices.md:29
msgid ""
"`[T]` is a **slice** of a contiguous sequence of elements of type `T`.  \n"
"It's most commonly used in its borrowed form, `&[T]`."
msgstr ""
"`[T]`ëŠ” `T` íƒ€ì…ì˜ ì—°ì†ëœ ìš”ì†Œ ì‹œí€€ìŠ¤ì˜ **ìŠ¬ë¼ì´ìŠ¤**ì…ë‹ˆë‹¤.  \n"
"ë³´í†µ ì°¸ì¡° í˜•íƒœì¸ `&[T]`ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/06_ticket_management/10_slices.md:32
msgid "There are various ways to create a slice reference from a `Vec`:"
msgstr "`Vec`ì—ì„œ ìŠ¬ë¼ì´ìŠ¤ ì°¸ì¡°ë¥¼ ìƒì„±í•˜ëŠ” ë°©ë²•ì—ëŠ” ì—¬ëŸ¬ ê°€ì§€ê°€ ìˆìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/10_slices.md:35
msgid "// Via index syntax\n"
msgstr "// ì¸ë±ìŠ¤ êµ¬ë¬¸ì„ í†µí•´\n"

#: src/06_ticket_management/10_slices.md:37
msgid "// Via a method\n"
msgstr "// ë©”ì†Œë“œë¥¼ í†µí•´\n"

#: src/06_ticket_management/10_slices.md:39
msgid "// Or for a subset of the elements\n"
msgstr "// ë˜ëŠ” ìš”ì†Œì˜ í•˜ìœ„ ì§‘í•©ì— ëŒ€í•´\n"

#: src/06_ticket_management/10_slices.md:44
msgid ""
"`Vec` implements the `Deref` trait using `[T]` as the target type, so you can "
"use slice methods on a `Vec` directly thanks to deref coercion:"
msgstr ""
"`Vec`ì€ `[T]`ë¥¼ ëŒ€ìƒ íƒ€ì…ìœ¼ë¡œ ì‚¬ìš©í•˜ì—¬ `Deref` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•˜ë¯€ë¡œ deref "
"coercion ë•ë¶„ì— `Vec`ì—ì„œ ì§ì ‘ ìŠ¬ë¼ì´ìŠ¤ ë©”ì„œë“œë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/10_slices.md:48
msgid ""
"// Surprise, surprise: `iter` is not a method on `Vec`!\n"
"// It's a method on `&[T]`, but you can call it on a `Vec` \n"
"// thanks to deref coercion.\n"
msgstr ""
"// ë†€ë¼ìš´ ì‚¬ì‹¤: `iter`ëŠ” `Vec`ì˜ ë©”ì„œë“œê°€ ì•„ë‹™ë‹ˆë‹¤!\n"
"// `&[T]`ì˜ ë©”ì„œë“œì´ì§€ë§Œ deref coercion ë•ë¶„ì—\n"
"// `Vec`ì—ì„œ í˜¸ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"

#: src/06_ticket_management/10_slices.md:57
msgid ""
"A `&[T]` is a **fat pointer**, just like `&str`.  \n"
"It consists of a pointer to the first element of the slice and the length of "
"the slice."
msgstr ""
"`&[T]`ëŠ” `&str`ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ **íŒ» í¬ì¸í„°**ì…ë‹ˆë‹¤.  \n"
"ì´ëŠ” ìŠ¬ë¼ì´ìŠ¤ì˜ ì²« ë²ˆì§¸ ìš”ì†Œì— ëŒ€í•œ í¬ì¸í„°ì™€ ìŠ¬ë¼ì´ìŠ¤ì˜ ê¸¸ì´ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤."

#: src/06_ticket_management/10_slices.md:60
msgid "If you have a `Vec` with three elements:"
msgstr "ì„¸ ê°€ì§€ ìš”ì†Œë¥¼ í¬í•¨í•˜ëŠ” `Vec`ì´ ìˆëŠ” ê²½ìš°:"

#: src/06_ticket_management/10_slices.md:66
msgid "and then create a slice reference:"
msgstr "ê·¸ëŸ° ë‹¤ìŒ ìŠ¬ë¼ì´ìŠ¤ ì°¸ì¡°ë¥¼ ë§Œë“­ë‹ˆë‹¤:"

#: src/06_ticket_management/10_slices.md:72
msgid "you'll get this memory layout:"
msgstr "ë‹¤ìŒê³¼ ê°™ì€ ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒì„ ì–»ê²Œ ë©ë‹ˆë‹¤:"

#: src/06_ticket_management/10_slices.md:91
msgid "`&Vec<T>` vs `&[T]`"
msgstr "`&Vec<T>` vs `&[T]`"

#: src/06_ticket_management/10_slices.md:93
msgid ""
"When you need to pass an immutable reference to a `Vec` to a function, prefer "
"`&[T]` over `&Vec<T>`.  \n"
"This allows the function to accept any kind of slice, not necessarily one "
"backed by a `Vec`."
msgstr ""
"`Vec`ì— ëŒ€í•œ ë¶ˆë³€ ì°¸ì¡°ë¥¼ í•¨ìˆ˜ì— ì „ë‹¬í•´ì•¼ í•˜ëŠ” ê²½ìš° `&Vec<T>`ë³´ë‹¤ `&[T]`ë¥¼ ì‚¬ìš©"
"í•˜ì„¸ìš”.  \n"
"ì´ë¥¼ í†µí•´ í•¨ìˆ˜ëŠ” ë°˜ë“œì‹œ `Vec`ì— ì˜í•´ ì§€ì›ë˜ëŠ” ìŠ¬ë¼ì´ìŠ¤ê°€ ì•„ë‹Œ ëª¨ë“  ì¢…ë¥˜ì˜ ìŠ¬ë¼"
"ì´ìŠ¤ë¥¼ í—ˆìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/06_ticket_management/10_slices.md:96
msgid ""
"For example, you can then pass a subset of the elements in a `Vec`. But it "
"goes further than thatâ€”you could also pass a **slice of an array**:"
msgstr ""
"ì˜ˆë¥¼ ë“¤ì–´, `Vec`ì— ìˆëŠ” ìš”ì†Œì˜ í•˜ìœ„ ì§‘í•©ì„ ì „ë‹¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ê·¸ ì´ìƒ"
"ì…ë‹ˆë‹¤. **ë°°ì—´ì˜ ìŠ¬ë¼ì´ìŠ¤**ë„ ì „ë‹¬í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."

#: src/06_ticket_management/10_slices.md:104
msgid ""
"Array slices and `Vec` slices are the same type: they're fat pointers to a "
"contiguous sequence of elements. In the case of arrays, the pointer points to "
"the stack rather than the heap, but that doesn't matter when it comes to "
"using the slice."
msgstr ""
"ë°°ì—´ ìŠ¬ë¼ì´ìŠ¤ì™€ `Vec` ìŠ¬ë¼ì´ìŠ¤ëŠ” ë™ì¼í•œ íƒ€ì…ì…ë‹ˆë‹¤. ì¦‰, ì—°ì†ëœ ìš”ì†Œ ì‹œí€€ìŠ¤ì— "
"ëŒ€í•œ íŒ» í¬ì¸í„°ì…ë‹ˆë‹¤. ë°°ì—´ì˜ ê²½ìš° í¬ì¸í„°ëŠ” í™ì´ ì•„ë‹Œ ìŠ¤íƒì„ ê°€ë¦¬í‚¤ì§€ë§Œ ìŠ¬ë¼ì´"
"ìŠ¤ë¥¼ ì‚¬ìš©í•  ë•ŒëŠ” ì¤‘ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/06_ticket_management/10_slices.md:110
msgid ""
"The exercise for this section is located in [`06_ticket_management/10_slices`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/10_slices)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`06_ticket_management/10_slices`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/10_slices)ì— ìˆìŠµë‹ˆë‹¤"

#: src/06_ticket_management/11_mutable_slices.md:3
msgid ""
"Every time we've talked about slice types (like `str` and `[T]`), we've used "
"their immutable borrow form (`&str` and `&[T]`).  \n"
"But slices can also be mutable!"
msgstr ""
"ìš°ë¦¬ëŠ” ìŠ¬ë¼ì´ìŠ¤ íƒ€ì…(ì˜ˆ: `str`ì™€ `[T]`)ì— ëŒ€í•´ ì´ì•¼ê¸°í•  ë•Œë§ˆë‹¤ ë¶ˆë³€ ì°¸ì¡° í˜•ì‹"
"(`&str` ë° `&[T]`)ì„ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.  \n"
"í•˜ì§€ë§Œ ìŠ¬ë¼ì´ìŠ¤ë„ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!"

#: src/06_ticket_management/11_mutable_slices.md:6
msgid "Here's how you create a mutable slice:"
msgstr "ë³€ê²½ ê°€ëŠ¥í•œ ìŠ¬ë¼ì´ìŠ¤ë¥¼ ë§Œë“œëŠ” ë°©ë²•ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/11_mutable_slices.md:13
msgid "You can then modify the elements in the slice:"
msgstr "ê·¸ëŸ° ë‹¤ìŒ ìŠ¬ë¼ì´ìŠ¤ì˜ ìš”ì†Œë¥¼ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/11_mutable_slices.md:19
msgid "This will change the first element of the `Vec` to `42`."
msgstr "ê·¸ëŸ¬ë©´ `Vec`ì˜ ì²« ë²ˆì§¸ ìš”ì†Œê°€ `42`ë¡œ ë³€ê²½ë©ë‹ˆë‹¤."

#: src/06_ticket_management/11_mutable_slices.md:23
msgid ""
"When working with immutable borrows, the recommendation was clear: prefer "
"slice references over references to the owned type (e.g. `&[T]` over "
"`&Vec<T>`).  \n"
"That's **not** the case with mutable borrows."
msgstr ""
"ë¶ˆë³€ ì°¸ì¡°ë¡œ ì‘ì—…í•  ë•Œ ê¶Œì¥ ì‚¬í•­ì€ ëª…í™•í–ˆìŠµë‹ˆë‹¤. ì†Œìœ í•œ íƒ€ì…ì— ëŒ€í•œ ì°¸ì¡°ë³´ë‹¤ ìŠ¬"
"ë¼ì´ìŠ¤ ì°¸ì¡°ë¥¼ ì„ í˜¸í•©ë‹ˆë‹¤(ì˜ˆ: `&Vec<T>`ë³´ë‹¤ `&[T]`).  \n"
"ë³€ê²½ ê°€ëŠ¥í•œ ë¹Œë¦¼ì˜ ê²½ìš°ëŠ” **ê·¸ë ‡ì§€** ì•ŠìŠµë‹ˆë‹¤."

#: src/06_ticket_management/11_mutable_slices.md:27
msgid "Consider this scenario:"
msgstr "ë‹¤ìŒ ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ìƒê°í•´ë³´ì„¸ìš”:"

#: src/06_ticket_management/11_mutable_slices.md:35
msgid ""
"It won't compile!  \n"
"`push` is a method on `Vec`, not on slices. This is the manifestation of a "
"more general principle: Rust won't allow you to add or remove elements from a "
"slice. You will only be able to modify/replace the elements that are already "
"there."
msgstr ""
"ì»´íŒŒì¼ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤!  \n"
"`push`ëŠ” ìŠ¬ë¼ì´ìŠ¤ê°€ ì•„ë‹Œ `Vec`ì— ëŒ€í•œ ë©”ì„œë“œì…ë‹ˆë‹¤. ì´ëŠ” ë³´ë‹¤ ì¼ë°˜ì ì¸ ì›ì¹™ì˜ "
"í‘œí˜„ì…ë‹ˆë‹¤. RustëŠ” ìŠ¬ë¼ì´ìŠ¤ì—ì„œ ìš”ì†Œë¥¼ ì¶”ê°€í•˜ê±°ë‚˜ ì œê±°í•˜ëŠ” ê²ƒì„ í—ˆìš©í•˜ì§€ ì•ŠìŠµ"
"ë‹ˆë‹¤. ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ìš”ì†Œë¥¼ ìˆ˜ì •/êµì²´ë§Œ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/06_ticket_management/11_mutable_slices.md:40
msgid ""
"In this regard, a `&mut Vec` or a `&mut String` are strictly more powerful "
"than a `&mut [T]` or a `&mut str`.  \n"
"Choose the type that best fits based on the operations you need to perform."
msgstr ""
"ì´ì™€ ê´€ë ¨í•˜ì—¬ `&mut Vec` ë˜ëŠ” `&mut String`ì€ `&mut [T]` ë˜ëŠ” `&mut str`ë³´ë‹¤ "
"ì—„ê²©í•˜ê²Œ ë” ê°•ë ¥í•©ë‹ˆë‹¤.  \n"
"ìˆ˜í–‰í•´ì•¼ í•˜ëŠ” ì‘ì—…ì— ë”°ë¼ ê°€ì¥ ì í•©í•œ íƒ€ì…ì„ ì„ íƒí•˜ì‹­ì‹œì˜¤."

#: src/06_ticket_management/11_mutable_slices.md:45
msgid ""
"The exercise for this section is located in "
"[`06_ticket_management/11_mutable_slices`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/11_mutable_slices)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`06_ticket_management/11_mutable_slices`](https://github."
"com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/11_mutable_slices)ì— ìˆìŠµë‹ˆë‹¤"

#: src/06_ticket_management/12_two_states.md:1
msgid "Ticket ids"
msgstr "í‹°ì¼“ ID"

#: src/06_ticket_management/12_two_states.md:3
msgid ""
"Let's think again about our ticket management system.  \n"
"Our ticket model right now looks like this:"
msgstr ""
"ìš°ë¦¬ì˜ í‹°ì¼“ ê´€ë¦¬ ì‹œìŠ¤í…œì— ëŒ€í•´ ë‹¤ì‹œ ìƒê°í•´ ë´…ì‹œë‹¤.  \n"
"í˜„ì¬ ìš°ë¦¬ì˜ í‹°ì¼“ ëª¨ë¸ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/12_two_states.md:14
msgid ""
"One thing is missing here: an **identifier** to uniquely identify a "
"ticket.  \n"
"That identifier should be unique for each ticket. That can be guaranteed by "
"generating it automatically when a new ticket is created."
msgstr ""
"ì—¬ê¸°ì„œëŠ” í‹°ì¼“ì„ ê³ ìœ í•˜ê²Œ ì‹ë³„í•˜ëŠ” **ì‹ë³„ì**ê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤.  \n"
"í•´ë‹¹ ì‹ë³„ìëŠ” ê° í‹°ì¼“ë§ˆë‹¤ ê³ ìœ í•´ì•¼ í•©ë‹ˆë‹¤. ìƒˆ í‹°ì¼“ì´ ìƒì„±ë  ë•Œ ìë™ìœ¼ë¡œ ìƒì„±í•˜"
"ì—¬ ì´ë¥¼ ë³´ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/06_ticket_management/12_two_states.md:18
msgid "Refining the model"
msgstr "ëª¨ë¸ ê°œì„ "

#: src/06_ticket_management/12_two_states.md:20
msgid ""
"Where should the id be stored?  \n"
"We could add a new field to the `Ticket` struct:"
msgstr ""
"IDëŠ” ì–´ë””ì— ì €ì¥í•´ì•¼ í•˜ë‚˜ìš”?  \n"
"`Ticket` êµ¬ì¡°ì²´ì— ìƒˆ í•„ë“œë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/12_two_states.md:32
msgid ""
"But we don't know the id before creating the ticket. So it can't be there "
"from the get-go.  \n"
"It'd have to be optional:"
msgstr ""
"í•˜ì§€ë§Œ í‹°ì¼“ì„ ë§Œë“¤ê¸° ì „ì—ëŠ” IDë¥¼ ì•Œ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‹ˆ ì²˜ìŒë¶€í„° ìˆì„ ìˆ˜ëŠ” ì—†"
"ìŠµë‹ˆë‹¤.  \n"
"ì˜µì…”ë„í•´ì•¼ í•œë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/06_ticket_management/12_two_states.md:44
msgid ""
"That's also not idealâ€”we'd have to handle the `None` case every single time "
"we retrieve a ticket from the store, even though we know that the id should "
"always be there once the ticket has been created."
msgstr ""
"ê·¸ê²ƒì€ ë˜í•œ ì´ìƒì ì´ì§€ ì•ŠìŠµë‹ˆë‹¤. í‹°ì¼“ì´ ìƒì„±ë˜ë©´ IDê°€ í•­ìƒ ê±°ê¸°ì— ìˆì–´ì•¼ í•œë‹¤"
"ëŠ” ê²ƒì„ ì•Œê³  ìˆë”ë¼ë„ ìƒì ì—ì„œ í‹°ì¼“ì„ ê²€ìƒ‰í•  ë•Œë§ˆë‹¤ `None` ì¼€ì´ìŠ¤ë¥¼ ì²˜ë¦¬í•´ì•¼ "
"í•©ë‹ˆë‹¤."

#: src/06_ticket_management/12_two_states.md:47
msgid ""
"The best solution is to have two different ticket **states**, represented by "
"two separate types: a `TicketDraft` and a `Ticket`:"
msgstr ""
"ê°€ì¥ ì¢‹ì€ í•´ê²°ì±…ì€ `TicketDraft`ì™€ `Ticket`ì´ë¼ëŠ” ë‘ ê°€ì§€ ë³„ë„ íƒ€ì…ìœ¼ë¡œ í‘œì‹œë˜"
"ëŠ” ë‘ ê°œì˜ ì„œë¡œ ë‹¤ë¥¸ í‹°ì¼“ **ìƒíƒœ**ë§Œë“œëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/06_ticket_management/12_two_states.md:64
msgid ""
"A `TicketDraft` is a ticket that hasn't been created yet. It doesn't have an "
"id, and it doesn't have a status.  \n"
"A `Ticket` is a ticket that has been created. It has an id and a status.  \n"
"Since each field in `TicketDraft` and `Ticket` embeds its own constraints, we "
"don't have to duplicate logic across the two types."
msgstr ""
"`TicketDraft`ëŠ” ì•„ì§ ìƒì„±ë˜ì§€ ì•Šì€ í‹°ì¼“ì…ë‹ˆë‹¤. IDë„ ì—†ê³  ìƒíƒœë„ ì—†ìŠµë‹ˆë‹¤.  \n"
"`Ticket`ì€ ìƒì„±ëœ í‹°ì¼“ì…ë‹ˆë‹¤. IDì™€ ìƒíƒœê°€ ìˆìŠµë‹ˆë‹¤.  \n"
"`TicketDraft`ì™€ `Ticket`ì˜ ê° í•„ë“œì—ëŠ” ìì²´ ì œì•½ ì¡°ê±´ì´ í¬í•¨ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ë‘ "
"íƒ€ì…ì— ë¡œì§ì„ ì¤‘ë³µí•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤."

#: src/06_ticket_management/12_two_states.md:71
msgid ""
"The exercise for this section is located in "
"[`06_ticket_management/12_two_states`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/12_two_states)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`06_ticket_management/12_two_states`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/12_two_states)ì— ìˆìŠµë‹ˆë‹¤"

#: src/06_ticket_management/13_index.md:1
msgid "Indexing"
msgstr "ì¸ë±ì‹±"

#: src/06_ticket_management/13_index.md:3
msgid ""
"`TicketStore::get` returns an `Option<&Ticket>` for a given `TicketId`.  \n"
"We've seen before how to access elements of arrays and vectors using Rust's "
"indexing syntax:"
msgstr ""
"`TicketStore::get`ì€ ì£¼ì–´ì§„ `TicketId`ì— ëŒ€í•´ `Option<&Ticket>`ì„ ë°˜í™˜í•©ë‹ˆ"
"ë‹¤.  \n"
"ìš°ë¦¬ëŠ” ì´ì „ì— Rustì˜ ì¸ë±ì‹± êµ¬ë¬¸ì„ ì‚¬ìš©í•˜ì—¬ ë°°ì—´ê³¼ ë²¡í„°ì˜ ìš”ì†Œì— ì•¡ì„¸ìŠ¤í•˜ëŠ” ë°©"
"ë²•ì„ ì‚´í´ë³´ì•˜ìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/13_index.md:12
msgid ""
"How can we provide the same experience for `TicketStore`?  \n"
"You guessed right: we need to implement a trait, `Index`!"
msgstr ""
"ì–´ë–»ê²Œ `TicketStore`ì— ëŒ€í•´ì„œë„ ë™ì¼í•œ ê²½í—˜ì„ ì œê³µí•  ìˆ˜ ìˆì„ê¹Œìš”?  \n"
"ë‹¹ì‹ ì´ ìƒê°í•˜ê³  ìˆëŠ” ê·¸ê²Œ ë§ìŠµë‹ˆë‹¤: `Index` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤!"

#: src/06_ticket_management/13_index.md:15
msgid "`Index`"
msgstr "`Index`"

#: src/06_ticket_management/13_index.md:17
msgid "The `Index` trait is defined in Rust's standard library:"
msgstr "`Index` íŠ¸ë ˆì‡ì€ Rustì˜ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ì •ì˜ë˜ì–´ ìˆìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/13_index.md:25
#: src/06_ticket_management/14_index_mut.md:14
#: src/06_ticket_management/15_hashmap.md:63
msgid "// Required method\n"
msgstr "// í•„ìˆ˜ ë©”ì„œë“œ\n"

#: src/06_ticket_management/13_index.md:30
msgid "It has:"
msgstr "`Index` íŠ¸ë ˆì‡ì€ ì•„ë˜ì˜ ê²ƒë“¤ì„ ê°€ì§‘ë‹ˆë‹¤:"

#: src/06_ticket_management/13_index.md:32
msgid "One generic parameter, `Idx`, to represent the index type"
msgstr "ì¸ë±ìŠ¤ íƒ€ì…ì„ ë‚˜íƒ€ë‚´ëŠ” í•˜ë‚˜ì˜ ì œë„¤ë¦­ ë§¤ê°œë³€ìˆ˜ `Idx`"

#: src/06_ticket_management/13_index.md:33
msgid ""
"One associated type, `Output`, to represent the type we retrieved using the "
"index"
msgstr "ì¸ë±ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ ê²€ìƒ‰í•œ íƒ€ì…ì„ ë‚˜íƒ€ë‚´ëŠ” í•˜ë‚˜ì˜ ì—°ê´€ íƒ€ì… `Output`"

#: src/06_ticket_management/13_index.md:35
msgid ""
"Notice how the `index` method doesn't return an `Option`. The assumption is "
"that `index` will panic if you try to access an element that's not there, as "
"it happens for array and vec indexing."
msgstr ""
"`index` ë©”ì„œë“œê°€ ì–´ë–»ê²Œ `Option`ì„ ë°˜í™˜í•˜ì§€ ì•ŠëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”. ë°°ì—´ ë° vec ì¸"
"ë±ì‹±ì—ì„œ ë°œìƒí•˜ëŠ” ê²ƒì²˜ëŸ¼ `index`ê°€ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ìš”ì†Œì— ì•¡ì„¸ìŠ¤í•˜ë ¤ê³  í•˜ë©´ íŒ¨ë‹‰"
"ì´ ë°œìƒí•  ê²ƒì´ë¼ê³  ê°€ì •í•©ë‹ˆë‹¤."

#: src/06_ticket_management/13_index.md:41
msgid ""
"The exercise for this section is located in [`06_ticket_management/13_index`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/13_index)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`06_ticket_management/13_index`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/13_index)ì— ìˆìŠµë‹ˆë‹¤"

#: src/06_ticket_management/14_index_mut.md:1
msgid "Mutable indexing"
msgstr "ë³€ê²½ ê°€ëŠ¥í•œ ì¸ë±ì‹±"

#: src/06_ticket_management/14_index_mut.md:3
msgid ""
"`Index` allows read-only access. It doesn't let you mutate the value you "
"retrieved."
msgstr ""
"`Index`ëŠ” ì½ê¸° ì „ìš© ì•¡ì„¸ìŠ¤ë¥¼ í—ˆìš©í•©ë‹ˆë‹¤. ê²€ìƒ‰í•œ ê°’ì„ ë³€ê²½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/06_ticket_management/14_index_mut.md:6
msgid "`IndexMut`"
msgstr "`IndexMut`"

#: src/06_ticket_management/14_index_mut.md:8
msgid ""
"If you want to allow mutability, you need to implement the `IndexMut` trait."
msgstr "ê°€ë³€ì„±ì„ í—ˆìš©í•˜ë ¤ë©´ `IndexMut` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/06_ticket_management/14_index_mut.md:19
msgid ""
"`IndexMut` can only be implemented if the type already implements `Index`, "
"since it unlocks an _additional_ capability."
msgstr ""
"`IndexMut`ëŠ” íƒ€ì…ì´ ì´ë¯¸ `Index`ë¥¼ êµ¬í˜„í•œ ê²½ìš°ì—ë§Œ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. _ì¶”ê°€_ "
"ê¸°ëŠ¥ì„ ì ê¸ˆ í•´ì œí•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/06_ticket_management/14_index_mut.md:24
msgid ""
"The exercise for this section is located in "
"[`06_ticket_management/14_index_mut`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/06_ticket_management/14_index_mut)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`06_ticket_management/14_index_mut`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/14_index_mut)ì— ìˆìŠµë‹ˆë‹¤"

#: src/06_ticket_management/15_hashmap.md:3
msgid ""
"Our implementation of `Index`/`IndexMut` is not ideal: we need to iterate "
"over the entire `Vec` to retrieve a ticket by id; the algorithmic complexity "
"is `O(n)`, where `n` is the number of tickets in the store."
msgstr ""
"ìš°ë¦¬ì˜ `Index`/`IndexMut` êµ¬í˜„ì€ ìµœì ì´ ì•„ë‹™ë‹ˆë‹¤: í‹°ì¼“ì„ IDë¡œ ê²€ìƒ‰í•˜ê¸° ìœ„í•´ ì „"
"ì²´ `Vec`ì„ ë°˜ë³µí•´ì•¼ í•˜ë©°, ì•Œê³ ë¦¬ì¦˜ ë³µì¡ë„ëŠ” í‹°ì¼“ ìŠ¤í† ì–´ ë‚´ì˜ í‹°ì¼“ ìˆ˜ë¥¼ ë‚˜íƒ€ë‚´"
"ëŠ” `n`ì— ë¹„ë¡€í•˜ì—¬ `O(n)`ì…ë‹ˆë‹¤."

#: src/06_ticket_management/15_hashmap.md:7
msgid ""
"We can do better by using a different data structure for storing tickets: a "
"`HashMap<K, V>`."
msgstr ""
"í‹°ì¼“ ì €ì¥ì„ ìœ„í•´ `HashMap<K, V>`ë¼ëŠ” ë‹¤ë¥¸ ë°ì´í„° êµ¬ì¡°ë¥¼ ì‚¬ìš©í•˜ë©´ ë” ë‚˜ì€ ê²°ê³¼"
"ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/06_ticket_management/15_hashmap.md:11
msgid ""
"// Type inference lets us omit an explicit type signature (which\n"
"// would be `HashMap<String, String>` in this example).\n"
msgstr ""
"// íƒ€ì… ì¶”ë¡ ì„ í†µí•´ ëª…ì‹œì ì¸ íƒ€ì… ì‹œê·¸ë‹ˆì²˜(ì´ ì˜ˆì—ì„œëŠ”\n"
"// HashMap<String, String>`ì´ ë¨)ì„ ìƒëµí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"

#: src/06_ticket_management/15_hashmap.md:17
msgid "\"Adventures of Huckleberry Finn\""
msgstr "\"Adventures of Huckleberry Finn\""

#: src/06_ticket_management/15_hashmap.md:18
msgid "\"My favorite book.\""
msgstr "\"My favorite book.\""

#: src/06_ticket_management/15_hashmap.md:22
msgid ""
"`HashMap` works with key-value pairs. It's generic over both: `K` is the "
"generic parameter for the key type, while `V` is the one for the value type."
msgstr ""
"`HashMap`ì€ í‚¤-ê°’ ìŒìœ¼ë¡œ ì‘ë™í•©ë‹ˆë‹¤. ë‘ ê°€ì§€ ëª¨ë‘ì— ëŒ€í•´ ì¼ë°˜í™”ë©ë‹ˆë‹¤. `K`ëŠ” "
"í‚¤ íƒ€ì…ì— ëŒ€í•œ ì¼ë°˜ ë§¤ê°œë³€ìˆ˜ì´ê³  `V`ëŠ” ê°’ íƒ€ì…ì— ëŒ€í•œ ë§¤ê°œë³€ìˆ˜ì…ë‹ˆë‹¤."

#: src/06_ticket_management/15_hashmap.md:25
msgid ""
"The expected cost of insertions, retrievals and removals is **constant**, "
"`O(1)`. That sounds perfect for our usecase, doesn't it?"
msgstr ""
"ì‚½ì…, ê²€ìƒ‰ ë° ì œê±°ì˜ ì˜ˆìƒ ë¹„ìš©ì€ **ìƒìˆ˜**, `O(1)`ì…ë‹ˆë‹¤. ìš°ë¦¬ì˜ ì‚¬ìš© ì‚¬ë¡€ì— "
"ë”± ë§ëŠ” ê²ƒ ê°™ì§€ ì•Šë‚˜ìš”?"

#: src/06_ticket_management/15_hashmap.md:28
msgid "Key requirements"
msgstr "ì£¼ìš” ìš”êµ¬ ì‚¬í•­"

#: src/06_ticket_management/15_hashmap.md:30
msgid ""
"There are no trait bounds on `HashMap`'s struct definition, but you'll find "
"some on its methods. Let's look at `insert`, for example:"
msgstr ""
"`HashMap`ì˜ êµ¬ì¡°ì²´ ì •ì˜ì—ëŠ” íŠ¸ë ˆì‡ ë°”ìš´ë“œê°€ ì—†ì§€ë§Œ í•´ë‹¹ ë©”ì„œë“œì—ì„œ ì¼ë¶€ë¥¼ ì°¾"
"ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ `insert`ë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/15_hashmap.md:45
msgid ""
"The key type must implement the `Eq` and `Hash` traits.  \n"
"Let's dig into those two."
msgstr ""
"í‚¤ íƒ€ì…ì€ `Eq` ë° `Hash` íŠ¸ë ˆì‡ì„ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤.  \n"
"ê·¸ ë‘ ê°€ì§€ë¥¼ íŒŒí—¤ì³ ë³´ê² ìŠµë‹ˆë‹¤."

#: src/06_ticket_management/15_hashmap.md:48
msgid "`Hash`"
msgstr "`Hash`"

#: src/06_ticket_management/15_hashmap.md:50
msgid ""
"A hashing function (or hasher) maps a potentially infinite set of a values (e."
"g. all possible strings) to a bounded range (e.g. a `u64` value).  \n"
"There are many different hashing functions around, each with different "
"properties (speed, collision risk, reversibility, etc.)."
msgstr ""
"í•´ì‹± í•¨ìˆ˜(ë˜ëŠ” í•´ì…”)ëŠ” ì ì¬ì ìœ¼ë¡œ ë¬´í•œí•œ ê°’ ì§‘í•©(ì˜ˆ: ê°€ëŠ¥í•œ ëª¨ë“  ë¬¸ìì—´)ì„ ì œ"
"í•œëœ ë²”ìœ„(ì˜ˆ: `u64` ê°’)ì— ë§¤í•‘í•©ë‹ˆë‹¤.  \n"
"ì°¾ì•„ë³´ë©´ ì„œë¡œ ë‹¤ë¥¸ ì†ì„±(ì†ë„, ì¶©ëŒ ìœ„í—˜, ê°€ì—­ì„± ë“±)ì„ ê°€ì§„ ë‹¤ì–‘í•œ í•´ì‹± í•¨ìˆ˜ê°€ "
"ìˆìŠµë‹ˆë‹¤."

#: src/06_ticket_management/15_hashmap.md:55
msgid ""
"A `HashMap`, as the name suggests, uses a hashing function behind the scene. "
"It hashes your key and then uses that hash to store/retrieve the associated "
"value. This strategy requires the key type must be hashable, hence the `Hash` "
"trait bound on `K`."
msgstr ""
"ì´ë¦„ì—ì„œ ì•Œ ìˆ˜ ìˆë“¯ì´ `HashMap`ì€ ë’¤ì—ì„œ í•´ì‹± í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. í‚¤ë¥¼ í•´ì‹œí•œ "
"ë‹¤ìŒ í•´ë‹¹ í•´ì‹œë¥¼ ì‚¬ìš©í•˜ì—¬ ê´€ë ¨ ê°’ì„ ì €ì¥/ê²€ìƒ‰í•©ë‹ˆë‹¤. ì´ ì „ëµì—ì„œëŠ” í‚¤ íƒ€ì…ì´ "
"í•´ì‹œ ê°€ëŠ¥í•´ì•¼ í•˜ë¯€ë¡œ `K`ì— `Hash` íŠ¸ë ˆì‡ì´ ë°”ì¸ë”©ë©ë‹ˆë‹¤."

#: src/06_ticket_management/15_hashmap.md:59
msgid "You can find the `Hash` trait in the `std::hash` module:"
msgstr "`std::hash` ëª¨ë“ˆì—ì„œ `Hash` íŠ¸ë ˆì‡ì„ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/15_hashmap.md:69
msgid ""
"You will rarely implement `Hash` manually. Most of the times you'll derive it:"
msgstr ""
"`Hash`ë¥¼ ìˆ˜ë™ìœ¼ë¡œ êµ¬í˜„í•˜ëŠ” ê²½ìš°ëŠ” ê±°ì˜ ì—†ìŠµë‹ˆë‹¤. ëŒ€ë¶€ë¶„ì˜ ê²½ìš° ë‹¤ìŒê³¼ ê°™ì´ íŒŒ"
"ìƒë©ë‹ˆë‹¤:"

#: src/06_ticket_management/15_hashmap.md:79
msgid "`Eq`"
msgstr "`Eq`"

#: src/06_ticket_management/15_hashmap.md:81
msgid ""
"`HashMap` must be able to compare keys for equality. This is particularly "
"important when dealing with hash collisionsâ€”i.e. when two different keys hash "
"to the same value."
msgstr ""
"`HashMap`ì€ í‚¤ê°€ ë™ì¼í•œì§€ ë¹„êµí•  ìˆ˜ ìˆì–´ì•¼ í•©ë‹ˆë‹¤. ì´ëŠ” í•´ì‹œ ì¶©ëŒì„ ì²˜ë¦¬í•  ë•Œ "
"íŠ¹íˆ ì¤‘ìš”í•©ë‹ˆë‹¤. ì¦‰ ë‘ ê°œì˜ ì„œë¡œ ë‹¤ë¥¸ í‚¤ê°€ ë™ì¼í•œ ê°’ìœ¼ë¡œ í•´ì‹œë˜ëŠ” ê²½ìš° ë§ì…ë‹ˆ"
"ë‹¤."

#: src/06_ticket_management/15_hashmap.md:84
msgid ""
"You may wonder: isn't that what the `PartialEq` trait is for? Almost!  \n"
"`PartialEq` is not enough for `HashMap` because it doesn't guarantee "
"reflexivity, i.e. `a == a` is always `true`.  \n"
"For example, floating point numbers (`f32` and `f64`) implement `PartialEq`, "
"but they don't satisfy the reflexivity property: `f32::NAN == f32::NAN` is "
"`false`.  \n"
"Reflexivity is crucial for `HashMap` to work correctly: without it, you "
"wouldn't be able to retrieve a value from the map using the same key you used "
"to insert it."
msgstr ""
"ì•„ë§ˆ ë‹¹ì‹ ì€ ê¶ê¸ˆí•  ê²ƒì…ë‹ˆë‹¤: ì´ê²Œ ë°”ë¡œ `PartialEq` íŠ¸ë ˆì‡ì´ í•˜ëŠ” ì¼ ì•„ë‹Œê°€ìš”? "
"ê±°ì˜ ë§ì•˜ìŠµë‹ˆë‹¤!  \n"
"`PartialEq`ëŠ” ë°˜ì‚¬ì„±(reflexivity)ì„ ë³´ì¥í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— `HashMap`ì— ì í•©í•˜ì§€ "
"ì•ŠìŠµë‹ˆë‹¤. ì¦‰ `a == a`ëŠ” í•­ìƒ `true`ì…ë‹ˆë‹¤.  \n"
"ì˜ˆë¥¼ ë“¤ì–´ ë¶€ë™ ì†Œìˆ˜ì  ìˆ«ì(`f32` ë° `f64`)ëŠ” `PartialEq`ë¥¼ êµ¬í˜„í•˜ì§€ë§Œ ë°˜ì‚¬ì„± "
"ì†ì„±ì„ ì¶©ì¡±í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. `f32::NAN == f32::NAN`ì€ `false`ì…ë‹ˆë‹¤.  \n"
"ì¬ê·€ì„±ì€ `HashMap`ì´ ì˜¬ë°”ë¥´ê²Œ ì‘ë™í•˜ëŠ” ë° ë§¤ìš° ì¤‘ìš”í•©ë‹ˆë‹¤. ì¬ê·€ì„±ì´ ì—†ìœ¼ë©´ ì´"
"ë¥¼ ì‚½ì…í•˜ëŠ” ë° ì‚¬ìš©í•œ ê²ƒê³¼ ë™ì¼í•œ í‚¤ë¥¼ ì‚¬ìš©í•˜ì—¬ ë§µì—ì„œ ê°’ì„ ê²€ìƒ‰í•  ìˆ˜ ì—†ìŠµë‹ˆ"
"ë‹¤."

#: src/06_ticket_management/15_hashmap.md:91
msgid "The `Eq` trait extends `PartialEq` with the reflexivity property:"
msgstr "`Eq` íŠ¸ë ˆì‡ì€ ë°˜ì‚¬ì„± ì†ì„±ì„ ì‚¬ìš©í•˜ì—¬ `PartialEq`ë¥¼ í™•ì¥í•©ë‹ˆë‹¤:"

#: src/06_ticket_management/15_hashmap.md:95
msgid "// No additional methods\n"
msgstr "// ì¶”ê°€ ë©”ì„œë“œ ì—†ìŒ\n"

#: src/06_ticket_management/15_hashmap.md:99
msgid ""
"It's a marker trait: it doesn't add any new methods, it's just a way for you "
"to say to the compiler that the equality logic implemented in `PartialEq` is "
"reflexive."
msgstr ""
"ì´ëŠ” ë§ˆì»¤ íŠ¹ì„±ì…ë‹ˆë‹¤. ìƒˆë¡œìš´ ë©”ì„œë“œë¥¼ ì¶”ê°€í•˜ì§€ ì•Šê³  `PartialEq`ì— êµ¬í˜„ëœ ë™ë“± "
"ë…¼ë¦¬ê°€ ë°˜ì‚¬ì ì„ì„ ì»´íŒŒì¼ëŸ¬ì— ì•Œë¦¬ëŠ” ë°©ë²•ì¼ ë¿ì…ë‹ˆë‹¤."

#: src/06_ticket_management/15_hashmap.md:102
msgid "You can derive `Eq` automatically when you derive `PartialEq`:"
msgstr "`PartialEq`ë¥¼ íŒŒìƒì‹œí‚¤ë©´ `Eq`ê°€ ìë™ìœ¼ë¡œ íŒŒìƒë  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/15_hashmap.md:112
msgid "`Eq` and `Hash` are linked"
msgstr "`Eq`ì™€ `Hash`ëŠ” ì—°ê´€ë˜ì–´ìˆìŠµë‹ˆë‹¤"

#: src/06_ticket_management/15_hashmap.md:114
msgid ""
"There is an implicit contract between `Eq` and `Hash`: if two keys are equal, "
"their hashes must be equal too. This is crucial for `HashMap` to work "
"correctly. If you break this contract, you'll get nonsensical results when "
"using `HashMap`."
msgstr ""
"`Eq`ì™€ `Hash` ì‚¬ì´ì—ëŠ” ì•”ë¬µì ì¸ ì•½ì†ì´ ìˆìŠµë‹ˆë‹¤. ë‘ í‚¤ê°€ ë™ì¼í•˜ë©´ í•´ë‹¹ í•´ì‹œë„ "
"ë™ì¼í•´ì•¼ í•©ë‹ˆë‹¤. ì´ëŠ” `HashMap`ì´ ì˜¬ë°”ë¥´ê²Œ ì‘ë™í•˜ëŠ” ë° ì¤‘ìš”í•©ë‹ˆë‹¤. ì´ ì•½ì†ì„ "
"ì–´ê¸°ë©´ `HashMap`ì„ ì‚¬ìš©í•  ë•Œ ì˜ë¯¸ ì—†ëŠ” ê²°ê³¼ë¥¼ ì–»ê²Œ ë©ë‹ˆë‹¤."

#: src/06_ticket_management/15_hashmap.md:120
msgid ""
"The exercise for this section is located in "
"[`06_ticket_management/15_hashmap`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/06_ticket_management/15_hashmap)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`06_ticket_management/15_hashmap`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/15_hashmap)ì— ìˆìŠµë‹ˆë‹¤"

#: src/06_ticket_management/16_btreemap.md:1
msgid "Ordering"
msgstr "ìˆœì„œ"

#: src/06_ticket_management/16_btreemap.md:3
msgid ""
"By moving from a `Vec` to a `HashMap` we have improved the performance of our "
"ticket management system, and simplified our code in the process.  \n"
"It's not all roses, though. When iterating over a `Vec`\\-backed store, we "
"could be sure that the tickets would be returned in the order they were "
"added.  \n"
"That's not the case with a `HashMap`: you can iterate over the tickets, but "
"the order is random."
msgstr ""
"`Vec`ì—ì„œ `HashMap`ìœ¼ë¡œ ì´ë™í•˜ì—¬ í‹°ì¼“ ê´€ë¦¬ ì‹œìŠ¤í…œì˜ ì„±ëŠ¥ì„ ê°œì„ í•˜ê³  ê·¸ ê³¼ì •ì—"
"ì„œ ì½”ë“œë¥¼ ë‹¨ìˆœí™”í–ˆìŠµë‹ˆë‹¤.  \n"
"í•˜ì§€ë§Œ ì•„ì§ ëª¨ë“  ê²ƒì´ ì™„ë²½í•˜ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤. `Vec` ì§€ì› ìŠ¤í† ì–´ë¥¼ ë°˜ë³µí•  ë•Œ í‹°ì¼“"
"ì´ ì¶”ê°€ëœ ìˆœì„œëŒ€ë¡œ ë°˜í™˜ëœë‹¤ëŠ” ê²ƒì„ í™•ì‹ í•  ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.  \n"
"`HashMap`ì˜ ê²½ìš°ëŠ” ê·¸ë ‡ì§€ ì•ŠìŠµë‹ˆë‹¤. í‹°ì¼“ì„ ë°˜ë³µí•  ìˆ˜ ìˆì§€ë§Œ ìˆœì„œëŠ” ë¬´ì‘ìœ„ì…ë‹ˆ"
"ë‹¤."

#: src/06_ticket_management/16_btreemap.md:9
msgid ""
"We can recover a consistent ordering by switching from a `HashMap` to a "
"`BTreeMap`."
msgstr ""
"`HashMap`ì—ì„œ `BTreeMap`ìœ¼ë¡œ ì „í™˜í•˜ë©´ ë‹¤ì‹œ ì¼ê´€ëœ ìˆœì„œë¥¼ ë³´ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/06_ticket_management/16_btreemap.md:13
msgid ""
"A `BTreeMap` guarantees that entries are sorted by their keys.  \n"
"This is useful when you need to iterate over the entries in a specific order, "
"or if you need to perform range queries (e.g. \"give me all tickets with an "
"id between 10 and 20\")."
msgstr ""
"`BTreeMap`ì€ í•­ëª©ì´ í‚¤ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ë˜ë„ë¡ ë³´ì¥í•©ë‹ˆë‹¤.  \n"
"ì´ëŠ” íŠ¹ì • ìˆœì„œë¡œ í•­ëª©ì„ ë°˜ë³µí•´ì•¼ í•˜ê±°ë‚˜ ë²”ìœ„ ì¿¼ë¦¬ë¥¼ ìˆ˜í–‰í•´ì•¼ í•˜ëŠ” ê²½ìš°(ì˜ˆ: "
"\"IDê°€ 10ì—ì„œ 20 ì‚¬ì´ì¸ ëª¨ë“  í‹°ì¼“ì„ ì£¼ì„¸ìš”\") ìœ ìš©í•©ë‹ˆë‹¤."

#: src/06_ticket_management/16_btreemap.md:17
msgid ""
"Just like `HashMap`, you won't find trait bounds on the definition of "
"`BTreeMap`. But you'll find trait bounds on its methods. Let's look at "
"`insert`:"
msgstr ""
"`HashMap`ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ `BTreeMap` ì •ì˜ì—ì„œëŠ” íŠ¸ë ˆì‡ ë°”ìš´ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆ"
"ë‹¤. ê·¸ëŸ¬ë‚˜ í•´ë‹¹ ë©”ì„œë“œì—ì„œ íŠ¸ë ˆì‡ ë°”ìš´ë“œë¥¼ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. `insert`ë¥¼ ì‚´í´ë³´"
"ê² ìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/16_btreemap.md:21
msgid ""
"// `K` and `V` stand for the key and value types, respectively,\n"
"// just like in `HashMap`.\n"
msgstr ""
"// `K`ì™€ `V`ëŠ” ê°ê° `HashMap`ì—ì„œì™€ ë§ˆì°¬ê°€ì§€ë¡œ // í‚¤ì™€ ê°’ íƒ€ì…ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.\n"

#: src/06_ticket_management/16_btreemap.md:28
msgid "// implementation\n"
msgstr "// êµ¬í˜„\n"

#: src/06_ticket_management/16_btreemap.md:33
msgid ""
"`Hash` is no longer required. Instead, the key type must implement the `Ord` "
"trait."
msgstr ""
"`Hash`ëŠ” ë” ì´ìƒ í•„ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ëŒ€ì‹ , í‚¤ ìœ í˜•ì€ 'Ord' íŠ¸ë ˆì‡ì„ êµ¬í˜„í•´ì•¼ í•©"
"ë‹ˆë‹¤."

#: src/06_ticket_management/16_btreemap.md:35
msgid "`Ord`"
msgstr "`Ord`"

#: src/06_ticket_management/16_btreemap.md:37
msgid ""
"The `Ord` trait is used to compare values.  \n"
"While `PartialEq` is used to compare for equality, `Ord` is used to compare "
"for ordering."
msgstr ""
"`Ord` íŠ¸ë ˆì‡ì€ ê°’ì„ ë¹„êµí•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.  \n"
"`PartialEq`ëŠ” ë™ë“±ì„±ì„ ë¹„êµí•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” ë°˜ë©´, `Ord`ëŠ” ìˆœì„œë¥¼ ë¹„êµí•˜ëŠ” ë° "
"ì‚¬ìš©ë©ë‹ˆë‹¤."

#: src/06_ticket_management/16_btreemap.md:40
msgid "It's defined in `std::cmp`:"
msgstr "ì´ëŠ” `std::cmp`ì— ì •ì˜ë˜ì–´ ìˆìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/16_btreemap.md:48
msgid ""
"The `cmp` method returns an `Ordering` enum, which can be one of `Less`, "
"`Equal`, or `Greater`.  \n"
"`Ord` requires that two other traits are implemented: `Eq` and `PartialOrd`."
msgstr ""
"`cmp` ë©”ì†Œë“œëŠ” `Less`, `Equal` ë˜ëŠ” `Greater` ì¤‘ í•˜ë‚˜ì¼ ìˆ˜ ìˆëŠ” `Ordering` ì—´"
"ê±°í˜•ì„ ë°˜í™˜í•©ë‹ˆë‹¤.  \n"
"`Ord`ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ `Eq`ì™€ `PartialOrd`ë¼ëŠ” ë‘ ê°€ì§€ ë‹¤ë¥¸ íŠ¸ë ˆì‡ì´ êµ¬í˜„ë˜ì–´ì•¼ í•©"
"ë‹ˆë‹¤."

#: src/06_ticket_management/16_btreemap.md:52
msgid "`PartialOrd`"
msgstr "`PartialOrd`"

#: src/06_ticket_management/16_btreemap.md:54
msgid ""
"`PartialOrd` is a weaker version of `Ord`, just like `PartialEq` is a weaker "
"version of `Eq`. You can see why by looking at its definition:"
msgstr ""
"`PartialOrd`ëŠ” `Ord`ì˜ ì•½í•œ ë²„ì „ì…ë‹ˆë‹¤. ë§ˆì¹˜ `PartialEq`ê°€ `Eq`ì˜ ì•½í•œ ë²„ì „ì¸ "
"ê²ƒê³¼ ê°™ìŠµë‹ˆë‹¤. ì •ì˜ë¥¼ ë³´ë©´ ê·¸ ì´ìœ ë¥¼ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/16_btreemap.md:63
msgid ""
"`PartialOrd::partial_cmp` returns an `Option`â€”it is not guaranteed that two "
"values can be compared.  \n"
"For example, `f32` doesn't implement `Ord` because `NaN` values are not "
"comparable, the same reason why `f32` doesn't implement `Eq`."
msgstr ""
"`PartialOrd::partial_cmp`ëŠ” `Option`ì„ ë°˜í™˜í•©ë‹ˆë‹¤. ë‘ ê°’ì„ ë¹„êµí•  ìˆ˜ ìˆë‹¤ëŠ” ë³´"
"ì¥ì€ ì—†ìŠµë‹ˆë‹¤.  \n"
"ì˜ˆë¥¼ ë“¤ì–´, `f32`ëŠ” `NaN` ê°’ì„ ë¹„êµí•  ìˆ˜ ì—†ê¸° ë•Œë¬¸ì— `Ord`ë¥¼ êµ¬í˜„í•˜ì§€ ì•ŠìŠµë‹ˆ"
"ë‹¤. ì´ëŠ” `f32`ê°€ `Eq`ë¥¼ êµ¬í˜„í•˜ì§€ ì•ŠëŠ” ê²ƒê³¼ ê°™ì€ ì´ìœ ì…ë‹ˆë‹¤."

#: src/06_ticket_management/16_btreemap.md:68
msgid "Implementing `Ord` and `PartialOrd`"
msgstr "`Ord`ì™€ `PartialOrd` êµ¬í˜„"

#: src/06_ticket_management/16_btreemap.md:70
msgid "Both `Ord` and `PartialOrd` can be derived for your types:"
msgstr "íƒ€ì…ì— `Ord`ì™€ `PartialOrd`ë¥¼ ëª¨ë‘ íŒŒìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/06_ticket_management/16_btreemap.md:73
msgid ""
"// You need to add `Eq` and `PartialEq` too,\n"
"// since `Ord` requires them.\n"
msgstr ""
"// `Eq`ì™€ `PartialEq`ë„ ì¶”ê°€í•´ì•¼ í•©ë‹ˆë‹¤.\n"
"// `Ord`ê°€ í•„ìš”ë¡œ í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.\n"

#: src/06_ticket_management/16_btreemap.md:79
msgid "If you choose (or need) to implement them manually, be careful:"
msgstr "ìˆ˜ë™ìœ¼ë¡œ êµ¬í˜„í•˜ê¸°ë¡œ ì„ íƒí•˜ê±°ë‚˜ í•„ìš”í•œ ê²½ìš° ë‹¤ìŒ ì‚¬í•­ì— ì£¼ì˜í•˜ì„¸ìš”:"

#: src/06_ticket_management/16_btreemap.md:81
msgid "`Ord` and `PartialOrd` must be consistent with `Eq` and `PartialEq`."
msgstr "`Ord`ì™€ `PartialOrd`ëŠ” `Eq`ì™€ `PartialEq`ì™€ ì¼ê´€ë˜ì–´ì•¼ í•©ë‹ˆë‹¤."

#: src/06_ticket_management/16_btreemap.md:82
msgid "`Ord` and `PartialOrd` must be consistent with each other."
msgstr "`Ord`ì™€ `PartialOrd`ëŠ” ì„œë¡œ ì¼ê´€ë˜ì–´ì•¼ í•©ë‹ˆë‹¤."

#: src/06_ticket_management/16_btreemap.md:86
msgid ""
"The exercise for this section is located in "
"[`06_ticket_management/16_btreemap`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/06_ticket_management/16_btreemap)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`06_ticket_management/16_btreemap`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/16_btreemap)ì— ìˆìŠµë‹ˆë‹¤"

#: src/07_threads/00_intro.md:3
msgid ""
"One of Rust's big promises is _fearless concurrency_: making it easier to "
"write safe, concurrent programs. We haven't seen much of that yet. All the "
"work we've done so far has been single-threaded. Time to change that!"
msgstr ""
"Rustì˜ ê°€ì¥ í° ì•½ì† ì¤‘ í•˜ë‚˜ëŠ” _ë‘ë ¤ì›€ ì—†ëŠ” ë™ì‹œì„±_ì…ë‹ˆë‹¤. ì¦‰, ì•ˆì „í•œ ë™ì‹œì„± í”„"
"ë¡œê·¸ë¨ ì‘ì„±ì„ ë” ì‰½ê²Œ ë§Œë“œëŠ” ê²ƒì…ë‹ˆë‹¤. ìš°ë¦¬ëŠ” ì•„ì§ ê·¸ëŸ° ê²ƒì„ ë§ì´ ë³´ì§€ ëª»í–ˆìŠµ"
"ë‹ˆë‹¤. ì§€ê¸ˆê¹Œì§€ ìš°ë¦¬ê°€ ìˆ˜í–‰í•œ ëª¨ë“  ì‘ì—…ì€ ë‹¨ì¼ ìŠ¤ë ˆë“œì˜€ìŠµë‹ˆë‹¤. ì´ì œ ë°”ë€” ì‹œê°„ì…"
"ë‹ˆë‹¤!"

#: src/07_threads/00_intro.md:7
msgid ""
"In this chapter we'll make our ticket store multithreaded.  \n"
"We'll have the opportunity to touch most of Rust's core concurrency features, "
"including:"
msgstr ""
"ì´ë²ˆ ì¥ì—ì„œëŠ” í‹°ì¼“ ìŠ¤í† ì–´ë¥¼ ë©€í‹°ìŠ¤ë ˆë“œë¡œ ë§Œë“¤ê² ìŠµë‹ˆë‹¤.  \n"
"ìš°ë¦¬ëŠ” ë‹¤ìŒì„ í¬í•¨í•´ Rustì˜ í•µì‹¬ ë™ì‹œì„± ê¸°ëŠ¥ ëŒ€ë¶€ë¶„ì„ ë‹¤ë£° ê¸°íšŒë¥¼ ê°–ê²Œ ë  ê²ƒì…"
"ë‹ˆë‹¤:"

#: src/07_threads/00_intro.md:10
msgid "Threads, using the `std::thread` module"
msgstr "ìŠ¤ë ˆë“œ, `std::thread` ëª¨ë“ˆë¥¼ ì‚¬ìš©"

#: src/07_threads/00_intro.md:11
msgid "Message passing, using channels"
msgstr "ë©”ì‹œì§€ ì „ë‹¬, ì±„ë„ ì‚¬ìš©"

#: src/07_threads/00_intro.md:12
msgid "Shared state, using `Arc`, `Mutex` and `RwLock`"
msgstr "ê³µìœ  ìƒíƒœ, `Arc`, `Mutex`ê·¸ë¦¬ê³  `RwLock`ì„ ì‚¬ìš©"

#: src/07_threads/00_intro.md:13
msgid "`Send` and `Sync`, the traits that encode Rust's concurrency guarantees"
msgstr "`Send`ì™€ `Sync`, Rustì˜ ë™ì‹œì„±ì„ ë³´ì¥í•˜ëŠ” íŠ¸ë ˆì‡"

#: src/07_threads/00_intro.md:15
msgid ""
"We'll also discuss various design patterns for multithreaded systems and some "
"of their trade-offs."
msgstr ""
"ë˜í•œ ë©€í‹° ìŠ¤ë ˆë“œ ì‹œìŠ¤í…œì˜ ë‹¤ì–‘í•œ ë””ìì¸ íŒ¨í„´ê³¼ ê·¸ ì¥ë‹¨ì ì— ëŒ€í•´ì„œë„ ë…¼ì˜í•  ê²ƒ"
"ì…ë‹ˆë‹¤."

#: src/07_threads/00_intro.md:19
msgid ""
"The exercise for this section is located in [`07_threads/00_intro`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/00_intro)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`07_threads/00_intro`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/00_intro)ì— ìˆìŠµë‹ˆë‹¤"

#: src/07_threads/01_threads.md:3
msgid ""
"Before we start writing multithreaded code, let's take a step back and talk "
"about what threads are and why we might want to use them."
msgstr ""
"ë©€í‹°ìŠ¤ë ˆë“œ ì½”ë“œ ì‘ì„±ì„ ì‹œì‘í•˜ê¸° ì „ì— í•œë°œ ë¬¼ëŸ¬ì„œì„œ ìŠ¤ë ˆë“œê°€ ë¬´ì—‡ì¸ì§€, ì™œ ìŠ¤ë ˆ"
"ë“œë¥¼ ì‚¬ìš©í•˜ë ¤ëŠ”ì§€ì— ëŒ€í•´ ì´ì•¼ê¸°í•´ ë³´ê² ìŠµë‹ˆë‹¤."

#: src/07_threads/01_threads.md:6
msgid "What is a thread?"
msgstr "ìŠ¤ë ˆë“œë€ ë¬´ì—‡ì¼ê¹Œìš”?"

#: src/07_threads/01_threads.md:8
msgid ""
"A **thread** is an execution context managed by the underlying operating "
"system.  \n"
"Each thread has its own stack, instruction pointer, and program counter."
msgstr ""
"**ìŠ¤ë ˆë“œ**ëŠ” ê¸°ë³¸ ìš´ì˜ ì²´ì œì—ì„œ ê´€ë¦¬í•˜ëŠ” ì‹¤í–‰ ì»¨í…ìŠ¤íŠ¸ì…ë‹ˆë‹¤.  \n"
"ê° ìŠ¤ë ˆë“œì—ëŠ” ìì²´ ìŠ¤íƒ, ëª…ë ¹ í¬ì¸í„° ë° í”„ë¡œê·¸ë¨ ì¹´ìš´í„°ê°€ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/01_threads.md:11
msgid ""
"A single **process** can manage multiple threads. These threads share the "
"same memory space, which means they can access the same data."
msgstr ""
"ë‹¨ì¼ **í”„ë¡œì„¸ìŠ¤**ëŠ” ì—¬ëŸ¬ ìŠ¤ë ˆë“œë¥¼ ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŸ¬í•œ ìŠ¤ë ˆë“œëŠ” ë™ì¼í•œ "
"ë©”ëª¨ë¦¬ ê³µê°„ì„ ê³µìœ í•˜ë¯€ë¡œ ë™ì¼í•œ ë°ì´í„°ì— ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/01_threads.md:14
msgid ""
"Threads are a **logical** construct. In the end, you can only run one set of "
"instructions at a time on a CPU core, the **physical** execution unit.  \n"
"Since there can be many more threads than there are CPU cores, the operating "
"system's **scheduler** is in charge of deciding which thread to run at any "
"given time, partitioning CPU time among them to maximize throughput and "
"responsiveness."
msgstr ""
"ìŠ¤ë ˆë“œëŠ” **ë…¼ë¦¬ì ** êµ¬ì¡°ì…ë‹ˆë‹¤. ê²°êµ­ CPU ì½”ì–´, ì¦‰ **ë¬¼ë¦¬ì ** ì‹¤í–‰ ë‹¨ìœ„ì—ì„œëŠ” "
"í•œ ë²ˆì— í•˜ë‚˜ì˜ ëª…ë ¹ì–´ ì„¸íŠ¸ë§Œ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"CPU ì½”ì–´ë³´ë‹¤ ë” ë§ì€ ìŠ¤ë ˆë“œê°€ ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ìš´ì˜ ì²´ì œì˜ **ìŠ¤ì¼€ì¤„ëŸ¬**ëŠ” ì£¼ì–´"
"ì§„ ì‹œê°„ì— ì‹¤í–‰í•  ìŠ¤ë ˆë“œë¥¼ ê²°ì •í•˜ê³  ì²˜ë¦¬ëŸ‰ê³¼ ì‘ë‹µì„±ì„ ìµœëŒ€í™”í•˜ê¸° ìœ„í•´ ìŠ¤ë ˆë“œ ê°„"
"ì— CPU ì‹œê°„ì„ ë¶„í• í•˜ëŠ” ì¼ì„ ë‹´ë‹¹í•©ë‹ˆë‹¤."

#: src/07_threads/01_threads.md:20
msgid "`main`"
msgstr "`main`"

#: src/07_threads/01_threads.md:22
msgid ""
"When a Rust program starts, it runs on a single thread, the **main "
"thread**.  \n"
"This thread is created by the operating system and is responsible for running "
"the `main` function."
msgstr ""
"Rust í”„ë¡œê·¸ë¨ì´ ì‹œì‘ë˜ë©´ ë‹¨ì¼ ìŠ¤ë ˆë“œì¸ **ë©”ì¸ ìŠ¤ë ˆë“œ**ì—ì„œ ì‹¤í–‰ë©ë‹ˆë‹¤.  \n"
"ì´ ìŠ¤ë ˆë“œëŠ” ìš´ì˜ ì²´ì œì— ì˜í•´ ìƒì„±ë˜ë©° `main` í•¨ìˆ˜ ì‹¤í–‰ì„ ë‹´ë‹¹í•©ë‹ˆë‹¤."

#: src/07_threads/01_threads.md:33 src/07_threads/01_threads.md:63
msgid "\"Hello from the main thread!\""
msgstr "\"Hello from the main thread!\""

#: src/07_threads/01_threads.md:38
msgid "`std::thread`"
msgstr "`std::thread`"

#: src/07_threads/01_threads.md:40
msgid ""
"Rust's standard library provides a module, `std::thread`, that allows you to "
"create and manage threads."
msgstr ""
"Rustì˜ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ê³  ê´€ë¦¬í•  ìˆ˜ ìˆëŠ” `std::thread` ëª¨ë“ˆ"
"ì„ ì œê³µí•©ë‹ˆë‹¤."

#: src/07_threads/01_threads.md:43
msgid "`spawn`"
msgstr "`spawn`"

#: src/07_threads/01_threads.md:45
msgid ""
"You can use `std::thread::spawn` to create new threads and execute code on "
"them."
msgstr ""
"`std::thread::spawn`ì„ ì‚¬ìš©í•˜ì—¬ ìƒˆ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ê³  í•´ë‹¹ ìŠ¤ë ˆë“œì—ì„œ ì½”ë“œë¥¼ ì‹¤"
"í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/01_threads.md:57 src/07_threads/01_threads.md:85
#: src/07_threads/01_threads.md:105
msgid "\"Hello from a thread!\""
msgstr "\"Hello from a thread!\""

#: src/07_threads/01_threads.md:68
msgid ""
"If you execute this program on the [Rust playground](https://play.rust-lang."
"org/?"
"version=stable&mode=debug&edition=2021&gist=afedf7062298ca8f5a248bc551062eaa) "
"you'll see that the main thread and the spawned thread run concurrently.  \n"
"Each thread makes progress independently of the other."
msgstr ""
"[Rust playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=afedf7062298ca8f5a248bc551062eaa)"
"ì—ì„œ ì´ í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰í•˜ë©´ ë©”ì¸ ìŠ¤ë ˆë“œì™€ ìƒì„±ëœ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ì‹¤í–‰ë˜ëŠ” ê²ƒ"
"ì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"ê° ìŠ¤ë ˆë“œëŠ” ì„œë¡œ ë…ë¦½ì ìœ¼ë¡œ ì§„í–‰ë©ë‹ˆë‹¤."

#: src/07_threads/01_threads.md:72
msgid "Process termination"
msgstr "í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ"

#: src/07_threads/01_threads.md:74
msgid ""
"When the main thread finishes, the overall process will exit.  \n"
"A spawned thread will continue running until it finishes or the main thread "
"finishes."
msgstr ""
"ë©”ì¸ ìŠ¤ë ˆë“œê°€ ì™„ë£Œë˜ë©´ ì „ì²´ í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œë©ë‹ˆë‹¤.  \n"
"ìƒì„±ëœ ìŠ¤ë ˆë“œëŠ” ì™„ë£Œë˜ê±°ë‚˜ ë©”ì¸ ìŠ¤ë ˆë“œê°€ ì¢…ë£Œë  ë•Œê¹Œì§€ ê³„ì† ì‹¤í–‰ë©ë‹ˆë‹¤."

#: src/07_threads/01_threads.md:93
msgid ""
"In the example above, you can expect to see the message \"Hello from a thread!"
"\" printed roughly five times.  \n"
"Then the main thread will finish (when the `sleep` call returns), and the "
"spawned thread will be terminated since the overall process exits."
msgstr ""
"ìœ„ì˜ ì˜ˆì—ì„œëŠ” \"Hello from a thread!\"ë¼ëŠ” ë©”ì‹œì§€ê°€ í‘œì‹œë  ê²ƒìœ¼ë¡œ ì˜ˆìƒí•  ìˆ˜ ìˆ"
"ìŠµë‹ˆë‹¤. ëŒ€ëµ 5ë²ˆ ì •ë„ í”„ë¦°íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤.  \n"
"ê·¸ëŸ° ë‹¤ìŒ ë©”ì¸ ìŠ¤ë ˆë“œê°€ ì¢…ë£Œë˜ê³ (`sleep` í˜¸ì¶œì´ ë°˜í™˜ë  ë•Œ) ì „ì²´ í”„ë¡œì„¸ìŠ¤ê°€ ì¢…"
"ë£Œë˜ë¯€ë¡œ ìƒì„±ëœ ìŠ¤ë ˆë“œê°€ ì¢…ë£Œë©ë‹ˆë‹¤."

#: src/07_threads/01_threads.md:97
msgid "`join`"
msgstr "`join`"

#: src/07_threads/01_threads.md:99
msgid ""
"You can also wait for a spawned thread to finish by calling the `join` method "
"on the `JoinHandle` that `spawn` returns."
msgstr ""
"ë˜í•œ `spawn`ì´ ë°˜í™˜í•˜ëŠ” `JoinHandle`ì—ì„œ `join` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ì—¬ ìƒì„±ëœ ìŠ¤ë ˆ"
"ë“œê°€ ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦´ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/01_threads.md:112
msgid ""
"In this example, the main thread will wait for the spawned thread to finish "
"before exiting.  \n"
"This introduces a form of **synchronization** between the two threads: you're "
"guaranteed to see the message \"Hello from a thread!\" printed before the "
"program exits, because the main thread won't exit until the spawned thread "
"has finished."
msgstr ""
"ì´ ì˜ˆì—ì„œ ê¸°ë³¸ ìŠ¤ë ˆë“œëŠ” ì¢…ë£Œë˜ê¸° ì „ì— ìƒì„±ëœ ìŠ¤ë ˆë“œê°€ ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦½ë‹ˆ"
"ë‹¤.  \n"
"ì´ë ‡ê²Œ í•˜ë©´ ë‘ ìŠ¤ë ˆë“œ ê°„ì— ì¼ì¢…ì˜ **ë™ê¸°í™”**ê°€ ë„ì…ë©ë‹ˆë‹¤. ì¦‰, \"Hello from a "
"thread!\"ë¼ëŠ” ë©”ì‹œì§€ê°€ í‘œì‹œë©ë‹ˆë‹¤. ìƒì„±ëœ ìŠ¤ë ˆë“œê°€ ì™„ë£Œë  ë•Œê¹Œì§€ ë©”ì¸ ìŠ¤ë ˆë“œ"
"ê°€ ì¢…ë£Œë˜ì§€ ì•Šê¸° ë•Œë¬¸ì— í”„ë¡œê·¸ë¨ì´ ì¢…ë£Œë˜ê¸° ì „ì— í”„ë¦°íŠ¸ë©ë‹ˆë‹¤."

#: src/07_threads/01_threads.md:119
msgid ""
"The exercise for this section is located in [`07_threads/01_threads`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/01_threads)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`07_threads/01_threads`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/01_threads)ì— ìˆìŠµë‹ˆë‹¤"

#: src/07_threads/02_static.md:1
msgid "`'static`"
msgstr "`'static`"

#: src/07_threads/02_static.md:3
msgid ""
"If you tried to borrow a slice from the vector in the previous exercise, you "
"probably got a compiler error that looks something like this:"
msgstr ""
"ì´ì „ ì—°ìŠµì—ì„œ ë²¡í„°ì˜ ìŠ¬ë¼ì´ìŠ¤ë¥¼ ì°¨ìš©í•˜ë ¤ê³  ì‹œë„í–ˆë‹¤ë©´ ì•„ë§ˆë„ ë‹¤ìŒê³¼ ê°™ì€ ì»´íŒŒ"
"ì¼ëŸ¬ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì„ ê²ƒì…ë‹ˆë‹¤:"

#: src/07_threads/02_static.md:21
msgid "`argument requires that v is borrowed for 'static`, what does that mean?"
msgstr "`argument requires that v is borrowed for 'static`. ì´ê²Œ ë¬´ìŠ¨ ë§ì¼ê¹Œìš”?"

#: src/07_threads/02_static.md:23
msgid ""
"The `'static` lifetime is a special lifetime in Rust.  \n"
"It means that the value will be valid for the entire duration of the program."
msgstr ""
"`'static` ìˆ˜ëª…ì€ Rustì—ì„œ íŠ¹ë³„í•œ ìˆ˜ëª…ì…ë‹ˆë‹¤.  \n"
"ì´ëŠ” í•´ë‹¹ ê°’ì´ í”„ë¡œê·¸ë¨ ì „ì²´ ê¸°ê°„ ë™ì•ˆ ìœ íš¨í•¨ì„ ì˜ë¯¸í•©ë‹ˆë‹¤."

#: src/07_threads/02_static.md:26
msgid "Detached threads"
msgstr "ë¶„ë¦¬ëœ ìŠ¤ë ˆë“œ"

#: src/07_threads/02_static.md:28
msgid ""
"A thread launched via `thread::spawn` can **outlive** the thread that spawned "
"it.  \n"
"For example:"
msgstr ""
"`thread::spawn`ì„ í†µí•´ ì‹œì‘ëœ ìŠ¤ë ˆë“œëŠ” ì´ë¥¼ ìƒì„±í•œ ìŠ¤ë ˆë“œë³´ë‹¤ **ì˜¤ë˜ ì‚´ì•„**ìˆ"
"ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"ì˜ˆì‹œ:"

#: src/07_threads/02_static.md:39
msgid "\"Hello from the detached thread!\""
msgstr "\"Hello from the detached thread!\""

#: src/07_threads/02_static.md:46
msgid ""
"In this example, the first spawned thread will in turn spawn a child thread "
"that prints a message every second.  \n"
"The first thread will then finish and exit. When that happens, its child "
"thread will **continue running** for as long as the overall process is "
"running.  \n"
"In Rust's lingo, we say that the child thread has **outlived** its parent."
msgstr ""
"ì´ ì˜ˆì‹œì—ì„œ ì²« ë²ˆì§¸ ìƒì„±ëœ ìŠ¤ë ˆë“œëŠ” ë§¤ì´ˆ ë©”ì‹œì§€ë¥¼ í”„ë¦°íŠ¸í•˜ëŠ” í•˜ìœ„ ìŠ¤ë ˆë“œë¥¼ ìƒ"
"ì„±í•©ë‹ˆë‹¤.  \n"
"ê·¸ëŸ¬ë©´ ì²« ë²ˆì§¸ ìŠ¤ë ˆë“œê°€ ì™„ë£Œë˜ê³  ì¢…ë£Œë©ë‹ˆë‹¤. ê·¸ëŸ° ì¼ì´ ë°œìƒí•˜ë©´ í•´ë‹¹ í•˜ìœ„ ìŠ¤ë ˆ"
"ë“œëŠ” ì „ì²´ í”„ë¡œì„¸ìŠ¤ê°€ ì‹¤í–‰ë˜ëŠ” ë™ì•ˆ **ê³„ì† ì‹¤í–‰**ë©ë‹ˆë‹¤.  \n"
"Rustì˜ ìš©ì–´ì—ì„œëŠ” í•˜ìœ„ ìŠ¤ë ˆë“œê°€ ìƒìœ„ ìŠ¤ë ˆë“œë³´ë‹¤ **ì˜¤ë˜ ì‚´ì•˜ë‹¤(outlived)**ê³  ë§"
"í•©ë‹ˆë‹¤."

#: src/07_threads/02_static.md:56
msgid "Since a spawned thread can:"
msgstr "ìƒì„±ëœ ìŠ¤ë ˆë“œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ê²ƒì´ ê°€ëŠ¥í•˜ê¸°ë•Œë¬¸ì—:"

#: src/07_threads/02_static.md:58
msgid "outlive the thread that spawned it (its parent thread)"
msgstr "ìì‹ ì„ ìƒì„±í•œ ìŠ¤ë ˆë“œ(ìƒìœ„ ìŠ¤ë ˆë“œ)ë³´ë‹¤ ì˜¤ë˜ ì‚´ ìˆ˜ ìˆìŒ"

#: src/07_threads/02_static.md:59
msgid "run until the program exits"
msgstr "í”„ë¡œê·¸ë¨ì´ ì¢…ë£Œë  ë•Œê¹Œì§€ ì‹¤í–‰ë¨"

#: src/07_threads/02_static.md:61
msgid ""
"it must not borrow any values that might be dropped before the program exits; "
"violating this constraint would expose us to a use-after-free bug.  \n"
"That's why `std::thread::spawn`'s signature requires that the closure passed "
"to it has the `'static` lifetime:"
msgstr ""
"ê·¸ í•¨ìˆ˜ê°€ ì¢…ë£Œë˜ê¸° ì „ì— ì‚­ì œë  ìˆ˜ ìˆëŠ” ì–´ë–¤ ê°’ë„ ì°¨ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì´ ì œì•½"
"ì„ ìœ„ë°˜í•˜ë©´ ì‚¬ìš© í›„ ë©”ëª¨ë¦¬ í•´ì œ í›„ì—ë„ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë²„ê·¸ê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆ"
"ë‹¤.\n"
"ê·¸ê²ƒì´ `std::thread::spawn`ì˜ ì‹œê·¸ë‹ˆì²˜ê°€ ì „ë‹¬ëœ í´ë¡œì €ê°€ `'static` ìˆ˜ëª…ì„ ê°€ì ¸"
"ì•¼ í•œë‹¤ê³  ìš”êµ¬í•˜ëŠ” ì´ìœ ì…ë‹ˆë‹¤:"

#: src/07_threads/02_static.md:72
msgid "// [..]\n"
msgstr "// [..]\n"

#: src/07_threads/02_static.md:76
msgid "`'static` is not (just) about references"
msgstr "``static'ì€ (ê·¸ëƒ¥) ì°¸ì¡°ì— ê´€í•œ ê²ƒì´ ì•„ë‹™ë‹ˆë‹¤"

#: src/07_threads/02_static.md:78
msgid "All values in Rust have a lifetime, not just references."
msgstr "Rustì˜ ëª¨ë“  ê°’ì—ëŠ” ì°¸ì¡°ë¿ë§Œ ì•„ë‹ˆë¼ ìˆ˜ëª…ì´ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/02_static.md:80
msgid ""
"In particular, a type that owns its data (like a `Vec` or a `String`) "
"satisfies the `'static` constraint: if you own it, you can keep working with "
"it for as long as you want, even after the function that originally created "
"it has returned."
msgstr ""
"íŠ¹íˆ, ë°ì´í„°ë¥¼ ì†Œìœ í•œ íƒ€ì…(ì˜ˆ: `Vec` ë˜ëŠ” `String`)ì€ `'static` ì œì•½ ì¡°ê±´ì„ ì¶©"
"ì¡±í•©ë‹ˆë‹¤. ì´ë¥¼ ì†Œìœ í•˜ê³  ìˆìœ¼ë©´ ì›í•˜ëŠ” ë§Œí¼ ê³„ì† ì‘ì—…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì›ë˜ ìƒì„±"
"í•œ í•¨ìˆ˜ê°€ ë°˜í™˜ë˜ë”ë¼ë„ ë§ì…ë‹ˆë‹¤."

#: src/07_threads/02_static.md:85
msgid "You can thus interpret `'static` as a way to say:"
msgstr "ë”°ë¼ì„œ `'static`ì„ ë‹¤ìŒê³¼ ê°™ì´ í•´ì„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/07_threads/02_static.md:87
msgid "Give me an owned value"
msgstr "ë‚˜ì—ê²Œ ì†Œìœ ê¶Œì´ ìˆëŠ” ê°’ì„ ì£¼ì„¸ìš”"

#: src/07_threads/02_static.md:88
msgid "Give me a reference that's valid for the entire duration of the program"
msgstr "í”„ë¡œê·¸ë¨ ì „ì²´ ê¸°ê°„ ë™ì•ˆ ìœ íš¨í•œ ì°¸ì¡°ë¥¼ ì œê³µí•´ ì£¼ì„¸ìš”"

#: src/07_threads/02_static.md:90
msgid ""
"The first approach is how you solved the issue in the previous exercise: by "
"allocating new vectors to hold the left and right parts of the original "
"vector, which were then moved into the spawned threads."
msgstr ""
"ì²« ë²ˆì§¸ ì ‘ê·¼ ë°©ì‹ì€ ì´ì „ ì—°ìŠµì—ì„œ ë¬¸ì œë¥¼ í•´ê²°í•œ ë°©ë²•ì…ë‹ˆë‹¤. ì¦‰, ì›ë˜ ë²¡í„°ì˜ ì™¼"
"ìª½ê³¼ ì˜¤ë¥¸ìª½ ë¶€ë¶„ì„ ìœ ì§€í•˜ê¸° ìœ„í•´ ìƒˆ ë²¡í„°ë¥¼ í• ë‹¹í•œ ë‹¤ìŒ ìƒì„±ëœ ìŠ¤ë ˆë“œë¡œ ë³´ë‚´ "
"ì¤€ ê²ƒì…ë‹ˆë‹¤."

#: src/07_threads/02_static.md:94
msgid "`'static` references"
msgstr "`'static` ì°¸ì¡°"

#: src/07_threads/02_static.md:96
msgid ""
"Let's talk about the second case, references that are valid for the entire "
"duration of the program."
msgstr ""
"í”„ë¡œê·¸ë¨ ì „ì²´ ê¸°ê°„ ë™ì•ˆ ìœ íš¨í•œ ì°¸ì¡°ì¸ ë‘ ë²ˆì§¸ ì¼€ì´ìŠ¤ì— ëŒ€í•´ ì´ì•¼ê¸°í•´ ë³´ê² ìŠµë‹ˆ"
"ë‹¤."

#: src/07_threads/02_static.md:99
msgid "Static data"
msgstr "ì •ì  ë°ì´í„°"

#: src/07_threads/02_static.md:101
msgid ""
"The most common case is a reference to **static data**, such as string "
"literals:"
msgstr ""
"ê°€ì¥ ì¼ë°˜ì ì¸ ê²½ìš°ëŠ” ë¬¸ìì—´ ë¦¬í„°ëŸ´ê³¼ ê°™ì€ **ì •ì  ë°ì´í„°**ì— ëŒ€í•œ ì°¸ì¡°ì…ë‹ˆë‹¤:"

#: src/07_threads/02_static.md:104
msgid "\"Hello world!\""
msgstr "\"Hello world!\""

#: src/07_threads/02_static.md:107
msgid ""
"Since string literals are known at compile-time, Rust stores them _inside_ "
"your executable, in a region known as **read-only data segment**. All "
"references pointing to that region will therefore be valid for as long as the "
"program runs; they satisfy the `'static` contract."
msgstr ""
"ë¬¸ìì—´ ë¦¬í„°ëŸ´ì€ ì»´íŒŒì¼ ì‹œì ì—ì„œ ì•Œë ¤ì ¸ ìˆê¸° ë•Œë¬¸ì—, RustëŠ” ì´ë“¤ì„ ì‹¤í–‰íŒŒì¼ _ë‚´"
"ë¶€ì˜_ **ì½ê¸° ì „ìš© ë°ì´í„° ì„¸ê·¸ë¨¼íŠ¸**ì— ì €ì¥í•©ë‹ˆë‹¤. ë”°ë¼ì„œ ê·¸ ì˜ì—­ì„ ê°€ë¦¬í‚¤ëŠ” ëª¨"
"ë“  ì°¸ì¡°ëŠ” í”„ë¡œê·¸ë¨ì´ ì‹¤í–‰ë˜ëŠ” ë™ì•ˆ ìœ íš¨í•  ê²ƒì…ë‹ˆë‹¤. ì´ëŠ” `'static` ì¡°ê±´ì„ ë§Œì¡±"
"ì‹œí‚µë‹ˆë‹¤."

#: src/07_threads/02_static.md:114
msgid "[The data segment](https://en.wikipedia.org/wiki/Data_segment)"
msgstr "[The data segment](https://en.wikipedia.org/wiki/Data_segment)"

#: src/07_threads/02_static.md:118
msgid ""
"The exercise for this section is located in [`07_threads/02_static`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/02_static)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`07_threads/02_static`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/02_static)ì— ìˆìŠµë‹ˆë‹¤"

#: src/07_threads/03_leak.md:1
msgid "Leaking data"
msgstr "ë°ì´í„° ìœ ì¶œ"

#: src/07_threads/03_leak.md:3
msgid ""
"The main concern around passing references to spawned threads is use-after-"
"free bugs: accessing data using a pointer to a memory region that's already "
"been freed/de-allocated.  \n"
"If you're working with heap-allocated data, you can avoid the issue by "
"telling Rust that you'll never reclaim that memory: you choose to **leak "
"memory**, intentionally."
msgstr ""
"ìƒì„±ëœ ìŠ¤ë ˆë“œì— ëŒ€í•œ ì°¸ì¡° ì „ë‹¬ê³¼ ê´€ë ¨ëœ ì£¼ìš” ê´€ì‹¬ì‚¬ëŠ” use-after-free ë²„ê·¸ì…ë‹ˆ"
"ë‹¤. ì¦‰, ì´ë¯¸ í•´ì œ/í• ë‹¹ í•´ì œëœ ë©”ëª¨ë¦¬ ì˜ì—­ì— ëŒ€í•œ í¬ì¸í„°ë¥¼ ì‚¬ìš©í•˜ì—¬ ë°ì´í„°ì— ì•¡"
"ì„¸ìŠ¤í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.  \n"
"í™ í• ë‹¹ ë°ì´í„°ë¡œ ì‘ì—…í•˜ëŠ” ê²½ìš° Rustì— í•´ë‹¹ ë©”ëª¨ë¦¬ë¥¼ ì ˆëŒ€ íšŒìˆ˜í•˜ì§€ ì•Šì„ ê²ƒì´ë¼"
"ê³  ì•Œë ¤ì¤Œìœ¼ë¡œì¨ ë¬¸ì œë¥¼ í”¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ë„ì ìœ¼ë¡œ **ë©”ëª¨ë¦¬ ëˆ„ìˆ˜**ë¥¼ ë°œìƒì‹œí‚¤"
"ëŠ”ê²ë‹ˆë‹¤."

#: src/07_threads/03_leak.md:9
msgid ""
"This can be done, for example, using the `Box::leak` method from Rust's "
"standard library:"
msgstr ""
"ì˜ˆë¥¼ ë“¤ì–´ Rustì˜ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ìˆëŠ” `Box::leak` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ë©´ ì´ ì‘ì—…"
"ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/07_threads/03_leak.md:12
msgid "// Allocate a `u32` on the heap, by wrapping it in a `Box`.\n"
msgstr "// `u32`ë¥¼ `Box`ë¡œ ê°ì‹¸ì„œ í™ì— í• ë‹¹í•©ë‹ˆë‹¤.\n"

#: src/07_threads/03_leak.md:13
msgid ""
"// Tell Rust that you'll never free that heap allocation\n"
"// using `Box::leak`. You can thus get back a 'static reference.\n"
msgstr ""
"// `Box::leak`ì„ ì‚¬ìš©í•˜ì—¬ í•´ë‹¹ í™ í• ë‹¹ì„ í•´ì œí•˜ì§€ ì•Šì„ ê²ƒì´ë¼ê³ \n"
"// Rustì— ì•Œë¦½ë‹ˆë‹¤. ë”°ë¼ì„œ 'static ì°¸ì¡°ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"

#: src/07_threads/03_leak.md:19
msgid "Data leakage is process-scoped"
msgstr "ë°ì´í„° ìœ ì¶œì€ í”„ë¡œì„¸ìŠ¤ ìŠ¤ì½”í”„ì— ì†í•©ë‹ˆë‹¤."

#: src/07_threads/03_leak.md:21
msgid ""
"Leaking data is dangerous: if you keep leaking memory, you'll eventually run "
"out and crash with an out-of-memory error."
msgstr ""
"ë°ì´í„° ëˆ„ì¶œì€ ìœ„í—˜í•©ë‹ˆë‹¤. ë©”ëª¨ë¦¬ ëˆ„ì¶œì´ ê³„ì†ë˜ë©´ ê²°êµ­ ë©”ëª¨ë¦¬ ë¶€ì¡± ì˜¤ë¥˜ë¡œ ì¸í•´ "
"ë©”ëª¨ë¦¬ê°€ ë¶€ì¡±í•´ì§€ê³  í¬ë˜ì‹œê°€ ë°œìƒí•˜ê²Œë©ë‹ˆë‹¤."

#: src/07_threads/03_leak.md:25
msgid ""
"// If you leave this running for a while, \n"
"// it'll eventually use all the available memory.\n"
msgstr ""
"// í•œë™ì•ˆ ì‹¤í–‰ ìƒíƒœë¡œ ë†”ë‘ë©´\n"
"// ê²°êµ­ ì‚¬ìš© ê°€ëŠ¥í•œ ë©”ëª¨ë¦¬ë¥¼ ëª¨ë‘ ì‚¬ìš©í•˜ê²Œ ë©ë‹ˆë‹¤.\n"

#: src/07_threads/03_leak.md:35
msgid ""
"At the same time, memory leaked via `Box::leak` is not truly forgotten.  \n"
"The operating system can map each memory region to the process responsible "
"for it. When the process exits, the operating system will reclaim that memory."
msgstr ""
"ë™ì‹œì— `Box::leak`ì„ í†µí•´ ìœ ì¶œëœ ë©”ëª¨ë¦¬ëŠ” ì™„ì „íˆ ìŠí˜€ì§€ì§€ ì•ŠìŠµë‹ˆë‹¤.  \n"
"ìš´ì˜ ì²´ì œëŠ” ê° ë©”ëª¨ë¦¬ ì˜ì—­ì„ í•´ë‹¹ ì˜ì—­ì„ ë‹´ë‹¹í•˜ëŠ” í”„ë¡œì„¸ìŠ¤ì— ë§¤í•‘í•  ìˆ˜ ìˆìŠµë‹ˆ"
"ë‹¤. í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œë˜ë©´ ìš´ì˜ ì²´ì œëŠ” í•´ë‹¹ ë©”ëª¨ë¦¬ë¥¼ íšŒìˆ˜í•©ë‹ˆë‹¤."

#: src/07_threads/03_leak.md:39
msgid "Keeping this in mind, it can be OK to leak memory when:"
msgstr "ì´ ì ì„ ì—¼ë‘ì— ë‘ê³  ë‹¤ìŒê³¼ ê°™ì€ ê²½ìš° ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ê°€ í—ˆìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/07_threads/03_leak.md:41
msgid "The amount of memory you need to leak is not unbounded/known upfront, or"
msgstr "ëˆ„ìˆ˜í•´ì•¼ í•˜ëŠ” ë©”ëª¨ë¦¬ ì–‘ì´ ìœ í•œí•˜ê±°ë‚˜/ì–‘ì„ ì•Œê³ ìˆì„ ë•Œ, í˜¹ì€"

#: src/07_threads/03_leak.md:42
msgid ""
"Your process is short-lived and you're confident you won't exhaust all the "
"available memory before it exits"
msgstr ""
"í”„ë¡œì„¸ìŠ¤ì˜ ìˆ˜ëª…ì´ ì§§ê³  ì¢…ë£Œë˜ê¸° ì „ì— ì‚¬ìš© ê°€ëŠ¥í•œ ë©”ëª¨ë¦¬ê°€ ëª¨ë‘ ì†Œì§„ë˜ì§€ ì•Šì„ "
"ê²ƒì´ë¼ê³  í™•ì‹ í•  ë•Œ"

#: src/07_threads/03_leak.md:45
msgid ""
"\"Let the OS deal with it\" is a perfectly valid memory management strategy "
"if your usecase allows for it."
msgstr ""
"\"OSê°€ ì²˜ë¦¬í•˜ê²Œ í•˜ë¼\"ëŠ” ì‚¬ìš© ì‚¬ë¡€ê°€ í—ˆìš©í•˜ëŠ” ê²½ìš° ì™„ë²½í•˜ê²Œ ìœ íš¨í•œ ë©”ëª¨ë¦¬ ê´€"
"ë¦¬ ì „ëµì…ë‹ˆë‹¤."

#: src/07_threads/03_leak.md:50
msgid ""
"The exercise for this section is located in [`07_threads/03_leak`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/03_leak)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`07_threads/03_leak`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/03_leak)ì— ìˆìŠµë‹ˆë‹¤"

#: src/07_threads/04_scoped_threads.md:3
msgid ""
"All the lifetime issues we discussed so far have a common source: the spawned "
"thread can outlive its parent.  \n"
"We can sidestep this issue by using **scoped threads**."
msgstr ""
"ì§€ê¸ˆê¹Œì§€ ë…¼ì˜í•œ ëª¨ë“  ìˆ˜ëª… ë¬¸ì œì—ëŠ” ê³µí†µëœ ì›ì¸ì´ ìˆìŠµë‹ˆë‹¤. ì¦‰, ìƒì„±ëœ ìŠ¤ë ˆë“œ"
"ê°€ ìƒìœ„ ìŠ¤ë ˆë“œë³´ë‹¤ ì˜¤ë˜ ì§€ì†ë  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤.  \n"
"**ë²”ìœ„ ìŠ¤ë ˆë“œ**ë¥¼ ì‚¬ìš©í•˜ë©´ ì´ ë¬¸ì œë¥¼ í”¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/04_scoped_threads.md:14 src/07_threads/04_scoped_threads.md:47
msgid "\"Here's the first half of v: {first:?}\""
msgstr "\"Here's the first half of v: {first:?}\""

#: src/07_threads/04_scoped_threads.md:18 src/07_threads/04_scoped_threads.md:51
msgid "\"Here's the second half of v: {second:?}\""
msgstr "\"Here's the second half of v: {second:?}\""

#: src/07_threads/04_scoped_threads.md:22 src/07_threads/04_scoped_threads.md:57
msgid "\"Here's v: {v:?}\""
msgstr "\"Here's v: {v:?}\""

#: src/07_threads/04_scoped_threads.md:25
msgid "Let's unpack what's happening."
msgstr "ë¬´ìŠ¨ ì¼ì´ ì¼ì–´ë‚˜ê³  ìˆëŠ”ì§€ íŒŒí—¤ì³ë´…ì‹œë‹¤."

#: src/07_threads/04_scoped_threads.md:27
msgid "`scope`"
msgstr "`scope`"

#: src/07_threads/04_scoped_threads.md:29
msgid ""
"The `std::thread::scope` function creates a new **scope**.  \n"
"`std::thread::scope` takes as input a closure, with a single argument: a "
"`Scope` instance."
msgstr ""
"`std::thread::scope` í•¨ìˆ˜ëŠ” ìƒˆë¡œìš´ **ìŠ¤ì½”í”„**ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.  \n"
"`std::thread::scope`ëŠ” ë‹¨ì¼ ì¸ìˆ˜ì¸ `Scope` ì¸ìŠ¤í„´ìŠ¤ì™€ í•¨ê»˜ í´ë¡œì €ë¥¼ ì¸í’‹ìœ¼ë¡œ "
"ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/07_threads/04_scoped_threads.md:32
msgid "Scoped spawns"
msgstr "Scoped spawns"

#: src/07_threads/04_scoped_threads.md:34
msgid ""
"`Scope` exposes a `spawn` method.  \n"
"Unlike `std::thread::spawn`, all threads spawned using a `Scope` will be "
"**automatically joined** when the scope ends."
msgstr ""
"`Scope`ëŠ” `spawn` ë©”ì„œë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤.  \n"
"`std::thread::spawn`ê³¼ ë‹¬ë¦¬ `Scope`ë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒì„±ëœ ëª¨ë“  ìŠ¤ë ˆë“œëŠ” ë²”ìœ„ê°€ ë"
"ë‚˜ë©´ **ìë™ìœ¼ë¡œ ì¡°ì¸**ë©ë‹ˆë‹¤."

#: src/07_threads/04_scoped_threads.md:38
msgid ""
"If we were to \"translate\" the previous example to `std::thread::spawn`, "
"it'd look like this:"
msgstr ""
"ì´ì „ ì˜ˆì œë¥¼ `std::thread::spawn`ìœ¼ë¡œ \"ë²ˆì—­\"í•œë‹¤ë©´ ë‹¤ìŒê³¼ ê°™ì„ ê²ƒì…ë‹ˆë‹¤:"

#: src/07_threads/04_scoped_threads.md:60
msgid "Borrowing from the environment"
msgstr "í™˜ê²½ì—ì„œ ì°¨ìš©í•˜ê¸°"

#: src/07_threads/04_scoped_threads.md:62
msgid ""
"The translated example wouldn't compile, though: the compiler would complain "
"that `&v` can't be used from our spawned threads since its lifetime isn't "
"`'static`."
msgstr ""
"í•˜ì§€ë§Œ ë²ˆì—­ëœ ì˜ˆì œëŠ” ì»´íŒŒì¼ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” ìˆ˜ëª…ì´ `'static`ì´ ì•„ë‹ˆ"
"ê¸° ë•Œë¬¸ì— ìƒì„±ëœ ìŠ¤ë ˆë“œì—ì„œ `&v`ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤ê³  ë¶ˆí‰í•©ë‹ˆë‹¤."

#: src/07_threads/04_scoped_threads.md:66
msgid ""
"That's not an issue with `std::thread::scope`â€”you can **safely borrow from "
"the environment**."
msgstr ""
"ì´ëŠ” `std::thread::scope`ì—ì„œëŠ” ë¬¸ì œê°€ ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. **í™˜ê²½ì—ì„œ ì•ˆì „í•˜ê²Œ ë¹Œ"
"ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤**."

#: src/07_threads/04_scoped_threads.md:68
msgid ""
"In our example, `v` is created before the spawning points. It will only be "
"dropped _after_ `scope` returns. At the same time, all threads spawned inside "
"`scope` are guaranteed to finish _before_ `scope` returns, therefore there is "
"no risk of having dangling references."
msgstr ""
"ì´ ì˜ˆì—ì„œëŠ” `v`ê°€ ìƒì„± ì§€ì  ì•ì— ìƒì„±ë©ë‹ˆë‹¤. `scope`ê°€ ë°˜í™˜ëœ _ì´í›„_ì—ë§Œ ì‚­ì œ"
"ë©ë‹ˆë‹¤. ë™ì‹œì— `scope` ë‚´ë¶€ì— ìƒì„±ëœ ëª¨ë“  ìŠ¤ë ˆë“œëŠ” `scope`ê°€ ë°˜í™˜ë˜ê¸° _ì „ì—_ "
"ì™„ë£Œê°€ ë³´ì¥ë˜ë¯€ë¡œ ëŒ•ê¸€ë§ í¬ì¸í„°ê°€ ìƒê¸¸ ìœ„í—˜ì´ ì—†ìŠµë‹ˆë‹¤."

#: src/07_threads/04_scoped_threads.md:73
msgid "The compiler won't complain!"
msgstr "ì»´íŒŒì¼ëŸ¬ëŠ” ë¶ˆí‰í•˜ì§€ ì•Šì„ ê²ƒì…ë‹ˆë‹¤!"

#: src/07_threads/04_scoped_threads.md:77
msgid ""
"The exercise for this section is located in [`07_threads/04_scoped_threads`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/04_scoped_threads)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`07_threads/04_scoped_threads`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/04_scoped_threads)ì— ìˆìŠµë‹ˆë‹¤"

#: src/07_threads/05_channels.md:3
msgid ""
"All our spawned threads have been fairly short-lived so far.  \n"
"Get some input, run a computation, return the result, shut down."
msgstr ""
"ìš°ë¦¬ê°€ ìƒì„±í•œ ëª¨ë“  ìŠ¤ë ˆë“œëŠ” ì§€ê¸ˆê¹Œì§€ ìƒë‹¹íˆ ìˆ˜ëª…ì´ ì§§ì•˜ìŠµë‹ˆë‹¤.  \n"
"ì…ë ¥ì„ ë°›ê³ , ê³„ì‚°ì„ ì‹¤í–‰í•˜ê³ , ê²°ê³¼ë¥¼ ë°˜í™˜í•˜ê³ , ì¢…ë£Œí•©ë‹ˆë‹¤."

#: src/07_threads/05_channels.md:6
msgid ""
"For our ticket management system, we want to do something different: a client-"
"server architecture."
msgstr ""
"í‹°ì¼“ ê´€ë¦¬ ì‹œìŠ¤í…œì˜ ê²½ìš° í´ë¼ì´ì–¸íŠ¸-ì„œë²„ ì•„í‚¤í…ì²˜ë¼ëŠ” ë‹¤ë¥¸ ì‘ì—…ì„ ìˆ˜í–‰í•˜ë ¤ê³  í•©"
"ë‹ˆë‹¤."

#: src/07_threads/05_channels.md:9
msgid ""
"We will have **one long-running server thread**, responsible for managing our "
"state, the stored tickets."
msgstr ""
"ìš°ë¦¬ëŠ” ìƒíƒœ, ì €ì¥ëœ í‹°ì¼“ ê´€ë¦¬ë¥¼ ë‹´ë‹¹í•˜ëŠ” **í•˜ë‚˜ì˜ ì¥ê¸° ì‹¤í–‰ ì„œë²„ ìŠ¤ë ˆë“œ**ë¥¼ ê°–"
"ê²Œ ë©ë‹ˆë‹¤."

#: src/07_threads/05_channels.md:12
msgid ""
"We will then have **multiple client threads**.  \n"
"Each client will be able to send **commands** and **queries** to the stateful "
"thread, in order to change its state (e.g. add a new ticket) or retrieve "
"information (e.g. get the status of a ticket).  \n"
"Client threads will run concurrently."
msgstr ""
"ê·¸ëŸ¬ë©´ **ì—¬ëŸ¬ í´ë¼ì´ì–¸íŠ¸ ìŠ¤ë ˆë“œ**ê°€ ìƒì„±ë©ë‹ˆë‹¤.  \n"
"ê° í´ë¼ì´ì–¸íŠ¸ëŠ” ìƒíƒœë¥¼ ë³€ê²½(ì˜ˆ: ìƒˆ í‹°ì¼“ ì¶”ê°€)í•˜ê±°ë‚˜ ì •ë³´ë¥¼ ê²€ìƒ‰(ì˜ˆ: í‹°ì¼“ ìƒíƒœ "
"ê°€ì ¸ì˜¤ê¸°)í•˜ê¸° ìœ„í•´ ìƒíƒœ ì €ì¥ ìŠ¤ë ˆë“œì— **ëª…ë ¹** ë° **ì¿¼ë¦¬**ë¥¼ ë³´ë‚¼ ìˆ˜ ìˆìŠµë‹ˆ"
"ë‹¤.  \n"
"í´ë¼ì´ì–¸íŠ¸ ìŠ¤ë ˆë“œë“¤ì€ ë™ì‹œì— ì‹¤í–‰ë ê²ë‹ˆë‹¤."

#: src/07_threads/05_channels.md:18
msgid "Communication"
msgstr "ì»¤ë®¤ë‹ˆì¼€ì´ì…˜"

#: src/07_threads/05_channels.md:20
msgid "So far we've only had very limited parent-child communication:"
msgstr "ì§€ê¸ˆê¹Œì§€ ìš°ë¦¬ëŠ” ë¶€ëª¨-ìì‹ ì»¤ë®¤ë‹ˆì¼€ì´ì…˜ì´ ë§¤ìš° ì œí•œì ì´ì—ˆìŠµë‹ˆë‹¤:"

#: src/07_threads/05_channels.md:22
msgid "The spawned thread borrowed/consumed data from the parent context"
msgstr "ìƒì„±ëœ ìŠ¤ë ˆë“œëŠ” ìƒìœ„ ì»¨í…ìŠ¤íŠ¸ì—ì„œ ë°ì´í„°ë¥¼ ì°¨ìš©/ì†Œë¹„í–ˆìŠµë‹ˆë‹¤"

#: src/07_threads/05_channels.md:23
msgid "The spawned thread returned data to the parent when joined"
msgstr "ìƒì„±ëœ ìŠ¤ë ˆë“œëŠ” ì¡°ì¸ ì‹œ ìƒìœ„ ìŠ¤ë ˆë“œì— ë°ì´í„°ë¥¼ ë°˜í™˜í–ˆìŠµë‹ˆë‹¤"

#: src/07_threads/05_channels.md:25
msgid ""
"This isn't enough for a client-server design.  \n"
"Clients need to be able to send and receive data from the server thread "
"_after_ it has been launched."
msgstr ""
"í´ë¼ì´ì–¸íŠ¸-ì„œë²„ ì„¤ê³„ì—ëŠ” ì´ê²ƒë§Œìœ¼ë¡œëŠ” ì¶©ë¶„í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.  \n"
"í´ë¼ì´ì–¸íŠ¸ëŠ” ì„œë²„ ìŠ¤ë ˆë“œê°€ ì‹œì‘ëœ _í›„_ ì„œë²„ ìŠ¤ë ˆë“œì— ë°ì´í„°ë¥¼ ë³´ë‚´ê³  ë°›ì„ ìˆ˜ "
"ìˆì–´ì•¼ í•©ë‹ˆë‹¤."

#: src/07_threads/05_channels.md:29
msgid "We can solve the issue using **channels**."
msgstr "**ì±„ë„**ì„ ì‚¬ìš©í•˜ì—¬ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/05_channels.md:33
msgid ""
"Rust's standard library provides **multi-producer, single-consumer** (mpsc) "
"channels in its `std::sync::mpsc` module.  \n"
"There are two channel flavours: bounded and unbounded. We'll stick to the "
"unbounded version for now, but we'll discuss the pros and cons later on."
msgstr ""
"Rustì˜ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” `std::sync::mpsc` ëª¨ë“ˆì—ì„œ **ë‹¤ì¤‘ ìƒì‚°ì, ë‹¨ì¼ ì†Œë¹„ì"
"**(mpsc) ì±„ë„ì„ ì œê³µí•©ë‹ˆë‹¤.  \n"
"ì±„ë„ì—ëŠ” ì œí•œëœ ì±„ë„ê³¼ ë¬´ì œí•œ ì±„ë„ì˜ ë‘ ê°€ì§€ íƒ€ì…ì´ ìˆìŠµë‹ˆë‹¤. ì§€ê¸ˆì€ ë¬´ì œí•œ ë²„"
"ì „ì„ ê³ ìˆ˜í•˜ê² ì§€ë§Œ ì¥ë‹¨ì ì— ëŒ€í•´ì„œëŠ” ë‚˜ì¤‘ì— ë…¼ì˜í•˜ê² ìŠµë‹ˆë‹¤."

#: src/07_threads/05_channels.md:38
msgid "Channel creation looks like this:"
msgstr "ì±„ë„ ìƒì„±ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/07_threads/05_channels.md:46
msgid ""
"You get a sender and a receiver.  \n"
"You call `send` on the sender to push data into the channel.  \n"
"You call `recv` on the receiver to pull data from the channel."
msgstr ""
"ë°œì‹ ìì™€ ìˆ˜ì‹ ìë¥¼ ì–»ìŠµë‹ˆë‹¤.  \n"
"ë°ì´í„°ë¥¼ ì±„ë„ì— í‘¸ì‹œí•˜ë ¤ë©´ ë°œì‹ ìì—ì„œ `send`ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.  \n"
"ì±„ë„ì—ì„œ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ë ¤ë©´ ìˆ˜ì‹ ê¸°ì—ì„œ `recv`ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤."

#: src/07_threads/05_channels.md:50
msgid "Multiple senders"
msgstr "ì—¬ëŸ¬ ë°œì‹ ì"

#: src/07_threads/05_channels.md:52
msgid ""
"`Sender` is clonable: we can create multiple senders (e.g. one for each "
"client thread) and they will all push data into the same channel."
msgstr ""
"`Sender`ëŠ” ë³µì œ ê°€ëŠ¥í•©ë‹ˆë‹¤. ì—¬ëŸ¬ ê°œì˜ ë°œì‹ ìë¥¼ ìƒì„±í•  ìˆ˜ ìˆìœ¼ë©°(ì˜ˆ: ê° í´ë¼ì´"
"ì–¸íŠ¸ ìŠ¤ë ˆë“œì— ëŒ€í•´ í•˜ë‚˜ì”©) ëª¨ë‘ ë™ì¼í•œ ì±„ë„ì— ë°ì´í„°ë¥¼ í‘¸ì‹œí•©ë‹ˆë‹¤."

#: src/07_threads/05_channels.md:55
msgid ""
"`Receiver`, instead, is not clonable: there can only be a single receiver for "
"a given channel."
msgstr ""
"ëŒ€ì‹  `ìˆ˜ì‹ ê¸°`ëŠ” ë³µì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. íŠ¹ì • ì±„ë„ì— ëŒ€í•´ ë‹¨ì¼ ìˆ˜ì‹ ê¸°ë§Œ ìˆì„ ìˆ˜ ìˆ"
"ìŠµë‹ˆë‹¤."

#: src/07_threads/05_channels.md:58
msgid "That's what **mpsc** (multi-producer single-consumer) stands for!"
msgstr "ì´ê²ƒì´ **mpsc**(ë‹¤ì¤‘ ìƒì‚°ì ë‹¨ì¼ ì†Œë¹„ì)ê°€ ì˜ë¯¸í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤!"

#: src/07_threads/05_channels.md:60
msgid "Message type"
msgstr "ë©”ì‹œì§€ íƒ€ì…"

#: src/07_threads/05_channels.md:62
msgid ""
"Both `Sender` and `Receiver` are generic over a type parameter `T`.  \n"
"That's the type of the _messages_ that can travel on our channel."
msgstr ""
"`Sender`ì™€ `Receiver`ëŠ” ëª¨ë‘ íƒ€ì… ë§¤ê°œë³€ìˆ˜ `T`ë¡œ ì¼ë°˜í™”ë©ë‹ˆë‹¤.  \n"
"ì´ê²ƒì´ ë°”ë¡œ ìš°ë¦¬ ì±„ë„ì„ í†µí•´ ì „ë‹¬ë  ìˆ˜ ìˆëŠ” _ë©”ì‹œì§€_ íƒ€ì…ì…ë‹ˆë‹¤."

#: src/07_threads/05_channels.md:65
msgid "It could be a `u64`, a struct, an enum, etc."
msgstr "`u64`, êµ¬ì¡°ì²´, ì—´ê±°í˜• ë“±ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/05_channels.md:67
msgid "Errors"
msgstr "ì—ëŸ¬"

#: src/07_threads/05_channels.md:69
msgid ""
"Both `send` and `recv` can fail.  \n"
"`send` returns an error if the receiver has been dropped.  \n"
"`recv` returns an error if all senders have been dropped and the channel is "
"empty."
msgstr ""
"`send`ì™€ `recv` ëª¨ë‘ ì‹¤íŒ¨í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"`send`ëŠ” ìˆ˜ì‹ ìê°€ ì‚­ì œëœ ê²½ìš° ì˜¤ë¥˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.  \n"
"ëª¨ë“  ë°œì‹ ìê°€ ì‚­ì œë˜ê³  ì±„ë„ì´ ë¹„ì–´ ìˆìœ¼ë©´ `recv`ëŠ” ì˜¤ë¥˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."

#: src/07_threads/05_channels.md:73
msgid ""
"In other words, `send` and `recv` error when the channel is effectively "
"closed."
msgstr "ì¦‰, ì‚¬ì‹¤ìƒ ì±„ë„ì´ ë‹«í ë•Œ `send`ì™€ `recv`ëŠ” ì˜¤ë¥˜ë¥¼ ë°œìƒì‹œí‚µë‹ˆë‹¤."

#: src/07_threads/05_channels.md:77
msgid ""
"The exercise for this section is located in [`07_threads/05_channels`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/05_channels)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`07_threads/05_channels`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/05_channels)ì— ìˆìŠµë‹ˆë‹¤"

#: src/07_threads/06_interior_mutability.md:3
msgid "Let's take a moment to reason about the signature of `Sender`'s `send`:"
msgstr "`Sender`ì˜ `send` ì‹œê·¸ë‹ˆì²˜ì— ëŒ€í•´ ì ì‹œ ìƒê°í•´ ë´…ì‹œë‹¤:"

#: src/07_threads/06_interior_mutability.md:13
msgid ""
"`send` takes `&self` as its argument.  \n"
"But it's clearly causing a mutation: it's adding a new message to the "
"channel. What's even more interesting is that `Sender` is cloneable: we can "
"have multiple instances of `Sender` trying to modify the channel state **at "
"the same time**, from different threads."
msgstr ""
"`send`ëŠ” `&self`ë¥¼ ì¸ìˆ˜ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.  \n"
"ê·¸ëŸ¬ë‚˜ ì´ëŠ” ë¶„ëª…íˆ ë³€í˜•ì„ ì¼ìœ¼í‚¤ê³  ìˆìŠµë‹ˆë‹¤. ì¦‰, ì±„ë„ì— ìƒˆ ë©”ì‹œì§€ë¥¼ ì¶”ê°€í•˜ëŠ” "
"ê²ƒì…ë‹ˆë‹¤. ë”ìš± í¥ë¯¸ë¡œìš´ ì ì€ `Sender`ê°€ ë³µì œ ê°€ëŠ¥í•˜ë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. ì„œë¡œ ë‹¤ë¥¸ ìŠ¤"
"ë ˆë“œì—ì„œ **ë™ì‹œì—** ì±„ë„ ìƒíƒœë¥¼ ìˆ˜ì •í•˜ë ¤ê³  ì‹œë„í•˜ëŠ” `Sender`ì˜ ì—¬ëŸ¬ ì¸ìŠ¤í„´ìŠ¤"
"ê°€ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/06_interior_mutability.md:18
msgid ""
"That's the key property we are using to build this client-server "
"architecture. But why does it work? Doesn't it violate Rust's rules about "
"borrowing? How are we performing mutations via an _immutable_ reference?"
msgstr ""
"ì´ê²ƒì´ ë°”ë¡œ ìš°ë¦¬ê°€ í´ë¼ì´ì–¸íŠ¸-ì„œë²„ ì•„í‚¤í…ì²˜ë¥¼ êµ¬ì¶•í•˜ëŠ” ë° ì‚¬ìš©í•˜ëŠ” í•µì‹¬ ì†ì„±ì…"
"ë‹ˆë‹¤. ê·¸ëŸ°ë° ì™œ ì´ê²Œ ê°€ëŠ¥í• ê¹Œìš”? ì°¨ìš©ì— ê´€í•œ Rustì˜ ê·œì¹™ì„ ìœ„ë°˜í•˜ì§€ ì•Šë‚˜ìš”? _"
"ë¶ˆë³€_ ì°¸ì¡°ë¥¼ í†µí•´ ë³€í˜•ì„ ì¼ìœ¼í‚¬ ìˆ˜ ìˆì„ê¹Œìš”?"

#: src/07_threads/06_interior_mutability.md:21
msgid "Shared rather than immutable references"
msgstr "ë¶ˆë³€ ì°¸ì¡°ê°€ ì•„ë‹Œ ê³µìœ  ì°¸ì¡°"

#: src/07_threads/06_interior_mutability.md:23
msgid ""
"When we introduced the borrow-checker, we named the two types of references "
"we can have in Rust:"
msgstr ""
"ì°¨ìš© ê²€ì‚¬ê¸°ë¥¼ ë„ì…í–ˆì„ ë•Œ ìš°ë¦¬ëŠ” Rustì—ì„œ ê°€ì§ˆ ìˆ˜ ìˆëŠ” ì°¸ì¡° íƒ€ì…ì„ ë‘ ê°€ì§€ë¡œ "
"ëª…ëª…í–ˆìŠµë‹ˆë‹¤:"

#: src/07_threads/06_interior_mutability.md:25
msgid "immutable references (`&T`)"
msgstr "ë¶ˆë³€ ì°¸ì¡° (`&T`)"

#: src/07_threads/06_interior_mutability.md:26
msgid "mutable references (`&mut T`)"
msgstr "ë³€ê²½ ê°€ëŠ¥í•œ ì°¸ì¡° (`&mut T`)"

#: src/07_threads/06_interior_mutability.md:28
msgid "It would have been more accurate to name them:"
msgstr "ì´ëŸ° ì´ë¦„ì„ ì§€ì–´ì£¼ëŠ” ê²ƒì´ ë” ì •í™•í• ê²ë‹ˆë‹¤:"

#: src/07_threads/06_interior_mutability.md:30
msgid "shared references (`&T`)"
msgstr "ê³µìœ  ì°¸ì¡° (`&T`)"

#: src/07_threads/06_interior_mutability.md:31
msgid "exclusive references (`&mut T`)"
msgstr "ë…ì  ì°¸ì¡° (`&mut T`)"

#: src/07_threads/06_interior_mutability.md:33
msgid ""
"Immutable/mutable is a mental model that works for the vast majority of "
"cases, and it's a great one to get started with Rust. But it's not the whole "
"story, as you've just seen: `&T` doesn't actually guarantee that the data it "
"points to is immutable.  \n"
"Don't worry, though: Rust is still keeping its promises. It's just that the "
"terms are a bit more nuanced than they might seem at first."
msgstr ""
"ë¶ˆë³€/ë³€ê²½ ê°€ëŠ¥ì€ ëŒ€ë¶€ë¶„ì˜ ê²½ìš°ì— ì‘ë™í•˜ëŠ” ì •ì‹  ëª¨ë¸ì´ë©° Rustë¥¼ ì‹œì‘í•˜ê¸°ì— ì¢‹"
"ì€ ëª¨ë¸ì…ë‹ˆë‹¤. í•˜ì§€ë§Œ ë°©ê¸ˆ ë³¸ ê²ƒì²˜ëŸ¼ ì´ê²ƒì´ ì „ë¶€ëŠ” ì•„ë‹™ë‹ˆë‹¤. `&T`ëŠ” ì‹¤ì œë¡œ ê°€"
"ë¦¬í‚¤ëŠ” ë°ì´í„°ê°€ ë¶ˆë³€ì„ì„ ë³´ì¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.  \n"
"í•˜ì§€ë§Œ ê±±ì •í•˜ì§€ ë§ˆì‹­ì‹œì˜¤. RustëŠ” ì—¬ì „íˆ ì•½ì†ì„ ì§€í‚¤ê³  ìˆìŠµë‹ˆë‹¤. ë‹¨ì§€ ìš©ì–´ê°€ ì²˜"
"ìŒì— ë³´ì´ëŠ” ê²ƒë³´ë‹¤ ì¡°ê¸ˆ ë” ë¯¸ë¬˜í•˜ë‹¤ëŠ” ê²ƒë¿ì…ë‹ˆë‹¤."

#: src/07_threads/06_interior_mutability.md:39
msgid "`UnsafeCell`"
msgstr "`UnsafeCell`"

#: src/07_threads/06_interior_mutability.md:41
msgid ""
"Whenever a type allows you to mutate data through a shared reference, you're "
"dealing with **interior mutability**."
msgstr ""
"íƒ€ì…ì´ ê³µìœ  ì°¸ì¡°ë¥¼ í†µí•´ ë°ì´í„°ë¥¼ ë³€ê²½í•  ìˆ˜ ìˆë„ë¡ í—ˆìš©í•  ë•Œë§ˆë‹¤ **ë‚´ë¶€ ë³€ê²½ ê°€"
"ëŠ¥ì„±**ì„ ë‹¤ë£¨ê³  ìˆëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/07_threads/06_interior_mutability.md:43
msgid ""
"By default, the Rust compiler assumes that shared references are immutable. "
"It **optimises your code** based on that assumption.  \n"
"The compiler can reorder operations, cache values, and do all sorts of magic "
"to make your code faster."
msgstr ""
"ê¸°ë³¸ì ìœ¼ë¡œ Rust ì»´íŒŒì¼ëŸ¬ëŠ” ê³µìœ  ì°¸ì¡°ê°€ ë¶ˆë³€ì´ë¼ê³  ê°€ì •í•©ë‹ˆë‹¤. í•´ë‹¹ ê°€ì •ì„ ê¸°ë°˜"
"ìœ¼ë¡œ **ì½”ë“œë¥¼ ìµœì í™”**í•©ë‹ˆë‹¤.  \n"
"ì»´íŒŒì¼ëŸ¬ëŠ” ì‘ì—… ìˆœì„œë¥¼ ë³€ê²½í•˜ê³  ê°’ì„ ìºì‹œí•˜ë©° ëª¨ë“  ì¢…ë¥˜ì˜ ë§ˆë²•ì„ ìˆ˜í–‰í•˜ì—¬ ì½”ë“œ"
"ë¥¼ ë” ë¹ ë¥´ê²Œ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/06_interior_mutability.md:46
msgid ""
"You can tell the compiler \"No, this shared reference is actually mutable\" "
"by wrapping the data in an `UnsafeCell`.  \n"
"Every time you see a type that allows interior mutability, you can be certain "
"that `UnsafeCell` is involved, either directly or indirectly.  \n"
"Using `UnsafeCell`, raw pointers and `unsafe` code, you can mutate data "
"through shared references."
msgstr ""
"ë°ì´í„°ë¥¼ `UnsafeCell`ë¡œ ë˜í•‘í•˜ì—¬ \"ì•„ë‹ˆìš”, ì´ ê³µìœ  ì°¸ì¡°ëŠ” ì‹¤ì œë¡œ ë³€ê²½ ê°€ëŠ¥í•©ë‹ˆ"
"ë‹¤\"ë¼ê³  ì»´íŒŒì¼ëŸ¬ì— ì•Œë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"ë‚´ë¶€ ê°€ë³€ì„±ì„ í—ˆìš©í•˜ëŠ” ìœ í˜•ì„ ë³¼ ë•Œë§ˆë‹¤ `UnsafeCell`ì´ ì§ì ‘ì ìœ¼ë¡œë“  ê°„ì ‘ì ìœ¼ë¡œ"
"ë“  ê´€ë ¨ë˜ì–´ ìˆìŒì„ í™•ì‹ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"`UnsafeCell`, ì›ì‹œ í¬ì¸í„° ë° `unsafe` ì½”ë“œë¥¼ ì‚¬ìš©í•˜ë©´ ê³µìœ  ì°¸ì¡°ë¥¼ í†µí•´ ë°ì´í„°"
"ë¥¼ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/06_interior_mutability.md:51
msgid ""
"Let's be clear, though: `UnsafeCell` isn't a magic wand that allows you to "
"ignore the borrow-checker!  \n"
"`unsafe` code is still subject to Rust's rules about borrowing and aliasing. "
"It's an (advanced) tool that you can leverage to build **safe abstractions** "
"whose safety can't be directly expressed in Rust's type system. Whenever you "
"use the `unsafe` keyword you're telling the compiler: \"I know what I'm "
"doing, I won't violate your invariants, trust me.\""
msgstr ""
"í•˜ì§€ë§Œ ë¶„ëª…íˆ í•´ë‘ìë©´ `UnsafeCell`ì€ ì°¨ìš© ê²€ì‚¬ê¸°ë¥¼ ë¬´ì‹œí•  ìˆ˜ ìˆê²Œ í•´ì£¼ëŠ” ë§ˆ"
"ìˆ  ì§€íŒ¡ì´ê°€ ì•„ë‹™ë‹ˆë‹¤!  \n"
"`unsafe` ì½”ë“œì—ëŠ” ì—¬ì „íˆ ì°¨ìš© ë° ë³„ì¹­ì— ëŒ€í•œ Rustì˜ ê·œì¹™ì´ ì ìš©ë©ë‹ˆë‹¤. ì´ëŠ” "
"Rustì˜ íƒ€ì… ì‹œìŠ¤í…œì—ì„œ ì•ˆì „ì„±ì„ ì§ì ‘ í‘œí˜„í•  ìˆ˜ ì—†ëŠ” **ì•ˆì „í•œ ì¶”ìƒí™”**ë¥¼ êµ¬ì¶•í•˜"
"ëŠ” ë° í™œìš©í•  ìˆ˜ ìˆëŠ” (ê³ ê¸‰) ë„êµ¬ì…ë‹ˆë‹¤. `unsafe` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•  ë•Œë§ˆë‹¤ ì»´íŒŒì¼"
"ëŸ¬ì—ê²Œ ë‹¤ìŒê³¼ ê°™ì´ ë§í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. \"ë‚˜ëŠ” ë‚´ê°€ ë¬´ì—‡ì„ í•˜ëŠ”ì§€ ì•Œê³  ìˆìŠµë‹ˆë‹¤. "
"ë‚˜ëŠ” ë‹¹ì‹ ì˜ ë¶ˆë³€ì„±ì„ ìœ„ë°˜í•˜ì§€ ì•Šì„ ê²ƒì…ë‹ˆë‹¤. ë‚˜ë¥¼ ë¯¿ìœ¼ì‹­ì‹œì˜¤.\""

#: src/07_threads/06_interior_mutability.md:57
msgid ""
"Every time you call an `unsafe` function, there will be documentation "
"explaining its **safety preconditions**: under what circumstances it's safe "
"to execute its `unsafe` block. You can find the ones for `UnsafeCell` [in "
"`std`'s documentation](https://doc.rust-lang.org/std/cell/struct.UnsafeCell."
"html)."
msgstr ""
"`unsafe` í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ë•Œë§ˆë‹¤ **ì•ˆì „ ì „ì œ ì¡°ê±´**ì„ ì„¤ëª…í•˜ëŠ” ë¬¸ì„œê°€ ìˆì„ê²ë‹ˆ"
"ë‹¤. ì–´ë–¤ ìƒí™©ì—ì„œ `unsafe` ë¸”ë¡ì„ ì‹¤í–‰í•˜ëŠ” ê²ƒì´ ì•ˆì „í•œì§€ ì„¤ëª…í•©ë‹ˆë‹¤. [`std` ë¬¸"
"ì„œì—ì„œ](https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html) "
"`UnsafeCell`ì— ëŒ€í•œ ë‚´ìš©ì„ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/06_interior_mutability.md:61
msgid ""
"We won't be using `UnsafeCell` directly in this course, nor will we be "
"writing `unsafe` code. But it's important to know that it's there, why it "
"exists and how it relates to the types you use every day in Rust."
msgstr ""
"ì´ ê³¼ì •ì—ì„œëŠ” `UnsafeCell`ì„ ì§ì ‘ ì‚¬ìš©í•˜ì§€ ì•Šì„ ê²ƒì´ë©° `unsafe` ì½”ë“œë¥¼ ì‘ì„±í•˜"
"ì§€ë„ ì•Šì„ ê²ƒì…ë‹ˆë‹¤. í•˜ì§€ë§Œ ê·¸ê²ƒì´ ì¡´ì¬í•˜ëŠ”ì§€, ê·¸ê²ƒì´ ì™œ ì¡´ì¬í•˜ëŠ”ì§€, ê·¸ë¦¬ê³  ê·¸"
"ê²ƒì´ Rustì—ì„œ ë§¤ì¼ ì‚¬ìš©í•˜ëŠ” íƒ€ì…ê³¼ ì–´ë–»ê²Œ ê´€ë ¨ë˜ëŠ”ì§€ë¥¼ ì•„ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤."

#: src/07_threads/06_interior_mutability.md:65
msgid "Key examples"
msgstr "ì£¼ìš” ì‚¬ë¡€"

#: src/07_threads/06_interior_mutability.md:67
msgid ""
"Let's go through a couple of important `std` types that leverage interior "
"mutability.  \n"
"These are types that you'll encounter somewhat often in Rust code, especially "
"if you peek under the hood of some the libraries you use."
msgstr ""
"ë‚´ë¶€ ê°€ë³€ì„±ì„ í™œìš©í•˜ëŠ” ëª‡ ê°€ì§€ ì¤‘ìš”í•œ `std` íƒ€ì…ì„ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.  \n"
"ì´ëŠ” Rust ì½”ë“œì—ì„œ ë‹¤ì†Œ ìì£¼ ì ‘í•˜ê²Œ ë  ìœ í˜•ì…ë‹ˆë‹¤. íŠ¹íˆ ì‚¬ìš©í•˜ëŠ” ì¼ë¶€ ë¼ì´ë¸ŒëŸ¬"
"ë¦¬ì˜ ë‚´ë¶€ë¥¼ ë“¤ì—¬ë‹¤ë³´ë©´ ë”ìš± ê·¸ë ‡ìŠµë‹ˆë‹¤."

#: src/07_threads/06_interior_mutability.md:71
msgid "Reference counting"
msgstr "ì°¸ì¡° ì¹´ìš´íŒ…"

#: src/07_threads/06_interior_mutability.md:73
msgid ""
"`Rc` is a reference-counted pointer.  \n"
"It wraps around a value and keeps track of how many references to the value "
"exist. When the last reference is dropped, the value is deallocated.  \n"
"The value wrapped in an `Rc` is immutable: you can only get shared references "
"to it."
msgstr ""
"`Rc`ëŠ” ì°¸ì¡° ì¹´ìš´íŠ¸ í¬ì¸í„°ì…ë‹ˆë‹¤.  \n"
"ì´ëŠ” ê°’ì„ ë‘˜ëŸ¬ì‹¸ë©° í•´ë‹¹ ê°’ì— ëŒ€í•œ ì°¸ì¡° ìˆ˜ë¥¼ ì¶”ì í•©ë‹ˆë‹¤. ë§ˆì§€ë§‰ ì°¸ì¡°ê°€ ì‚­ì œë˜"
"ë©´ ê°’ì˜ í• ë‹¹ì´ ì·¨ì†Œë©ë‹ˆë‹¤.  \n"
"`Rc`ì— í¬í•¨ëœ ê°’ì€ ë³€ê²½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ê°’ì— ëŒ€í•œ ê³µìœ  ì°¸ì¡°ë§Œ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/06_interior_mutability.md:81
msgid "\"My string\""
msgstr "\"My string\""

#: src/07_threads/06_interior_mutability.md:81
msgid "// Only one reference to the string data exists.\n"
msgstr "// ë¬¸ìì—´ ë°ì´í„°ì— ëŒ€í•œ ì°¸ì¡°ëŠ” í•˜ë‚˜ë§Œ ì¡´ì¬í•©ë‹ˆë‹¤.\n"

#: src/07_threads/06_interior_mutability.md:84
msgid ""
"// When we call `clone`, the string data is not copied!\n"
"// Instead, the reference count for `Rc` is incremented.\n"
msgstr ""
"// `clone`ì„ í˜¸ì¶œí•˜ë©´ ë¬¸ìì—´ ë°ì´í„°ê°€ ë³µì‚¬ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤!\n"
"// ëŒ€ì‹  `Rc`ì— ëŒ€í•œ ì°¸ì¡° íšŸìˆ˜ê°€ ì¦ê°€í•©ë‹ˆë‹¤.\n"

#: src/07_threads/06_interior_mutability.md:89
msgid ""
"// ^ Both `a` and `b` point to the same string data\n"
"//   and share the same reference counter.\n"
msgstr ""
"// ^ `a`ì™€ `b`ëŠ” ëª¨ë‘ ë™ì¼í•œ ë¬¸ìì—´ ë°ì´í„°ë¥¼ ê°€ë¦¬í‚¤ë©°\n"
"//   ë™ì¼í•œ ì°¸ì¡° ì¹´ìš´í„°ë¥¼ ê³µìœ í•©ë‹ˆë‹¤.\n"

#: src/07_threads/06_interior_mutability.md:94
msgid ""
"`Rc` uses `UnsafeCell` internally to allow shared references to increment and "
"decrement the reference count."
msgstr ""
"`Rc`ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ `UnsafeCell`ì„ ì‚¬ìš©í•˜ì—¬ ê³µìœ  ì°¸ì¡°ê°€ ì°¸ì¡° ì¹´ìš´íŠ¸ë¥¼ ëŠ˜ë¦¬ê±°ë‚˜ "
"ì¤„ì¼ ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤."

#: src/07_threads/06_interior_mutability.md:96
msgid "`RefCell`"
msgstr "`RefCell`"

#: src/07_threads/06_interior_mutability.md:98
msgid ""
"`RefCell` is one of the most common examples of interior mutability in Rust. "
"It allows you to mutate the value wrapped in a `RefCell` even if you only "
"have an immutable reference to the `RefCell` itself."
msgstr ""
"RefCellì€ Rustì˜ ë‚´ë¶€ ê°€ë³€ì„±ì˜ ê°€ì¥ ì¼ë°˜ì ì¸ ì˜ˆ ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤. `RefCell` ìì²´"
"ì— ëŒ€í•œ ë¶ˆë³€ ì°¸ì¡°ë§Œ ìˆëŠ” ê²½ìš°ì—ë„ `RefCell`ì— ë˜í•‘ëœ ê°’ì„ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/06_interior_mutability.md:102
msgid ""
"This is done via **runtime borrow checking**. The `RefCell` keeps track of "
"the number (and type) of references to the value it contains at runtime. If "
"you try to borrow the value mutably while it's already borrowed immutably, "
"the program will panic, ensuring that Rust's borrowing rules are always "
"enforced."
msgstr ""
"ì´ëŠ” **ëŸ°íƒ€ì„ ì°¨ìš© ê²€ì‚¬**ë¥¼ í†µí•´ ìˆ˜í–‰ë©ë‹ˆë‹¤. `RefCell`ì€ ëŸ°íƒ€ì„ì— í¬í•¨ëœ ê°’ì— "
"ëŒ€í•œ ì°¸ì¡° ìˆ˜(ë° íƒ€ì…)ë¥¼ ì¶”ì í•©ë‹ˆë‹¤. ì´ë¯¸ ë¶ˆë³€ì ìœ¼ë¡œ ë¹Œë¦° ê°’ì„ ë³€ê²½ ê°€ëŠ¥í•˜ê²Œ ë¹Œ"
"ë¦¬ë ¤ê³  í•˜ë©´ í”„ë¡œê·¸ë¨ì€ íŒ¨ë‹‰ ìƒíƒœê°€ ë˜ì–´ Rustì˜ ì°¨ìš© ê·œì¹™ì´ í•­ìƒ ì‹œí–‰ë˜ë„ë¡ í•©"
"ë‹ˆë‹¤."

#: src/07_threads/06_interior_mutability.md:112
msgid "// Immutable borrow\n"
msgstr "// ë¶ˆë³€ ì°¨ìš©\n"

#: src/07_threads/06_interior_mutability.md:113
msgid "// Panics! There is an active immutable borrow.\n"
msgstr "// íŒ¨ë‹‰! ì´ë¯¸ ë¶ˆë³€ ì°¨ìš©ì´ ì¡´ì¬í•©ë‹ˆë‹¤.\n"

#: src/07_threads/06_interior_mutability.md:118
msgid ""
"The exercise for this section is located in "
"[`07_threads/06_interior_mutability`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/06_interior_mutability)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`07_threads/06_interior_mutability`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/06_interior_mutability)ì— ìˆìŠµë‹ˆë‹¤"

#: src/07_threads/07_ack.md:1
msgid "Two-way communication"
msgstr "ì–‘ë°©í–¥ í†µì‹ "

#: src/07_threads/07_ack.md:3
msgid ""
"In our current client-server implementation, communication flows in one "
"direction: from the client to the server.  \n"
"The client has no way of knowing if the server received the message, executed "
"it successfully, or failed. That's not ideal."
msgstr ""
"í˜„ì¬ í´ë¼ì´ì–¸íŠ¸-ì„œë²„ êµ¬í˜„ì—ì„œ í†µì‹ ì€ í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì„œë²„ë¡œ í•œ ë°©í–¥ìœ¼ë¡œ íë¦…ë‹ˆ"
"ë‹¤.  \n"
"í´ë¼ì´ì–¸íŠ¸ëŠ” ì„œë²„ê°€ ë©”ì‹œì§€ë¥¼ ë°›ì•˜ëŠ”ì§€, ì„±ê³µì ìœ¼ë¡œ ì‹¤í–‰í–ˆëŠ”ì§€, ì‹¤íŒ¨í–ˆëŠ”ì§€ ì•Œ "
"ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê·¸ê²ƒì€ ì´ìƒì ì´ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/07_threads/07_ack.md:7
msgid "To solve this issue, we can introduce a two-way communication system."
msgstr "ì´ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ì–‘ë°©í–¥ í†µì‹  ì‹œìŠ¤í…œì„ ë„ì…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/07_ack.md:9
msgid "Response channel"
msgstr "ì‘ë‹µ ì±„ë„"

#: src/07_threads/07_ack.md:11
msgid ""
"We need a way for the server to send a response back to the client.  \n"
"There are various ways to do this, but the simplest option is to include a "
"`Sender` channel in the message that the client sends to the server. After "
"processing the message, the server can use this channel to send a response "
"back to the client."
msgstr ""
"ì„œë²„ê°€ í´ë¼ì´ì–¸íŠ¸ì— ì‘ë‹µì„ ë‹¤ì‹œ ë³´ë‚¼ ìˆ˜ ìˆëŠ” ë°©ë²•ì´ í•„ìš”í•©ë‹ˆë‹¤.  \n"
"ì´ë¥¼ ìˆ˜í–‰í•˜ëŠ” ë°©ë²•ì€ ë‹¤ì–‘í•˜ì§€ë§Œ ê°€ì¥ ê°„ë‹¨í•œ ì˜µì…˜ì€ í´ë¼ì´ì–¸íŠ¸ê°€ ì„œë²„ì— ë³´ë‚´ëŠ” "
"ë©”ì‹œì§€ì— `Sender` ì±„ë„ì„ í¬í•¨ì‹œí‚¤ëŠ” ê²ƒì…ë‹ˆë‹¤. ë©”ì‹œì§€ë¥¼ ì²˜ë¦¬í•œ í›„ ì„œë²„ëŠ” ì´ ì±„"
"ë„ì„ ì‚¬ìš©í•˜ì—¬ í´ë¼ì´ì–¸íŠ¸ì— ì‘ë‹µì„ ë‹¤ì‹œ ë³´ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/07_ack.md:16
msgid ""
"This is a fairly common pattern in Rust applications built on top of message-"
"passing primitives."
msgstr ""
"ì´ëŠ” ë©”ì‹œì§€ ì „ë‹¬ ê¸°ë³¸ ìš”ì†Œë¥¼ ê¸°ë°˜ìœ¼ë¡œ êµ¬ì¶•ëœ Rust ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ìƒë‹¹íˆ ì¼ë°˜"
"ì ì¸ íŒ¨í„´ì…ë‹ˆë‹¤."

#: src/07_threads/07_ack.md:20
msgid ""
"The exercise for this section is located in [`07_threads/07_ack`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/07_ack)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`07_threads/07_ack`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/07_ack)ì— ìˆìŠµë‹ˆë‹¤"

#: src/07_threads/08_client.md:1
msgid "A dedicated `Client` type"
msgstr "ì „ìš© `í´ë¼ì´ì–¸íŠ¸` íƒ€ì…"

#: src/07_threads/08_client.md:3
msgid ""
"All the interactions from the client side have been fairly low-level: you "
"have to manually create a response channel, build the command, send it to the "
"server, and then call `recv` on the response channel to get the response."
msgstr ""
"í´ë¼ì´ì–¸íŠ¸ ì¸¡ì˜ ëª¨ë“  ìƒí˜¸ ì‘ìš©ì€ ìƒë‹¹íˆ ë‚®ì€ ìˆ˜ì¤€ì´ì—ˆìŠµë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œ ì‘ë‹µ ì±„"
"ë„ì„ ë§Œë“¤ê³ , ëª…ë ¹ì„ ë¹Œë“œí•˜ê³ , ì´ë¥¼ ì„œë²„ë¡œ ë³´ë‚¸ ë‹¤ìŒ ì‘ë‹µ ì±„ë„ì—ì„œ `recv`ë¥¼ í˜¸"
"ì¶œí•˜ì—¬ ì‘ë‹µì„ ë°›ì•„ì•¼ í•©ë‹ˆë‹¤."

#: src/07_threads/08_client.md:7
msgid ""
"This is a lot of boilerplate code that could be abstracted away, and that's "
"exactly what we're going to do in this exercise."
msgstr ""
"ì´ê²ƒì€ ì¶”ìƒí™”í•  ìˆ˜ ìˆëŠ” ë§ì€ ìƒìš©êµ¬ ì½”ë“œì´ë©° ì´ê²ƒì´ ë°”ë¡œ ìš°ë¦¬ê°€ ì´ ì˜ˆì œì—ì„œ ìˆ˜"
"í–‰í•  ì‘ì—…ì…ë‹ˆë‹¤."

#: src/07_threads/08_client.md:12
msgid ""
"The exercise for this section is located in [`07_threads/08_client`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/08_client)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`07_threads/08_client`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/08_client)ì— ìˆìŠµë‹ˆë‹¤"

#: src/07_threads/09_bounded.md:1
msgid "Bounded vs unbounded channels"
msgstr "ì œí•œëœ ì±„ë„ê³¼ ë¬´ì œí•œ ì±„ë„"

#: src/07_threads/09_bounded.md:3
msgid ""
"So far we've been using unbounded channels.  \n"
"You can send as many messages as you want, and the channel will grow to "
"accommodate them.  \n"
"In a multi-producer single-consumer scenario, this can be problematic: if the "
"producers enqueues messages at a faster rate than the consumer can process "
"them, the channel will keep growing, potentially consuming all available "
"memory."
msgstr ""
"ì§€ê¸ˆê¹Œì§€ ìš°ë¦¬ëŠ” ë¬´ì œí•œ ì±„ë„ì„ ì‚¬ìš©í•´ ì™”ìŠµë‹ˆë‹¤.  \n"
"ì›í•˜ëŠ” ë§Œí¼ ë§ì€ ë©”ì‹œì§€ë¥¼ ë³´ë‚¼ ìˆ˜ ìˆìœ¼ë©° ì±„ë„ì€ ë©”ì‹œì§€ë¥¼ ìˆ˜ìš©í•  ìˆ˜ ìˆë„ë¡ ì»¤ì§‘"
"ë‹ˆë‹¤.  \n"
"ë‹¤ì¤‘ ìƒì‚°ì ë‹¨ì¼ ì†Œë¹„ì ì‹œë‚˜ë¦¬ì˜¤ì—ì„œ ì´ëŠ” ë¬¸ì œê°€ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìƒì‚°ìê°€ ì†Œë¹„"
"ìê°€ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” ê²ƒë³´ë‹¤ ë” ë¹ ë¥¸ ì†ë„ë¡œ ë©”ì‹œì§€ë¥¼ ëŒ€ê¸°ì—´ì— ë„£ìœ¼ë©´ ì±„ë„ì´ ê³„"
"ì† ì„±ì¥í•˜ì—¬ ì ì¬ì ìœ¼ë¡œ ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë“  ë©”ëª¨ë¦¬ë¥¼ ì†Œë¹„í•˜ê²Œ ë©ë‹ˆë‹¤."

#: src/07_threads/09_bounded.md:9
msgid ""
"Our recommendation is to **never** use an unbounded channel in a production "
"system.  \n"
"You should always enforce an upper limit on the number of messages that can "
"be enqueued using a **bounded channel**."
msgstr ""
"ìš°ë¦¬ì˜ ê¶Œì¥ ì‚¬í•­ì€ í”„ë¡œë•ì…˜ ì‹œìŠ¤í…œì—ì„œ ë¬´ì œí•œ ì±„ë„ì„ **ì ˆëŒ€ë¡œ** ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” "
"ê²ƒì…ë‹ˆë‹¤.  \n"
"**ë°”ìš´ë“œ ì±„ë„**ì„ ì‚¬ìš©í•˜ì—¬ ëŒ€ê¸°ì—´ì— ì¶”ê°€í•  ìˆ˜ ìˆëŠ” ë©”ì‹œì§€ ìˆ˜ì— ëŒ€í•œ ìƒí•œì„ í•­"
"ìƒ ì ìš©í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/07_threads/09_bounded.md:15
msgid ""
"A bounded channel has a fixed capacity.  \n"
"You can create one by calling `sync_channel` with a capacity greater than "
"zero:"
msgstr ""
"ì œí•œëœ ì±„ë„ì—ëŠ” ê³ ì •ëœ ìš©ëŸ‰ì´ ìˆìŠµë‹ˆë‹¤.  \n"
"0ë³´ë‹¤ í° ìš©ëŸ‰ìœ¼ë¡œ `sync_channel`ì„ í˜¸ì¶œí•˜ì—¬ ì±„ë„ì„ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/07_threads/09_bounded.md:24
msgid ""
"`receiver` has the same type as before, `Receiver<T>`.  \n"
"`sender`, instead, is an instance of `SyncSender<T>`."
msgstr ""
"`receiver`ëŠ” ì´ì „ê³¼ ë™ì¼í•œ íƒ€ì…ì¸ `Receiver<T>`ë¥¼ ê°–ìŠµë‹ˆë‹¤.  \n"
"ëŒ€ì‹  `sender`ëŠ” `SyncSender<T>`ì˜ ì¸ìŠ¤í„´ìŠ¤ì…ë‹ˆë‹¤."

#: src/07_threads/09_bounded.md:27
msgid "Sending messages"
msgstr "ë©”ì‹œì§€ ë³´ë‚´ê¸°"

#: src/07_threads/09_bounded.md:29
msgid "You have two different methods to send messages through a `SyncSender`:"
msgstr "`SyncSender`ë¥¼ í†µí•´ ë©”ì‹œì§€ë¥¼ ë³´ë‚´ëŠ” ë°©ë²•ì—ëŠ” ë‘ ê°€ì§€ê°€ ìˆìŠµë‹ˆë‹¤:"

#: src/07_threads/09_bounded.md:31
msgid ""
"`send`: if there is space in the channel, it will enqueue the message and "
"return `Ok(())`.  \n"
"If the channel is full, it will block and wait until there is space available."
msgstr ""
"`send`: ì±„ë„ì— ê³µê°„ì´ ìˆìœ¼ë©´ ë©”ì‹œì§€ë¥¼ ëŒ€ê¸°ì—´ì— ì¶”ê°€í•˜ê³  `Ok(())`ë¥¼ ë°˜í™˜í•©ë‹ˆ"
"ë‹¤.  \n"
"ì±„ë„ì´ ê°€ë“ ì°¨ë©´ ì‚¬ìš© ê°€ëŠ¥í•œ ê³µê°„ì´ ìƒê¸¸ ë•Œê¹Œì§€ ì°¨ë‹¨í•˜ê³  ê¸°ë‹¤ë¦½ë‹ˆë‹¤."

#: src/07_threads/09_bounded.md:33
msgid ""
"`try_send`: if there is space in the channel, it will enqueue the message and "
"return `Ok(())`.  \n"
"If the channel is full, it will return `Err(TrySendError::Full(value))`, "
"where `value` is the message that couldn't be sent."
msgstr ""
"`try_send`: ì±„ë„ì— ê³µê°„ì´ ìˆìœ¼ë©´ ë©”ì‹œì§€ë¥¼ ëŒ€ê¸°ì—´ì— ì¶”ê°€í•˜ê³  `Ok(())`ë¥¼ ë°˜í™˜í•©"
"ë‹ˆë‹¤.  \n"
"ì±„ë„ì´ ê½‰ ì°¨ë©´ `Err(TrySendError::Full(value))`ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. ì—¬ê¸°ì„œ `value`"
"ëŠ” ì „ì†¡í•  ìˆ˜ ì—†ëŠ” ë©”ì‹œì§€ì…ë‹ˆë‹¤."

#: src/07_threads/09_bounded.md:36
msgid "Depending on your use case, you might want to use one or the other."
msgstr "ì¼€ì´ìŠ¤ì— ë”°ë¼ ë‘˜ ì¤‘ í•˜ë‚˜ë¥¼ ê³¨ë¼ ì‚¬ìš©í•˜ë©´ ë©ë‹ˆë‹¤."

#: src/07_threads/09_bounded.md:38
msgid "Backpressure"
msgstr "ë°°ì••"

#: src/07_threads/09_bounded.md:40
msgid ""
"The main advantage of using bounded channels is that they provide a form of "
"**backpressure**.  \n"
"They force the producers to slow down if the consumer can't keep up. The "
"backpressure can then propagate through the system, potentially affecting the "
"whole architecture and preventing end users from overwhelming the system with "
"requests."
msgstr ""
"ì œí•œëœ ì±„ë„ì„ ì‚¬ìš©í•˜ëŠ” ì£¼ìš” ì´ì ì€ **ë°°ì••** í˜•íƒœë¥¼ ì œê³µí•œë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤.  \n"
"ì†Œë¹„ìê°€ ë”°ë¼ì¡ì„ ìˆ˜ ì—†ìœ¼ë©´ ìƒì‚°ìê°€ ì†ë„ë¥¼ ëŠ¦ì¶”ë„ë¡ ê°•ìš”í•©ë‹ˆë‹¤. ê·¸ëŸ° ë‹¤ìŒ ë°°"
"ì••ì´ ì‹œìŠ¤í…œì„ í†µí•´ ì „íŒŒë˜ì–´ ì ì¬ì ìœ¼ë¡œ ì „ì²´ ì•„í‚¤í…ì²˜ì— ì˜í–¥ì„ ë¯¸ì¹˜ê³  ìµœì¢… ì‚¬ìš©"
"ìê°€ ìš”ì²­ìœ¼ë¡œ ì‹œìŠ¤í…œì„ ì••ë°•í•˜ëŠ” ê²ƒì„ ë°©ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/09_bounded.md:47
msgid ""
"The exercise for this section is located in [`07_threads/09_bounded`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/09_bounded)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`07_threads/09_bounded`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/09_bounded)ì— ìˆìŠµë‹ˆë‹¤"

#: src/07_threads/10_patch.md:1
msgid "Update operations"
msgstr "ì—…ë°ì´íŠ¸ ì‘ì—…"

#: src/07_threads/10_patch.md:3
msgid ""
"So far we've implemented only insertion and retrieval operations.  \n"
"Let's see how we can expand the system to provide an update operation."
msgstr ""
"ì§€ê¸ˆê¹Œì§€ ìš°ë¦¬ëŠ” ì‚½ì… ë° ê²€ìƒ‰ ì‘ì—…ë§Œ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.  \n"
"ì—…ë°ì´íŠ¸ ì‘ì—…ì„ ì œê³µí•˜ê¸° ìœ„í•´ ì‹œìŠ¤í…œì„ ì–´ë–»ê²Œ í™•ì¥í•  ìˆ˜ ìˆëŠ”ì§€ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤."

#: src/07_threads/10_patch.md:6
msgid "Legacy updates"
msgstr "ë ˆê±°ì‹œ ì—…ë°ì´íŠ¸"

#: src/07_threads/10_patch.md:8
msgid ""
"In the non-threaded version of the system, updates were fairly "
"straightforward: `TicketStore` exposed a `get_mut` method that allowed the "
"caller to obtain a mutable reference to a ticket, and then modify it."
msgstr ""
"ìŠ¤ë ˆë“œë˜ì§€ ì•Šì€ ì‹œìŠ¤í…œ ë²„ì „ì—ì„œëŠ” ì—…ë°ì´íŠ¸ê°€ ë§¤ìš° ê°„ë‹¨í–ˆìŠµë‹ˆë‹¤. `TicketStore`"
"ëŠ” í˜¸ì¶œìê°€ í‹°ì¼“ì— ëŒ€í•œ ë³€ê²½ ê°€ëŠ¥í•œ ì°¸ì¡°ë¥¼ ì–»ì€ ë‹¤ìŒ ì´ë¥¼ ìˆ˜ì •í•  ìˆ˜ ìˆë„ë¡ í•˜"
"ëŠ” `get_mut` ë©”ì„œë“œë¥¼ ì œê³µí–ˆìŠµë‹ˆë‹¤."

#: src/07_threads/10_patch.md:11
msgid "Multithreaded updates"
msgstr "ë©€í‹°ìŠ¤ë ˆë“œ ì—…ë°ì´íŠ¸"

#: src/07_threads/10_patch.md:13
msgid ""
"The same strategy won't work in the current multi-threaded version, because "
"the mutable reference would have to be sent over a channel. The borrow "
"checker would stop us, because `&mut Ticket` doesn't satisfy the `'static` "
"lifetime requirement of `SyncSender::send`."
msgstr ""
"ë³€ê²½ ê°€ëŠ¥í•œ ì°¸ì¡°ë¥¼ ì±„ë„ì„ í†µí•´ ì „ì†¡í•´ì•¼ í•˜ê¸° ë•Œë¬¸ì— í˜„ì¬ ë©€í‹° ìŠ¤ë ˆë“œ ë²„ì „ì—ì„œ"
"ëŠ” ë™ì¼í•œ ì „ëµì´ ì‘ë™í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì°¨ìš© ê²€ì‚¬ê¸°ëŠ” `&mut Ticket`ì´ "
"`SyncSender::send`ì˜ `'static` ìˆ˜ëª… ìš”êµ¬ ì‚¬í•­ì„ ì¶©ì¡±í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ìš°ë¦¬ë¥¼ ë§‰"
"ì„ ê²ƒì…ë‹ˆë‹¤."

#: src/07_threads/10_patch.md:17
msgid ""
"There are a few ways to work around this limitation. We'll explore a few of "
"them in the following exercises."
msgstr ""
"ì´ ì œí•œ ì‚¬í•­ì„ í•´ê²°í•˜ëŠ” ë°©ë²•ì—ëŠ” ëª‡ ê°€ì§€ê°€ ìˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ì—°ìŠµì—ì„œëŠ” ê·¸ ì¤‘ ëª‡ "
"ê°€ì§€ë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤."

#: src/07_threads/10_patch.md:21
msgid ""
"We can't send a `&mut Ticket` over a channel, therefore we can't mutate on "
"the client-side.  \n"
"Can we mutate on the server-side?"
msgstr ""
"ì±„ë„ì„ í†µí•´ `&mut Ticket`ì„ ë³´ë‚¼ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ í´ë¼ì´ì–¸íŠ¸ ì¸¡ì—ì„œ ë³€ê²½í•  ìˆ˜ ì—†ìŠµ"
"ë‹ˆë‹¤.  \n"
"ì„œë²„ ì¸¡ì—ì„œ ë³€ê²½í•  ìˆœ ì—†ì„ê¹Œìš”?"

#: src/07_threads/10_patch.md:24
msgid ""
"We can, if we tell the server what needs to be changed. In other words, if we "
"send a **patch** to the server:"
msgstr ""
"ë³€ê²½í•´ì•¼ í•  ì‚¬í•­ì„ ì„œë²„ì— ì•Œë¦¬ë©´ ê°€ëŠ¥í•©ë‹ˆë‹¤. ì¦‰, ì„œë²„ì— **íŒ¨ì¹˜**ë¥¼ ë³´ë‚´ëŠ” ê²½"
"ìš°:"

#: src/07_threads/10_patch.md:35
msgid ""
"The `id` field is mandatory, since it's required to identify the ticket that "
"needs to be updated.  \n"
"All other fields are optional:"
msgstr ""
"`id` í•„ë“œëŠ” ì—…ë°ì´íŠ¸í•´ì•¼ í•˜ëŠ” í‹°ì¼“ì„ ì‹ë³„í•˜ëŠ” ë° í•„ìš”í•˜ë¯€ë¡œ í•„ìˆ˜ì…ë‹ˆë‹¤.  \n"
"ë‹¤ë¥¸ ëª¨ë“  í•„ë“œëŠ” ì„ íƒì‚¬í•­ì…ë‹ˆë‹¤:"

#: src/07_threads/10_patch.md:38
msgid "If a field is `None`, it means that the field should not be changed."
msgstr "í•„ë“œê°€ `None`ì¸ ê²½ìš° í•´ë‹¹ í•„ë“œë¥¼ ë³€ê²½í•´ì„œëŠ” ì•ˆ ëœë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤."

#: src/07_threads/10_patch.md:39
msgid ""
"If a field is `Some(value)`, it means that the field should be changed to "
"`value`."
msgstr ""
"í•„ë“œê°€ `Some(value)`ì¸ ê²½ìš° í•´ë‹¹ í•„ë“œê°€ `value`ë¡œ ë³€ê²½ë˜ì–´ì•¼ í•¨ì„ ì˜ë¯¸í•©ë‹ˆë‹¤."

#: src/07_threads/10_patch.md:43
msgid ""
"The exercise for this section is located in [`07_threads/10_patch`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/10_patch)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`07_threads/10_patch`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/10_patch)ì— ìˆìŠµë‹ˆë‹¤"

#: src/07_threads/11_locks.md:1
msgid "Locks, `Send` and `Arc`"
msgstr "Locks, `Send` ê·¸ë¦¬ê³  `Arc`"

#: src/07_threads/11_locks.md:3
msgid ""
"The patching strategy you just implemented has a major drawback: it's "
"racy.  \n"
"If two clients send patches for the same ticket roughly at same time, the "
"server will apply them in an arbitrary order. Whoever enqueues their patch "
"last will overwrite the changes made by the other client."
msgstr ""
"ë°©ê¸ˆ êµ¬í˜„í•œ íŒ¨ì¹˜ ì „ëµì—ëŠ” í° ë‹¨ì ì´ ìˆìŠµë‹ˆë‹¤. ë°”ë¡œ ê²½ìŸ ì¡°ê±´ì´ ë°œìƒí•  ìˆ˜ ìˆë‹¤"
"ëŠ” ê²ƒì…ë‹ˆë‹¤.  \n"
"ë‘ í´ë¼ì´ì–¸íŠ¸ê°€ ê±°ì˜ ë™ì‹œì— ë™ì¼í•œ í‹°ì¼“ì— ëŒ€í•œ íŒ¨ì¹˜ë¥¼ ë³´ë‚´ëŠ” ê²½ìš° ì„œë²„ëŠ” ì´ë¥¼ "
"ì„ì˜ì˜ ìˆœì„œë¡œ ì ìš©í•©ë‹ˆë‹¤. íŒ¨ì¹˜ë¥¼ ë§ˆì§€ë§‰ìœ¼ë¡œ ëŒ€ê¸°ì—´ì— ì¶”ê°€í•˜ëŠ” ì‚¬ëŒì€ ë‹¤ë¥¸ í´ë¼"
"ì´ì–¸íŠ¸ì˜ ë³€ê²½ ì‚¬í•­ì„ ë®ì–´ì“°ê²Œ ë©ë‹ˆë‹¤."

#: src/07_threads/11_locks.md:7
msgid "Version numbers"
msgstr "ë²„ì „ ë²ˆí˜¸"

#: src/07_threads/11_locks.md:9
msgid ""
"We could try to fix this by using a **version number**.  \n"
"Each ticket gets assigned a version number upon creation, set to `0`.  \n"
"Whenever a client sends a patch, they must include the current version number "
"of the ticket alongside the desired changes. The server will only apply the "
"patch if the version number matches the one it has stored."
msgstr ""
"**ë²„ì „ ë²ˆí˜¸**ë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"ê° í‹°ì¼“ì—ëŠ” ìƒì„± ì‹œ `0`ìœ¼ë¡œ ì„¤ì •ëœ ë²„ì „ ë²ˆí˜¸ê°€ í• ë‹¹ë©ë‹ˆë‹¤.  \n"
"í´ë¼ì´ì–¸íŠ¸ê°€ íŒ¨ì¹˜ë¥¼ ë³´ë‚¼ ë•Œë§ˆë‹¤ ì›í•˜ëŠ” ë³€ê²½ ì‚¬í•­ê³¼ í•¨ê»˜ í‹°ì¼“ì˜ í˜„ì¬ ë²„ì „ ë²ˆí˜¸"
"ë¥¼ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤. ì„œë²„ëŠ” ë²„ì „ ë²ˆí˜¸ê°€ ì €ì¥ëœ ë²„ì „ ë²ˆí˜¸ì™€ ì¼ì¹˜í•˜ëŠ” ê²½ìš°ì—ë§Œ íŒ¨"
"ì¹˜ë¥¼ ì ìš©í•©ë‹ˆë‹¤."

#: src/07_threads/11_locks.md:14
msgid ""
"In the scenario described above, the server would reject the second patch, "
"because the version number would have been incremented by the first patch and "
"thus wouldn't match the one sent by the second client."
msgstr ""
"ìœ„ì— ì„¤ëª…ëœ ì‹œë‚˜ë¦¬ì˜¤ì—ì„œ ì„œë²„ëŠ” ë‘ ë²ˆì§¸ íŒ¨ì¹˜ë¥¼ ê±°ë¶€í•©ë‹ˆë‹¤. ë²„ì „ ë²ˆí˜¸ê°€ ì²« ë²ˆ"
"ì§¸ íŒ¨ì¹˜ì— ì˜í•´ ì¦ê°€ë˜ì–´ ë‘ ë²ˆì§¸ í´ë¼ì´ì–¸íŠ¸ê°€ ë³´ë‚¸ ë²„ì „ ë²ˆí˜¸ì™€ ì¼ì¹˜í•˜ì§€ ì•Šê¸° ë•Œ"
"ë¬¸ì…ë‹ˆë‹¤."

#: src/07_threads/11_locks.md:17
msgid ""
"This approach is fairly common in distributed systems (e.g. when client and "
"servers don't share memory), and it is known as **optimistic concurrency "
"control**.  \n"
"The idea is that most of the time, conflicts won't happen, so we can optimize "
"for the common case. You know enough about Rust by now to implement this "
"strategy on your own as a bonus exercise, if you want to."
msgstr ""
"ì´ ì ‘ê·¼ ë°©ì‹ì€ ë¶„ì‚° ì‹œìŠ¤í…œ(ì˜ˆ: í´ë¼ì´ì–¸íŠ¸ì™€ ì„œë²„ê°€ ë©”ëª¨ë¦¬ë¥¼ ê³µìœ í•˜ì§€ ì•ŠëŠ” ê²½"
"ìš°)ì—ì„œ ë§¤ìš° ì¼ë°˜ì ì´ë©° **ë‚™ê´€ì  ë™ì‹œì„± ì œì–´**ë¼ê³  ì•Œë ¤ì ¸ ìˆìŠµë‹ˆë‹¤.  \n"
"ëŒ€ë¶€ë¶„ì˜ ê²½ìš° ì¶©ëŒì´ ë°œìƒí•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì¼ë°˜ì ì¸ ê²½ìš°ì— ë§ê²Œ ìµœì í™”í•  ìˆ˜ ìˆë‹¤"
"ëŠ” ì•„ì´ë””ì–´ì…ë‹ˆë‹¤. ë‹¹ì‹ ì€ ì›í•œë‹¤ë©´ ë³´ë„ˆìŠ¤ ì—°ìŠµìœ¼ë¡œ ì´ ì „ëµì„ ìŠ¤ìŠ¤ë¡œ êµ¬í˜„í•  ìˆ˜ "
"ìˆì„ ë§Œí¼ Rustì— ëŒ€í•´ ì¶©ë¶„íˆ ì•Œê³  ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/11_locks.md:22
msgid "Locking"
msgstr "ì ê¸ˆ"

#: src/07_threads/11_locks.md:24
msgid ""
"We can also fix the race condition by introducing a **lock**.  \n"
"Whenever a client wants to update a ticket, they must first acquire a lock on "
"it. While the lock is active, no other client can modify the ticket."
msgstr ""
"**ì ê¸ˆ**ì„ ë„ì…í•˜ì—¬ ê²½ìŸ ì¡°ê±´ì„ ìˆ˜ì •í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.  \n"
"í´ë¼ì´ì–¸íŠ¸ê°€ í‹°ì¼“ì„ ì—…ë°ì´íŠ¸í•˜ë ¤ê³  í•  ë•Œë§ˆë‹¤ ë¨¼ì € í‹°ì¼“ì— ëŒ€í•œ ì ê¸ˆì„ íšë“í•´ì•¼ "
"í•©ë‹ˆë‹¤. ì ê¸ˆì´ í™œì„±í™”ë˜ì–´ ìˆëŠ” ë™ì•ˆì—ëŠ” ë‹¤ë¥¸ í´ë¼ì´ì–¸íŠ¸ê°€ í‹°ì¼“ì„ ìˆ˜ì •í•  ìˆ˜ ì—†"
"ìŠµë‹ˆë‹¤."

#: src/07_threads/11_locks.md:28
msgid ""
"Rust's standard library provides two different locking primitives: `Mutex<T>` "
"and `RwLock<T>`.  \n"
"Let's start with `Mutex<T>`. It stands for **mut**ual **ex**clusion, and it's "
"the simplest kind of lock: it allows only one thread to access the data, no "
"matter if it's for reading or writing."
msgstr ""
"Rustì˜ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” `Mutex<T>`ì™€ `RwLock<T>`ë¼ëŠ” ë‘ ê°€ì§€ ì ê¸ˆ ê¸°ë³¸ ìš”ì†Œ"
"ë¥¼ ì œê³µí•©ë‹ˆë‹¤.  \n"
"`Mutex<T>`ë¶€í„° ì‹œì‘í•´ ë³´ê² ìŠµë‹ˆë‹¤. ì´ëŠ” **mut**ual **ex**clusion(ìƒí˜¸ ë°°ì œ)ì„ "
"ì˜ë¯¸í•˜ë©° ê°€ì¥ ê°„ë‹¨í•œ ì¢…ë¥˜ì˜ ì ê¸ˆì…ë‹ˆë‹¤. ì½ê¸°ìš©ì´ë“  ì“°ê¸°ìš©ì´ë“  ê´€ê³„ì—†ì´ í•˜ë‚˜ì˜ "
"ìŠ¤ë ˆë“œë§Œ ë°ì´í„°ì— ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆë„ë¡ í—ˆìš©í•©ë‹ˆë‹¤."

#: src/07_threads/11_locks.md:32
msgid ""
"`Mutex<T>` wraps the data it protects, and it's therefore generic over the "
"type of the data.  \n"
"You can't access the data directly: the type system forces you to acquire a "
"lock first using either `Mutex::lock` or `Mutex::try_lock`. The former blocks "
"until the lock is acquired, the latter returns immediately with an error if "
"the lock can't be acquired.  \n"
"Both methods return a guard object that dereferences to the data, allowing "
"you to modify it. The lock is released when the guard is dropped."
msgstr ""
"`Mutex<T>`ëŠ” ë³´í˜¸í•˜ëŠ” ë°ì´í„°ë¥¼ ë˜í•‘í•˜ë¯€ë¡œ ë°ì´í„° íƒ€ì…ìœ¼ë¡œ ì¼ë°˜í™”ë©ë‹ˆë‹¤.  \n"
"ë°ì´í„°ì— ì§ì ‘ ì•¡ì„¸ìŠ¤í•  ìˆ˜ëŠ” ì—†ìŠµë‹ˆë‹¤. íƒ€ì… ì‹œìŠ¤í…œì€ `Mutex::lock` ë˜ëŠ” "
"`Mutex::try_lock`ì„ ì‚¬ìš©í•˜ì—¬ ë¨¼ì € ì ê¸ˆì„ íšë“í•˜ë„ë¡ ê°•ì œí•©ë‹ˆë‹¤. ì „ìëŠ” ì ê¸ˆì„ "
"íšë“í•  ë•Œê¹Œì§€ ì°¨ë‹¨í•˜ê³  í›„ìëŠ” ì ê¸ˆì„ íšë“í•  ìˆ˜ ì—†ëŠ” ê²½ìš° ì˜¤ë¥˜ì™€ í•¨ê»˜ ì¦‰ì‹œ ë°˜í™˜"
"í•©ë‹ˆë‹¤.  \n"
"ë‘ ë©”ì„œë“œ ëª¨ë‘ ë°ì´í„°ë¥¼ ì—­ì°¸ì¡°í•˜ëŠ” ê°€ë“œ ê°œì²´ë¥¼ ë°˜í™˜í•˜ë¯€ë¡œ ë°ì´í„°ë¥¼ ìˆ˜ì •í•  ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤. ê°€ë“œë¥¼ ì‚­ì œí•˜ë©´ ì ê¸ˆì´ í•´ì œë©ë‹ˆë‹¤."

#: src/07_threads/11_locks.md:41
msgid "// An integer protected by a mutex lock\n"
msgstr "// ë®¤í…ìŠ¤ ì ê¸ˆìœ¼ë¡œ ë³´í˜¸ë˜ëŠ” ì •ìˆ˜\n"

#: src/07_threads/11_locks.md:44
msgid "// Acquire a lock on the mutex\n"
msgstr "// ë®¤í…ìŠ¤ì— ëŒ€í•œ ì ê¸ˆì„ íšë“í•©ë‹ˆë‹¤\n"

#: src/07_threads/11_locks.md:47
msgid ""
"// Modify the data through the guard,\n"
"// leveraging its `Deref` implementation\n"
msgstr ""
"// `Deref` êµ¬í˜„ì„ í™œìš©í•˜ì—¬ ê°€ë“œë¥¼\n"
"// í†µí•´ ë°ì´í„°ë¥¼ ìˆ˜ì •í•©ë‹ˆë‹¤\n"

#: src/07_threads/11_locks.md:51
msgid ""
"// The lock is released when `data` goes out of scope\n"
"// This can be done explicitly by dropping the guard\n"
"// or happen implicitly when the guard goes out of scope\n"
msgstr ""
"// `data`ê°€ ìŠ¤ì½”í”„ë¥¼ ë²—ì–´ë‚  ë•Œ ì ê¸ˆì´ í•´ì œë©ë‹ˆë‹¤\n"
"// ì´ëŠ” ê°€ë“œë¥¼ ì‚­ì œí•˜ì—¬ ëª…ì‹œì ìœ¼ë¡œ ìˆ˜í–‰í•  ìˆ˜ë„ ìˆê³ \n"
"// ê°€ë“œê°€ ìŠ¤ì½”í”„ë¥¼ ë²—ì–´ë‚  ë•Œ ì•”ì‹œì ìœ¼ë¡œ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤\n"

#: src/07_threads/11_locks.md:58
msgid "Locking granularity"
msgstr "ì ê¸ˆ ì„¸ë¶„ì„±"

#: src/07_threads/11_locks.md:60
msgid ""
"What should our `Mutex` wrap?  \n"
"The simplest option would be the wrap the entire `TicketStore` in a single "
"`Mutex`.  \n"
"This would work, but it would severely limit the system's performance: you "
"wouldn't be able to read tickets in parallel, because every read would have "
"to wait for the lock to be released.  \n"
"This is known as **coarse-grained locking**."
msgstr ""
"`Mutex`ëŠ” ë¬´ì—‡ì„ ê°ì‹¸ì•¼ í• ê¹Œìš”?  \n"
"ê°€ì¥ ê°„ë‹¨í•œ ì˜µì…˜ì€ ì „ì²´ `TicketStore`ë¥¼ í•˜ë‚˜ì˜ `Mutex`ë¡œ ë¬¶ëŠ” ê²ƒì…ë‹ˆë‹¤.  \n"
"ì´ëŠ” ì‘ë™í•˜ì§€ë§Œ ì‹œìŠ¤í…œ ì„±ëŠ¥ì„ ì‹¬ê°í•˜ê²Œ ì œí•œí•©ë‹ˆë‹¤. ëª¨ë“  ì½ê¸°ëŠ” ì ê¸ˆì´ í•´ì œë  "
"ë•Œê¹Œì§€ ê¸°ë‹¤ë ¤ì•¼ í•˜ê¸° ë•Œë¬¸ì— í‹°ì¼“ì„ ë³‘ë ¬ë¡œ ì½ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.  \n"
"ì´ë¥¼ **ëŒ€ëµì ì¸ ì ê¸ˆ**ì´ë¼ê³  í•©ë‹ˆë‹¤."

#: src/07_threads/11_locks.md:66
msgid ""
"It would be better to use **fine-grained locking**, where each ticket is "
"protected by its own lock. This way, clients can keep working with tickets in "
"parallel, as long as they aren't trying to access the same ticket."
msgstr ""
"ê° í‹°ì¼“ì´ ìì²´ ì ê¸ˆìœ¼ë¡œ ë³´í˜¸ë˜ëŠ” **ì„¸ë°€í•œ ì ê¸ˆ**ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ë” ì¢‹ìŠµë‹ˆë‹¤. "
"ì´ë ‡ê²Œ í•˜ë©´ í´ë¼ì´ì–¸íŠ¸ëŠ” ë™ì¼í•œ í‹°ì¼“ì— ì•¡ì„¸ìŠ¤í•˜ë ¤ê³  ì‹œë„í•˜ì§€ ì•ŠëŠ” í•œ í‹°ì¼“ ì‘ì—…"
"ì„ ê³„ì†í•´ì„œ ë³‘ë ¬ë¡œ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/11_locks.md:70
msgid "// The new structure, with a lock for each ticket\n"
msgstr "// ê° í‹°ì¼“ì— ëŒ€í•œ ì ê¸ˆ ì¥ì¹˜ê°€ ìˆëŠ” ìƒˆë¡œìš´ êµ¬ì¡°\n"

#: src/07_threads/11_locks.md:76
msgid ""
"This approach is more efficient, but it has a downside: `TicketStore` has to "
"become **aware** of the multithreaded nature of the system; up until now, "
"`TicketStore` has been blissfully ignoring the existence of threads.  \n"
"Let's go for it anyway."
msgstr ""
"ì´ ì ‘ê·¼ ë°©ì‹ì€ ë” íš¨ìœ¨ì ì´ì§€ë§Œ ë‹¨ì ë„ ìˆìŠµë‹ˆë‹¤: `TicketStore`ê°€ ì‹œìŠ¤í…œì˜ ë©€í‹°"
"ìŠ¤ë ˆë“œ íŠ¹ì„±ì„ **ì¸ì§€**í•´ì•¼ í•©ë‹ˆë‹¤. ì§€ê¸ˆê¹Œì§€ `TicketStore`ëŠ” ìŠ¤ë ˆë“œì˜ ì¡´ì¬ë¥¼ ì‹ "
"ê²½ ì“°ì§€ ì•Šê³  ìˆì—ˆìŠµë‹ˆë‹¤.\n"
"ì¼ë‹¨ í•œë²ˆ í•´ë´…ì‹œë‹¤."

#: src/07_threads/11_locks.md:80
msgid "Who holds the lock?"
msgstr "ëˆ„ê°€ lockì„ ê±¸ê³ ìˆë‚˜ìš”?"

#: src/07_threads/11_locks.md:82
msgid ""
"For the whole scheme to work, the lock must be passed to the client that "
"wants to modify the ticket.  \n"
"The client can then directly modify the ticket (as if they had a `&mut "
"Ticket`) and release the lock when they're done."
msgstr ""
"ì „ì²´ ì²´ê³„ê°€ ì‘ë™í•˜ë ¤ë©´ í‹°ì¼“ì„ ìˆ˜ì •í•˜ë ¤ëŠ” í´ë¼ì´ì–¸íŠ¸ì— ì ê¸ˆì„ ì „ë‹¬í•´ì•¼ í•©ë‹ˆ"
"ë‹¤.  \n"
"ê·¸ëŸ° ë‹¤ìŒ í´ë¼ì´ì–¸íŠ¸ëŠ” í‹°ì¼“ì„ ì§ì ‘ ìˆ˜ì •í•˜ê³ (`&mut í‹°ì¼“`ì´ ìˆëŠ” ê²ƒì²˜ëŸ¼) ì‘ì—…ì´ "
"ì™„ë£Œë˜ë©´ ì ê¸ˆì„ í•´ì œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/11_locks.md:85
msgid ""
"This is a bit tricky.  \n"
"We can't send a `Mutex<Ticket>` over a channel, because `Mutex` is not "
"`Clone` and we can't move it out of the `TicketStore`. Could we send the "
"`MutexGuard` instead?"
msgstr ""
"ì´ê²ƒì€ ì•½ê°„ ê¹Œë‹¤ë¡­ìŠµë‹ˆë‹¤.  \n"
"`Mutex`ëŠ” `Clone`ì´ ì•„ë‹ˆê³  `TicketStore` ë°–ìœ¼ë¡œ ì´ë™í•  ìˆ˜ ì—†ê¸° ë•Œë¬¸ì— ì±„ë„ì„ "
"í†µí•´ `Mutex<Ticket>`ì„ ë³´ë‚¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ëŒ€ì‹  `MutexGuard`ë¥¼ ë³´ë‚¼ ìˆ˜ ìˆë‚˜ìš”?"

#: src/07_threads/11_locks.md:89
msgid "Let's test the idea with a small example:"
msgstr "ì‘ì€ ì˜ˆë¥¼ í†µí•´ ì•„ì´ë””ì–´ë¥¼ í…ŒìŠ¤íŠ¸í•´ ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/07_threads/11_locks.md:105
msgid ""
"// Try to send the guard over the channel\n"
"    // to another thread\n"
msgstr ""
"// ì±„ë„ì„ í†µí•´ ê°€ë“œë¥¼\n"
"    // ë‹¤ë¥¸ ìŠ¤ë ˆë“œë¡œ ë³´ë‚´ë ¤ê³  í•©ë‹ˆë‹¤\n"

#: src/07_threads/11_locks.md:111
msgid "The compiler is not happy with this code:"
msgstr "ì»´íŒŒì¼ëŸ¬ëŠ” ì´ ì½”ë“œì— ë§Œì¡±í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤:"

#: src/07_threads/11_locks.md:130
msgid "`MutexGuard<'_, i32>` is not `Send`: what does it mean?"
msgstr "`MutexGuard<'_, i32>`ëŠ” `Send`ê°€ ì•„ë‹ˆëë‹ˆë‹¤. ë¬´ìŠ¨ ëœ»ì¼ê¹Œìš”?"

#: src/07_threads/11_locks.md:132
msgid "`Send`"
msgstr "`Send`"

#: src/07_threads/11_locks.md:134
msgid ""
"`Send` is a marker trait that indicates that a type can be safely transferred "
"from one thread to another.  \n"
"`Send` is also an auto-trait, just like `Sized`; it's automatically "
"implemented (or not implemented) for your type by the compiler, based on its "
"definition.  \n"
"You can also implement `Send` manually for your types, but it requires "
"`unsafe` since you have to guarantee that the type is indeed safe to send "
"between threads for reasons that the compiler can't automatically verify."
msgstr ""
"`Send`ëŠ” íƒ€ì…ì´ í•œ ìŠ¤ë ˆë“œì—ì„œ ë‹¤ë¥¸ ìŠ¤ë ˆë“œë¡œ ì•ˆì „í•˜ê²Œ ì „ì†¡ë  ìˆ˜ ìˆìŒì„ ë‚˜íƒ€ë‚´"
"ëŠ” ë§ˆì»¤ íŠ¸ë ˆì‡ì…ë‹ˆë‹¤.\n"
"`Send`ëŠ” `Sized`ì²˜ëŸ¼ ìë™ íŠ¸ë ˆì‡ì´ê¸°ë„ í•©ë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ê°€ íƒ€ì…ì˜ ì •ì˜ë¥¼ ê¸°ë°˜ìœ¼"
"ë¡œ ìë™ìœ¼ë¡œ êµ¬í˜„í•˜ê±°ë‚˜ êµ¬í˜„í•˜ì§€ ì•Šê¸°ë„ í•©ë‹ˆë‹¤.\n"
"`Send`ë¥¼ ì§ì ‘ êµ¬í˜„í•  ìˆ˜ë„ ìˆì§€ë§Œ, ì´ ê²½ìš° `unsafe`ê°€ í•„ìš”í•©ë‹ˆë‹¤. ì´ëŠ” ì»´íŒŒì¼ëŸ¬"
"ê°€ ìë™ìœ¼ë¡œ í™•ì¸í•  ìˆ˜ ì—†ëŠ” ì´ìœ ë¡œ íƒ€ì…ì´ ìŠ¤ë ˆë“œ ê°„ì— ì•ˆì „í•˜ê²Œ ì „ì†¡ë  ìˆ˜ ìˆìŒ"
"ì„ ë³´ì¥í•´ì•¼ í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/07_threads/11_locks.md:140
msgid "Channel requirements"
msgstr "ì±„ë„ ìš”êµ¬ ì‚¬í•­"

#: src/07_threads/11_locks.md:142
msgid ""
"`Sender<T>`, `SyncSender<T>` and `Receiver<T>` are `Send` if and only if `T` "
"is `Send`.  \n"
"That's because they are used to send values between threads, and if the value "
"itself is not `Send`, it would be unsafe to send it between threads."
msgstr ""
"`Sender<T>`, `SyncSender<T>` ë° `Receiver<T>`ëŠ” `T`ê°€ `Send`ì¸ ê²½ìš°ì—ë§Œ `Send`"
"ì…ë‹ˆë‹¤.  \n"
"ìŠ¤ë ˆë“œ ê°„ì— ê°’ì„ ë³´ë‚´ëŠ” ë° ì‚¬ìš©ë˜ë©°, ê°’ ìì²´ê°€ `Send`ê°€ ì•„ë‹Œ ê²½ìš° ìŠ¤ë ˆë“œ ê°„ì— "
"ì „ì†¡í•˜ëŠ” ê²ƒì´ ì•ˆì „í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/07_threads/11_locks.md:146
msgid "`MutexGuard`"
msgstr "`MutexGuard`"

#: src/07_threads/11_locks.md:148
msgid ""
"`MutexGuard` is not `Send` because the underlying operating system primitives "
"that `Mutex` uses to implement the lock require (on some platforms) that the "
"lock must be released by the same thread that acquired it.  \n"
"If we were to send a `MutexGuard` to another thread, the lock would be "
"released by a different thread, which would lead to undefined behavior."
msgstr ""
"`MutexGuard`ëŠ” `Mutex`ê°€ ì ê¸ˆì„ êµ¬í˜„í•˜ëŠ” ë° ì‚¬ìš©í•˜ëŠ” ê¸°ë³¸ ìš´ì˜ ì²´ì œ í”„ë¦¬ë¯¸í‹°ë¸Œ"
"ê°€ (ì¼ë¶€ í”Œë«í¼ì—ì„œ) ì ê¸ˆì„ íšë“í•œ ë™ì¼í•œ ìŠ¤ë ˆë“œì— ì˜í•´ ì ê¸ˆì„ í•´ì œí•´ì•¼ í•˜ê¸° "
"ë•Œë¬¸ì— `Send`ê°€ ì•„ë‹™ë‹ˆë‹¤.  \n"
"ë‹¤ë¥¸ ìŠ¤ë ˆë“œì— `MutexGuard`ë¥¼ ë³´ë‚´ë©´ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì— ì˜í•´ ì ê¸ˆì´ í•´ì œë˜ì–´ ì •ì˜ë˜"
"ì§€ ì•Šì€ ë™ì‘ì´ ë°œìƒí•˜ê²Œ ë©ë‹ˆë‹¤."

#: src/07_threads/11_locks.md:153
msgid "Our challenges"
msgstr "ë„ì „ê³¼ì œ"

#: src/07_threads/11_locks.md:155
msgid "Summing it up:"
msgstr "ìš”ì•½í•˜ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/07_threads/11_locks.md:157
msgid ""
"We can't send a `MutexGuard` over a channel. So we can't lock on the server-"
"side and then modify the ticket on the client-side."
msgstr ""
"ì±„ë„ì„ í†µí•´ `MutexGuard`ë¥¼ ë³´ë‚¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ì„œë²„ ì¸¡ì„ ì ê·¼ ë‹¤ìŒ í´ë¼ì´"
"ì–¸íŠ¸ ì¸¡ì—ì„œ í‹°ì¼“ì„ ìˆ˜ì •í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/07_threads/11_locks.md:159
msgid ""
"We can send a `Mutex` over a channel because it's `Send` as long as the data "
"it protects is `Send`, which is the case for `Ticket`. At the same time, we "
"can't move the `Mutex` out of the `TicketStore` nor clone it."
msgstr ""
"ë³´í˜¸í•˜ëŠ” ë°ì´í„°ê°€ `Send`ì¸ í•œ `Send`ì´ê¸° ë•Œë¬¸ì— ì±„ë„ì„ í†µí•´ `Mutex`ë¥¼ ë³´ë‚¼ ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤. ì´ëŠ” `Ticket`ì˜ ê²½ìš°ì…ë‹ˆë‹¤. ë™ì‹œì— `TicketStore`ì—ì„œ `Mutex`ë¥¼ ì´ë™"
"í•˜ê±°ë‚˜ ë³µì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/07_threads/11_locks.md:163
msgid ""
"How can we solve this conundrum?  \n"
"We need to look at the problem from a different angle. To lock a `Mutex`, we "
"don't need an owned value. A shared reference is enough, since `Mutex` uses "
"internal mutability:"
msgstr ""
"ì´ ìˆ˜ìˆ˜ê»˜ë¼ë¥¼ ì–´ë–»ê²Œ í•´ê²°í•  ìˆ˜ ìˆì„ê¹Œìš”?  \n"
"ìš°ë¦¬ëŠ” ë‹¤ë¥¸ ê°ë„ì—ì„œ ë¬¸ì œë¥¼ ë³¼ í•„ìš”ê°€ ìˆìŠµë‹ˆë‹¤. `Mutex`ë¥¼ ì ê¸€ ë•Œ ê°’ì„ ì†Œìœ  "
"í•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤. `Mutex`ëŠ” ë‚´ë¶€ ê°€ë³€ì„±ì„ ì‚¬ìš©í•˜ë¯€ë¡œ ê³µìœ  ì°¸ì¡°ë¡œ ì¶©ë¶„í•©ë‹ˆë‹¤."

#: src/07_threads/11_locks.md:169
msgid "// `&self`, not `self`!\n"
msgstr "// `self`ê°€ ì•„ë‹ˆë¼ `&self`!\n"

#: src/07_threads/11_locks.md:171
msgid "// Implementation details\n"
msgstr "// ì„¸ë¶€ êµ¬í˜„\n"

#: src/07_threads/11_locks.md:176
msgid ""
"It is therefore enough to send a shared reference to the client.  \n"
"We can't do that directly, though, because the reference would have to be "
"`'static` and that's not the case.  \n"
"In a way, we need an \"owned shared reference\". It turns out that Rust has a "
"type that fits the bill: `Arc`."
msgstr ""
"ë”°ë¼ì„œ í´ë¼ì´ì–¸íŠ¸ì— ê³µìœ  ì°¸ì¡°ë¥¼ ë³´ë‚´ëŠ” ê²ƒìœ¼ë¡œ ì¶©ë¶„í•©ë‹ˆë‹¤.  \n"
"í•˜ì§€ë§Œ ì°¸ì¡°ëŠ” `'static`ì´ì–´ì•¼ í•˜ëŠ”ë° ê·¸ë ‡ì§€ ì•Šê¸° ë•Œë¬¸ì— ì§ì ‘ì ìœ¼ë¡œ ê·¸ë ‡ê²Œ í•  "
"ìˆ˜ëŠ” ì—†ìŠµë‹ˆë‹¤.  \n"
"ì–´ë–¤ ë©´ì—ì„œëŠ” \"ì†Œìœ ëœ ê³µìœ  ì°¸ì¡°\"ê°€ í•„ìš”í•©ë‹ˆë‹¤. Rustì—ëŠ” `Arc`ë¼ëŠ” ìš°ë¦¬ ëª©ì "
"ì— ë§ëŠ” íƒ€ì…ì´ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/11_locks.md:180
msgid "`Arc` to the rescue"
msgstr "ìš°ë¦¬ë¥¼ êµ¬ì›í•´ì¤„ `Arc`"

#: src/07_threads/11_locks.md:182
msgid ""
"`Arc` stands for **atomic reference counting**.  \n"
"`Arc` wraps around a value and keeps track of how many references to the "
"value exist. When the last reference is dropped, the value is deallocated.  \n"
"The value wrapped in an `Arc` is immutable: you can only get shared "
"references to it."
msgstr ""
"`Arc`ëŠ” **ì›ì ì°¸ì¡° ì¹´ìš´íŒ…**ì„ ì˜ë¯¸í•©ë‹ˆë‹¤.  \n"
"`Arc`ëŠ” ê°’ì„ ê°ì‹¸ê³  í•´ë‹¹ ê°’ì— ëŒ€í•œ ì°¸ì¡°ê°€ ì–¼ë§ˆë‚˜ ë§ì´ ì¡´ì¬í•˜ëŠ”ì§€ ì¶”ì í•©ë‹ˆë‹¤. "
"ë§ˆì§€ë§‰ ì°¸ì¡°ê°€ ì‚­ì œë˜ë©´ ê°’ì˜ í• ë‹¹ì´ ì·¨ì†Œë©ë‹ˆë‹¤.  \n"
"`Arc`ì— í¬í•¨ëœ ê°’ì€ ë³€ê²½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì´ì— ëŒ€í•œ ê³µìœ  ì°¸ì¡°ë§Œ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆ"
"ë‹¤."

#: src/07_threads/11_locks.md:192
msgid ""
"// `Arc<T>` implements `Deref<T>`, so can convert \n"
"// a `&Arc<T>` to a `&T` using deref coercion\n"
msgstr ""
"// `Arc<T>`ëŠ” `Deref<T>`ë¥¼ êµ¬í˜„í•˜ë¯€ë¡œ\n"
"// deref coercionì„ ì‚¬ìš©í•˜ì—¬ `&Arc<T>`ë¥¼ `&T`ë¡œ ë³€í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤\n"

#: src/07_threads/11_locks.md:198
msgid ""
"If you're having a dÃ©jÃ  vu moment, you're right: `Arc` sounds very similar to "
"`Rc`, the reference-counted pointer we introduced when talking about interior "
"mutability. The difference is thread-safety: `Rc` is not `Send`, while `Arc` "
"is. It boils down to the way the reference count is implemented: `Rc` uses a "
"\"normal\" integer, while `Arc` uses an **atomic** integer, which can be "
"safely shared and modified across threads."
msgstr ""
"ë°ìë·°ë¥¼ ê²ªê³  ê³„ì‹œë‹¤ë©´ ë§ìŠµë‹ˆë‹¤. `Arc`ëŠ” ë‚´ë¶€ ê°€ë³€ì„±ì— ëŒ€í•´ ì´ì•¼ê¸°í•  ë•Œ ì†Œê°œ"
"í•œ ì°¸ì¡° ì¹´ìš´íŠ¸ í¬ì¸í„°ì¸ `Rc`ì™€ ë§¤ìš° ìœ ì‚¬í•´ ë³´ì…ë‹ˆë‹¤. ì°¨ì´ì ì€ ìŠ¤ë ˆë“œ ì•ˆì „ì„±ì…"
"ë‹ˆë‹¤. `Rc`ëŠ” `Send`ê°€ ì•„ë‹ˆì§€ë§Œ `Arc`ëŠ” ê·¸ë ‡ìŠµë‹ˆë‹¤. ì´ëŠ” ì°¸ì¡° ì¹´ìš´íŠ¸ê°€ êµ¬í˜„ë˜"
"ëŠ” ë°©ì‹ìœ¼ë¡œ ìš”ì•½ë©ë‹ˆë‹¤. `Rc`ëŠ” \"ì¼ë°˜\" ì •ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°˜ë©´, `Arc`ëŠ” ìŠ¤ë ˆë“œ "
"ê°„ì— ì•ˆì „í•˜ê²Œ ê³µìœ ë˜ê³  ìˆ˜ì •ë  ìˆ˜ ìˆëŠ” **ì›ì** ì •ìˆ˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/07_threads/11_locks.md:203
msgid "`Arc<Mutex<T>>`"
msgstr "`Arc<Mutex<T>>`"

#: src/07_threads/11_locks.md:205
msgid "If we pair `Arc` with `Mutex`, we finally get a type that:"
msgstr ""
"`Arc`ì™€ `Mutex`ë¥¼ ìŒìœ¼ë¡œ ì‚¬ìš©í•˜ë©´ ë§ˆì¹¨ë‚´ ë‹¤ìŒê³¼ ê°™ì€ íƒ€ì…ì„ ì–»ê²Œ ë©ë‹ˆë‹¤."

#: src/07_threads/11_locks.md:207
msgid "Can be sent between threads, because:"
msgstr "ë‹¤ìŒê³¼ ê°™ì€ ì´ìœ ë¡œ ìŠ¤ë ˆë“œ ê°„ì— ì „ì†¡ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: src/07_threads/11_locks.md:208
msgid "`Arc` is `Send` if `T` is `Send`, and"
msgstr "`T`ê°€ `Send`ì´ë©´ `Arc`ëŠ” `Send`ì´ê³ "

#: src/07_threads/11_locks.md:209
msgid "`Mutex` is `Send` if `T` is `Send`."
msgstr "`T`ê°€ `Send`ì´ë©´ `Mutex`ëŠ” `Send`ì…ë‹ˆë‹¤."

#: src/07_threads/11_locks.md:210
msgid "`T` is `Ticket`, which is `Send`."
msgstr "`T`ëŠ” `Ticket`, ì¦‰ `Send`ì…ë‹ˆë‹¤."

#: src/07_threads/11_locks.md:211
msgid ""
"Can be cloned, because `Arc` is `Clone` no matter what `T` is. Cloning an "
"`Arc` increments the reference count, the data is not copied."
msgstr ""
"`T`ê°€ ë¬´ì—‡ì´ë“  `Arc`ëŠ” `Clone`ì´ê¸° ë•Œë¬¸ì— ë³µì œë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `Arc`ë¥¼ ë³µì œí•˜"
"ë©´ ì°¸ì¡° ì¹´ìš´íŠ¸ê°€ ì¦ê°€í•˜ì§€ë§Œ ë°ì´í„°ëŠ” ë³µì‚¬ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/07_threads/11_locks.md:213
msgid ""
"Can be used to modify the data it wraps, because `Arc` lets you get a shared "
"reference to `Mutex<T>` which can in turn be used to acquire a lock."
msgstr ""
"`Arc`ë¥¼ ì‚¬ìš©í•˜ë©´ ì ê¸ˆì„ íšë“í•˜ëŠ” ë° ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” `Mutex<T>`ì— ëŒ€í•œ ê³µìœ  ì°¸ì¡°"
"ë¥¼ ì–»ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë˜í•‘ëœ ë°ì´í„°ë¥¼ ìˆ˜ì •í•˜ëŠ” ë° ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/11_locks.md:216
msgid ""
"We have all the pieces we need to implement the locking strategy for our "
"ticket store."
msgstr ""
"ìš°ë¦¬ëŠ” í‹°ì¼“ ìŠ¤í† ì–´ì˜ ì ê¸ˆ ì „ëµì„ êµ¬í˜„í•˜ëŠ” ë° í•„ìš”í•œ ëª¨ë“  ìš”ì†Œë¥¼ â€‹â€‹ê°–ì¶”ê³  ìˆìŠµë‹ˆ"
"ë‹¤."

#: src/07_threads/11_locks.md:220
msgid ""
"We won't be covering the details of atomic operations in this course, but you "
"can find more information [in the `std` documentation](https://doc.rust-lang."
"org/std/sync/atomic/index.html) as well as in the [\"Rust atomics and locks\" "
"book](https://marabos.nl/atomics/)."
msgstr ""
"ì´ ê³¼ì •ì—ì„œëŠ” ì›ì ì—°ì‚°ì— ëŒ€í•œ ì„¸ë¶€ ì‚¬í•­ì„ ë‹¤ë£¨ì§€ ì•Šì§€ë§Œ [`std` ë¬¸ì„œ](https://"
"doc.rust-lang.org/std/sync/atomic/index.html)ì™€ [\"Rust atomics and locks\" "
"book](https://marabos.nl/atomics/) ì±…ì—ì„œ ë” ë§ì€ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/11_locks.md:226
msgid ""
"The exercise for this section is located in [`07_threads/11_locks`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/11_locks)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`07_threads/11_locks`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/11_locks)ì— ìˆìŠµë‹ˆë‹¤"

#: src/07_threads/12_rw_lock.md:1
msgid "Readers and writers"
msgstr "Readersì™€ writers"

#: src/07_threads/12_rw_lock.md:3
msgid ""
"Our new `TicketStore` works, but its read performance is not great: there can "
"only be one client at a time reading a specific ticket, because `Mutex<T>` "
"doesn't distinguish between readers and writers."
msgstr ""
"ìƒˆë¡œìš´ `TicketStore`ëŠ” ì‘ë™í•˜ì§€ë§Œ ì½ê¸° ì„±ëŠ¥ì€ ì¢‹ì§€ ì•ŠìŠµë‹ˆë‹¤. `Mutex<T>`ëŠ” ë¦¬ë”"
"ì™€ ë¼ì´í„°ë¥¼ êµ¬ë³„í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— íŠ¹ì • í‹°ì¼“ì„ í•œ ë²ˆì— í•˜ë‚˜ì˜ í´ë¼ì´ì–¸íŠ¸ë§Œ ì½ì„ "
"ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/12_rw_lock.md:6
msgid ""
"We can solve the issue by using a different locking primitive: "
"`RwLock<T>`.  \n"
"`RwLock<T>` stands for **read-write lock**. It allows **multiple readers** to "
"access the data simultaneously, but only one writer at a time."
msgstr ""
"ë‹¤ë¥¸ ì ê¸ˆ ê¸°ë³¸ ìš”ì†Œì¸ `RwLock<T>`ë¥¼ ì‚¬ìš©í•˜ì—¬ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"`RwLock<T>`ëŠ” **ì½ê¸°-ì“°ê¸° ì ê¸ˆ**ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. **ì—¬ëŸ¬ ë¦¬ë”**ê°€ ë™ì‹œì— ë°ì´í„°"
"ì— ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆì§€ë§Œ í•œ ë²ˆì— í•œ ëª…ì˜ ë¼ì´í„°ë§Œ ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/12_rw_lock.md:10
msgid ""
"`RwLock<T>` has two methods to acquire a lock: `read` and `write`.  \n"
"`read` returns a guard that allows you to read the data, while `write` "
"returns a guard that allows you to modify it."
msgstr ""
"`RwLock<T>`ì—ëŠ” ì ê¸ˆì„ íšë“í•˜ëŠ” ë‘ ê°€ì§€ ë°©ë²•, `ì½ê¸°`ì™€ `ì“°ê¸°`ê°€ ìˆìŠµë‹ˆë‹¤.  \n"
"`read`ëŠ” ë°ì´í„°ë¥¼ ì½ì„ ìˆ˜ ìˆëŠ” ê°€ë“œë¥¼ ë°˜í™˜í•˜ê³ , `write`ëŠ” ë°ì´í„°ë¥¼ ìˆ˜ì •í•  ìˆ˜ "
"ìˆëŠ” ê°€ë“œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."

#: src/07_threads/12_rw_lock.md:15
msgid "// An integer protected by a read-write lock\n"
msgstr "// ì½ê¸°-ì“°ê¸° ì ê¸ˆìœ¼ë¡œ ë³´í˜¸ë˜ëŠ” ì •ìˆ˜\n"

#: src/07_threads/12_rw_lock.md:18
msgid "// Acquire a read lock on the RwLock\n"
msgstr "// RwLockì— ëŒ€í•œ ì½ê¸° ì ê¸ˆì„ íšë“í•©ë‹ˆë‹¤\n"

#: src/07_threads/12_rw_lock.md:21
msgid ""
"// Acquire a **second** read lock\n"
"// while the first one is still active\n"
msgstr ""
"// ì²« ë²ˆì§¸ ì½ê¸° ì ê¸ˆì´ ì•„ì§ í™œì„±í™”ë˜ì–´ ìˆëŠ” ë™ì•ˆ\n"
"// **ë‘ ë²ˆì§¸** ì½ê¸° ì ê¸ˆì„ íšë“í•©ë‹ˆë‹¤\n"

#: src/07_threads/12_rw_lock.md:27
msgid "Trade-offs"
msgstr "ì¥ë‹¨ì "

#: src/07_threads/12_rw_lock.md:29
msgid ""
"On the surface, `RwLock<T>` seems like a no-brainer: it provides a superset "
"of the functionality of `Mutex<T>`. Why would you ever use `Mutex<T>` if you "
"can use `RwLock<T>` instead?"
msgstr ""
"í‘œë©´ì ìœ¼ë¡œ `RwLock<T>`ëŠ” ë‹¹ì—°í•œ ê²ƒì²˜ëŸ¼ ë³´ì…ë‹ˆë‹¤. ì´ëŠ” `Mutex<T>` ê¸°ëŠ¥ì˜ ìƒìœ„ "
"ì§‘í•©ì„ ì œê³µí•©ë‹ˆë‹¤. `RwLock<T>`ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ”ë° ì™œ `Mutex<T>`ë¥¼ ì‚¬ìš©í• ê¹Œìš”?"

#: src/07_threads/12_rw_lock.md:32
msgid "There are two key reasons:"
msgstr "ë‘ ê°€ì§€ ì£¼ìš” ì´ìœ ê°€ ìˆìŠµë‹ˆë‹¤:"

#: src/07_threads/12_rw_lock.md:34
msgid ""
"Locking a `RwLock<T>` is more expensive than locking a `Mutex<T>`.  \n"
"This is because `RwLock<T>` has to keep track of the number of active readers "
"and writers, while `Mutex<T>` only has to keep track of whether the lock is "
"held or not. This performance overhead is not an issue if there are more "
"readers than writers, but if the workload is write-heavy `Mutex<T>` might be "
"a better choice."
msgstr ""
"`RwLock<T>`ì„ ì ê·¸ëŠ” ê²ƒì€ `Mutex<T>`ë¥¼ ì ê·¸ëŠ” ê²ƒë³´ë‹¤ ë¹„ìš©ì´ ë” ë§ì´ ë“­ë‹ˆ"
"ë‹¤.  \n"
"ì´ëŠ” `RwLock<T>`ì´ í™œì„± íŒë…ê¸°ì™€ ê¸°ë¡ê¸°ì˜ ìˆ˜ë¥¼ ì¶”ì í•´ì•¼ í•˜ëŠ” ë°˜ë©´ `Mutex<T>`"
"ëŠ” ì ê¸ˆì´ ìœ ì§€ë˜ëŠ”ì§€ ì—¬ë¶€ë§Œ ì¶”ì í•˜ë©´ ë˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ì´ ì„±ëŠ¥ ì˜¤ë²„í—¤ë“œëŠ” ì‘ì„±"
"ê¸°ë³´ë‹¤ íŒë…ê¸°ê°€ ë” ë§ì€ ê²½ìš° ë¬¸ì œê°€ ë˜ì§€ ì•Šì§€ë§Œ ì‘ì—… ë¶€í•˜ê°€ ì“°ê¸°ê°€ ë§ì€ ê²½ìš° "
"`Mutex<T>`ê°€ ë” ë‚˜ì€ ì„ íƒì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/12_rw_lock.md:39
msgid ""
"`RwLock<T>` can cause **writer starvation**.  \n"
"If there are always readers waiting to acquire the lock, writers might never "
"get a chance to run.  \n"
"`RwLock<T>` doesn't provide any guarantees about the order in which readers "
"and writers are granted access to the lock. It depends on the policy "
"implemented by the underlying OS, which might not be fair to writers."
msgstr ""
"`RwLock<T>`ëŠ” **ì‘ì„±ê¸° ê¸°ì•„**ë¥¼ ìœ ë°œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"ì ê¸ˆì„ íšë“í•˜ê¸° ìœ„í•´ ëŒ€ê¸°í•˜ëŠ” íŒë…ê¸°ê°€ í•­ìƒ ìˆëŠ” ê²½ìš° ì‘ì„±ìëŠ” ì‹¤í–‰í•  ê¸°íšŒë¥¼ "
"ì–»ì§€ ëª»í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.  \n"
"`RwLock<T>`ëŠ” íŒë…ê¸°ì™€ ê¸°ë¡ê¸°ì—ê²Œ ì ê¸ˆì— ëŒ€í•œ ì•¡ì„¸ìŠ¤ ê¶Œí•œì´ ë¶€ì—¬ë˜ëŠ” ìˆœì„œì— ëŒ€"
"í•´ ì–´ë– í•œ ë³´ì¥ë„ ì œê³µí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì´ëŠ” ê¸°ë³¸ OSì—ì„œ êµ¬í˜„í•˜ëŠ” ì •ì±…ì— ë”°ë¼ ë‹¬ë¼"
"ì§€ë©°, ì´ëŠ” ì‘ì„±ìì—ê²Œ ê³µí‰í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/07_threads/12_rw_lock.md:44
msgid ""
"In our case, we can expect the workload to be read-heavy (since most clients "
"will be reading tickets, not modifying them), so `RwLock<T>` is a good choice."
msgstr ""
"ìš°ë¦¬ì˜ ê²½ìš° ì‘ì—…ëŸ‰ì´ ì½ê¸° ì¤‘ì‹¬ì¼ ê²ƒìœ¼ë¡œ ì˜ˆìƒí•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ(ëŒ€ë¶€ë¶„ì˜ í´ë¼ì´ì–¸íŠ¸"
"ëŠ” í‹°ì¼“ì„ ìˆ˜ì •í•˜ì§€ ì•Šê³  ì½ê¸° ë•Œë¬¸ì—) `RwLock<T>`ì„ ì„ íƒí•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤."

#: src/07_threads/12_rw_lock.md:49
msgid ""
"The exercise for this section is located in [`07_threads/12_rw_lock`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/12_rw_lock)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`07_threads/12_rw_lock`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/12_rw_lock)ì— ìˆìŠµë‹ˆë‹¤"

#: src/07_threads/13_without_channels.md:1
msgid "Design review"
msgstr "ë””ìì¸ ë¦¬ë·°"

#: src/07_threads/13_without_channels.md:3
msgid "Let's take a moment to review the journey we've been through."
msgstr "ì ì‹œ ìš°ë¦¬ê°€ ê²ªì–´ì˜¨ ì—¬ì •ì„ ë˜ëŒì•„ë³´ê² ìŠµë‹ˆë‹¤."

#: src/07_threads/13_without_channels.md:5
msgid "Lockless with channel serialization"
msgstr "ì±„ë„ ì§ë ¬í™”ë¥¼ í†µí•œ ì ê¸ˆ ì—†ìŒ"

#: src/07_threads/13_without_channels.md:7
msgid "Our first implementation of a multithreaded ticket store used:"
msgstr "ì‚¬ìš©ëœ ë©€í‹°ìŠ¤ë ˆë“œ í‹°ì¼“ ì €ì¥ì†Œì˜ ì²« ë²ˆì§¸ êµ¬í˜„ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: src/07_threads/13_without_channels.md:9
msgid "a single long-lived thread (server), to hold the shared state"
msgstr "ê³µìœ  ìƒíƒœë¥¼ ìœ ì§€í•˜ê¸° ìœ„í•œ ë‹¨ì¼ ìˆ˜ëª…ì´ ê¸´ ìŠ¤ë ˆë“œ(ì„œë²„)"

#: src/07_threads/13_without_channels.md:10
msgid ""
"multiple clients sending requests to it via channels from their own threads."
msgstr "ì—¬ëŸ¬ í´ë¼ì´ì–¸íŠ¸ê°€ ìì²´ ìŠ¤ë ˆë“œì˜ ì±„ë„ì„ í†µí•´ ìš”ì²­ì„ ë³´ëƒ…ë‹ˆë‹¤."

#: src/07_threads/13_without_channels.md:12
msgid ""
"No locking of the state was necessary, since the server was the only one "
"modifying the state. That's because the \"inbox\" channel naturally "
"**serialized** incoming requests: the server would process them one by "
"one.  \n"
"We've already discussed the limitations of this approach when it comes to "
"patching behaviour, but we didn't discuss the performance implications of the "
"original design: the server could only process one request at a time, "
"including reads."
msgstr ""
"ì„œë²„ê°€ ìƒíƒœë¥¼ ìˆ˜ì •í•˜ëŠ” ìœ ì¼í•œ ì„œë²„ì˜€ìœ¼ë¯€ë¡œ ìƒíƒœ ì ê¸ˆì´ í•„ìš”í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. "
"ê·¸ ì´ìœ ëŠ” \"ë°›ì€ í¸ì§€í•¨\" ì±„ë„ì´ ë“¤ì–´ì˜¤ëŠ” ìš”ì²­ì„ ìì—°ìŠ¤ëŸ½ê²Œ **ì§ë ¬í™”**í–ˆê¸° ë•Œ"
"ë¬¸ì…ë‹ˆë‹¤. ì„œë²„ëŠ” ìš”ì²­ì„ í•˜ë‚˜ì”© ì²˜ë¦¬í•©ë‹ˆë‹¤.  \n"
"íŒ¨ì¹˜ ë™ì‘ê³¼ ê´€ë ¨í•˜ì—¬ ì´ ì ‘ê·¼ ë°©ì‹ì˜ í•œê³„ì— ëŒ€í•´ ì´ë¯¸ ë…¼ì˜í–ˆì§€ë§Œ ì›ë˜ ì„¤ê³„ì˜ ì„±"
"ëŠ¥ ì˜í–¥ì— ëŒ€í•´ì„œëŠ” ë…¼ì˜í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì„œë²„ëŠ” ì½ê¸°ë¥¼ í¬í•¨í•˜ì—¬ í•œ ë²ˆì— í•˜ë‚˜ì˜ "
"ìš”ì²­ë§Œ ì²˜ë¦¬í•  ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤."

#: src/07_threads/13_without_channels.md:18
msgid "Fine-grained locking"
msgstr "ì„¸ë¶„í™”ëœ ì ê¸ˆ"

#: src/07_threads/13_without_channels.md:20
msgid ""
"We then moved to a more sophisticated design, where each ticket was protected "
"by its own lock and clients could independently decide if they wanted to read "
"or atomically modify a ticket, acquiring the appropriate lock."
msgstr ""
"ê·¸ëŸ° ë‹¤ìŒ ê° í‹°ì¼“ì´ ìì²´ ì ê¸ˆìœ¼ë¡œ ë³´í˜¸ë˜ê³  í´ë¼ì´ì–¸íŠ¸ê°€ í‹°ì¼“ì„ ì½ì„ì§€ ë˜ëŠ” ì›"
"ìì ìœ¼ë¡œ ìˆ˜ì •í• ì§€ ì—¬ë¶€ë¥¼ ë…ë¦½ì ìœ¼ë¡œ ê²°ì •í•˜ì—¬ ì ì ˆí•œ ì ê¸ˆì„ íšë“í•  ìˆ˜ ìˆëŠ” ë³´"
"ë‹¤ ì •êµí•œ ë””ìì¸ìœ¼ë¡œ ì „í™˜í–ˆìŠµë‹ˆë‹¤."

#: src/07_threads/13_without_channels.md:23
msgid ""
"This design allows for better parallelism (i.e. multiple clients can read "
"tickets at the same time), but it is still fundamentally **serial**: the "
"server processes commands one by one. In particular, it hands out locks to "
"clients one by one."
msgstr ""
"ì´ ë””ìì¸ì€ ë” ë‚˜ì€ ë³‘ë ¬ ì²˜ë¦¬ë¥¼ í—ˆìš©í•˜ì§€ë§Œ(ì¦‰, ì—¬ëŸ¬ í´ë¼ì´ì–¸íŠ¸ê°€ ë™ì‹œì— í‹°ì¼“"
"ì„ ì½ì„ ìˆ˜ ìˆìŒ) ê¸°ë³¸ì ìœ¼ë¡œëŠ” ì—¬ì „íˆ **ì§ë ¬**ì…ë‹ˆë‹¤. ì¦‰, ì„œë²„ê°€ ëª…ë ¹ì„ í•˜ë‚˜ì”© "
"ì²˜ë¦¬í•©ë‹ˆë‹¤. íŠ¹íˆ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ í•˜ë‚˜ì”© ì ê¸ˆì„ ì „ë‹¬í•©ë‹ˆë‹¤."

#: src/07_threads/13_without_channels.md:27
msgid ""
"Could we remove the channels entirely and allow clients to directly access "
"the `TicketStore`, relying exclusively on locks to synchronize access?"
msgstr ""
"ì±„ë„ì„ ì™„ì „íˆ ì œê±°í•˜ê³  í´ë¼ì´ì–¸íŠ¸ê°€ ì•¡ì„¸ìŠ¤ë¥¼ ë™ê¸°í™”í•˜ê¸° ìœ„í•´ ì ê¸ˆì—ë§Œ ì˜ì¡´í•˜"
"ì—¬ `TicketStore`ì— ì§ì ‘ ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆë„ë¡ í—ˆìš©í•  ìˆ˜ ìˆìŠµë‹ˆê¹Œ?"

#: src/07_threads/13_without_channels.md:30
msgid "Removing channels"
msgstr "ì±„ë„ ì‚­ì œ"

#: src/07_threads/13_without_channels.md:32
msgid "We have two problems to solve:"
msgstr "í•´ê²°í•´ì•¼ í•  ë‘ ê°€ì§€ ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤:"

#: src/07_threads/13_without_channels.md:34
#: src/07_threads/13_without_channels.md:37
msgid "Sharing `TicketStore` across threads"
msgstr "ìŠ¤ë ˆë“œ ê°„ì— `TicketStore` ê³µìœ "

#: src/07_threads/13_without_channels.md:35
#: src/07_threads/13_without_channels.md:43
msgid "Synchronizing access to the store"
msgstr "ìŠ¤í† ì–´ì— ëŒ€í•œ ì•¡ì„¸ìŠ¤ ë™ê¸°í™”"

#: src/07_threads/13_without_channels.md:39
msgid ""
"We want all threads to refer to the same state, otherwise we don't really "
"have a multithreaded systemâ€”we're just running multiple single-threaded "
"systems in parallel.  \n"
"We've already encountered this problem when we tried to share a lock across "
"threads: we can use an `Arc`."
msgstr ""
"ìš°ë¦¬ëŠ” ëª¨ë“  ìŠ¤ë ˆë“œê°€ ë™ì¼í•œ ìƒíƒœë¥¼ ì°¸ì¡°í•˜ê¸°ë¥¼ ì›í•©ë‹ˆë‹¤. ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ì‹¤ì œë¡œ"
"ëŠ” ë©€í‹°ìŠ¤ë ˆë“œ ì‹œìŠ¤í…œì´ ì•„ë‹™ë‹ˆë‹¤. ë‹¨ì§€ ì—¬ëŸ¬ ë‹¨ì¼ ìŠ¤ë ˆë“œ ì‹œìŠ¤í…œì„ ë³‘ë ¬ë¡œ ì‹¤í–‰í•˜"
"ëŠ” ê²ƒë¿ì…ë‹ˆë‹¤.  \n"
"ìŠ¤ë ˆë“œ ê°„ì— ì ê¸ˆì„ ê³µìœ í•˜ë ¤ê³  í•  ë•Œ ì´ë¯¸ ì´ ë¬¸ì œì— ì§ë©´í–ˆìŠµë‹ˆë‹¤. `Arc`ë¥¼ ì‚¬ìš©"
"í•˜ë©´ ë©ë‹ˆë‹¤."

#: src/07_threads/13_without_channels.md:45
msgid ""
"There is one interaction that's still lockless thanks to the serialization "
"provided by the channels: inserting (or removing) a ticket from the store.  \n"
"If we remove the channels, we need to introduce (another) lock to synchronize "
"access to the `TicketStore` itself."
msgstr ""
"ì±„ë„ì—ì„œ ì œê³µí•˜ëŠ” ì§ë ¬í™” ë•ë¶„ì— ì—¬ì „íˆ ì ê¸ˆì´ í•´ì œëœ ìƒí˜¸ ì‘ìš©ì´ í•˜ë‚˜ ìˆìŠµë‹ˆ"
"ë‹¤. ë°”ë¡œ ë§¤ì¥ì—ì„œ í‹°ì¼“ì„ ì‚½ì…(ë˜ëŠ” ì œê±°)í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.  \n"
"ì±„ë„ì„ ì œê±°í•˜ëŠ” ê²½ìš° `TicketStore` ìì²´ì— ëŒ€í•œ ì•¡ì„¸ìŠ¤ë¥¼ ë™ê¸°í™”í•˜ê¸° ìœ„í•´ (ë˜ ë‹¤"
"ë¥¸) ì ê¸ˆì´ í•„ìš”í•©ë‹ˆë‹¤."

#: src/07_threads/13_without_channels.md:49
msgid ""
"If we use a `Mutex`, then it makes no sense to use an additional `RwLock` for "
"each ticket: the `Mutex` will already serialize access to the entire store, "
"so we wouldn't be able to read tickets in parallel anyway.  \n"
"If we use a `RwLock`, instead, we can read tickets in parallel. We just need "
"to pause all reads while inserting or removing a ticket."
msgstr ""
"`Mutex`ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš° ê° í‹°ì¼“ì— ì¶”ê°€ `RwLock`ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì€ ì˜ë¯¸ê°€ ì—†ìŠµë‹ˆ"
"ë‹¤. `Mutex`ëŠ” ì´ë¯¸ ì „ì²´ ë§¤ì¥ì— ëŒ€í•œ ì•¡ì„¸ìŠ¤ë¥¼ ì§ë ¬í™”í•˜ë¯€ë¡œ ì–´ì¨Œë“  í‹°ì¼“ì„ ë³‘ë ¬"
"ë¡œ ì½ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. .  \n"
"ëŒ€ì‹  `RwLock`ì„ ì‚¬ìš©í•˜ë©´ í‹°ì¼“ì„ ë³‘ë ¬ë¡œ ì½ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. í‹°ì¼“ì„ ì‚½ì…í•˜ê±°ë‚˜ ì œ"
"ê±°í•˜ëŠ” ë™ì•ˆ ëª¨ë“  ì½ê¸°ë¥¼ ì¼ì‹œ ì¤‘ì§€í•˜ë©´ ë©ë‹ˆë‹¤."

#: src/07_threads/13_without_channels.md:54
msgid "Let's go down this path and see where it leads us."
msgstr "ì´ ì ‘ê·¼ ë°©ì‹ì„ ë”°ë¼ê°€ë´…ì‹œë‹¤."

#: src/07_threads/13_without_channels.md:58
msgid ""
"The exercise for this section is located in [`07_threads/13_without_channels`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/13_without_channels)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`07_threads/13_without_channels`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/13_without_channels)ì— ìˆìŠµë‹ˆë‹¤"

#: src/07_threads/14_sync.md:1
msgid "`Sync`"
msgstr "`Sync`"

#: src/07_threads/14_sync.md:3
msgid ""
"Before we wrap up this chapter, let's talk about another key trait in Rust's "
"standard library: `Sync`."
msgstr ""
"ì´ ì¥ì„ ë§ˆë¬´ë¦¬í•˜ê¸° ì „ì— Rust í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ ë˜ ë‹¤ë¥¸ í•µì‹¬ íŠ¸ë ˆì‡ì¸ `Sync`ì— "
"ëŒ€í•´ ì´ì•¼ê¸°í•´ ë³´ê² ìŠµë‹ˆë‹¤."

#: src/07_threads/14_sync.md:5
msgid ""
"`Sync` is an auto trait, just like `Send`.  \n"
"It is automatically implemented by all types that can be safely **shared** "
"between threads."
msgstr ""
"`Sync`ëŠ” `Send`ì™€ ë§ˆì°¬ê°€ì§€ë¡œ ì˜¤í†  íŠ¸ë ˆì‡ì…ë‹ˆë‹¤.  \n"
"ìŠ¤ë ˆë“œ ê°„ì— ì•ˆì „í•˜ê²Œ **ê³µìœ **í•  ìˆ˜ ìˆëŠ” ëª¨ë“  íƒ€ì…ì— ëŒ€í•´ ìë™ìœ¼ë¡œ êµ¬í˜„ë©ë‹ˆë‹¤."

#: src/07_threads/14_sync.md:8
msgid "In order words: `T: Sync` means that `&T` is `Send`."
msgstr "ì¦‰, `T: Sync`ëŠ” `&T`ê°€ `Send`ì„ì„ ì˜ë¯¸í•©ë‹ˆë‹¤."

#: src/07_threads/14_sync.md:10
msgid "`Sync` doesn't imply `Send`"
msgstr "`Sync`ëŠ” `Send`ë¥¼ ëœ»í•˜ëŠ”ê²Œ ì•„ë‹™ë‹ˆë‹¤"

#: src/07_threads/14_sync.md:12
msgid ""
"It's important to note that `Sync` doesn't imply `Send`.  \n"
"For example: `MutexGuard` is not `Send`, but it is `Sync`."
msgstr ""
"`Sync`ëŠ” `Send`ë¥¼ ì˜ë¯¸í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì ì— ìœ ì˜í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.  \n"
"ì˜ˆë¥¼ ë“¤ì–´ `MutexGuard`ëŠ” `Send`ê°€ ì•„ë‹ˆì§€ë§Œ `Sync`ì…ë‹ˆë‹¤."

#: src/07_threads/14_sync.md:15
msgid ""
"It isn't `Send` because the lock must be released on the same thread that "
"acquired it, therefore we don't want `MutexGuard` to be dropped on a "
"different thread.  \n"
"But it is `Sync`, because giving a `&MutexGuard` to another thread has no "
"impact on where the lock is released."
msgstr ""
"ì ê¸ˆì„ íšë“í•œ ë™ì¼í•œ ìŠ¤ë ˆë“œì—ì„œ ì ê¸ˆì„ í•´ì œí•´ì•¼ í•˜ê¸° ë•Œë¬¸ì— `Send`ê°€ ì•„ë‹™ë‹ˆ"
"ë‹¤. ë”°ë¼ì„œ `MutexGuard`ê°€ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ì„œ ì‚­ì œë˜ëŠ” ê²ƒì„ ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.  \n"
"ê·¸ëŸ¬ë‚˜ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì— `&MutexGuard`ë¥¼ ì œê³µí•´ë„ ì ê¸ˆì´ í•´ì œë˜ëŠ” ìœ„ì¹˜ì—ëŠ” ì˜í–¥ì„ "
"ë¯¸ì¹˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ì´ëŠ” `Sync`ì…ë‹ˆë‹¤."

#: src/07_threads/14_sync.md:19
msgid "`Send` doesn't imply `Sync`"
msgstr "`Send`ëŠ” `Sync`ë¥¼ ëœ»í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/07_threads/14_sync.md:21
msgid ""
"The opposite is also true: `Send` doesn't imply `Sync`.  \n"
"For example: `RefCell<T>` is `Send` (if `T` is `Send`), but it is not `Sync`."
msgstr ""
"ê·¸ ë°˜ëŒ€ë„ ë§ˆì°¬ê°€ì§€ì…ë‹ˆë‹¤. `Send`ëŠ” `Sync`ë¥¼ ëœ»í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.  \n"
"ì˜ˆë¥¼ ë“¤ì–´ `RefCell<T>`ëŠ” `Send`(`T`ê°€ `Send`ì¸ ê²½ìš°)ì´ì§€ë§Œ `Sync`ëŠ” ì•„ë‹™ë‹ˆë‹¤."

#: src/07_threads/14_sync.md:24
msgid ""
"`RefCell<T>` performs runtime borrow checking, but the counters it uses to "
"track borrows are not thread-safe. Therefore, having multiple threads holding "
"a `&RefCell` would lead to a data race, with potentially multiple threads "
"obtaining mutable references to the same data. Hence `RefCell` is not "
"`Sync`.  \n"
"`Send` is fine, instead, because when we send a `RefCell` to another thread "
"we're not leaving behind any references to the data it contains, hence no "
"risk of concurrent mutable access."
msgstr ""
"`RefCell<T>`ëŠ” ëŸ°íƒ€ì„ ì°¨ìš© ê²€ì‚¬ë¥¼ ìˆ˜í–‰í•˜ì§€ë§Œ ì°¨ìš©ì„ ì¶”ì í•˜ëŠ” ë° ì‚¬ìš©í•˜ëŠ” ì¹´ìš´"
"í„°ëŠ” ìŠ¤ë ˆë“œë¡œë¶€í„° ì•ˆì „í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë”°ë¼ì„œ `&RefCell`ì„ ë³´ìœ í•˜ëŠ” ì—¬ëŸ¬ ìŠ¤ë ˆë“œ"
"ê°€ ìˆìœ¼ë©´ ë°ì´í„° ê²½ìŸì´ ë°œìƒí•˜ê³  ì ì¬ì ìœ¼ë¡œ ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì¼í•œ ë°ì´í„°ì— ëŒ€"
"í•œ ë³€ê²½ ê°€ëŠ¥í•œ ì°¸ì¡°ë¥¼ ì–»ê²Œ ë©ë‹ˆë‹¤. ë”°ë¼ì„œ `RefCell`ì€ `Sync`ê°€ ì•„ë‹™ë‹ˆë‹¤.  \n"
"ëŒ€ì‹  `Send` ë§ìŠµë‹ˆë‹¤. ì™œëƒí•˜ë©´ `RefCell`ì„ ë‹¤ë¥¸ ìŠ¤ë ˆë“œë¡œ ë³´ë‚¼ ë•Œ í¬í•¨ëœ ë°ì´í„°"
"ì— ëŒ€í•œ ì°¸ì¡°ë¥¼ ë‚¨ê¸°ì§€ ì•Šê³  ë™ì‹œì— ë³€ê²½ ê°€ëŠ¥í•œ ì•¡ì„¸ìŠ¤ê°€ ë°œìƒí•  ìœ„í—˜ì´ ì—†ê¸° ë•Œë¬¸"
"ì…ë‹ˆë‹¤."

#: src/07_threads/14_sync.md:32
msgid ""
"The exercise for this section is located in [`07_threads/14_sync`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/14_sync)"
msgstr ""
"ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” [`07_threads/14_sync`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/14_sync)ì— ìˆìŠµë‹ˆë‹¤"

#: src/08_futures/00_intro.md:1
#, fuzzy
msgid "Async Rust"
msgstr "ë¹„ë™ê¸° ëŸ¬ìŠ¤íŠ¸"

#: src/08_futures/00_intro.md:3
#, fuzzy
msgid ""
"Threads are not the only way to write concurrent programs in Rust.  \n"
"In this chapter we'll explore another approach: **asynchronous programming**."
msgstr ""
"ìŠ¤ë ˆë“œëŠ” Rustì—ì„œ ë™ì‹œì„± í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ëŠ” ìœ ì¼í•œ ë°©ë²•ì€ ì•„ë‹™ë‹ˆë‹¤.  \n"
"ì´ë²ˆ ì¥ì—ì„œëŠ” **ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë°**ì´ë¼ëŠ” ë˜ ë‹¤ë¥¸ ì ‘ê·¼ ë°©ì‹ì„ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤."

#: src/08_futures/00_intro.md:6
#, fuzzy
msgid "In particular, you'll get an introduction to:"
msgstr "íŠ¹íˆ ë‹¤ìŒ ë‚´ìš©ì„ ì†Œê°œí•˜ê²Œ ë©ë‹ˆë‹¤."

#: src/08_futures/00_intro.md:8
#, fuzzy
msgid "The `async`/`.await` keywords, to write asynchronous code effortlessly"
msgstr "ë¹„ë™ê¸° ì½”ë“œë¥¼ ì‰½ê²Œ ì‘ì„±í•˜ê¸° ìœ„í•œ `async`/`.await` í‚¤ì›Œë“œ"

#: src/08_futures/00_intro.md:9
#, fuzzy
msgid ""
"The `Future` trait, to represent computations that may not be complete yet"
msgstr "ì•„ì§ ì™„ë£Œë˜ì§€ ì•Šì€ ê³„ì‚°ì„ ë‚˜íƒ€ë‚´ëŠ” `Future` íŠ¹ì„±"

#: src/08_futures/00_intro.md:10
#, fuzzy
msgid "`tokio`, the most popular runtime for running asynchronous code"
msgstr "ë¹„ë™ê¸° ì½”ë“œ ì‹¤í–‰ì„ ìœ„í•œ ê°€ì¥ ì¸ê¸° ìˆëŠ” ëŸ°íƒ€ì„ì¸ 'tokio'"

#: src/08_futures/00_intro.md:11
#, fuzzy
msgid ""
"The cooperative nature of Rust asynchronous model, and how this affects your "
"code"
msgstr "Rust ë¹„ë™ê¸° ëª¨ë¸ì˜ í˜‘ë ¥ì  íŠ¹ì„±ê³¼ ì´ê²ƒì´ ì½”ë“œì— ë¯¸ì¹˜ëŠ” ì˜í–¥"

#: src/08_futures/00_intro.md:15
msgid ""
"The exercise for this section is located in [`08_futures/00_intro`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/08_futures/00_intro)"
msgstr ""

#: src/08_futures/01_async_fn.md:3
#, fuzzy
msgid ""
"All the functions and methods you've written so far were eager.  \n"
"Nothing happened until you invoked them. But once you did, they ran to "
"completion: they did **all** their work, and then returned their output."
msgstr ""
"ì§€ê¸ˆê¹Œì§€ ì‘ì„±í•œ ëª¨ë“  í•¨ìˆ˜ì™€ ë©”ì†Œë“œëŠ” ì—´ë§ì ì´ì—ˆìŠµë‹ˆë‹¤.  \n"
"ë‹¹ì‹ ì´ ê·¸ë“¤ì„ í˜¸ì¶œí•  ë•Œê¹Œì§€ ì•„ë¬´ ì¼ë„ ì¼ì–´ë‚˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ í•œ ë²ˆ ìˆ˜í–‰í•˜"
"ë©´ ì™„ë£Œë  ë•Œê¹Œì§€ ë‹¬ë ¸ìŠµë‹ˆë‹¤. **ëª¨ë“ ** ì‘ì—…ì„ ìˆ˜í–‰í•œ ë‹¤ìŒ ì¶œë ¥ë¬¼ì„ ë°˜í™˜í–ˆìŠµë‹ˆ"
"ë‹¤."

#: src/08_futures/01_async_fn.md:7
#, fuzzy
msgid ""
"Sometimes that's undesirable.  \n"
"For example, if you're writing an HTTP server, there might be a lot of "
"**waiting**: waiting for the request body to arrive, waiting for the database "
"to respond, waiting for a downstream service to reply, etc."
msgstr ""
"ë•Œë•Œë¡œ ê·¸ê²ƒì€ ë°”ëŒì§í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.  \n"
"ì˜ˆë¥¼ ë“¤ì–´, HTTP ì„œë²„ë¥¼ ì‘ì„±í•˜ëŠ” ê²½ìš° ìš”ì²­ ë³¸ë¬¸ì´ ë„ì°©í•˜ê¸°ë¥¼ ê¸°ë‹¤ë¦¬ê¸°, ë°ì´í„°ë² "
"ì´ìŠ¤ê°€ ì‘ë‹µí•˜ê¸°ë¥¼ ê¸°ë‹¤ë¦¬ê¸°, ë‹¤ìš´ìŠ¤íŠ¸ë¦¼ ì„œë¹„ìŠ¤ê°€ ì‘ë‹µí•˜ê¸°ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ë“± ë§ì€ **"
"ëŒ€ê¸°**ê°€ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/08_futures/01_async_fn.md:12
#, fuzzy
msgid ""
"What if you could do something else while you're waiting?  \n"
"What if you could choose to give up midway through a computation?  \n"
"What if you could choose to prioritise another task over the current one?"
msgstr ""
"ê¸°ë‹¤ë¦¬ëŠ” ë™ì•ˆ ë‹¤ë¥¸ ì¼ì„ í•  ìˆ˜ ìˆë‹¤ë©´ ì–´ë–¨ê¹Œìš”?  \n"
"ê³„ì‚° ë„ì¤‘ì— í¬ê¸°í•  ìˆ˜ ìˆë‹¤ë©´ ì–´ë–¨ê¹Œìš”?  \n"
"í˜„ì¬ ì‘ì—…ë³´ë‹¤ ë‹¤ë¥¸ ì‘ì—…ì˜ ìš°ì„ ìˆœìœ„ë¥¼ ì„ íƒí•  ìˆ˜ ìˆë‹¤ë©´ ì–´ë–¨ê¹Œìš”?"

#: src/08_futures/01_async_fn.md:16
#, fuzzy
msgid "That's where **asynchronous functions** come in."
msgstr "ì´ê²ƒì´ ë°”ë¡œ **ë¹„ë™ê¸° í•¨ìˆ˜**ê°€ ë“±ì¥í•˜ëŠ” ê³³ì…ë‹ˆë‹¤."

#: src/08_futures/01_async_fn.md:18
#, fuzzy
msgid "`async fn`"
msgstr "`ë¹„ë™ê¸° fn`"

#: src/08_futures/01_async_fn.md:20
#, fuzzy
msgid "You use the `async` keyword to define an asynchronous function:"
msgstr "ë¹„ë™ê¸° í•¨ìˆ˜ë¥¼ ì •ì˜í•˜ë ¤ë©´ `async` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/08_futures/01_async_fn.md:24
#, fuzzy
msgid "// This function is asynchronous\n"
msgstr "// ì´ í•¨ìˆ˜ëŠ” ë¹„ë™ê¸°ì‹ì…ë‹ˆë‹¤."

#: src/08_futures/01_async_fn.md:31
#, fuzzy
msgid "What happens if you call `bind_random` as you would a regular function?"
msgstr "ì¼ë°˜ í•¨ìˆ˜ì²˜ëŸ¼ `bind_random`ì„ í˜¸ì¶œí•˜ë©´ ì–´ë–»ê²Œ ë˜ë‚˜ìš”?"

#: src/08_futures/01_async_fn.md:35
#, fuzzy
msgid "// Invoke `bind_random`\n"
msgstr "// `bind_random` í˜¸ì¶œ"

#: src/08_futures/01_async_fn.md:37
#, fuzzy
msgid "// Now what?\n"
msgstr "// ì´ì œ ë­?"

#: src/08_futures/01_async_fn.md:41
#, fuzzy
msgid ""
"Nothing happens!  \n"
"Rust doesn't start executing `bind_random` when you call it, not even as a "
"background task (as you might expect based on your experience with other "
"languages). Asynchronous functions in Rust are **lazy**: they don't do any "
"work until you explicitly ask them to. Using Rust's terminology, we say that "
"`bind_random` returns a **future**, a type that represents a computation that "
"may complete later. They're called futures because they implement the "
"`Future` trait, an interface that we'll examine in detail later on in this "
"chapter."
msgstr ""
"ì•„ë¬´ ë°˜ì‘ì´ ì—†ìŠµë‹ˆë‹¤!  \n"
"RustëŠ” í˜¸ì¶œí•  ë•Œ `bind_random` ì‹¤í–‰ì„ ì‹œì‘í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. (ë‹¤ë¥¸ ì–¸ì–´ ì‚¬ìš© ê²½í—˜"
"ì„ ë°”íƒ•ìœ¼ë¡œ ì˜ˆìƒí•  ìˆ˜ ìˆë“¯ì´) ë°±ê·¸ë¼ìš´ë“œ ì‘ì—…ìœ¼ë¡œë„ ì‹¤í–‰í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. Rustì˜ "
"ë¹„ë™ê¸° í•¨ìˆ˜ëŠ” **ê²Œìœ¼ë¥´ë‹¤**: ëª…ì‹œì ìœ¼ë¡œ ìš”ì²­í•˜ê¸° ì „ê¹Œì§€ëŠ” ì–´ë–¤ ì‘ì—…ë„ ìˆ˜í–‰í•˜ì§€ "
"ì•ŠìŠµë‹ˆë‹¤. Rustì˜ ìš©ì–´ë¥¼ ì‚¬ìš©í•˜ë©´ 'bind_random'ì´ ë‚˜ì¤‘ì— ì™„ë£Œë  ìˆ˜ ìˆëŠ” ê³„ì‚°ì„ "
"ë‚˜íƒ€ë‚´ëŠ” ìœ í˜•ì¸ **future**ë¥¼ ë°˜í™˜í•œë‹¤ê³  ë§í•©ë‹ˆë‹¤. ì´ê²ƒë“¤ì€ ì´ ì¥ì˜ ë’·ë¶€ë¶„ì—ì„œ "
"ìì„¸íˆ ì‚´í´ë³¼ ì¸í„°í˜ì´ìŠ¤ì¸ `Future` íŠ¹ì„±ì„ êµ¬í˜„í•˜ê¸° ë•Œë¬¸ì— ë¯¸ë˜ë¼ê³  ë¶ˆë¦½ë‹ˆë‹¤."

#: src/08_futures/01_async_fn.md:52
#, fuzzy
msgid "`.await`"
msgstr "`.ê¸°ë‹¤ë ¤`"

#: src/08_futures/01_async_fn.md:54
#, fuzzy
msgid ""
"The most common way to ask an asynchronous function to do some work is to use "
"the `.await` keyword:"
msgstr ""
"ë¹„ë™ê¸° í•¨ìˆ˜ì— ì‘ì—…ì„ ìš”ì²­í•˜ëŠ” ê°€ì¥ ì¼ë°˜ì ì¸ ë°©ë²•ì€ `.await` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ëŠ” "
"ê²ƒì…ë‹ˆë‹¤."

#: src/08_futures/01_async_fn.md:65
#, fuzzy
msgid "// Invoke `bind_random` and wait for it to complete\n"
msgstr "// `bind_random`ì„ í˜¸ì¶œí•˜ê³  ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦½ë‹ˆë‹¤."

#: src/08_futures/01_async_fn.md:67
#, fuzzy
msgid "// Now `listener` is ready\n"
msgstr "// ì´ì œ `listener`ê°€ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤."

#: src/08_futures/01_async_fn.md:71
#, fuzzy
msgid ""
"`.await` doesn't return control to the caller until the asynchronous function "
"has run to completionâ€”e.g. until the `TcpListener` has been created in the "
"example above."
msgstr ""
"`.await`ëŠ” ë¹„ë™ê¸° í•¨ìˆ˜ ì‹¤í–‰ì´ ì™„ë£Œë  ë•Œê¹Œì§€ í˜¸ì¶œìì—ê²Œ ì œì–´ê¶Œì„ ë°˜í™˜í•˜ì§€ ì•ŠìŠµ"
"ë‹ˆë‹¤. ìœ„ì˜ ì˜ˆì—ì„œ `TcpListener`ê°€ ìƒì„±ë  ë•Œê¹Œì§€."

#: src/08_futures/01_async_fn.md:74
#, fuzzy
msgid "Runtimes"
msgstr "ëŸ°íƒ€ì„"

#: src/08_futures/01_async_fn.md:76
#, fuzzy
msgid ""
"If you're puzzled, you're right to be!  \n"
"We've just said that the perk of asynchronous functions is that they don't do "
"**all** their work at once. We then introduced `.await`, which doesn't return "
"until the asynchronous function has run to completion. Haven't we just re-"
"introduced the problem we were trying to solve? What's the point?"
msgstr ""
"ë‹¹ì‹ ì´ ì˜ì•„í•´í•œë‹¤ë©´, ë‹¹ì‹ ì´ ì˜³ìŠµë‹ˆë‹¤!  \n"
"ë¹„ë™ê¸° í•¨ìˆ˜ì˜ ì¥ì ì€ **ëª¨ë“ ** ì‘ì—…ì„ í•œ ë²ˆì— ìˆ˜í–‰í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. ê·¸ëŸ° "
"ë‹¤ìŒ ë¹„ë™ê¸° í•¨ìˆ˜ ì‹¤í–‰ì´ ì™„ë£Œë  ë•Œê¹Œì§€ ë°˜í™˜ë˜ì§€ ì•ŠëŠ” `.await`ë¥¼ ë„ì…í–ˆìŠµë‹ˆë‹¤. "
"ìš°ë¦¬ê°€ í•´ê²°í•˜ë ¤ê³  í–ˆë˜ ë¬¸ì œë¥¼ ë‹¤ì‹œ ë„ì…í•˜ì§€ ì•Šì•˜ë‚˜ìš”? ì ì€ ë¬´ì—‡ì¸ê°€?"

#: src/08_futures/01_async_fn.md:82
#, fuzzy
msgid ""
"Not quite! A lot happens behind the scenes when you call `.await`!  \n"
"You're yielding control to an **async runtime**, also known as an **async "
"executor**. Executors are where the magic happens: they are in charge of "
"managing all your ongoing asynchronous **tasks**. In particular, they balance "
"two different goals:"
msgstr ""
"ì¢€ ë¹ ì§€ëŠ”! `.await`ë¥¼ í˜¸ì¶œí•˜ë©´ ë’¤ì—ì„œ ë§ì€ ì¼ì´ ì¼ì–´ë‚©ë‹ˆë‹¤!  \n"
"**ë¹„ë™ê¸° ì‹¤í–‰ê¸°**ë¼ê³ ë„ ì•Œë ¤ì§„ **ë¹„ë™ê¸° ëŸ°íƒ€ì„**ì— ì œì–´ê¶Œì„ ì–‘ë³´í•˜ê³  ìˆìŠµë‹ˆ"
"ë‹¤. ì‹¤í–‰ìëŠ” ë§ˆë²•ì´ ì¼ì–´ë‚˜ëŠ” ê³³ì…ë‹ˆë‹¤. ì‹¤í–‰ ì¤‘ì¸ ëª¨ë“  ë¹„ë™ê¸° **ì‘ì—…**ì„ ê´€ë¦¬í•˜"
"ëŠ” ì—­í• ì„ ë‹´ë‹¹í•©ë‹ˆë‹¤. íŠ¹íˆ ë‘ ê°€ì§€ ëª©í‘œì˜ ê· í˜•ì„ ìœ ì§€í•©ë‹ˆë‹¤."

#: src/08_futures/01_async_fn.md:87
#, fuzzy
msgid "**Progress**: they make sure that tasks make progress whenever they can."
msgstr "**ì§„í–‰**: ê°€ëŠ¥í•  ë•Œë§ˆë‹¤ ì‘ì—…ì´ ì§„í–‰ë˜ë„ë¡ í•©ë‹ˆë‹¤."

#: src/08_futures/01_async_fn.md:88
#, fuzzy
msgid ""
"**Efficiency**: if a task is waiting for something, they try to make sure "
"that another task can run in the meantime, fully utilising the available "
"resources."
msgstr ""
"**íš¨ìœ¨ì„±**: ì‘ì—…ì´ ë¬´ì–¸ê°€ë¥¼ ê¸°ë‹¤ë¦¬ê³  ìˆëŠ” ê²½ìš° ì‚¬ìš© ê°€ëŠ¥í•œ ë¦¬ì†ŒìŠ¤ë¥¼ ìµœëŒ€í•œ í™œ"
"ìš©í•˜ì—¬ ê·¸ ë™ì•ˆ ë‹¤ë¥¸ ì‘ì—…ì´ ì‹¤í–‰ë  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•˜ë ¤ê³  í•©ë‹ˆë‹¤."

#: src/08_futures/01_async_fn.md:91
#, fuzzy
msgid "No default runtime"
msgstr "ê¸°ë³¸ ëŸ°íƒ€ì„ ì—†ìŒ"

#: src/08_futures/01_async_fn.md:93
#, fuzzy
msgid ""
"Rust is fairly unique in its approach to asynchronous programing: there is no "
"default runtime. The standard library doesn't ship with one. You need to "
"bring your own!"
msgstr ""
"RustëŠ” ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë°ì— ëŒ€í•œ ì ‘ê·¼ ë°©ì‹ì´ ë§¤ìš° ë…íŠ¹í•©ë‹ˆë‹¤. ê¸°ë³¸ ëŸ°íƒ€ì„ì´ ì—†"
"ìŠµë‹ˆë‹¤. í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” í•¨ê»˜ ì œê³µë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì§ì ‘ ê°€ì ¸ì™€ì•¼í•©ë‹ˆë‹¤!"

#: src/08_futures/01_async_fn.md:97
#, fuzzy
msgid ""
"In most cases, you'll choose one of the options available in the ecosystem. "
"Some runtimes are designed to be broadly applicable, a solid option for most "
"applications. `tokio` and `async-std` belong to this category. Other runtimes "
"are optimised for specific use casesâ€”e.g. `embassy` for embedded systems."
msgstr ""
"ëŒ€ë¶€ë¶„ì˜ ê²½ìš° ìƒíƒœê³„ì—ì„œ ì‚¬ìš© ê°€ëŠ¥í•œ ì˜µì…˜ ì¤‘ í•˜ë‚˜ë¥¼ ì„ íƒí•˜ê²Œ ë©ë‹ˆë‹¤. ì¼ë¶€ ëŸ°íƒ€"
"ì„ì€ ê´‘ë²”ìœ„í•˜ê²Œ ì ìš© ê°€ëŠ¥í•˜ë„ë¡ ì„¤ê³„ë˜ì–´ ëŒ€ë¶€ë¶„ì˜ ì• í”Œë¦¬ì¼€ì´ì…˜ì— í™•ì‹¤í•œ ì˜µì…˜ì…"
"ë‹ˆë‹¤. `tokio`ì™€ `async-std`ê°€ ì´ ë²”ì£¼ì— ì†í•©ë‹ˆë‹¤. ë‹¤ë¥¸ ëŸ°íƒ€ì„ì€ íŠ¹ì • ì‚¬ìš© ì‚¬ë¡€"
"ì— ìµœì í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì„ë² ë””ë“œ ì‹œìŠ¤í…œì„ ìœ„í•œ `ëŒ€ì‚¬ê´€`."

#: src/08_futures/01_async_fn.md:102
#, fuzzy
msgid ""
"Throughout this course we'll rely on `tokio`, the most popular runtime for "
"general-purpose asynchronous programming in Rust."
msgstr ""
"ì´ ê³¼ì • ì „ì²´ì—ì„œ ìš°ë¦¬ëŠ” Rustì˜ ë²”ìš© ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë°ì„ ìœ„í•œ ê°€ì¥ ì¸ê¸° ìˆëŠ” ëŸ°"
"íƒ€ì„ì¸ 'tokio'ë¥¼ ì‚¬ìš©í•˜ê²Œ ë©ë‹ˆë‹¤."

#: src/08_futures/01_async_fn.md:105
#, fuzzy
msgid "`#[tokio::main]`"
msgstr "`#[í† í‚¤ì˜¤::ë©”ì¸]`"

#: src/08_futures/01_async_fn.md:107
#, fuzzy
msgid ""
"The entrypoint of your executable, the `main` function, must be a synchronous "
"function. That's where you're supposed to set up and launch your chosen async "
"runtime."
msgstr ""
"ì‹¤í–‰ íŒŒì¼ì˜ ì§„ì…ì ì¸ 'main' í•¨ìˆ˜ëŠ” ë™ê¸° í•¨ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤. ì—¬ê¸°ì—ì„œ ì„ íƒí•œ ë¹„ë™"
"ê¸° ëŸ°íƒ€ì„ì„ ì„¤ì •í•˜ê³  ì‹¤í–‰í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/08_futures/01_async_fn.md:110
#, fuzzy
msgid ""
"Most runtimes provides a macro to make this easier. For `tokio`, it's `tokio::"
"main`:"
msgstr ""
"ëŒ€ë¶€ë¶„ì˜ ëŸ°íƒ€ì„ì€ ì´ë¥¼ ë” ì‰½ê²Œ í•˜ê¸° ìœ„í•´ ë§¤í¬ë¡œë¥¼ ì œê³µí•©ë‹ˆë‹¤. `tokio`ì˜ ê²½ìš° "
"`tokio::main`ì…ë‹ˆë‹¤."

#: src/08_futures/01_async_fn.md:115
#, fuzzy
msgid "// Your async code goes here\n"
msgstr "// ë¹„ë™ê¸° ì½”ë“œê°€ ì—¬ê¸°ì— ë“¤ì–´ê°‘ë‹ˆë‹¤."

#: src/08_futures/01_async_fn.md:119
#, fuzzy
msgid "which expands to:"
msgstr "ì´ëŠ” ë‹¤ìŒìœ¼ë¡œ í™•ì¥ë©ë‹ˆë‹¤."

#: src/08_futures/01_async_fn.md:125
#, fuzzy
msgid ""
"// Your async function goes here\n"
"        // [...]\n"
msgstr "// ë¹„ë™ê¸° í•¨ìˆ˜ê°€ ì—¬ê¸°ì— ìœ„ì¹˜í•©ë‹ˆë‹¤. // \\[...\\]"

#: src/08_futures/01_async_fn.md:131
#, fuzzy
msgid "`#[tokio::test]`"
msgstr "`#[tokio::í…ŒìŠ¤íŠ¸]`"

#: src/08_futures/01_async_fn.md:133
#, fuzzy
msgid ""
"The same goes for tests: they must be synchronous functions.  \n"
"Each test function is run in its own thread, and you're responsible for "
"setting up and launching an async runtime if you need to run async code in "
"your tests.  \n"
"`tokio` provides a `#[tokio::test]` macro to make this easier:"
msgstr ""
"í…ŒìŠ¤íŠ¸ë„ ë§ˆì°¬ê°€ì§€ì…ë‹ˆë‹¤. ë™ê¸°ì‹ í•¨ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤.  \n"
"ê° í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ëŠ” ìì²´ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰ë˜ë©°, í…ŒìŠ¤íŠ¸ì—ì„œ ë¹„ë™ê¸° ì½”ë“œë¥¼ ì‹¤í–‰í•´ì•¼ "
"í•˜ëŠ” ê²½ìš° ë¹„ë™ê¸° ëŸ°íƒ€ì„ì„ ì„¤ì •í•˜ê³  ì‹œì‘í•˜ëŠ” ì±…ì„ì€ ì‚¬ìš©ìì—ê²Œ ìˆìŠµë‹ˆë‹¤.  \n"
"`tokio`ëŠ” ì´ ì‘ì—…ì„ ë” ì‰½ê²Œ í•˜ê¸° ìœ„í•´ `#[tokio::test]` ë§¤í¬ë¡œë¥¼ ì œê³µí•©ë‹ˆë‹¤:"

#: src/08_futures/01_async_fn.md:142
#, fuzzy
msgid "// Your async test code goes here\n"
msgstr "// ë¹„ë™ê¸° í…ŒìŠ¤íŠ¸ ì½”ë“œê°€ ì—¬ê¸°ì— ë“¤ì–´ê°‘ë‹ˆë‹¤."

#: src/08_futures/01_async_fn.md:148
msgid ""
"The exercise for this section is located in [`08_futures/01_async_fn`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/08_futures/01_async_fn)"
msgstr ""

#: src/08_futures/02_spawn.md:3
#, fuzzy
msgid "Your solution to the previous exercise should look something like this:"
msgstr "ì´ì „ ì—°ìŠµì— ëŒ€í•œ ì†”ë£¨ì…˜ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤."

#: src/08_futures/02_spawn.md:15
#, fuzzy
msgid ""
"This is not bad!  \n"
"If a long time passes between two incoming connections, the `echo` function "
"will be idle (since `TcpListener::accept` is an asynchronous function), thus "
"allowing the executor to run other tasks in the meantime."
msgstr ""
"ì´ê²ƒì€ ë‚˜ì˜ì§€ ì•ŠìŠµë‹ˆë‹¤!  \n"
"ë‘ ê°œì˜ ë“¤ì–´ì˜¤ëŠ” ì—°ê²° ì‚¬ì´ì— ì˜¤ëœ ì‹œê°„ì´ ì§€ë‚˜ë©´ `echo` í•¨ìˆ˜ëŠ” ìœ íœ´ ìƒíƒœê°€ ë˜ë©°"
"(`TcpListener::accept`ëŠ” ë¹„ë™ê¸° í•¨ìˆ˜ì´ë¯€ë¡œ) ì‹¤í–‰ê¸°ê°€ ê·¸ ë™ì•ˆ ë‹¤ë¥¸ ì‘ì—…ì„ ì‹¤í–‰"
"í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/08_futures/02_spawn.md:20
#, fuzzy
msgid ""
"But how can we actually have multiple tasks running concurrently?  \n"
"If we always run our asynchronous functions until completion (by using `."
"await`), we'll never have more than one task running at a time."
msgstr ""
"í•˜ì§€ë§Œ ì‹¤ì œë¡œ ì—¬ëŸ¬ ì‘ì—…ì„ ë™ì‹œì— ì‹¤í–‰í•˜ë ¤ë©´ ì–´ë–»ê²Œ í•´ì•¼ í• ê¹Œìš”?  \n"
"ì™„ë£Œë  ë•Œê¹Œì§€ í•­ìƒ ë¹„ë™ê¸° í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•œë‹¤ë©´(`.await`ë¥¼ ì‚¬ìš©í•˜ì—¬) í•œ ë²ˆì— ë‘ "
"ê°œ ì´ìƒì˜ ì‘ì—…ì´ ì‹¤í–‰ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/08_futures/02_spawn.md:24
#, fuzzy
msgid "This is where the `tokio::spawn` function comes in."
msgstr "ì´ê²ƒì´ `tokio::spawn` í•¨ìˆ˜ê°€ ë“¤ì–´ì˜¤ëŠ” ê³³ì…ë‹ˆë‹¤."

#: src/08_futures/02_spawn.md:26
#, fuzzy
msgid "`tokio::spawn`"
msgstr "`tokio::spawn`"

#: src/08_futures/02_spawn.md:28
#, fuzzy
msgid ""
"`tokio::spawn` allows you to hand off a task to the executor, **without "
"waiting for it to complete**.  \n"
"Whenever you invoke `tokio::spawn`, you're telling `tokio` to continue "
"running the spawned task, in the background, **concurrently** with the task "
"that spawned it."
msgstr ""
"`tokio::spawn`ì„ ì‚¬ìš©í•˜ë©´ **ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ì§€ ì•Šê³ ** ì‘ì—…ì„ ì‹¤í–‰ìì—ê²Œ ì „"
"ë‹¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"`tokio::spawn`ì„ í˜¸ì¶œí•  ë•Œë§ˆë‹¤ `tokio`ì—ê²Œ ìƒì„±ëœ ì‘ì—…ì„ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ìƒì„±"
"ëœ ì‘ì—…ê³¼ **ë™ì‹œì—** ê³„ì† ì‹¤í–‰í•˜ë¼ê³  ì§€ì‹œí•˜ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/08_futures/02_spawn.md:32
#, fuzzy
msgid "Here's how you can use it to process multiple connections concurrently:"
msgstr "ì´ë¥¼ ì‚¬ìš©í•˜ì—¬ ì—¬ëŸ¬ ì—°ê²°ì„ ë™ì‹œì— ì²˜ë¦¬í•˜ëŠ” ë°©ë²•ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤."

#: src/08_futures/02_spawn.md:40
#, fuzzy
msgid ""
"// Spawn a background task to handle the connection\n"
"        // thus allowing the main task to immediately start \n"
"        // accepting new connections\n"
msgstr ""
"// ì—°ê²°ì„ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ë°±ê·¸ë¼ìš´ë“œ ì‘ì—…ì„ ìƒì„±í•©ë‹ˆë‹¤. // ë”°ë¼ì„œ ê¸°ë³¸ ì‘ì—…ì´ ì¦‰"
"ì‹œ ì‹œì‘ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. // ìƒˆ ì—°ê²°ì„ ìˆ˜ë½í•©ë‹ˆë‹¤."

#: src/08_futures/02_spawn.md:51
#, fuzzy
msgid "Asynchronous blocks"
msgstr "ë¹„ë™ê¸° ë¸”ë¡"

#: src/08_futures/02_spawn.md:53
#, fuzzy
msgid ""
"In this example, we've passed an **asynchronous block** to `tokio::spawn`: "
"`async move { /* */ }` Asynchronous blocks are a quick way to mark a region "
"of code as asynchronous without having to define a separate async function."
msgstr ""
"ì´ ì˜ˆì—ì„œëŠ” **ë¹„ë™ê¸° ë¸”ë¡**ì„ `tokio::spawn`ì— ì „ë‹¬í–ˆìŠµë‹ˆë‹¤. `async move { /* "
"*/ }` ë¹„ë™ê¸° ë¸”ë¡ì€ ì½”ë“œ ì˜ì—­ì„ ë¹„ë™ê¸°ë¡œ í‘œì‹œí•  ìˆ˜ ìˆëŠ” ë¹ ë¥¸ ë°©ë²•ì…ë‹ˆë‹¤. ë³„ë„"
"ì˜ ë¹„ë™ê¸° í•¨ìˆ˜ë¥¼ ì •ì˜í•©ë‹ˆë‹¤."

#: src/08_futures/02_spawn.md:57
#, fuzzy
msgid "`JoinHandle`"
msgstr "'ì¡°ì¸í•¸ë“¤'"

#: src/08_futures/02_spawn.md:59
#, fuzzy
msgid ""
"`tokio::spawn` returns a `JoinHandle`.  \n"
"You can use `JoinHandle` to `.await` the background task, in the same way we "
"used `join` for spawned threads."
msgstr ""
"`tokio::spawn`ì€ `JoinHandle`ì„ ë°˜í™˜í•©ë‹ˆë‹¤.  \n"
"ìƒì„±ëœ ìŠ¤ë ˆë“œì— ëŒ€í•´ 'join'ì„ ì‚¬ìš©í•œ ê²ƒê³¼ ê°™ì€ ë°©ì‹ìœ¼ë¡œ 'JoinHandle'ì„ ì‚¬ìš©í•˜"
"ì—¬ ë°±ê·¸ë¼ìš´ë“œ ì‘ì—…ì„ '.await'í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/08_futures/02_spawn.md:65
#, fuzzy
msgid ""
"// Spawn a background task to ship telemetry data\n"
"    // to a remote server\n"
msgstr ""
"// ì›ê²© ì„œë²„ì— ì›ê²© ì¸¡ì • ë°ì´í„°ë¥¼ ì „ì†¡í•˜ê¸° ìœ„í•œ ë°±ê·¸ë¼ìš´ë“œ ì‘ì—…ì„ ìƒì„±í•©ë‹ˆë‹¤."

#: src/08_futures/02_spawn.md:68
#, fuzzy
msgid "// In the meantime, do some other useful work\n"
msgstr "// ê·¸ë™ì•ˆ ë‹¤ë¥¸ ìœ ìš©í•œ ì‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤."

#: src/08_futures/02_spawn.md:70
#, fuzzy
msgid ""
"// But don't return to the caller until \n"
"    // the telemetry data has been successfully delivered\n"
msgstr ""
"// í•˜ì§€ë§Œ ì›ê²© ì¸¡ì • ë°ì´í„°ê°€ ì„±ê³µì ìœ¼ë¡œ ì „ë‹¬ë  ë•Œê¹Œì§€ // í˜¸ì¶œìì—ê²Œ ë°˜í™˜í•˜ì§€ "
"ë§ˆì„¸ìš”."

#: src/08_futures/02_spawn.md:84
#, fuzzy
msgid "Panic boundary"
msgstr "íŒ¨ë‹‰ ê²½ê³„"

#: src/08_futures/02_spawn.md:86
#, fuzzy
msgid ""
"If a task spawned with `tokio::spawn` panics, the panic will be caught by the "
"executor.  \n"
"If you don't `.await` the corresponding `JoinHandle`, the panic won't be "
"propagated to the spawner. Even if you do `.await` the `JoinHandle`, the "
"panic won't be propagated automatically. Awaiting a `JoinHandle` returns a "
"`Result`, with [`JoinError`](https://docs.rs/tokio/latest/tokio/task/struct."
"JoinError.html) as its error type. You can then check if the task panicked by "
"calling `JoinError::is_panic` and choose what to do with the panicâ€”either log "
"it, ignore it, or propagate it."
msgstr ""
"`tokio::spawn`ìœ¼ë¡œ ìƒì„±ëœ ì‘ì—…ì— íŒ¨ë‹‰ì´ ë°œìƒí•˜ë©´ ì‹¤í–‰ í”„ë¡œê·¸ë¨ì´ íŒ¨ë‹‰ì„ í¬ì°©í•©"
"ë‹ˆë‹¤.  \n"
"í•´ë‹¹í•˜ëŠ” `JoinHandle`ì„ `.await`í•˜ì§€ ì•Šìœ¼ë©´ íŒ¨ë‹‰ì´ ìƒì„±ìì—ê²Œ ì „íŒŒë˜ì§€ ì•ŠìŠµë‹ˆ"
"ë‹¤. `JoinHandle`ì„ `.await`í•˜ë”ë¼ë„ íŒ¨ë‹‰ì´ ìë™ìœ¼ë¡œ ì „íŒŒë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. "
"'JoinHandle'ì„ ê¸°ë‹¤ë¦¬ë©´ ì˜¤ë¥˜ ìœ í˜•ì´ 'JoinError'ì¸ 'ê²°ê³¼'ê°€ ë°˜í™˜ë©ë‹ˆë‹¤. ê·¸ëŸ° ë‹¤"
"ìŒ `JoinError::is_panic`ì„ í˜¸ì¶œí•˜ì—¬ ì‘ì—…ì— íŒ¨ë‹‰ì´ ë°œìƒí–ˆëŠ”ì§€ í™•ì¸í•˜ê³  íŒ¨ë‹‰ ì²˜"
"ë¦¬ ë°©ë²•(ê¸°ë¡, ë¬´ì‹œ ë˜ëŠ” ì „íŒŒ)ì„ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/08_futures/02_spawn.md:100
#, fuzzy
msgid ""
"// The task has panicked\n"
"            // We resume unwinding the panic,\n"
"            // thus propagating it to the current task\n"
msgstr ""
"// ì‘ì—…ì— íŒ¨ë‹‰ì´ ë°œìƒí–ˆìŠµë‹ˆë‹¤. // íŒ¨ë‹‰ í•´ì œë¥¼ ì¬ê°œí•˜ì—¬ // ì´ë¥¼ í˜„ì¬ ì‘ì—…ì— ì „"
"íŒŒí•©ë‹ˆë‹¤."

#: src/08_futures/02_spawn.md:113
#, fuzzy
msgid "`std::thread::spawn` vs `tokio::spawn`"
msgstr "`std::thread::spawn` ëŒ€ `tokio::spawn`"

#: src/08_futures/02_spawn.md:115
#, fuzzy
msgid ""
"You can think of `tokio::spawn` as the asynchronous sibling of `std::spawn::"
"thread`."
msgstr ""
"`tokio::spawn`ì„ `std::spawn::thread`ì˜ ë¹„ë™ê¸° í˜•ì œë¡œ ìƒê°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/08_futures/02_spawn.md:117
#, fuzzy
msgid ""
"Notice a key difference: with `std::thread::spawn`, you're delegating control "
"to the OS scheduler. You're not in control of how threads are scheduled."
msgstr ""
"ì£¼ìš” ì°¨ì´ì ì— ì£¼ëª©í•˜ì„¸ìš”. `std::thread::spawn`ì„ ì‚¬ìš©í•˜ë©´ ì œì–´ê¶Œì„ OS ìŠ¤ì¼€ì¤„ëŸ¬"
"ì— ìœ„ì„í•©ë‹ˆë‹¤. ìŠ¤ë ˆë“œ ì˜ˆì•½ ë°©ë²•ì„ ì œì–´í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/08_futures/02_spawn.md:120
#, fuzzy
msgid ""
"With `tokio::spawn`, you're delegating to an async executor that runs "
"entirely in user space. The underlying OS scheduler is not involved in the "
"decision of which task to run next. We're in charge of that decision now, via "
"the executor we chose to use."
msgstr ""
"`tokio::spawn`ì„ ì‚¬ìš©í•˜ë©´ ì „ì ìœ¼ë¡œ ì‚¬ìš©ì ê³µê°„ì—ì„œ ì‹¤í–‰ë˜ëŠ” ë¹„ë™ê¸° ì‹¤í–‰ê¸°ì— ìœ„"
"ì„í•˜ê²Œ ë©ë‹ˆë‹¤. ê¸°ë³¸ OS ìŠ¤ì¼€ì¤„ëŸ¬ëŠ” ë‹¤ìŒì— ì‹¤í–‰í•  ì‘ì—…ì„ ê²°ì •í•˜ëŠ” ë° ê´€ì—¬í•˜ì§€ ì•Š"
"ìŠµë‹ˆë‹¤. ìš°ë¦¬ëŠ” ì´ì œ ìš°ë¦¬ê°€ ì‚¬ìš©í•˜ê¸°ë¡œ ì„ íƒí•œ ì‹¤í–‰ìë¥¼ í†µí•´ ê·¸ ê²°ì •ì„ ë‹´ë‹¹í•˜ê³  "
"ìˆìŠµë‹ˆë‹¤."

#: src/08_futures/02_spawn.md:126
msgid ""
"The exercise for this section is located in [`08_futures/02_spawn`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/08_futures/02_spawn)"
msgstr ""

#: src/08_futures/03_runtime.md:1
#, fuzzy
msgid "Runtime architecture"
msgstr "ëŸ°íƒ€ì„ ì•„í‚¤í…ì²˜"

#: src/08_futures/03_runtime.md:3
#, fuzzy
msgid ""
"So far we've been talking about async runtimes as an abstract concept. Let's "
"dig a bit deeper into the way they are implementedâ€”as you'll see soon enough, "
"it has an impact on our code."
msgstr ""
"ì§€ê¸ˆê¹Œì§€ ìš°ë¦¬ëŠ” ì¶”ìƒì ì¸ ê°œë…ìœ¼ë¡œ ë¹„ë™ê¸° ëŸ°íƒ€ì„ì— ëŒ€í•´ ì´ì•¼ê¸°í•´ì™”ìŠµë‹ˆë‹¤. êµ¬í˜„ "
"ë°©ì‹ì— ëŒ€í•´ ì¢€ ë” ìì„¸íˆ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤. ê³§ ì•Œê²Œ ë˜ê² ì§€ë§Œ ì´ëŠ” ì½”ë“œì— ì˜í–¥ì„ "
"ë¯¸ì¹©ë‹ˆë‹¤."

#: src/08_futures/03_runtime.md:7
#, fuzzy
msgid "Flavors"
msgstr "ë§›"

#: src/08_futures/03_runtime.md:9
#, fuzzy
msgid "`tokio` ships two different runtime _flavors_."
msgstr "`tokio`ëŠ” ë‘ ê°€ì§€ ë‹¤ë¥¸ ëŸ°íƒ€ì„ _flavors_ë¥¼ ì œê³µí•©ë‹ˆë‹¤."

#: src/08_futures/03_runtime.md:11
#, fuzzy
msgid "You can configure your runtime via `tokio::runtime::Builder`:"
msgstr "`tokio::runtime::Builder`ë¥¼ í†µí•´ ëŸ°íƒ€ì„ì„ êµ¬ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/08_futures/03_runtime.md:13
#, fuzzy
msgid ""
"`Builder::new_multi_thread` gives you a **multithreaded `tokio` runtime**"
msgstr ""
"`Builder::new_multi_thread`ëŠ” **ë©€í‹°ìŠ¤ë ˆë“œ `tokio` ëŸ°íƒ€ì„**ì„ ì œê³µí•©ë‹ˆë‹¤."

#: src/08_futures/03_runtime.md:14
#, fuzzy
msgid ""
"`Builder::new_current_thread` will instead rely on the **current thread** for "
"execution."
msgstr ""
"ëŒ€ì‹  `Builder::new_current_thread`ëŠ” ì‹¤í–‰ì„ ìœ„í•´ **í˜„ì¬ ìŠ¤ë ˆë“œ**ì— ì˜ì¡´í•©ë‹ˆë‹¤."

#: src/08_futures/03_runtime.md:16
#, fuzzy
msgid ""
"`#[tokio::main]` returns a multithreaded runtime by default, while `#[tokio::"
"test]` uses a current thread runtime out of the box."
msgstr ""
"`#[tokio::main]`ì€ ê¸°ë³¸ì ìœ¼ë¡œ ë‹¤ì¤‘ ìŠ¤ë ˆë“œ ëŸ°íƒ€ì„ì„ ë°˜í™˜í•˜ëŠ” ë°˜ë©´ `#[tokio::"
"test]`ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ í˜„ì¬ ìŠ¤ë ˆë“œ ëŸ°íƒ€ì„ì„ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/08_futures/03_runtime.md:19
#, fuzzy
msgid "Current thread runtime"
msgstr "í˜„ì¬ ìŠ¤ë ˆë“œ ëŸ°íƒ€ì„"

#: src/08_futures/03_runtime.md:21
#, fuzzy
msgid ""
"The current-thread runtime, as the name implies, relies exclusively on the OS "
"thread it was launched on to schedule and execute tasks.  \n"
"When using the current-thread runtime, you have **concurrency** but no "
"**parallelism**: asynchronous tasks will be interleaved, but there will "
"always be at most one task running at any given time."
msgstr ""
"í˜„ì¬ ìŠ¤ë ˆë“œ ëŸ°íƒ€ì„ì€ ì´ë¦„ì—ì„œ ì•Œ ìˆ˜ ìˆë“¯ì´ ì‘ì—…ì„ ì˜ˆì•½í•˜ê³  ì‹¤í–‰í•˜ê¸° ìœ„í•´ ì‹œì‘"
"ëœ OS ìŠ¤ë ˆë“œì—ë§Œ ì˜ì¡´í•©ë‹ˆë‹¤.  \n"
"í˜„ì¬ ìŠ¤ë ˆë“œ ëŸ°íƒ€ì„ì„ ì‚¬ìš©í•˜ëŠ” ê²½ìš° **ë™ì‹œì„±**ì€ ìˆì§€ë§Œ **ë³‘ë ¬ì„±**ì€ ì—†ìŠµë‹ˆë‹¤. "
"ë¹„ë™ê¸° ì‘ì—…ì€ ì¸í„°ë¦¬ë¸Œë˜ì§€ë§Œ ì£¼ì–´ì§„ ì‹œê°„ì— í•­ìƒ ìµœëŒ€ í•˜ë‚˜ì˜ ì‘ì—…ì´ ì‹¤í–‰ë©ë‹ˆë‹¤."

#: src/08_futures/03_runtime.md:27
#, fuzzy
msgid "Multithreaded runtime"
msgstr "ë©€í‹°ìŠ¤ë ˆë“œ ëŸ°íƒ€ì„"

#: src/08_futures/03_runtime.md:29
#, fuzzy
msgid ""
"When using the multithreaded runtime, instead, there can up to `N` tasks "
"running _in parallel_ at any given time, where `N` is the number of threads "
"used by the runtime. By default, `N` matches the number of available CPU "
"cores."
msgstr ""
"ëŒ€ì‹  ë©€í‹°ìŠ¤ë ˆë“œ ëŸ°íƒ€ì„ì„ ì‚¬ìš©í•˜ëŠ” ê²½ìš° ì£¼ì–´ì§„ ì‹œê°„ì— ìµœëŒ€ 'N'ê°œì˜ ì‘ì—…ì„ _ë³‘ë ¬"
"_ë¡œ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì—¬ê¸°ì„œ 'N'ì€ ëŸ°íƒ€ì„ì—ì„œ ì‚¬ìš©í•˜ëŠ” ìŠ¤ë ˆë“œ ìˆ˜ì…ë‹ˆë‹¤. ê¸°ë³¸"
"ì ìœ¼ë¡œ 'N'ì€ ì‚¬ìš© ê°€ëŠ¥í•œ CPU ì½”ì–´ ìˆ˜ì™€ ì¼ì¹˜í•©ë‹ˆë‹¤."

#: src/08_futures/03_runtime.md:33
#, fuzzy
msgid ""
"There's more: `tokio` performs **work-stealing**.  \n"
"If a thread is idle, it won't wait around: it'll try to find a new task "
"that's ready for execution, either from a global queue or by stealing it from "
"the local queue of another thread.  \n"
"Work-stealing can have significant performance benefits, especially on tail "
"latencies, whenever your application is dealing with workloads that are not "
"perfectly balanced across threads."
msgstr ""
"ë” ë§ì€ ê²ƒì´ ìˆìŠµë‹ˆë‹¤: `tokio`ëŠ” **ì‘ì—… í›”ì¹˜ê¸°**ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.  \n"
"ìŠ¤ë ˆë“œê°€ ìœ íœ´ ìƒíƒœì´ë©´ ê¸°ë‹¤ë¦¬ì§€ ì•Šê³  ì „ì—­ ëŒ€ê¸°ì—´ì—ì„œ ë˜ëŠ” ë‹¤ë¥¸ ìŠ¤ë ˆë“œì˜ ë¡œì»¬ "
"ëŒ€ê¸°ì—´ì—ì„œ ì´ë¥¼ í›”ì³ ì‹¤í–‰í•  ì¤€ë¹„ê°€ ëœ ìƒˆ ì‘ì—…ì„ ì°¾ìœ¼ë ¤ê³  ì‹œë„í•©ë‹ˆë‹¤.  \n"
"ì‘ì—… ê°€ë¡œì±„ê¸°ëŠ” ì• í”Œë¦¬ì¼€ì´ì…˜ì´ ìŠ¤ë ˆë“œ ê°„ì— ì™„ë²½í•˜ê²Œ ê· í˜•ì„ ì´ë£¨ì§€ ëª»í•œ ì‘ì—… ë¶€"
"í•˜ë¥¼ ì²˜ë¦¬í•  ë•Œë§ˆë‹¤ íŠ¹íˆ ê¼¬ë¦¬ ì§€ì—° ì‹œê°„ì— ìƒë‹¹í•œ ì„±ëŠ¥ ì´ì ì„ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆ"
"ë‹¤."

#: src/08_futures/03_runtime.md:41
#, fuzzy
msgid "Implications"
msgstr "ì‹œì‚¬ì "

#: src/08_futures/03_runtime.md:43
#, fuzzy
msgid ""
"`tokio::spawn` is flavor-agnostic: it'll work no matter if you're running on "
"the multithreaded or current-thread runtime. The downside is that the "
"signature assume the worst case (i.e. multithreaded) and is constrained "
"accordingly:"
msgstr ""
"`tokio::spawn`ì€ ë²„ì „ì— êµ¬ì• ë°›ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‹¤ì¤‘ ìŠ¤ë ˆë“œ ëŸ°íƒ€ì„ì´ë‚˜ í˜„ì¬ ìŠ¤ë ˆë“œ "
"ëŸ°íƒ€ì„ì—ì„œ ì‹¤í–‰ ì¤‘ì¸ì§€ ìƒê´€ì—†ì´ ì‘ë™í•©ë‹ˆë‹¤. ë‹¨ì ì€ ì„œëª…ì´ ìµœì•…ì˜ ê²½ìš°(ì˜ˆ: ë‹¤"
"ì¤‘ ìŠ¤ë ˆë“œ)ë¥¼ ê°€ì •í•˜ê³  ì´ì— ë”°ë¼ ì œí•œëœë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤."

#: src/08_futures/03_runtime.md:55
#, fuzzy
msgid ""
"Let's ignore the `Future` trait for now to focus on the rest.  \n"
"`spawn` is asking all its inputs to be `Send` and have a `'static` lifetime."
msgstr ""
"ì§€ê¸ˆì€ 'ë¯¸ë˜' íŠ¹ì„±ì„ ë¬´ì‹œí•˜ê³  ë‚˜ë¨¸ì§€ ë¶€ë¶„ì— ì§‘ì¤‘í•˜ê² ìŠµë‹ˆë‹¤.  \n"
"`spawn`ì€ ëª¨ë“  ì…ë ¥ì´ `Send`ì´ê³  `ì •ì ` ìˆ˜ëª…ì„ ê°–ë„ë¡ ìš”ì²­í•©ë‹ˆë‹¤."

#: src/08_futures/03_runtime.md:58
#, fuzzy
msgid ""
"The `'static` constraint follows the same rationale of the `'static` "
"constraint on `std::thread::spawn`: the spawned task may outlive the context "
"it was spawned from, therefore it shouldn't depend on any local data that may "
"be de-allocated after the spawning context is destroyed."
msgstr ""
"`ì •ì ` ì œì•½ ì¡°ê±´ì€ `std::thread::spawn`ì— ëŒ€í•œ `ì •ì ` ì œì•½ ì¡°ê±´ê³¼ ë™ì¼í•œ ê·¼ê±°"
"ë¥¼ ë”°ë¦…ë‹ˆë‹¤. ìƒì„±ëœ ì‘ì—…ì€ ìƒì„±ëœ ì»¨í…ìŠ¤íŠ¸ë³´ë‹¤ ì˜¤ë˜ ì§€ì†ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë¡œì»¬ ë°"
"ì´í„°ì— ì˜ì¡´í•´ì„œëŠ” ì•ˆ ë©ë‹ˆë‹¤. ìƒì„± ì»¨í…ìŠ¤íŠ¸ê°€ ì‚­ì œëœ í›„ í• ë‹¹ì´ ì·¨ì†Œë  ìˆ˜ ìˆìŠµë‹ˆ"
"ë‹¤."

#: src/08_futures/03_runtime.md:66
#, fuzzy
msgid ""
"// This won't work, since `&v` doesn't\n"
"    // live long enough.\n"
msgstr "// `&v`ëŠ” // ì¶©ë¶„íˆ ì˜¤ë˜ ì§€ì†ë˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ì‘ë™í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/08_futures/03_runtime.md:70
#, fuzzy
msgid "\"{x}\""
msgstr "\"{ì—‘ìŠ¤}\""

#: src/08_futures/03_runtime.md:76
#, fuzzy
msgid ""
"`Send`, on the other hand, is a direct consequence of `tokio`'s work-stealing "
"strategy: a task that was spawned on thread `A` may end up being moved to "
"thread `B` if that's idle, thus requiring a `Send` bound since we're crossing "
"thread boundaries."
msgstr ""
"ë°˜ë©´ì— `Send`ëŠ” `tokio`ì˜ ì‘ì—… ë„ìš© ì „ëµì˜ ì§ì ‘ì ì¸ ê²°ê³¼ì…ë‹ˆë‹¤. ìŠ¤ë ˆë“œ `A`ì—"
"ì„œ ìƒì„±ëœ ì‘ì—…ì€ ìŠ¤ë ˆë“œ `B`ê°€ ìœ íœ´ ìƒíƒœì¸ ê²½ìš° ê²°êµ­ ìŠ¤ë ˆë“œ `B`ë¡œ ì´ë™ë  ìˆ˜ ìˆ"
"ìŠµë‹ˆë‹¤. ìŠ¤ë ˆë“œ ê²½ê³„ë¥¼ ë„˜ì—ˆê¸° ë•Œë¬¸ì— `Send` ê²½ê³„ì…ë‹ˆë‹¤."

#: src/08_futures/03_runtime.md:82
#, fuzzy
msgid ""
"// This won't work either, because\n"
"    // `Rc` isn't `Send`.\n"
msgstr ""
"// ì´ ì—­ì‹œ ì‘ë™í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì™œëƒí•˜ë©´ // `Rc`ëŠ” `Send`ê°€ ì•„ë‹ˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: src/08_futures/03_runtime.md:92
msgid ""
"The exercise for this section is located in [`08_futures/03_runtime`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/08_futures/03_runtime)"
msgstr ""

#: src/08_futures/04_future.md:1 src/08_futures/04_future.md:71
#, fuzzy
msgid "The `Future` trait"
msgstr "'ë¯¸ë˜' íŠ¹ì„±"

#: src/08_futures/04_future.md:3
#, fuzzy
msgid "The local `Rc` problem"
msgstr "ì§€ì—­ `Rc` ë¬¸ì œ"

#: src/08_futures/04_future.md:5
#, fuzzy
msgid "Let's go back to `tokio::spawn`'s signature:"
msgstr "`tokio::spawn`ì˜ ì„œëª…ìœ¼ë¡œ ëŒì•„ê°€ ë³´ê² ìŠµë‹ˆë‹¤."

#: src/08_futures/04_future.md:15
#, fuzzy
msgid ""
"What does it _actually_ mean for `F` to be `Send`?  \n"
"It implies, as we saw in the previous section, that whatever value it "
"captures from the spawning environment has to be `Send`. But it goes further "
"than that."
msgstr ""
"`F`ê°€ `ë³´ë‚´ê¸°`ë¼ëŠ” ê²ƒì´ _ì‹¤ì œë¡œ_ ë¬´ì—‡ì„ ì˜ë¯¸í•˜ë‚˜ìš”?  \n"
"ì´ëŠ” ì´ì „ ì„¹ì…˜ì—ì„œ ë³¸ ê²ƒì²˜ëŸ¼ ìƒì„± í™˜ê²½ì—ì„œ ìº¡ì²˜í•˜ëŠ” ê°’ì´ ë¬´ì—‡ì´ë“  'Send'ì—¬ì•¼ "
"í•¨ì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ê·¸ê²ƒì€ ê·¸ ì´ìƒì…ë‹ˆë‹¤."

#: src/08_futures/04_future.md:19
#, fuzzy
msgid ""
"Any value that's _held across a .await point_ has to be `Send`.  \n"
"Let's look at an example:"
msgstr ""
".await ì§€ì  ì „ì²´ì— ê±¸ì³ _ë³´ìœ ëœ_ ëª¨ë“  ê°’ì€ `Send`ì—¬ì•¼ í•©ë‹ˆë‹¤.  \n"
"ì˜ˆë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤:"

#: src/08_futures/04_future.md:31
#, fuzzy
msgid ""
"// A value that's not `Send`,\n"
"    // created _inside_ the async function\n"
msgstr "// `Send`ê°€ ì•„ë‹Œ ê°’, // ë¹„ë™ê¸° í•¨ìˆ˜ _ë‚´ë¶€_ì—ì„œ ìƒì„±ë¨"

#: src/08_futures/04_future.md:35
#, fuzzy
msgid "// A `.await` point that does nothing\n"
msgstr "// ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•ŠëŠ” `.await` ì§€ì "

#: src/08_futures/04_future.md:38
#, fuzzy
msgid ""
"// The local non-`Send` value is still needed\n"
"    // after the `.await`\n"
msgstr "// `.await` ë’¤ì—ëŠ” `Send`ê°€ ì•„ë‹Œ ë¡œì»¬ ê°’ì´ ì—¬ì „íˆ í•„ìš”í•©ë‹ˆë‹¤."

#: src/08_futures/04_future.md:44
#, fuzzy
msgid "The compiler will reject this code:"
msgstr "ì»´íŒŒì¼ëŸ¬ëŠ” ë‹¤ìŒ ì½”ë“œë¥¼ ê±°ë¶€í•©ë‹ˆë‹¤."

#: src/08_futures/04_future.md:46
msgid ""
"```text\n"
"error: future cannot be sent between threads safely\n"
"    |\n"
"5   |     tokio::spawn(example());\n"
"    |                  ^^^^^^^^^ future returned by `example` is not `Send`\n"
"    |\n"
"note: future is not `Send` as this value is used across an await\n"
"    |\n"
"11  |     let non_send = Rc::new(1);\n"
"    |         -------- has type `Rc<i32>` which is not `Send`\n"
"12  |     // A `.await` point\n"
"13  |     yield_now().await;\n"
"    |                 ^^^^^ await occurs here, with `non_send` maybe used "
"later\n"
"note: required by a bound in `tokio::spawn`\n"
"    |\n"
"164 |     pub fn spawn<F>(future: F) -> JoinHandle<F::Output>\n"
"    |            ----- required by a bound in this function\n"
"165 |     where\n"
"166 |         F: Future + Send + 'static,\n"
"    |                     ^^^^ required by this bound in `spawn`\n"
"```"
msgstr ""

#: src/08_futures/04_future.md:68
#, fuzzy
msgid ""
"To understand why that's the case, we need to refine our understanding of "
"Rust's asynchronous model."
msgstr ""
"ì™œ ê·¸ëŸ° ê²½ìš°ì¸ì§€ ì´í•´í•˜ë ¤ë©´ Rustì˜ ë¹„ë™ê¸° ëª¨ë¸ì— ëŒ€í•œ ì´í•´ë¥¼ ê°œì„ í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/08_futures/04_future.md:73
#, fuzzy
msgid ""
"We stated early on that `async` functions return **futures**, types that "
"implement the `Future` trait. You can think of a future as a **state "
"machine**. It's in one of two states:"
msgstr ""
"ìš°ë¦¬ëŠ” `async` í•¨ìˆ˜ê°€ `Future` íŠ¹ì„±ì„ êµ¬í˜„í•˜ëŠ” ìœ í˜•ì¸ **futures**ë¥¼ ë°˜í™˜í•œë‹¤"
"ê³  ì¼ì° ë°í˜”ìŠµë‹ˆë‹¤. ë¯¸ë˜ë¥¼ **ìƒíƒœ ë¨¸ì‹ **ìœ¼ë¡œ ìƒê°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ë‘ ê°€ì§€ "
"ìƒíƒœ ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤."

#: src/08_futures/04_future.md:77
#, fuzzy
msgid "**pending**: the computation has not finished yet."
msgstr "**ë³´ë¥˜ ì¤‘**: ê³„ì‚°ì´ ì•„ì§ ì™„ë£Œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."

#: src/08_futures/04_future.md:78
#, fuzzy
msgid "**ready**: the computation has finished, here's the output."
msgstr "**ì¤€ë¹„**: ê³„ì‚°ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ì¶œë ¥ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤."

#: src/08_futures/04_future.md:80
#, fuzzy
msgid "This is encoded in the trait definition:"
msgstr "ì´ëŠ” íŠ¹ì„± ì •ì˜ì— ì¸ì½”ë”©ë˜ì–´ ìˆìŠµë‹ˆë‹¤."

#: src/08_futures/04_future.md:86
#, fuzzy
msgid "// Ignore `Pin` and `Context` for now\n"
msgstr "// ì§€ê¸ˆì€ `Pin`ê³¼ `Context`ë¥¼ ë¬´ì‹œí•©ë‹ˆë‹¤."

#: src/08_futures/04_future.md:91
#, fuzzy
msgid "`poll`"
msgstr "'ì„¤ë¬¸ì¡°ì‚¬'"

#: src/08_futures/04_future.md:93
#, fuzzy
msgid ""
"The `poll` method is the heart of the `Future` trait.  \n"
"A future on its own doesn't do anything. It needs to be **polled** to make "
"progress.  \n"
"When you call `poll`, you're asking the future to do some work. `poll` tries "
"to make progress, and then returns one of the following:"
msgstr ""
"'Poll' ë°©ë²•ì€ 'Future' íŠ¹ì„±ì˜ í•µì‹¬ì…ë‹ˆë‹¤.  \n"
"ë¯¸ë˜ ê·¸ ìì²´ë¡œëŠ” ì•„ë¬´ê²ƒë„ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì§„í–‰í•˜ë ¤ë©´ **í´ë§**ì´ í•„ìš”í•©ë‹ˆ"
"ë‹¤.  \n"
"'poll'ì„ í˜¸ì¶œí•˜ë©´ ë¯¸ë˜ì— ì‘ì—…ì„ ìš”ì²­í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. `poll`ì€ ì§„í–‰ì„ ì‹œë„í•œ í›„ "
"ë‹¤ìŒ ì¤‘ í•˜ë‚˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."

#: src/08_futures/04_future.md:98
#, fuzzy
msgid ""
"`Poll::Pending`: the future is not ready yet. You need to call `poll` again "
"later."
msgstr ""
"`Poll::Pending`: ë¯¸ë˜ëŠ” ì•„ì§ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ë‚˜ì¤‘ì— 'poll'ì„ ë‹¤ì‹œ í˜¸ì¶œí•´"
"ì•¼ í•©ë‹ˆë‹¤."

#: src/08_futures/04_future.md:99
#, fuzzy
msgid ""
"`Poll::Ready(value)`: the future has finished. `value` is the result of the "
"computation, of type `Self::Output`."
msgstr ""
"`Poll::Ready(value)`: futureê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. 'value'ëŠ” 'Self::Output' ìœ í˜•"
"ì˜ ê³„ì‚° ê²°ê³¼ì…ë‹ˆë‹¤."

#: src/08_futures/04_future.md:102
#, fuzzy
msgid ""
"Once `Future::poll` returns `Poll::Ready`, it should not be polled again: the "
"future has completed, there's nothing left to do."
msgstr ""
"`Future::poll`ì´ `Poll::Ready`ë¥¼ ë°˜í™˜í•˜ë©´ ë‹¤ì‹œ í´ë§í•´ì„œëŠ” ì•ˆ ë©ë‹ˆë‹¤. futureê°€ "
"ì™„ë£Œë˜ì—ˆìœ¼ë¯€ë¡œ ë” ì´ìƒ í•  ì¼ì´ ì—†ìŠµë‹ˆë‹¤."

#: src/08_futures/04_future.md:105
#, fuzzy
msgid "The role of the runtime"
msgstr "ëŸ°íƒ€ì„ì˜ ì—­í• "

#: src/08_futures/04_future.md:107
#, fuzzy
msgid ""
"You'll rarely, if ever, be calling poll directly.  \n"
"That's the job of your async runtime: it has all the required information "
"(the `Context` in `poll`'s signature) to ensure that your futures are making "
"progress whenever they can."
msgstr ""
"ì„¤ë¬¸ ì¡°ì‚¬ë¥¼ ì§ì ‘ í˜¸ì¶œí•˜ëŠ” ê²½ìš°ëŠ” ê±°ì˜ ì—†ìŠµë‹ˆë‹¤.  \n"
"ì´ê²ƒì´ ë¹„ë™ê¸° ëŸ°íƒ€ì„ì˜ ì„ë¬´ì…ë‹ˆë‹¤. ë¯¸ë˜ê°€ ê°€ëŠ¥í•  ë•Œë§ˆë‹¤ ì§„í–‰ë˜ê³  ìˆëŠ”ì§€ í™•ì¸í•˜"
"ëŠ” ë° í•„ìš”í•œ ëª¨ë“  ì •ë³´(`poll` ì„œëª…ì˜ `Context`)ê°€ ìˆìŠµë‹ˆë‹¤."

#: src/08_futures/04_future.md:111
#, fuzzy
msgid "`async fn` and futures"
msgstr "`async fn`ê³¼ ë¯¸ë˜"

#: src/08_futures/04_future.md:113
#, fuzzy
msgid ""
"We've worked with the high-level interface, asynchronous functions.  \n"
"We've now looked at the low-level primitive, the `Future trait`."
msgstr ""
"ìš°ë¦¬ëŠ” ë†’ì€ ìˆ˜ì¤€ì˜ ì¸í„°í˜ì´ìŠ¤ì¸ ë¹„ë™ê¸° ê¸°ëŠ¥ì„ ì‚¬ìš©í•´ ì‘ì—…í–ˆìŠµë‹ˆë‹¤.  \n"
"ìš°ë¦¬ëŠ” ì´ì œ ì €ìˆ˜ì¤€ í”„ë¦¬ë¯¸í‹°ë¸Œì¸ 'ë¯¸ë˜ íŠ¹ì„±'ì„ ì‚´í´ë³´ì•˜ìŠµë‹ˆë‹¤."

#: src/08_futures/04_future.md:116
#, fuzzy
msgid "How are they related?"
msgstr "ê·¸ë“¤ì€ ì–´ë–»ê²Œ ê´€ë ¨ë˜ì–´ ìˆìŠµë‹ˆê¹Œ?"

#: src/08_futures/04_future.md:118
#, fuzzy
msgid ""
"Every time you mark a function as asynchronous, that function will return a "
"future. The compiler will transform the body of your asynchronous function "
"into a **state machine**: one state for each `.await` point."
msgstr ""
"í•¨ìˆ˜ë¥¼ ë¹„ë™ê¸°ë¡œ í‘œì‹œí•  ë•Œë§ˆë‹¤ í•´ë‹¹ í•¨ìˆ˜ëŠ” futureë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” ë¹„ë™"
"ê¸° í•¨ìˆ˜ì˜ ë³¸ë¬¸ì„ **ìƒíƒœ ë¨¸ì‹ **ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤. ê° `.await` ì§€ì ì— ëŒ€í•´ í•˜ë‚˜ì˜ "
"ìƒíƒœì…ë‹ˆë‹¤."

#: src/08_futures/04_future.md:122
#, fuzzy
msgid "Going back to our `Rc` example:"
msgstr "`Rc` ì˜ˆì œë¡œ ëŒì•„ê°€ë©´:"

#: src/08_futures/04_future.md:135
#, fuzzy
msgid ""
"The compiler would transform it into an enum that looks somewhat like this:"
msgstr "ì»´íŒŒì¼ëŸ¬ëŠ” ì´ë¥¼ ë‹¤ìŒê³¼ ê°™ì€ ì—´ê±°í˜•ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤."

#: src/08_futures/04_future.md:145
#, fuzzy
msgid ""
"When `example` is called, it returns `ExampleFuture::NotStarted`. The future "
"has never been polled yet, so nothing has happened.  \n"
"When the runtime polls it the first time, `ExampleFuture` will advance until "
"the next `.await` point: it'll stop at the `ExampleFuture::YieldNow(Rc<i32>)` "
"stage of the state machine, returning `Poll::Pending`.  \n"
"When it's polled again, it'll execute the remaining code (`println!`) and "
"return `Poll::Ready(())`."
msgstr ""
"`example`ì´ í˜¸ì¶œë˜ë©´ `ExampleFuture::NotStarted`ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. ë¯¸ë˜ëŠ” ì•„ì§ í´"
"ë§ëœ ì ì´ ì—†ìœ¼ë¯€ë¡œ ì•„ë¬´ ì¼ë„ ì¼ì–´ë‚˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.  \n"
"ëŸ°íƒ€ì„ì´ ì²˜ìŒìœ¼ë¡œ í´ë§í•˜ë©´ `ExampleFuture`ëŠ” ë‹¤ìŒ `.await` ì§€ì ê¹Œì§€ ì§„í–‰ë©ë‹ˆ"
"ë‹¤. ìƒíƒœ ì‹œìŠ¤í…œì˜ `ExampleFuture::YieldNow(Rc<i32>)` ë‹¨ê³„ì—ì„œ ë©ˆì¶”ê³  `Poll'ì„ "
"ë°˜í™˜í•©ë‹ˆë‹¤. ::ë³´ë¥˜ì¤‘`.  \n"
"ë‹¤ì‹œ í´ë§ë˜ë©´ ë‚˜ë¨¸ì§€ ì½”ë“œ(`println!`)ë¥¼ ì‹¤í–‰í•˜ê³  `Poll::Ready(())`ë¥¼ ë°˜í™˜í•©ë‹ˆ"
"ë‹¤."

#: src/08_futures/04_future.md:153
#, fuzzy
msgid ""
"When you look at its state machine representation, `ExampleFuture`, it is now "
"clear why `example` is not `Send`: it holds an `Rc`, therefore it cannot be "
"`Send`."
msgstr ""
"ìƒíƒœ ë¨¸ì‹  í‘œí˜„ì¸ `ExampleFuture`ë¥¼ ë³´ë©´ ì´ì œ `example`ì´ `Send`ê°€ ì•„ë‹Œ ì´ìœ ê°€ "
"ë¶„ëª…í•´ì¡ŒìŠµë‹ˆë‹¤. ì—¬ê¸°ì—ëŠ” `Rc`ê°€ ìˆìœ¼ë¯€ë¡œ `Send`ê°€ ë  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: src/08_futures/04_future.md:157
#, fuzzy
msgid "Yield points"
msgstr "í•­ë³µì "

#: src/08_futures/04_future.md:159
#, fuzzy
msgid ""
"As you've just seen with `example`, every `.await` point creates a new "
"intermediate state in the lifecycle of a future.  \n"
"That's why `.await` points are also known as **yield points**: your future "
"_yields control_ back to the runtime that was polling it, allowing the "
"runtime to pause it and (if necessary) schedule another task for execution, "
"thus making progress on multiple fronts concurrently."
msgstr ""
"ë°©ê¸ˆ `example`ì—ì„œ ë³¸ ê²ƒì²˜ëŸ¼ ëª¨ë“  `.await` ì§€ì ì€ futureì˜ ìˆ˜ëª… ì£¼ê¸°ì—ì„œ ìƒˆë¡œ"
"ìš´ ì¤‘ê°„ ìƒíƒœë¥¼ ìƒì„±í•©ë‹ˆë‹¤.  \n"
"ê·¸ë ‡ê¸° ë•Œë¬¸ì— `.await` í¬ì¸íŠ¸ëŠ” **ìˆ˜ìœ¨ í¬ì¸íŠ¸**ë¼ê³ ë„ ì•Œë ¤ì ¸ ìˆìŠµë‹ˆë‹¤. ë¯¸ë˜ì˜ "
"_ìˆ˜ìœ¨ ì œì–´_ëŠ” ì´ë¥¼ í´ë§í•œ ëŸ°íƒ€ì„ìœ¼ë¡œ ëŒì•„ê°€ì„œ ëŸ°íƒ€ì„ì´ ì´ë¥¼ ì¼ì‹œ ì¤‘ì§€í•˜ê³  (í•„"
"ìš”í•œ ê²½ìš°) ì‹¤í–‰ì„ ìœ„í•´ ë‹¤ë¥¸ ì‘ì—…ì„ ì˜ˆì•½í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤. ì—¬ëŸ¬ ë¶„ì•¼ì—ì„œ ë™ì‹œ"
"ì— ì§„í–‰ë©ë‹ˆë‹¤."

#: src/08_futures/04_future.md:165
#, fuzzy
msgid "We'll come back to the importance of yielding in a later section."
msgstr "ìš°ë¦¬ëŠ” ë‚˜ì¤‘ ì„¹ì…˜ì—ì„œ ì–‘ë³´ì˜ ì¤‘ìš”ì„±ìœ¼ë¡œ ë‹¤ì‹œ ëŒì•„ì˜¤ê² ìŠµë‹ˆë‹¤."

#: src/08_futures/04_future.md:169
msgid ""
"The exercise for this section is located in [`08_futures/04_future`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/08_futures/04_future)"
msgstr ""

#: src/08_futures/05_blocking.md:1
#, fuzzy
msgid "Don't block the runtime"
msgstr "ëŸ°íƒ€ì„ì„ ì°¨ë‹¨í•˜ì§€ ë§ˆì„¸ìš”"

#: src/08_futures/05_blocking.md:3
#, fuzzy
msgid ""
"Let's circle back to yield points.  \n"
"Unlike threads, **Rust tasks cannot be preempted**."
msgstr ""
"í•­ë³µì ìœ¼ë¡œ ë‹¤ì‹œ ëŒì•„ê°‘ì‹œë‹¤.  \n"
"ìŠ¤ë ˆë“œì™€ ë‹¬ë¦¬ **Rust ì‘ì—…ì€ ì„ ì ë  ìˆ˜ ì—†ìŠµë‹ˆë‹¤**."

#: src/08_futures/05_blocking.md:6
#, fuzzy
msgid ""
"`tokio` cannot, on its own, decide to pause a task and run another one in its "
"place. The control goes back to the executor **exclusively** when the task "
"yieldsâ€”i.e. when `Future::poll` returns `Poll::Pending` or, in the case of "
"`async fn`, when you `.await` a future."
msgstr ""
"'tokio'ëŠ” ìì²´ì ìœ¼ë¡œ ì‘ì—…ì„ ì¼ì‹œ ì¤‘ì§€í•˜ê³  ê·¸ ìë¦¬ì—ì„œ ë‹¤ë¥¸ ì‘ì—…ì„ ì‹¤í–‰í•˜ê¸°ë¡œ "
"ê²°ì •í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì‘ì—…ì´ ì–‘ë³´ë˜ë©´ ì œì–´ê¶Œì€ **ë…ì ì ìœ¼ë¡œ** ì‹¤í–‰ìì—ê²Œ ëŒì•„ê°‘"
"ë‹ˆë‹¤. ì¦‰, `Future::poll`ì´ `Poll::Pending`ì„ ë°˜í™˜í•  ë•Œ ë˜ëŠ” `async fn`ì˜ ê²½ìš° "
"ë¯¸ë˜ë¥¼ `.await`í•  ë•Œ."

#: src/08_futures/05_blocking.md:11
#, fuzzy
msgid ""
"This exposes the runtime to a risk: if a task never yields, the runtime will "
"never be able to run another task. This is called **blocking the runtime**."
msgstr ""
"ì´ë¡œ ì¸í•´ ëŸ°íƒ€ì„ì´ ìœ„í—˜ì— ë…¸ì¶œë©ë‹ˆë‹¤. ì‘ì—…ì´ ê²°ì½” ì–‘ë³´ë˜ì§€ ì•Šìœ¼ë©´ ëŸ°íƒ€ì„ì€ ë‹¤"
"ë¥¸ ì‘ì—…ì„ ì‹¤í–‰í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì´ë¥¼ **ëŸ°íƒ€ì„ ì°¨ë‹¨**ì´ë¼ê³  í•©ë‹ˆë‹¤."

#: src/08_futures/05_blocking.md:14
#, fuzzy
msgid "What is blocking?"
msgstr "ì°¨ë‹¨ì´ë€ ë¬´ì—‡ì…ë‹ˆê¹Œ?"

#: src/08_futures/05_blocking.md:16
#, fuzzy
msgid ""
"How long is too long? How much time can a task spend without yielding before "
"it becomes a problem?"
msgstr ""
"ì–¼ë§ˆë‚˜ ê¸´ê°€ìš”? ì‘ì—…ì´ ë¬¸ì œê°€ ë˜ê¸° ì „ì— ì–‘ë³´í•˜ì§€ ì•Šê³  ì–¼ë§ˆë‚˜ ë§ì€ ì‹œê°„ì„ ë³´ë‚¼ "
"ìˆ˜ ìˆìŠµë‹ˆê¹Œ?"

#: src/08_futures/05_blocking.md:19
#, fuzzy
msgid ""
"It depends on the runtime, the application, the number of in-flight tasks, "
"and many other factors. But, as a general rule of thumb, try to spend less "
"than 100 microseconds between yield points."
msgstr ""
"ëŸ°íƒ€ì„, ì• í”Œë¦¬ì¼€ì´ì…˜, ì§„í–‰ ì¤‘ì¸ ì‘ì—… ìˆ˜ ë° ê¸°íƒ€ ì—¬ëŸ¬ ìš”ì¸ì— ë”°ë¼ ë‹¬ë¼ì§‘ë‹ˆë‹¤. "
"ê·¸ëŸ¬ë‚˜ ì¼ë°˜ì ìœ¼ë¡œ í•­ë³µì  ì‚¬ì´ì— 100ë§ˆì´í¬ë¡œì´ˆ ë¯¸ë§Œì˜ ì‹œê°„ì„ ì†Œë¹„í•˜ë„ë¡ ë…¸ë ¥í•˜"
"ì‹­ì‹œì˜¤."

#: src/08_futures/05_blocking.md:23
#, fuzzy
msgid "Consequences"
msgstr "ê²°ê³¼"

#: src/08_futures/05_blocking.md:25
#, fuzzy
msgid "Blocking the runtime can lead to:"
msgstr "ëŸ°íƒ€ì„ì„ ì°¨ë‹¨í•˜ë©´ ë‹¤ìŒê³¼ ê°™ì€ ê²°ê³¼ê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/08_futures/05_blocking.md:27
#, fuzzy
msgid ""
"**Deadlocks**: if the task that's not yielding is waiting for another task to "
"complete, and that task is waiting for the first one to yield, you have a "
"deadlock. No progress can be made, unless the runtime is able to schedule the "
"other task on a different thread."
msgstr ""
"**êµì°© ìƒíƒœ**: ì–‘ë³´í•˜ì§€ ì•ŠëŠ” ì‘ì—…ì´ ë‹¤ë¥¸ ì‘ì—…ì´ ì™„ë£Œë˜ê¸°ë¥¼ ê¸°ë‹¤ë¦¬ê³  ìˆê³  í•´ë‹¹ "
"ì‘ì—…ì´ ì²« ë²ˆì§¸ ì‘ì—…ì´ ì–‘ë³´ë˜ê¸°ë¥¼ ê¸°ë‹¤ë¦¬ê³  ìˆë‹¤ë©´ êµì°© ìƒíƒœê°€ ë°œìƒí•œ ê²ƒì…ë‹ˆë‹¤. "
"ëŸ°íƒ€ì„ì´ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ì„œ ë‹¤ë¥¸ ì‘ì—…ì„ ì˜ˆì•½í•  ìˆ˜ ì—†ìœ¼ë©´ ì§„í–‰ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤."

#: src/08_futures/05_blocking.md:31
#, fuzzy
msgid ""
"**Starvation**: other tasks might not be able to run, or might run after a "
"long delay, which can lead to poor performances (e.g. high tail latencies)."
msgstr ""
"**ê¸°ì•„**: ë‹¤ë¥¸ ì‘ì—…ì„ ì‹¤í–‰í•  ìˆ˜ ì—†ê±°ë‚˜ ì˜¤ëœ ì§€ì—° í›„ì— ì‹¤í–‰ë  ìˆ˜ ìˆìœ¼ë©°, ì´ë¡œ "
"ì¸í•´ ì„±ëŠ¥ì´ ì €í•˜ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤(ì˜ˆ: ê¸´ ê¼¬ë¦¬ ì§€ì—° ì‹œê°„)."

#: src/08_futures/05_blocking.md:34
#, fuzzy
msgid "Blocking is not always obvious"
msgstr "ì°¨ë‹¨ì´ í•­ìƒ ëª…í™•í•œ ê²ƒì€ ì•„ë‹™ë‹ˆë‹¤."

#: src/08_futures/05_blocking.md:36
#, fuzzy
msgid ""
"Some types of operations should generally be avoided in async code, like:"
msgstr ""
"ë‹¤ìŒê³¼ ê°™ì€ ì¼ë¶€ ìœ í˜•ì˜ ì‘ì—…ì€ ì¼ë°˜ì ìœ¼ë¡œ ë¹„ë™ê¸° ì½”ë“œì—ì„œ í”¼í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/08_futures/05_blocking.md:38
#, fuzzy
msgid ""
"Synchronous I/O. You can't predict how long it will take, and it's likely to "
"be longer than 100 microseconds."
msgstr ""
"ë™ê¸°ì‹ I/O. ì‹œê°„ì´ ì–¼ë§ˆë‚˜ ê±¸ë¦´ì§€ ì˜ˆì¸¡í•  ìˆ˜ ì—†ìœ¼ë©° 100ë§ˆì´í¬ë¡œì´ˆë³´ë‹¤ ê¸¸ì–´ì§ˆ ê°€"
"ëŠ¥ì„±ì´ ë†’ìŠµë‹ˆë‹¤."

#: src/08_futures/05_blocking.md:40
#, fuzzy
msgid "Expensive CPU-bound computations."
msgstr "CPU ë°”ì¸ë”©ëœ ê³„ì‚° ë¹„ìš©ì´ ë§ì´ ë“­ë‹ˆë‹¤."

#: src/08_futures/05_blocking.md:42
msgid ""
"The latter category is not always obvious though. For example, sorting a "
"vector with a few elements is not a problem; that evaluation changes if the "
"vector has billions of entries."
msgstr ""

#: src/08_futures/05_blocking.md:46
#, fuzzy
msgid "How to avoid blocking"
msgstr "ì°¨ë‹¨ì„ í”¼í•˜ëŠ” ë°©ë²•"

#: src/08_futures/05_blocking.md:48
#, fuzzy
msgid ""
"OK, so how do you avoid blocking the runtime assuming you _must_ perform an "
"operation that qualifies or risks qualifying as blocking?  \n"
"You need to move the work to a different thread. You don't want to use the so-"
"called runtime threads, the ones used by `tokio` to run tasks."
msgstr ""
"ê·¸ë ‡ë‹¤ë©´ ì°¨ë‹¨ ìê²©ì„ ê°–ì¶”ê±°ë‚˜ ì°¨ë‹¨ ìê²©ì„ ì–»ì„ ìœ„í—˜ì´ ìˆëŠ” ì‘ì—…ì„ _ë°˜ë“œì‹œ_ ìˆ˜"
"í–‰í•´ì•¼ í•œë‹¤ê³  ê°€ì •í•  ë•Œ ëŸ°íƒ€ì„ ì°¨ë‹¨ì„ ì–´ë–»ê²Œ ë°©ì§€í•  ìˆ˜ ìˆì„ê¹Œìš”?  \n"
"ì‘ì—…ì„ ë‹¤ë¥¸ ìŠ¤ë ˆë“œë¡œ ì´ë™í•´ì•¼ í•©ë‹ˆë‹¤. ì‘ì—…ì„ ì‹¤í–‰í•˜ê¸° ìœ„í•´ `tokio`ì—ì„œ ì‚¬ìš©í•˜"
"ëŠ” ì†Œìœ„ ëŸ°íƒ€ì„ ìŠ¤ë ˆë“œë¥¼ ì‚¬ìš©í•˜ê³  ì‹¶ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/08_futures/05_blocking.md:53
#, fuzzy
msgid ""
"`tokio` provides a dedicated threadpool for this purpose, called the "
"**blocking pool**. You can spawn a synchronous operation on the blocking pool "
"using the `tokio::task::spawn_blocking` function. `spawn_blocking` returns a "
"future that resolves to the result of the operation when it completes."
msgstr ""
"`tokio`ëŠ” ì´ ëª©ì ì„ ìœ„í•´ **ì°¨ë‹¨ í’€**ì´ë¼ê³  ë¶ˆë¦¬ëŠ” ì „ìš© ìŠ¤ë ˆë“œ í’€ì„ ì œê³µí•©ë‹ˆ"
"ë‹¤. `tokio::task::spawn_blocking` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ì°¨ë‹¨ í’€ì—ì„œ ë™ê¸° ì‘ì—…ì„ ìƒì„±"
"í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `spawn_blocking`ì€ ì‘ì—…ì´ ì™„ë£Œë˜ë©´ ì‘ì—… ê²°ê³¼ë¡œ í™•ì¸ë˜ëŠ” future"
"ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."

#: src/08_futures/05_blocking.md:67
#, fuzzy
msgid "// Do other stuff in the meantime\n"
msgstr "// ê·¸ë™ì•ˆ ë‹¤ë¥¸ ì¼ì„ í•˜ì„¸ìš”"

#: src/08_futures/05_blocking.md:72
#, fuzzy
msgid ""
"The blocking pool is long-lived. `spawn_blocking` should be faster than "
"creating a new thread directly via `std::thread::spawn` because the cost of "
"thread initialization is amortized over multiple calls."
msgstr ""
"ì°¨ë‹¨ í’€ì€ ìˆ˜ëª…ì´ ê¸¸ë‹¤. ìŠ¤ë ˆë“œ ì´ˆê¸°í™” ë¹„ìš©ì€ ì—¬ëŸ¬ í˜¸ì¶œì„ í†µí•´ ë¶„í• ë˜ë¯€ë¡œ "
"`spawn_blocking`ì€ `std::thread::spawn`ì„ í†µí•´ ì§ì ‘ ìƒˆ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ëŠ” ê²ƒë³´"
"ë‹¤ ë” ë¹ ë¦…ë‹ˆë‹¤."

#: src/08_futures/05_blocking.md:78
#, fuzzy
msgid ""
"Check out [Alice Ryhl's blog post](https://ryhl.io/blog/async-what-is-"
"blocking/) on the topic."
msgstr "í•´ë‹¹ ì£¼ì œì— ëŒ€í•œ Alice Ryhlì˜ ë¸”ë¡œê·¸ ê²Œì‹œë¬¼ì„ í™•ì¸í•˜ì„¸ìš”."

#: src/08_futures/05_blocking.md:83
msgid ""
"The exercise for this section is located in [`08_futures/05_blocking`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/08_futures/05_blocking)"
msgstr ""

#: src/08_futures/06_async_aware_primitives.md:3
#, fuzzy
msgid ""
"If you browse `tokio`'s documentation, you'll notice that it provides a lot "
"of types that \"mirror\" the ones in the standard library, but with an "
"asynchronous twist: locks, channels, timers, and more."
msgstr ""
"`tokio`ì˜ ë¬¸ì„œë¥¼ ì°¾ì•„ë³´ë©´ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ ìœ í˜•ì„ \"ë¯¸ëŸ¬ë§\"í•˜ì§€ë§Œ ì ê¸ˆ, ì±„"
"ë„, íƒ€ì´ë¨¸ ë“± ë¹„ë™ê¸°ì‹ ë³€í˜•ì´ í¬í•¨ëœ ë§ì€ ìœ í˜•ì„ ì œê³µí•œë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆ"
"ë‹¤."

#: src/08_futures/06_async_aware_primitives.md:7
#, fuzzy
msgid ""
"When working in an asynchronous context, you should prefer these asynchronous "
"alternatives to their synchronous counterparts."
msgstr ""
"ë¹„ë™ê¸°ì‹ ì»¨í…ìŠ¤íŠ¸ì—ì„œ ì‘ì—…í•  ë•ŒëŠ” ë™ê¸°ì‹ ì»¨í…ìŠ¤íŠ¸ë³´ë‹¤ ì´ëŸ¬í•œ ë¹„ë™ê¸°ì‹ ëŒ€ì•ˆì„ "
"ì„ í˜¸í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/08_futures/06_async_aware_primitives.md:10
#, fuzzy
msgid ""
"To understand why, let's take a look at `Mutex`, the mutually exclusive lock "
"we explored in the previous chapter."
msgstr ""
"ê·¸ ì´ìœ ë¥¼ ì´í•´í•˜ê¸° ìœ„í•´ ì´ì „ ì¥ì—ì„œ ì‚´í´ë³¸ ìƒí˜¸ ë°°íƒ€ì  ì ê¸ˆ ì¥ì¹˜ì¸ 'Mutex'ë¥¼ "
"ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤."

#: src/08_futures/06_async_aware_primitives.md:13
#, fuzzy
msgid "Case study: `Mutex`"
msgstr "ì‚¬ë¡€ ì—°êµ¬: 'ë®¤í…ìŠ¤'"

#: src/08_futures/06_async_aware_primitives.md:15
#, fuzzy
msgid "Let's look at a simple example:"
msgstr "ê°„ë‹¨í•œ ì˜ˆë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤."

#: src/08_futures/06_async_aware_primitives.md:23
#: src/08_futures/06_async_aware_primitives.md:70
#, fuzzy
msgid "\"Sent {:?} to the server\""
msgstr "\"{:?}ì„(ë¥¼) ì„œë²„ë¡œ ë³´ëƒˆìŠµë‹ˆë‹¤.\""

#: src/08_futures/06_async_aware_primitives.md:24
#: src/08_futures/06_async_aware_primitives.md:71
#, fuzzy
msgid "// `guard` is dropped here\n"
msgstr "// `guard`ê°€ ì—¬ê¸°ì— ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤."

#: src/08_futures/06_async_aware_primitives.md:26
#, fuzzy
msgid "/// Use `v` as the body of an HTTP call.\n"
msgstr "/// `v`ë¥¼ HTTP í˜¸ì¶œì˜ ë³¸ë¬¸ìœ¼ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤."

#: src/08_futures/06_async_aware_primitives.md:33
#, fuzzy
msgid "`std::sync::MutexGuard` and yield points"
msgstr "`std::sync::MutexGuard` ë° í•­ë³µì "

#: src/08_futures/06_async_aware_primitives.md:35
#, fuzzy
msgid "This code will compile, but it's dangerous."
msgstr "ì´ ì½”ë“œëŠ” ì»´íŒŒì¼ë˜ì§€ë§Œ ìœ„í—˜í•©ë‹ˆë‹¤."

#: src/08_futures/06_async_aware_primitives.md:37
#, fuzzy
msgid ""
"We try to acquire a lock over a `Mutex` from `std` in an asynchronous "
"context. We then hold on to the resulting `MutexGuard` across a yield point "
"(the `.await` on `http_call`)."
msgstr ""
"ë¹„ë™ê¸° ì»¨í…ìŠ¤íŠ¸ì˜ `std`ì—ì„œ `Mutex`ì— ëŒ€í•œ ì ê¸ˆì„ íšë“í•˜ë ¤ê³  í•©ë‹ˆë‹¤. ê·¸ëŸ° ë‹¤"
"ìŒ í•­ë³µ ì§€ì (`http_call`ì˜ `.await`)ì—ì„œ ê²°ê³¼ `MutexGuard`ë¥¼ ìœ ì§€í•©ë‹ˆë‹¤."

#: src/08_futures/06_async_aware_primitives.md:41
#, fuzzy
msgid ""
"Let's imagine that there are two tasks executing `run`, concurrently, on a "
"single-threaded runtime. We observe the following sequence of scheduling "
"events:"
msgstr ""
"ë‹¨ì¼ ìŠ¤ë ˆë“œ ëŸ°íƒ€ì„ì—ì„œ 'run'ì„ ë™ì‹œì— ì‹¤í–‰í•˜ëŠ” ë‘ ê°€ì§€ ì‘ì—…ì´ ìˆë‹¤ê³  ê°€ì •í•´ ë³´"
"ê² ìŠµë‹ˆë‹¤. ìš°ë¦¬ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì¼ì • ì´ë²¤íŠ¸ ìˆœì„œë¥¼ ê´€ì°°í•©ë‹ˆë‹¤."

#: src/08_futures/06_async_aware_primitives.md:55
#, fuzzy
msgid ""
"We have a deadlock. Task B we'll never manage to acquire the lock, because "
"the lock is currently held by task A, which has yielded to the runtime before "
"releasing the lock and won't be scheduled again because the runtime cannot "
"preempt task B."
msgstr ""
"êµì°©ìƒíƒœì— ë¹ ì¡ŒìŠµë‹ˆë‹¤. ì‘ì—… BëŠ” ì ê¸ˆì„ íšë“í•˜ì§€ ëª»í•  ê²ƒì…ë‹ˆë‹¤. í˜„ì¬ ì‘ì—… Aê°€ "
"ì ê¸ˆì„ ë³´ìœ í•˜ê³  ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ì‘ì—… AëŠ” ì ê¸ˆì„ í•´ì œí•˜ê¸° ì „ì— ëŸ°íƒ€ì„ì— ì–‘ë³´í–ˆ"
"ìœ¼ë©° ëŸ°íƒ€ì„ì´ ì‘ì—… Bë¥¼ ì„ ì í•  ìˆ˜ ì—†ê¸° ë•Œë¬¸ì— ë‹¤ì‹œ ì˜ˆì•½ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/08_futures/06_async_aware_primitives.md:59
#, fuzzy
msgid "`tokio::sync::Mutex`"
msgstr "`tokio::sync::ë®¤í…ìŠ¤`"

#: src/08_futures/06_async_aware_primitives.md:61
#, fuzzy
msgid "You can solve the issue by switching to `tokio::sync::Mutex`:"
msgstr "`tokio::sync::Mutex`ë¡œ ì „í™˜í•˜ë©´ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/08_futures/06_async_aware_primitives.md:75
#, fuzzy
msgid ""
"Acquiring the lock is now an asynchronous operation, which yields back to the "
"runtime if it can't make progress.  \n"
"Going back to the previous scenario, the following would happen:"
msgstr ""
"ì ê¸ˆ íšë“ì€ ì´ì œ ë¹„ë™ê¸°ì‹ ì‘ì—…ìœ¼ë¡œ ì§„í–‰ë˜ì§€ ì•Šìœ¼ë©´ ëŸ°íƒ€ì„ìœ¼ë¡œ ë°˜í™˜ë©ë‹ˆë‹¤.  \n"
"ì´ì „ ì‹œë‚˜ë¦¬ì˜¤ë¡œ ëŒì•„ê°€ë©´ ë‹¤ìŒê³¼ ê°™ì€ ì¼ì´ ë°œìƒí•©ë‹ˆë‹¤."

#: src/08_futures/06_async_aware_primitives.md:104
#, fuzzy
msgid "All good!"
msgstr "ë¬¸ì œ ì—†ë‹¤!"

#: src/08_futures/06_async_aware_primitives.md:106
#, fuzzy
msgid "Multithreaded won't save you"
msgstr "ë©€í‹°ìŠ¤ë ˆë“œë¡œëŠ” ë‹¹ì‹ ì„ êµ¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤"

#: src/08_futures/06_async_aware_primitives.md:108
msgid ""
"We've used a single-threaded runtime as the execution context in our previous "
"example, but the same risk persists even when using a multithreaded "
"runtime.  \n"
"The only difference is in the number of concurrent tasks required to create "
"the deadlock: in a single-threaded runtime, 2 are enough; in a multithreaded "
"runtime, we would need `N+1` tasks, where `N` is the number of runtime "
"threads."
msgstr ""

#: src/08_futures/06_async_aware_primitives.md:117
#, fuzzy
msgid ""
"Having an async-aware `Mutex` comes with a performance penalty.  \n"
"If you're confident that the lock isn't under significant contention _and_ "
"you're careful to never hold it across a yield point, you can still use `std::"
"sync::Mutex` in an asynchronous context."
msgstr ""
"ë¹„ë™ê¸° ì¸ì‹ `Mutex`ë¥¼ ì‚¬ìš©í•˜ë©´ ì„±ëŠ¥ì´ ì €í•˜ë©ë‹ˆë‹¤.  \n"
"ì ê¸ˆì´ ì‹¬ê°í•œ ê²½í•© ìƒíƒœì— ìˆì§€ ì•Šë‹¤ê³  í™•ì‹ í•˜ê³  _ê·¸ë¦¬ê³ _ ì–‘ë³´ ì§€ì ì„ ë„˜ì–´ ì ê¸ˆ"
"ì„ ìœ ì§€í•˜ì§€ ì•Šë„ë¡ ì£¼ì˜í•œë‹¤ë©´ ì—¬ì „íˆ ë¹„ë™ê¸° ì»¨í…ìŠ¤íŠ¸ì—ì„œ `std::sync::Mutex`ë¥¼ "
"ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/08_futures/06_async_aware_primitives.md:122
#, fuzzy
msgid ""
"But weigh the performance benefit against the liveness risk you will incur."
msgstr "í•˜ì§€ë§Œ ë°œìƒí•  ìˆ˜ ìˆëŠ” í™œì„± ìœ„í—˜ê³¼ ì„±ëŠ¥ìƒì˜ ì´ì ì„ ë¹„êµí•´ë³´ì„¸ìš”."

#: src/08_futures/06_async_aware_primitives.md:125
#, fuzzy
msgid "Other primitives"
msgstr "ê¸°íƒ€ í”„ë¦¬ë¯¸í‹°ë¸Œ"

#: src/08_futures/06_async_aware_primitives.md:127
#, fuzzy
msgid ""
"We used `Mutex` as an example, but the same applies to `RwLock`, semaphores, "
"etc.  \n"
"Prefer async-aware versions when working in an asynchronous context to "
"minimise the risk of issues."
msgstr ""
"ì˜ˆì‹œë¡œ `Mutex`ë¥¼ ì‚¬ìš©í–ˆì§€ë§Œ `RwLock`, ì„¸ë§ˆí¬ì–´ ë“±ì—ë„ ë™ì¼í•˜ê²Œ ì ìš©ë©ë‹ˆë‹¤.  \n"
"ë¬¸ì œ ìœ„í—˜ì„ ìµœì†Œí™”í•˜ë ¤ë©´ ë¹„ë™ê¸° ì»¨í…ìŠ¤íŠ¸ì—ì„œ ì‘ì—…í•  ë•Œ ë¹„ë™ê¸° ì¸ì‹ ë²„ì „ì„ ì„ í˜¸"
"í•˜ì„¸ìš”."

#: src/08_futures/06_async_aware_primitives.md:133
msgid ""
"The exercise for this section is located in "
"[`08_futures/06_async_aware_primitives`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/"
"exercises/08_futures/06_async_aware_primitives)"
msgstr ""

#: src/08_futures/07_cancellation.md:3
#, fuzzy
msgid ""
"What happens when a pending future is dropped?  \n"
"The runtime will no longer poll it, therefore it won't make any further "
"progress. In other words, its execution has been **cancelled**."
msgstr ""
"ë³´ë¥˜ ì¤‘ì¸ ë¯¸ë˜ê°€ ì‚­ì œë˜ë©´ ì–´ë–»ê²Œ ë˜ë‚˜ìš”?  \n"
"ëŸ°íƒ€ì„ì€ ë” ì´ìƒ í´ë§í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ë” ì´ìƒ ì§„í–‰ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì¦‰, ì‹¤í–‰ì´ **ì·¨"
"ì†Œ**ë˜ì—ˆìŠµë‹ˆë‹¤."

#: src/08_futures/07_cancellation.md:7
#, fuzzy
msgid "In the wild, this often happens when working with timeouts. For example:"
msgstr "ì‹¤ì œë¡œëŠ” ì‹œê°„ ì´ˆê³¼ ì‘ì—…ì„ í•  ë•Œ ì´ëŸ° ì¼ì´ ìì£¼ ë°œìƒí•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´:"

#: src/08_futures/07_cancellation.md:20
#, fuzzy
msgid "// Wrap the future with a `Timeout` set to expire in 10 milliseconds.\n"
msgstr "// 10ë°€ë¦¬ì´ˆ í›„ì— ë§Œë£Œë˜ë„ë¡ ì„¤ì •ëœ 'Timeout'ìœ¼ë¡œ futureë¥¼ ë˜í•‘í•©ë‹ˆë‹¤."

#: src/08_futures/07_cancellation.md:23
#, fuzzy
msgid "\"Didn't receive a value within 10 ms\""
msgstr "\"10ms ì´ë‚´ì— ê°’ì„ ë°›ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\""

#: src/08_futures/07_cancellation.md:28
#, fuzzy
msgid ""
"When the timeout expires, the future returned by `http_call` will be "
"cancelled. Let's imagine that this is `http_call`'s body:"
msgstr ""
"ì œí•œ ì‹œê°„ì´ ë§Œë£Œë˜ë©´ `http_call`ì— ì˜í•´ ë°˜í™˜ëœ futureê°€ ì·¨ì†Œë©ë‹ˆë‹¤. ì´ê²ƒì´ "
"`http_call`ì˜ ë³¸ë¬¸ì´ë¼ê³  ìƒìƒí•´ ë´…ì‹œë‹¤:"

#: src/08_futures/07_cancellation.md:41
#, fuzzy
msgid ""
"Each yield point becomes a **cancellation point**.  \n"
"`http_call` can't be preempted by the runtime, so it can only be discarded "
"after it has yielded control back to the executor via `.await`. This applies "
"recursivelyâ€”e.g. `stream.write_all(&request)` is likely to have multiple "
"yield points in its implementation. It is perfectly possible to see "
"`http_call` pushing a _partial_ request before being cancelled, thus dropping "
"the connection and never finishing transmitting the body."
msgstr ""
"ê° í•­ë³µ ì§€ì ì€ **ì·¨ì†Œ ì§€ì **ì´ ë©ë‹ˆë‹¤.  \n"
"`http_call`ì€ ëŸ°íƒ€ì„ì— ì˜í•´ ì„ ì ë  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ `.await`ë¥¼ í†µí•´ ì‹¤í–‰ìì—ê²Œ ì œì–´"
"ê¶Œì„ ë‹¤ì‹œ ë„˜ê²¨ì¤€ í›„ì—ë§Œ íê¸°ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” ì¬ê·€ì ìœ¼ë¡œ ì ìš©ë©ë‹ˆë‹¤. "
"`stream.write_all(&request)`ëŠ” êµ¬í˜„ ì‹œ ì—¬ëŸ¬ í•­ë³µ ì§€ì ì„ ê°€ì§ˆ ê°€ëŠ¥ì„±ì´ ë†’ìŠµë‹ˆ"
"ë‹¤. `http_call`ì´ ì·¨ì†Œë˜ê¸° ì „ì— _partial_ ìš”ì²­ì„ í‘¸ì‹œí•˜ì—¬ ì—°ê²°ì´ ëŠì–´ì§€ê³  ë³¸"
"ë¬¸ ì „ì†¡ì´ ì™„ë£Œë˜ì§€ ì•ŠëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/08_futures/07_cancellation.md:49
#, fuzzy
msgid "Clean up"
msgstr "ì •ë¦¬í•˜ë‹¤"

#: src/08_futures/07_cancellation.md:51
#, fuzzy
msgid ""
"Rust's cancellation mechanism is quite powerfulâ€”it allows the caller to "
"cancel an ongoing task without needing any form of cooperation from the task "
"itself.  \n"
"At the same time, this can be quite dangerous. It may be desirable to perform "
"a **graceful cancellation**, to ensure that some clean-up tasks are performed "
"before aborting the operation."
msgstr ""
"Rustì˜ ì·¨ì†Œ ë©”ì»¤ë‹ˆì¦˜ì€ ë§¤ìš° ê°•ë ¥í•©ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ í˜¸ì¶œìëŠ” ì‘ì—… ìì²´ì—ì„œ ì–´ë–¤ "
"í˜•íƒœì˜ í˜‘ë ¥ë„ í•„ìš” ì—†ì´ ì§„í–‰ ì¤‘ì¸ ì‘ì—…ì„ ì·¨ì†Œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"ë™ì‹œì— ì´ëŠ” ë§¤ìš° ìœ„í—˜í•  ìˆ˜ ìˆë‹¤. ì‘ì—…ì„ ì¤‘ë‹¨í•˜ê¸° ì „ì— ì¼ë¶€ ì •ë¦¬ ì‘ì—…ì´ ìˆ˜í–‰ë˜"
"ë„ë¡ **ì •ìƒì ì¸ ì·¨ì†Œ**ë¥¼ ìˆ˜í–‰í•˜ëŠ” ê²ƒì´ ë°”ëŒì§í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/08_futures/07_cancellation.md:57
#, fuzzy
msgid "For example, consider this fictional API for a SQL transaction:"
msgstr "ì˜ˆë¥¼ ë“¤ì–´ SQL íŠ¸ëœì­ì…˜ì— ëŒ€í•œ ë‹¤ìŒ ê°€ìƒ APIë¥¼ ìƒê°í•´ ë³´ì„¸ìš”."

#: src/08_futures/07_cancellation.md:73
#, fuzzy
msgid ""
"On cancellation, it'd be ideal to explicitly abort the pending transaction "
"rather than leaving it hanging. Rust, unfortunately, doesn't provide a bullet-"
"proof mechanism for this kind of **asynchronous** clean up operations."
msgstr ""
"ì·¨ì†Œ ì‹œ ë³´ë¥˜ ì¤‘ì¸ íŠ¸ëœì­ì…˜ì„ ê·¸ëŒ€ë¡œ ë‘ëŠ” ê²ƒë³´ë‹¤ ëª…ì‹œì ìœ¼ë¡œ ì¤‘ë‹¨í•˜ëŠ” ê²ƒì´ ì´ìƒ"
"ì ì…ë‹ˆë‹¤. ì•ˆíƒ€ê¹ê²Œë„ RustëŠ” ì´ëŸ¬í•œ ì¢…ë¥˜ì˜ **ë¹„ë™ê¸°** ì •ë¦¬ ì‘ì—…ì— ëŒ€í•œ ì™„ë²½í•œ "
"ë©”ì»¤ë‹ˆì¦˜ì„ ì œê³µí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: src/08_futures/07_cancellation.md:78
#, fuzzy
msgid ""
"The most common strategy is to rely on the `Drop` trait to schedule the "
"required clean-up work. This can be by:"
msgstr ""
"ê°€ì¥ ì¼ë°˜ì ì¸ ì „ëµì€ 'Drop' íŠ¹ì„±ì„ ì‚¬ìš©í•˜ì—¬ í•„ìš”í•œ ì •ë¦¬ ì‘ì—…ì„ ì˜ˆì•½í•˜ëŠ” ê²ƒì…ë‹ˆ"
"ë‹¤. ì´ëŠ” ë‹¤ìŒê³¼ ê°™ì´ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/08_futures/07_cancellation.md:81
#, fuzzy
msgid "Spawning a new task on the runtime"
msgstr "ëŸ°íƒ€ì„ì— ìƒˆ ì‘ì—… ìƒì„±"

#: src/08_futures/07_cancellation.md:82
#, fuzzy
msgid "Enqueueing a message on a channel"
msgstr "ì±„ë„ì˜ ëŒ€ê¸°ì—´ì— ë©”ì‹œì§€ ì¶”ê°€"

#: src/08_futures/07_cancellation.md:83
#, fuzzy
msgid "Spawning a background thread"
msgstr "ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œ ìƒì„±"

#: src/08_futures/07_cancellation.md:85
#, fuzzy
msgid "The optimal choice is contextual."
msgstr "ìµœì ì˜ ì„ íƒì€ ìƒí™©ì— ë”°ë¼ ë‹¤ë¦…ë‹ˆë‹¤."

#: src/08_futures/07_cancellation.md:87
#, fuzzy
msgid "Cancelling spawned tasks"
msgstr "ìƒì„±ëœ ì‘ì—… ì·¨ì†Œ"

#: src/08_futures/07_cancellation.md:89
msgid ""
"When you spawn a task using `tokio::spawn`, you can no longer drop it; it "
"belongs to the runtime.  \n"
"Nonetheless, you can use its `JoinHandle` to cancel it if needed:"
msgstr ""

#: src/08_futures/07_cancellation.md:95
#, fuzzy
msgid "/* some async task */"
msgstr "/\\* ì¼ë¶€ ë¹„ë™ê¸° ì‘ì—… \\*/"

#: src/08_futures/07_cancellation.md:96
#, fuzzy
msgid "// Cancel the spawned task\n"
msgstr "// ìƒì„±ëœ ì‘ì—… ì·¨ì†Œ"

#: src/08_futures/07_cancellation.md:103
#, fuzzy
msgid ""
"Be extremely careful when using `tokio`'s `select!` macro to \"race\" two "
"different futures. Retrying the same task in a loop is dangerous unless you "
"can ensure **cancellation safety**. Check out [`select!`'s documentation]"
"(https://tokio.rs/tokio/tutorial/select) for more details.  \n"
"If you need to interleave two asynchronous streams of data (e.g. a socket and "
"a channel), prefer using [`StreamExt::merge`](https://docs.rs/tokio-stream/"
"latest/tokio_stream/trait.StreamExt.html#method.merge) instead."
msgstr ""
"ë‘ ê°œì˜ ì„œë¡œ ë‹¤ë¥¸ ë¯¸ë˜ë¥¼ \"ê²½ìŸ\"í•˜ê¸° ìœ„í•´ `tokio`ì˜ `select!` ë§¤í¬ë¡œë¥¼ ì‚¬ìš©"
"í•  ë•ŒëŠ” ë§¤ìš° ì£¼ì˜í•˜ì‹­ì‹œì˜¤. **ì·¨ì†Œ ì•ˆì „**ì„ ë³´ì¥í•  ìˆ˜ ì—†ë‹¤ë©´ ë£¨í”„ì—ì„œ ë™ì¼í•œ ì‘"
"ì—…ì„ ë‹¤ì‹œ ì‹œë„í•˜ëŠ” ê²ƒì€ ìœ„í—˜í•©ë‹ˆë‹¤. ìì„¸í•œ ë‚´ìš©ì€ `select!`ì˜ ë¬¸ì„œë¥¼ í™•ì¸í•˜ì„¸"
"ìš”.  \n"
"ë‘ ê°œì˜ ë¹„ë™ê¸° ë°ì´í„° ìŠ¤íŠ¸ë¦¼(ì˜ˆ: ì†Œì¼“ ë° ì±„ë„)ì„ ì¸í„°ë¦¬ë¸Œí•´ì•¼ í•˜ëŠ” ê²½ìš° "
"`StreamExt::merge`ë¥¼ ëŒ€ì‹  ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤."

#: src/08_futures/07_cancellation.md:108
#, fuzzy
msgid ""
"Rather than \"abrupt\" cancellation, it can be preferable to rely on "
"[`CancellationToken`](https://docs.rs/tokio-util/latest/tokio_util/sync/"
"struct.CancellationToken.html)."
msgstr ""
"\"ê°‘ì‘ìŠ¤ëŸ¬ìš´\" ì·¨ì†Œë³´ë‹¤ëŠ” 'CancellationToken'ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ë” ë‚˜ì„ ìˆ˜ ìˆìŠµ"
"ë‹ˆë‹¤."

#: src/08_futures/07_cancellation.md:113
msgid ""
"The exercise for this section is located in [`08_futures/07_cancellation`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/08_futures/07_cancellation)"
msgstr ""

#: src/08_futures/08_outro.md:3
#, fuzzy
msgid ""
"Rust's asynchronous model is quite powerful, but it does introduce additional "
"complexity. Take time to know your tools: dive deep into `tokio`'s "
"documentation and get familiar with its primitives to make the most out of it."
msgstr ""
"Rustì˜ ë¹„ë™ê¸° ëª¨ë¸ì€ ë§¤ìš° ê°•ë ¥í•˜ì§€ë§Œ ì¶”ê°€ì ì¸ ë³µì¡ì„±ì„ ì´ˆë˜í•©ë‹ˆë‹¤. ë„êµ¬ë¥¼ ì•Œì•„"
"ê°€ëŠ” ë° ì‹œê°„ì„ íˆ¬ìí•˜ì„¸ìš”. 'tokio'ì˜ ë¬¸ì„œë¥¼ ìì„¸íˆ ì‚´í´ë³´ê³  ë¬¸ì„œë¥¼ ìµœëŒ€í•œ í™œìš©"
"í•˜ê¸° ìœ„í•´ ê¸°ë³¸ ìš”ì†Œì— ìµìˆ™í•´ì§€ì„¸ìš”."

#: src/08_futures/08_outro.md:7
#, fuzzy
msgid ""
"Keep in mind, as well, that there is ongoing work at the language and `std` "
"level to streamline and \"complete\" Rust's asynchronous story. You may "
"experience some rough edges in your day-to-day work due to some of these "
"missing pieces."
msgstr ""
"ë˜í•œ Rustì˜ ë¹„ë™ê¸° ìŠ¤í† ë¦¬ë¥¼ ê°„ì†Œí™”í•˜ê³  \"ì™„ì„±\"í•˜ê¸° ìœ„í•´ ì–¸ì–´ ë° 'std' ìˆ˜ì¤€ì—"
"ì„œ ì§€ì†ì ì¸ ì‘ì—…ì´ ì§„í–‰ ì¤‘ì´ë¼ëŠ” ì ì„ ëª…ì‹¬í•˜ì„¸ìš”. ì´ëŸ¬í•œ ëˆ„ë½ëœ ë¶€ë¶„ìœ¼ë¡œ ì¸í•´ "
"ì¼ìƒì ì¸ ì‘ì—…ì—ì„œ ì•½ê°„ì˜ ê±°ì¹œ ë¶€ë¶„ì´ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/08_futures/08_outro.md:11
#, fuzzy
msgid "A few recommendations for a mostly-pain-free async experience:"
msgstr "ê±°ì˜ ê³ í†µ ì—†ëŠ” ë¹„ë™ê¸° í™˜ê²½ì„ ìœ„í•œ ëª‡ ê°€ì§€ ê¶Œì¥ ì‚¬í•­:"

#: src/08_futures/08_outro.md:13
#, fuzzy
msgid ""
"**Pick a runtime and stick to it.**  \n"
"Some primitives (e.g. timers, I/O) are not portable across runtimes. Trying "
"to mix runtimes is likely to cause you pain. Trying to write code that's "
"runtime agnostic can significantly increase the complexity of your codebase. "
"Avoid it if you can."
msgstr ""
"**ëŸ°íƒ€ì„ì„ ì„ íƒí•˜ê³  ì´ë¥¼ ê³ ìˆ˜í•˜ì„¸ìš”.**  \n"
"ì¼ë¶€ ê¸°ë³¸ ìš”ì†Œ(ì˜ˆ: íƒ€ì´ë¨¸, I/O)ëŠ” ëŸ°íƒ€ì„ ì „ë°˜ì— ê±¸ì³ ì´ì‹ ê°€ëŠ¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. "
"ëŸ°íƒ€ì„ì„ í˜¼í•©í•˜ë ¤ê³  í•˜ë©´ ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ëŸ°íƒ€ì„ì— êµ¬ì• ë°›ì§€ ì•ŠëŠ” ì½”"
"ë“œë¥¼ ì‘ì„±í•˜ë ¤ê³  í•˜ë©´ ì½”ë“œë² ì´ìŠ¤ì˜ ë³µì¡ì„±ì´ í¬ê²Œ ì¦ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê°€ëŠ¥í•˜ë‹¤"
"ë©´ í”¼í•˜ì„¸ìš”."

#: src/08_futures/08_outro.md:18
#, fuzzy
msgid ""
"**There is no stable `Stream`/`AsyncIterator` interface yet.**  \n"
"An `AsyncIterator` is, conceptually, an iterator that yields new items "
"asynchronously. There is ongoing design work, but no consensus (yet). If "
"you're using `tokio`, refer to [`tokio_stream`](https://docs.rs/tokio-stream/"
"latest/tokio_stream/) as your go-to interface."
msgstr ""
"**ì•ˆì •ì ì¸ `Stream`/`AsyncIterator` ì¸í„°í˜ì´ìŠ¤ëŠ” ì•„ì§ ì—†ìŠµë‹ˆë‹¤.**  \n"
"'AsyncIterator'ëŠ” ê°œë…ì ìœ¼ë¡œ ìƒˆ í•­ëª©ì„ ë¹„ë™ê¸°ì ìœ¼ë¡œ ìƒì„±í•˜ëŠ” ë°˜ë³µìì…ë‹ˆë‹¤. ë””"
"ìì¸ ì‘ì—…ì´ ì§„í–‰ ì¤‘ì´ì§€ë§Œ (ì•„ì§) í•©ì˜ê°€ ì´ë£¨ì–´ì§€ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. `tokio`ë¥¼ ì‚¬ìš©"
"í•˜ëŠ” ê²½ìš° ì´ë™ ì¸í„°í˜ì´ìŠ¤ë¡œ `tokio_stream`ì„ ì°¸ì¡°í•˜ì„¸ìš”."

#: src/08_futures/08_outro.md:23
#, fuzzy
msgid ""
"**Be careful with buffering.**  \n"
"It is often the cause of subtle bugs. Check out [\"Barbara battles buffered "
"streams\"](https://rust-lang.github.io/wg-async/vision/submitted_stories/"
"status_quo/barbara_battles_buffered_streams.html) for more details."
msgstr ""
"**ë²„í¼ë§ì— ì£¼ì˜í•˜ì„¸ìš”.**  \n"
"ë¯¸ë¬˜í•œ ë²„ê·¸ì˜ ì›ì¸ì´ ë˜ëŠ” ê²½ìš°ê°€ ë§ìŠµë‹ˆë‹¤. ìì„¸í•œ ë‚´ìš©ì€ \"Barbara ì „íˆ¬ ë²„í¼"
"ë§ ìŠ¤íŠ¸ë¦¼\"ì„ í™•ì¸í•˜ì„¸ìš”."

#: src/08_futures/08_outro.md:27
#, fuzzy
msgid ""
"**There is no equivalent of scoped threads for asynchronous tasks**.  \n"
"Check out [\"The scoped task trilemma\"](https://without.boats/blog/the-"
"scoped-task-trilemma/) for more details."
msgstr ""
"**ë¹„ë™ê¸° ì‘ì—…ì—ëŠ” ë²”ìœ„ê°€ ì§€ì •ëœ ìŠ¤ë ˆë“œì™€ ë™ë“±í•œ ê²ƒì´ ì—†ìŠµë‹ˆë‹¤**.  \n"
"ìì„¸í•œ ë‚´ìš©ì€ \"ë²”ìœ„ê°€ ì§€ì •ëœ ì‘ì—… íŠ¸ë¦´ë ˆë§ˆ\"ë¥¼ í™•ì¸í•˜ì„¸ìš”."

#: src/08_futures/08_outro.md:31
#, fuzzy
msgid ""
"Don't let these caveats scare you: asynchronous Rust is being used "
"effectively at _massive_ scale (e.g. AWS, Meta) to power foundational "
"services.  \n"
"You will have to master it if you're planning building networked applications "
"in Rust."
msgstr ""
"ì´ëŸ¬í•œ ì£¼ì˜ ì‚¬í•­ì— ê²ë¨¹ì§€ ë§ˆì„¸ìš”. ë¹„ë™ê¸°ì‹ RustëŠ” ê¸°ë³¸ ì„œë¹„ìŠ¤ë¥¼ ê°•í™”í•˜ê¸° ìœ„í•´ "
"_ëŒ€ê·œëª¨_ ê·œëª¨(ì˜ˆ: AWS, Meta)ì—ì„œ íš¨ê³¼ì ìœ¼ë¡œ ì‚¬ìš©ë˜ê³  ìˆìŠµë‹ˆë‹¤.  \n"
"Rustë¡œ ë„¤íŠ¸ì›Œí¬ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ êµ¬ì¶•í•  ê³„íšì´ë¼ë©´ ì´ë¥¼ ë§ˆìŠ¤í„°í•´ì•¼ í•©ë‹ˆë‹¤."

#: src/08_futures/08_outro.md:38
msgid ""
"The exercise for this section is located in [`08_futures/08_outro`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/08_futures/08_outro)"
msgstr ""

#: src/going_further.md:1
#, fuzzy
msgid "Epilogue"
msgstr "ë°œë¬¸"

#: src/going_further.md:3
#, fuzzy
msgid ""
"Our tour of Rust ends here.  \n"
"It has been quite extensive, but by no means exhaustive: Rust is a language "
"with a large surface area, and an even larger ecosystem!  \n"
"Don't let this scare you, though: there's **no need to learn everything**. "
"You'll pick up whatever is necessary to be effective in the domain (backend, "
"embedded, CLIs, GUIs, etc.) **while working on your projects**."
msgstr ""
"Rust íˆ¬ì–´ëŠ” ì—¬ê¸°ì„œ ëë‚©ë‹ˆë‹¤.  \n"
"ìƒë‹¹íˆ ê´‘ë²”ìœ„í–ˆì§€ë§Œ ê²°ì½” ì² ì €í•˜ì§€ëŠ” ì•Šì•˜ìŠµë‹ˆë‹¤. RustëŠ” í‘œë©´ì ì´ ë„“ê³  ìƒíƒœê³„ë„ "
"í›¨ì”¬ ë” í° ì–¸ì–´ì…ë‹ˆë‹¤!  \n"
"í•˜ì§€ë§Œ ê²ë¨¹ì§€ ë§ˆì„¸ìš”. **ëª¨ë“  ê²ƒì„ ë°°ìš¸ í•„ìš”ëŠ” ì—†ìŠµë‹ˆë‹¤**. **í”„ë¡œì íŠ¸ ì‘ì—…** ì¤‘"
"ì— ë„ë©”ì¸(ë°±ì—”ë“œ, ì„ë² ë””ë“œ, CLI, GUI ë“±)ì—ì„œ íš¨ìœ¨ì„±ì„ ë†’ì´ëŠ” ë° í•„ìš”í•œ ëª¨ë“  ê²ƒ"
"ì„ ì„ íƒí•˜ê²Œ ë©ë‹ˆë‹¤."

#: src/going_further.md:10
#, fuzzy
msgid ""
"In the end, there are no shortcuts: if you want to get good at something, you "
"need to do it, over and over again. Throughout this course you wrote a fair "
"amount of Rust, enough to get the language and its syntax flowing under your "
"fingers. It'll take many more lines of code to feel it \"yours\", but that "
"moment will come without a doubt if you keep practicing."
msgstr ""
"ê²°êµ­ ì§€ë¦„ê¸¸ì€ ì—†ìŠµë‹ˆë‹¤. ì–´ë–¤ ì¼ì„ ì˜í•˜ê³  ì‹¶ë‹¤ë©´ ê³„ì†í•´ì„œ ê·¸ ì¼ì„ í•´ì•¼ í•©ë‹ˆë‹¤. "
"ì´ ì½”ìŠ¤ ì „ë°˜ì— ê±¸ì³ ì—¬ëŸ¬ë¶„ì€ ì–¸ì–´ì™€ ê·¸ êµ¬ë¬¸ì„ ì†ê°€ë½ìœ¼ë¡œ ì§šì–´ë³¼ ìˆ˜ ìˆì„ ë§Œí¼ "
"ì¶©ë¶„í•œ ì–‘ì˜ Rustë¥¼ ì‘ì„±í–ˆìŠµë‹ˆë‹¤. \"ìì‹ ì˜ ê²ƒ\"ì´ë¼ê³  ëŠë¼ë ¤ë©´ í›¨ì”¬ ë” ë§ì€ ì½”"
"ë“œ ë¼ì¸ì´ í•„ìš”í•˜ì§€ë§Œ, ê³„ì† ì—°ìŠµí•˜ë©´ ê·¸ ìˆœê°„ì€ ì˜ì‹¬í•  ì—¬ì§€ ì—†ì´ ì°¾ì•„ì˜¬ ê²ƒì…ë‹ˆ"
"ë‹¤."

#: src/going_further.md:18
#, fuzzy
msgid ""
"Let's close with some pointers to additional resources that you might find "
"useful as you move forward in your journey with Rust."
msgstr ""
"Rustì™€ í•¨ê»˜í•˜ëŠ” ì—¬ì •ì—ì„œ ì•ìœ¼ë¡œ ë‚˜ì•„ê°ˆ ë•Œ ìœ ìš©í•  ìˆ˜ ìˆëŠ” ì¶”ê°€ ë¦¬ì†ŒìŠ¤ì— ëŒ€í•œ "
"ëª‡ ê°€ì§€ ì§€ì¹¨ìœ¼ë¡œ ë§ˆë¬´ë¦¬í•˜ê² ìŠµë‹ˆë‹¤."

#: src/going_further.md:21
#, fuzzy
msgid "Exercises"
msgstr "ìˆ˜ì—… ê³¼ì •"

#: src/going_further.md:23
#, fuzzy
msgid ""
"You can find more exercises to practice Rust in the [`rustlings`](https://"
"github.com/rust-lang/rustlings) project and on [exercism.io](https://exercism."
"io)'s Rust track."
msgstr ""
"Rustë¥¼ ì—°ìŠµí•˜ê¸° ìœ„í•œ ë” ë§ì€ ì—°ìŠµë¬¸ì œëŠ” `rustlings` í”„ë¡œì íŠ¸ì™€ exercism.ioì˜ "
"Rust íŠ¸ë™ì—ì„œ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: src/going_further.md:26
#, fuzzy
msgid "Introductory material"
msgstr "ì…ë¬¸ ìë£Œ"

#: src/going_further.md:28
msgid ""
"Check out [the Rust book](https://doc.rust-lang.org/book/title-page.html) and "
"[\"Programming Rust\"](https://www.oreilly.com/library/view/programming-"
"rust-2nd/9781492052586/) if you're looking for a different perspective on the "
"same concepts we covered throughout this course. You'll certainly learn "
"something new since they don't cover exactly the same topics; Rust has a lot "
"of surface area!"
msgstr ""

#: src/going_further.md:33
#, fuzzy
msgid "Advanced material"
msgstr "ê³ ê¸‰ ì†Œì¬"

#: src/going_further.md:35
#, fuzzy
msgid ""
"If you want to dive deeper into the language, refer to the [Rustonomicon]"
"(https://doc.rust-lang.org/nomicon/) and [\"Rust for Rustaceans\"](https://"
"nostarch.com/rust-rustaceans).  \n"
"The [\"Decrusted\" series](https://www.youtube.com/playlist?"
"list=PLqbS7AVVErFirH9armw8yXlE6dacF-A6z) is another excellent resource to "
"learn more about the internals of many of the most popular Rust libraries."
msgstr ""
"ì–¸ì–´ì— ëŒ€í•´ ë” ê¹Šì´ ì•Œê³  ì‹¶ë‹¤ë©´ Rustonomiconê³¼ \"Rust for Rustaceans\"ë¥¼ ì°¸ì¡°"
"í•˜ì„¸ìš”.  \n"
"\"Decrusted\" ì‹œë¦¬ì¦ˆëŠ” ê°€ì¥ ì¸ê¸° ìˆëŠ” Rust ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ ë‚´ë¶€ì— ëŒ€í•´ ìì„¸íˆ ì•Œ"
"ì•„ë³¼ ìˆ˜ ìˆëŠ” ë˜ ë‹¤ë¥¸ í›Œë¥­í•œ ë¦¬ì†ŒìŠ¤ì…ë‹ˆë‹¤."

#: src/going_further.md:40
#, fuzzy
msgid "Domain-specific material"
msgstr "ë„ë©”ì¸ë³„ ìë£Œ"

#: src/going_further.md:42
#, fuzzy
msgid ""
"If you want to use Rust for backend development, check out [\"Zero to "
"Production in Rust\"](https://zero2prod.com).  \n"
"If you want to use Rust for embedded development, check out the [Embedded "
"Rust book](https://docs.rust-embedded.org/book/)."
msgstr ""
"ë°±ì—”ë“œ ê°œë°œì— Rustë¥¼ ì‚¬ìš©í•˜ê³  ì‹¶ë‹¤ë©´ \"Zero to Production in Rust\"ë¥¼ í™•ì¸í•˜ì„¸"
"ìš”.  \n"
"ì„ë² ë””ë“œ ê°œë°œì— Rustë¥¼ ì‚¬ìš©í•˜ê³  ì‹¶ë‹¤ë©´ Embedded Rust ì±…ì„ í™•ì¸í•´ ë³´ì„¸ìš”."

#: src/going_further.md:47
#, fuzzy
msgid "Masterclasses"
msgstr "ë§ˆìŠ¤í„°í´ë˜ìŠ¤"

#: src/going_further.md:49
#, fuzzy
msgid ""
"You can then find resources on key topics that cut across domains.  \n"
"For testing, check out [\"Advanced testing, going beyond the basics\"]"
"(https://github.com/mainmatter/rust-advanced-testing-workshop).  \n"
"For telemetry, check out [\"You can't fix what you can't see\"](https://"
"github.com/mainmatter/rust-telemetry-workshop)."
msgstr ""
"ê·¸ëŸ° ë‹¤ìŒ ë„ë©”ì¸ ì „ë°˜ì— ê±¸ì¹œ ì£¼ìš” ì£¼ì œì— ëŒ€í•œ ë¦¬ì†ŒìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  \n"
"í…ŒìŠ¤íŠ¸ì— ëŒ€í•´ì„œëŠ” \"ê¸°ë³¸ì„ ë„˜ì–´ì„œëŠ” ê³ ê¸‰ í…ŒìŠ¤íŠ¸\"ë¥¼ ì°¸ê³ í•˜ì„¸ìš”.  \n"
"ì›ê²© ì¸¡ì •ì˜ ê²½ìš° \"ë³¼ ìˆ˜ ì—†ëŠ” ê²ƒì€ ê³ ì¹  ìˆ˜ ì—†ìŠµë‹ˆë‹¤\"ë¥¼ í™•ì¸í•˜ì„¸ìš”."

#~ msgid "The exercise for this section is located in `01_intro/00_welcome`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” `01_intro/00_welcome`ì— ìˆìŠµë‹ˆë‹¤."

#~ msgid "The exercise for this section is located in `01_intro/01_syntax`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì˜ˆì œëŠ” `01_intro/01_syntax`ì— ìˆìŠµë‹ˆë‹¤"

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `02_basic_calculator/00_intro`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `02_basic_calculator/00_intro`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The integer types section in the official Rust book"
#~ msgstr "ê³µì‹ Rust ì±…ì˜ ì •ìˆ˜ ìœ í˜• ì„¹ì…˜"

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`02_basic_calculator/01_integers`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `02_basic_calculator/01_integers`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`02_basic_calculator/02_variables`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `02_basic_calculator/02_variables`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`02_basic_calculator/03_if_else`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `02_basic_calculator/03_if_else`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The panic! macro documentation"
#~ msgstr "ê³µí™©! ë§¤í¬ë¡œ ë¬¸ì„œ"

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `02_basic_calculator/04_panics`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `02_basic_calculator/04_panics`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`02_basic_calculator/05_factorial`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `02_basic_calculator/05_factorial`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "`while` loop documentation"
#~ msgstr "`while` ë£¨í”„ ë¬¸ì„œ"

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `02_basic_calculator/06_while`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `02_basic_calculator/06_while`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "`for` loop documentation"
#~ msgstr "`for` ë£¨í”„ ë¬¸ì„œ"

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `02_basic_calculator/07_for`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `02_basic_calculator/07_for`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`02_basic_calculator/08_overflow`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `02_basic_calculator/08_overflow`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`02_basic_calculator/09_saturating`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `02_basic_calculator/09_saturating`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`02_basic_calculator/10_as_casting`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `02_basic_calculator/10_as_casting`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `03_ticket_v1/00_intro`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `03_ticket_v1/00_intro`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `03_ticket_v1/01_struct`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `03_ticket_v1/01_struct`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `03_ticket_v1/02_validation`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `03_ticket_v1/02_validation`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `03_ticket_v1/03_modules`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `03_ticket_v1/03_modules`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `03_ticket_v1/04_visibility`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `03_ticket_v1/04_visibility`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `03_ticket_v1/05_encapsulation`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `03_ticket_v1/05_encapsulation`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `03_ticket_v1/06_ownership`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `03_ticket_v1/06_ownership`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `03_ticket_v1/07_setters`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `03_ticket_v1/07_setters`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `03_ticket_v1/08_stack`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `03_ticket_v1/08_stack`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `03_ticket_v1/09_heap`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `03_ticket_v1/09_heap`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`03_ticket_v1/10_references_in_memory`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `03_ticket_v1/10_references_in_memory`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `03_ticket_v1/11_destructor`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `03_ticket_v1/11_destructor`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `03_ticket_v1/12_outro`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `03_ticket_v1/12_outro`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `04_traits/00_intro`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `04_traits/00_intro`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `04_traits/01_trait`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `04_traits/01_trait`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `04_traits/02_orphan_rule`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `04_traits/02_orphan_rule`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "`Add`"
#~ msgstr "`ì¶”ê°€`"

#, fuzzy
#~ msgid "`Sub`"
#~ msgstr "`ì„œë¸Œ`"

#, fuzzy
#~ msgid "`Mul`"
#~ msgstr "'ë¬¼'"

#, fuzzy
#~ msgid "`Div`"
#~ msgstr "`ë””ë¸Œ`"

#, fuzzy
#~ msgid "`Rem`"
#~ msgstr "'ë ˜'"

#, fuzzy
#~ msgid "`PartialEq`"
#~ msgstr "`ë¶€ë¶„ ë°©ì •ì‹`"

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`04_traits/03_operator_overloading`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `04_traits/03_operator_overloading`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "Proc macro workshop"
#~ msgstr "Proc ë§¤í¬ë¡œ ì›Œí¬ìˆ"

#, fuzzy
#~ msgid "The exercise for this section is located in `04_traits/04_derive`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `04_traits/04_derive`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `04_traits/05_trait_bounds`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `04_traits/05_trait_bounds`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `04_traits/06_str_slice`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `04_traits/06_str_slice`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `04_traits/07_deref`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `04_traits/07_deref`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `04_traits/08_sized`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `04_traits/08_size`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `04_traits/09_from`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `04_traits/09_from`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `04_traits/10_assoc_vs_generic`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `04_traits/10_assoc_vs_generic`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "/\\* \\*/"
#~ msgstr "/\\* \\*/"

#, fuzzy
#~ msgid "The exercise for this section is located in `04_traits/11_clone`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `04_traits/11_clone`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `04_traits/12_copy`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `04_traits/12_copy`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `04_traits/13_drop`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `04_traits/13_drop`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `04_traits/14_outro`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `04_traits/14_outro`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `05_ticket_v2/00_intro`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `05_ticket_v2/00_intro`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `05_ticket_v2/01_enum`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `05_ticket_v2/01_enum`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `05_ticket_v2/02_match`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `05_ticket_v2/02_match`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`05_ticket_v2/03_variants_with_data`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `05_ticket_v2/03_variants_with_data`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `05_ticket_v2/04_if_let`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `05_ticket_v2/04_if_let`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `05_ticket_v2/05_nullability`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `05_ticket_v2/05_nullability`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `05_ticket_v2/06_fallibility`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `05_ticket_v2/06_fallibility`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `05_ticket_v2/07_unwrap`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `05_ticket_v2/07_unwrap`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `05_ticket_v2/08_error_enums`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `05_ticket_v2/08_error_enums`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `05_ticket_v2/09_error_trait`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `05_ticket_v2/09_error_trait`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `05_ticket_v2/10_packages`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `05_ticket_v2/10_packages`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `05_ticket_v2/11_dependencies`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `05_ticket_v2/11_dependent`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `05_ticket_v2/12_thiserror`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `05_ticket_v2/12_thiserror`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `05_ticket_v2/13_try_from`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `05_ticket_v2/13_try_from`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `05_ticket_v2/14_source`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `05_ticket_v2/14_source`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "Parse, don't validate"
#~ msgstr "êµ¬ë¬¸ ë¶„ì„í•˜ê³  ìœ íš¨ì„±ì„ ê²€ì‚¬í•˜ì§€ ì•ŠìŒ"

#, fuzzy
#~ msgid "Using types to guarantee domain invariants"
#~ msgstr "ìœ í˜•ì„ ì‚¬ìš©í•˜ì—¬ ë„ë©”ì¸ ë¶ˆë³€ì„± ë³´ì¥"

#, fuzzy
#~ msgid "The exercise for this section is located in `05_ticket_v2/15_outro`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `05_ticket_v2/15_outro`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `06_ticket_management/00_intro`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `06_ticket_management/00_intro`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/01_arrays`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `06_ticket_management/01_arrays`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `06_ticket_management/02_vec`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `06_ticket_management/02_vec`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/03_resizing`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `06_ticket_management/03_resizing`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/04_iterators`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `06_ticket_management/04_iterators`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `06_ticket_management/05_iter`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `06_ticket_management/05_iter`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "std::vec::Vec::iter"
#~ msgstr "í‘œì¤€::vec::Vec::iter"

#, fuzzy
#~ msgid "std::slice::Iter"
#~ msgstr "í‘œì¤€::ìŠ¬ë¼ì´ìŠ¤::Iter"

#, fuzzy
#~ msgid "Lifetime elision rules"
#~ msgstr "í‰ìƒ ì œê±° ê·œì¹™"

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/06_lifetimes`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `06_ticket_management/06_lifetimes`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/07_combinators`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `06_ticket_management/07_combinators`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/08_impl_trait`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `06_ticket_management/08_impl_trait`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/09_impl_trait_2`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `06_ticket_management/09_impl_trait_2`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/10_slices`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `06_ticket_management/10_slices`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/11_mutable_slices`"
#~ msgstr ""
#~ "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `06_ticket_management/11_mutable_slices`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/12_two_states`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `06_ticket_management/12_two_states`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `06_ticket_management/13_index`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `06_ticket_management/13_index`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/14_index_mut`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `06_ticket_management/14_index_mut`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/15_hashmap`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `06_ticket_management/15_hashmap`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/16_btreemap`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `06_ticket_management/16_btreemap`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `07_threads/00_intro`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `07_threads/00_intro`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `07_threads/01_threads`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `07_threads/01_threads`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "// \\[..\\]"
#~ msgstr "// \\[..\\]"

#, fuzzy
#~ msgid "The data segment"
#~ msgstr "ë°ì´í„° ì„¸ê·¸ë¨¼íŠ¸"

#, fuzzy
#~ msgid "The exercise for this section is located in `07_threads/02_static`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `07_threads/02_static`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `07_threads/03_leak`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `07_threads/03_leak`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `07_threads/04_scoped_threads`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `07_threads/04_scoped_threads`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `07_threads/05_channels`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `07_threads/05_channels`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`07_threads/06_interior_mutability`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `07_threads/06_interior_mutability`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `07_threads/07_ack`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `07_threads/07_ack`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `07_threads/08_client`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `07_threads/08_client`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `07_threads/09_bounded`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `07_threads/09_bounded`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `07_threads/10_patch`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `07_threads/10_patch`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `07_threads/11_locks`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `07_threads/11_locks`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `07_threads/12_rw_lock`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `07_threads/12_rw_lock`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`07_threads/13_without_channels`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `07_threads/13_without_channels`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `07_threads/14_sync`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `07_threads/14_sync`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `08_futures/00_intro`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `08_futures/00_intro`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `08_futures/01_async_fn`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `08_futures/01_async_fn`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `08_futures/02_spawn`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `08_futures/02_spawn`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `08_futures/03_runtime`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `08_futures/03_runtime`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `08_futures/04_future`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `08_futures/04_future`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `08_futures/05_blocking`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `08_futures/05_blocking`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`08_futures/06_async_aware_primitives`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `08_futures/06_async_aware_primitives`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `08_futures/07_cancellation`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `08_futures/07_cancellation`ì— ìˆìŠµë‹ˆë‹¤."

#, fuzzy
#~ msgid "The exercise for this section is located in `08_futures/08_outro`"
#~ msgstr "ì´ ì„¹ì…˜ì˜ ì—°ìŠµì€ `08_futures/08_outro`ì— ìˆìŠµë‹ˆë‹¤."
