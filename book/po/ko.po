msgid ""
msgstr ""
"Project-Id-Version: 100 Exercises To Learn Rust\n"
"POT-Creation-Date: 2024-06-20T21:50:15+09:00\n"
"PO-Revision-Date: 2024-06-22 07:07+0900\n"
"Last-Translator: bigfood <satcom1600@hanmail.net>\n"
"Language-Team: Korean <translation-team-ko@googlegroups.com>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.4\n"

#: src/SUMMARY.md:1 src/02_basic_calculator/01_integers.md:44
msgid "Summary"
msgstr "요약"

#: src/SUMMARY.md:3 src/01_intro/00_welcome.md:1
msgid "Welcome"
msgstr "환영합니다"

#: src/SUMMARY.md:4 src/01_intro/01_syntax.md:1
#: src/03_ticket_v1/06_ownership.md:181
msgid "Syntax"
msgstr "문법"

#: src/SUMMARY.md:6 src/02_basic_calculator/00_intro.md:1
msgid "A Basic Calculator"
msgstr "간단한 계산기"

#: src/SUMMARY.md:7 src/02_basic_calculator/01_integers.md:13
msgid "Integers"
msgstr "정수"

#: src/SUMMARY.md:8 src/02_basic_calculator/02_variables.md:1
msgid "Variables"
msgstr "변수"

#: src/SUMMARY.md:9
msgid "Branching: `if`/`else`"
msgstr "분기: `if`/`else`"

#: src/SUMMARY.md:10 src/02_basic_calculator/00_intro.md:12
#: src/02_basic_calculator/04_panics.md:1
msgid "Panics"
msgstr "패닉"

#: src/SUMMARY.md:11 src/02_basic_calculator/05_factorial.md:1
msgid "Factorial"
msgstr "팩토리얼"

#: src/SUMMARY.md:12
msgid "Loops: `while`"
msgstr "루프: `while`"

#: src/SUMMARY.md:13
msgid "Loops: `for`"
msgstr "루프: `for`"

#: src/SUMMARY.md:14
msgid "Overflow and underflow"
msgstr "오버플로우와 언더플로우"

#: src/SUMMARY.md:15
msgid "Saturating arithmetic"
msgstr "포화 산술"

#: src/SUMMARY.md:16
msgid "Conversions: `as` casting"
msgstr "변환: `as` 캐스팅"

#: src/SUMMARY.md:18
msgid "Ticket v1"
msgstr "Ticket v1"

#: src/SUMMARY.md:19 src/03_ticket_v1/01_struct.md:1
msgid "Structs"
msgstr "구조체"

#: src/SUMMARY.md:20 src/03_ticket_v1/02_validation.md:1
msgid "Validation"
msgstr "확인"

#: src/SUMMARY.md:21 src/03_ticket_v1/03_modules.md:1
msgid "Modules"
msgstr "모듈"

#: src/SUMMARY.md:22 src/03_ticket_v1/04_visibility.md:1
msgid "Visibility"
msgstr "가시성"

#: src/SUMMARY.md:23 src/03_ticket_v1/05_encapsulation.md:1
msgid "Encapsulation"
msgstr "캡슐화"

#: src/SUMMARY.md:24 src/03_ticket_v1/06_ownership.md:1
msgid "Ownership"
msgstr "소유권"

#: src/SUMMARY.md:25 src/03_ticket_v1/07_setters.md:25
msgid "Setters"
msgstr "설정자(Setters)"

#: src/SUMMARY.md:26 src/03_ticket_v1/08_stack.md:13
msgid "Stack"
msgstr "스택"

#: src/SUMMARY.md:27 src/03_ticket_v1/09_heap.md:1
msgid "Heap"
msgstr "힙"

#: src/SUMMARY.md:28
msgid "References in memory"
msgstr "메모리 참조"

#: src/SUMMARY.md:29 src/03_ticket_v1/11_destructor.md:1
#: src/03_ticket_v1/11_destructor.md:39
msgid "Destructors"
msgstr "소멸자(Destructors)"

#: src/SUMMARY.md:30 src/SUMMARY.md:46 src/SUMMARY.md:63 src/SUMMARY.md:107
#: src/08_futures/08_outro.md:1
msgid "Outro"
msgstr "마무리"

#: src/SUMMARY.md:32 src/04_traits/00_intro.md:1 src/04_traits/01_trait.md:1
msgid "Traits"
msgstr "트레잇"

#: src/SUMMARY.md:33 src/04_traits/03_operator_overloading.md:35
msgid "Trait"
msgstr "트레잇"

#: src/SUMMARY.md:34 src/04_traits/02_orphan_rule.md:86
msgid "Orphan rule"
msgstr "고아 규칙(Orphan rule)"

#: src/SUMMARY.md:35 src/04_traits/03_operator_overloading.md:1
msgid "Operator overloading"
msgstr "연산자 오버로딩"

#: src/SUMMARY.md:36 src/04_traits/04_derive.md:1 src/04_traits/04_derive.md:69
msgid "Derive macros"
msgstr "파생(Derive) 매크로"

#: src/SUMMARY.md:37 src/04_traits/05_trait_bounds.md:1
#: src/04_traits/05_trait_bounds.md:81
msgid "Trait bounds"
msgstr "트레잇 바운드"

#: src/SUMMARY.md:38 src/04_traits/06_str_slice.md:1
#: src/04_traits/06_str_slice.md:67
msgid "String slices"
msgstr "문자열 슬라이스"

#: src/SUMMARY.md:39 src/04_traits/07_deref.md:1
msgid "`Deref` trait"
msgstr "`Deref` 트레잇"

#: src/SUMMARY.md:40
msgid "`Sized` trait"
msgstr "`Sized` 트레잇"

#: src/SUMMARY.md:41
msgid "`From` trait"
msgstr "`From` 트레잇"

#: src/SUMMARY.md:42
msgid "Associated vs generic types"
msgstr "연관 vs 제네릭 타입"

#: src/SUMMARY.md:43
msgid "`Clone` trait"
msgstr "`Clone` 트레잇"

#: src/SUMMARY.md:44
msgid "`Copy` trait"
msgstr "`Copy` 트레잇"

#: src/SUMMARY.md:45
msgid "`Drop` trait"
msgstr "`Drop` 트레잇"

#: src/SUMMARY.md:48
msgid "Ticket v2"
msgstr "Ticket v2"

#: src/SUMMARY.md:49
msgid "Enums"
msgstr "열거형(Enums)"

#: src/SUMMARY.md:50
msgid "Branching: `match`"
msgstr "분기: `match`"

#: src/SUMMARY.md:51
msgid "Variants with data"
msgstr "데이터를 가진 배리언트"

#: src/SUMMARY.md:52
msgid "Branching: `if let` and `let/else`"
msgstr "분기: `if let` 과 `let/else`"

#: src/SUMMARY.md:53 src/05_ticket_v2/05_nullability.md:1
msgid "Nullability"
msgstr "Null 가능성(Nullability)"

#: src/SUMMARY.md:54 src/05_ticket_v2/06_fallibility.md:1
msgid "Fallibility"
msgstr "실패 가능성(Fallibility)"

#: src/SUMMARY.md:55
msgid "Unwrap"
msgstr "Unwrap"

#: src/SUMMARY.md:56 src/05_ticket_v2/08_error_enums.md:1
msgid "Error enums"
msgstr "Error 열거형"

#: src/SUMMARY.md:57
msgid "`Error` trait"
msgstr "`Error` 트레잇"

#: src/SUMMARY.md:58
msgid "Packages"
msgstr "패키지"

#: src/SUMMARY.md:59 src/05_ticket_v2/11_dependencies.md:1
msgid "Dependencies"
msgstr "디펜던시"

#: src/SUMMARY.md:60 src/05_ticket_v2/12_thiserror.md:1
msgid "`thiserror`"
msgstr "`thiserror`"

#: src/SUMMARY.md:61
msgid "`TryFrom` trait"
msgstr "`TryFrom` 트레잇"

#: src/SUMMARY.md:62 src/05_ticket_v2/14_source.md:1
msgid "`Error::source`"
msgstr "`Error::source`"

#: src/SUMMARY.md:65
msgid "Ticket Management"
msgstr "티켓 관리"

#: src/SUMMARY.md:66 src/06_ticket_management/01_arrays.md:1
#: src/06_ticket_management/01_arrays.md:9
msgid "Arrays"
msgstr "배열"

#: src/SUMMARY.md:67 src/06_ticket_management/02_vec.md:1
msgid "Vectors"
msgstr "벡터"

#: src/SUMMARY.md:68 src/06_ticket_management/03_resizing.md:1
msgid "Resizing"
msgstr "리사이징"

#: src/SUMMARY.md:69
msgid "Iterators"
msgstr "반복자"

#: src/SUMMARY.md:70
msgid "Iter"
msgstr "Iter"

#: src/SUMMARY.md:71 src/06_ticket_management/06_lifetimes.md:1
msgid "Lifetimes"
msgstr "수명"

#: src/SUMMARY.md:72 src/06_ticket_management/07_combinators.md:1
msgid "Combinators"
msgstr "결합자(Combinators)"

#: src/SUMMARY.md:73 src/06_ticket_management/08_impl_trait.md:1
#: src/06_ticket_management/08_impl_trait.md:35
msgid "`impl Trait`"
msgstr "`impl Trait`"

#: src/SUMMARY.md:74
msgid "`impl Trait`, pt.2"
msgstr "`impl Trait`, pt.2"

#: src/SUMMARY.md:75 src/06_ticket_management/10_slices.md:1
msgid "Slices"
msgstr "슬라이스"

#: src/SUMMARY.md:76 src/06_ticket_management/11_mutable_slices.md:1
msgid "Mutable slices"
msgstr "변경 가능한 슬라이스"

#: src/SUMMARY.md:77
msgid "Two states"
msgstr "두 가지 상태"

#: src/SUMMARY.md:78
msgid "`Index` trait"
msgstr "`Index` 트레잇"

#: src/SUMMARY.md:79
msgid "`IndexMut` trait"
msgstr "`IndexMut` 트레잇"

#: src/SUMMARY.md:80 src/06_ticket_management/15_hashmap.md:1
msgid "`HashMap`"
msgstr "`HashMap`"

#: src/SUMMARY.md:81 src/06_ticket_management/16_btreemap.md:11
msgid "`BTreeMap`"
msgstr "`BTreeMap`"

#: src/SUMMARY.md:83 src/SUMMARY.md:84 src/07_threads/01_threads.md:1
msgid "Threads"
msgstr "스레드"

#: src/SUMMARY.md:85 src/07_threads/02_static.md:54
msgid "`'static` lifetime"
msgstr "`'static` 수명"

#: src/SUMMARY.md:86
msgid "Leaking memory"
msgstr "메모리 누수"

#: src/SUMMARY.md:87 src/07_threads/04_scoped_threads.md:1
msgid "Scoped threads"
msgstr "범위 스레드"

#: src/SUMMARY.md:88 src/07_threads/05_channels.md:1
#: src/07_threads/05_channels.md:31
msgid "Channels"
msgstr "채널"

#: src/SUMMARY.md:89 src/07_threads/06_interior_mutability.md:1
msgid "Interior mutability"
msgstr "내부 가변성(Interior mutability)"

#: src/SUMMARY.md:90
msgid "Ack pattern"
msgstr "Ack 패턴"

#: src/SUMMARY.md:91
msgid "Client"
msgstr "클라이언트"

#: src/SUMMARY.md:92 src/07_threads/09_bounded.md:13
msgid "Bounded channels"
msgstr "제한 채널(Bounded channels)"

#: src/SUMMARY.md:93 src/07_threads/10_patch.md:19
msgid "Patching"
msgstr "패치"

#: src/SUMMARY.md:94
msgid "`Mutex`, `Send` and `Arc`"
msgstr "`Mutex`, `Send` 그리고 `Arc`"

#: src/SUMMARY.md:95
msgid "`RwLock`"
msgstr "`RwLock`"

#: src/SUMMARY.md:96
msgid "Without channels"
msgstr "채널 없이"

#: src/SUMMARY.md:97
msgid "`Sync` trait"
msgstr "`Sync` 트레잇"

#: src/SUMMARY.md:99
msgid "Futures"
msgstr "Futures"

#: src/SUMMARY.md:100 src/08_futures/01_async_fn.md:1
msgid "Asynchronous functions"
msgstr "비동기 함수"

#: src/SUMMARY.md:101 src/08_futures/02_spawn.md:1
msgid "Spawning tasks"
msgstr "태스크 띄우기"

#: src/SUMMARY.md:102
msgid "Runtime"
msgstr "런타임"

#: src/SUMMARY.md:103
msgid "Future trait"
msgstr "Future trait"

#: src/SUMMARY.md:104
msgid "Blocking the runtime"
msgstr "런타임 블로킹"

#: src/SUMMARY.md:105 src/08_futures/06_async_aware_primitives.md:1
msgid "Async-aware primitives"
msgstr "Async-aware 기본 요소"

#: src/SUMMARY.md:106 src/08_futures/07_cancellation.md:1
msgid "Cancellation"
msgstr "취소"

#: src/SUMMARY.md:109 src/going_further.md:16
msgid "Going further"
msgstr "더 나아가"

#: src/01_intro/00_welcome.md:3
msgid "Welcome to **\"100 Exercises To Learn Rust\"**!"
msgstr "**Rust를 배우기 위한 100가지 연습**에 오신 것을 환영합니다!"

#: src/01_intro/00_welcome.md:5
msgid ""
"This course will teach you Rust's core concepts, one exercise at a time.  \n"
"You'll learn about Rust's syntax, its type system, its standard library, and "
"its ecosystem."
msgstr ""
"이 코스에서는 Rust의 핵심 개념을 한 번에 하나씩 연습해 볼 것입니다.  \n"
"Rust의 문법, Trait 시스템, 표준 라이브러리와 생태계에 대해 배우게 됩니다."

#: src/01_intro/00_welcome.md:8
msgid ""
"We don't assume any prior knowledge of Rust, but we assume you know at least "
"another programming language. We also don't assume any prior knowledge of "
"systems programming or memory management. Those topics will be covered in the "
"course."
msgstr ""
"우리는 당신이 Rust에 대한 사전 지식이 없지만, 적어도 다른 프로그래밍 언어 하나"
"는 알고 있다고 가정합니다. 그리고 시스템 프로그래밍이나 메모리 관리에 대한 사"
"전 지식을 가지고있다고 가정합니다. 이 코스에서 앞선 주제들을 다루어 볼것입니"
"다."

#: src/01_intro/00_welcome.md:13
msgid ""
"In other words, we'll be starting from scratch!  \n"
"You'll build up your Rust knowledge in small, manageable steps. By the end of "
"the course, you will have solved ~100 exercises, enough to feel comfortable "
"working on small to medium-sized Rust projects."
msgstr ""
"즉, 처음부터 다시 시작하는 것입니다!  \n"
"작고 관리 가능한 단계를 통해 Rust 지식을 쌓을 수 있습니다. 과정이 끝나면 중소 "
"규모의 Rust 프로젝트에서 편안하게 작업할 수 있을 만큼 약 100개의 연습 문제를 "
"풀게 됩니다."

#: src/01_intro/00_welcome.md:18
msgid "Methodology"
msgstr "방법론"

#: src/01_intro/00_welcome.md:20
msgid ""
"This course is based on the \"learn by doing\" principle.  \n"
"It has been designed to be interactive and hands-on."
msgstr ""
"이 과정은 \"실행을 통해 학습\" 원칙을 기반으로 합니다.  \n"
"대화형 및 실습형으로 설계되었습니다."

#: src/01_intro/00_welcome.md:23
msgid ""
"[Mainmatter](https://mainmatter.com/rust-consulting/) developed this course "
"to be delivered in a classroom setting, over 4 days: each attendee advances "
"through the lessons at their own pace, with an experienced instructor "
"providing guidance, answering questions and diving deeper into the topics as "
"needed.  \n"
"If you're interested in attending one of our training sessions, or if you'd "
"like to bring this course to your company, please [get in touch](https://"
"mainmatter.com/contact/)."
msgstr ""
"[Mainmatter](https://mainmatter.com/rust-consulting/) 는 4일에 걸친 교육환경에"
"서 제공되도록 이 코스를 만들었습니다. 각 참석자는 자신만의 페이스로, 숙련된 강"
"사의 지도를 받으며, 질문에 답하고, 필요에 따라 주제에 대해 더 깊이 파고들며 수"
"업을 진행합니다.  \n"
"교육 세션에 참여하고 싶거나 이 교육 과정을 회사에 도입하고 싶다면 연락해 주세"
"요."

#: src/01_intro/00_welcome.md:30
msgid ""
"You can also follow the course on your own, but we recommend you find a "
"friend or a mentor to help you along the way should you get stuck. You can "
"also find solutions to all exercises in the [`solutions` branch of the GitHub "
"repository](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/"
"solutions)."
msgstr ""
"스스로 과정을 따라갈 수도 있지만, 막히는 경우 과정을 진행하는 데 도움을 줄 수 "
"있는 친구나 멘토를 찾는 것이 좋습니다.  [깃헙 리포지토리의 `solutions` 브랜치]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/solutions)에"
"서 모든 연습에 대한 솔루션을 찾을 수도 있습니다."

#: src/01_intro/00_welcome.md:35
msgid "Structure"
msgstr "구조"

#: src/01_intro/00_welcome.md:37
msgid ""
"On the left side of the screen, you can see that the course is divided into "
"sections. Each section introduces a new concept or feature of the Rust "
"language.  \n"
"To verify your understanding, each section is paired with an exercise that "
"you need to solve."
msgstr ""
"화면 왼쪽을 보면 코스가 여러 섹션으로 나누어져 있는 것을 볼 수 있습니다. 각 섹"
"션에서는 Rust 언어의 새로운 개념이나 기능을 소개합니다.  \n"
"이해를 확인하기 위해 각 섹션은 해결해야 하는 연습문제와 짝을 이룹니다."

#: src/01_intro/00_welcome.md:41
msgid ""
"You can find the exercises in the [companion GitHub repository](https://"
"github.com/mainmatter/100-exercises-to-learn-rust).  \n"
"Before starting the course, make sure to clone the repository to your local "
"machine:"
msgstr ""
"[자매 깃헙 리포지토리](https://github.com/mainmatter/100-exercises-to-learn-"
"rust)에서 예제들을 확인할 수 있습니다.  \n"
"코스를 시작하기전에 리포지토리를 로컬에 클론하세요:"

#: src/01_intro/00_welcome.md:46
msgid "# If you have an SSH key set up with GitHub\n"
msgstr "# GitHub에 SSH 키가 설정되어 있는 경우\n"

#: src/01_intro/00_welcome.md:47
msgid ""
"# Otherwise, use the HTTPS URL:\n"
"#\n"
"#   git clone https://github.com/mainmatter/100-exercises-to-learn-rust.git\n"
msgstr ""
"# 아니면 HTTPS URL을 사용하십시오:\n"
"# \n"
"#    git clone https://github.com/mainmatter/100-exercises-to-learn-rust.git\n"

#: src/01_intro/00_welcome.md:53
msgid ""
"We also recommend you work on a branch, so you can easily track your progress "
"and pull in updates from the main repository, if needed:"
msgstr ""
"또한 진행 상황을 쉽게 추적하고 필요한 경우 메인 리포지토리에서 업데이트를 가져"
"올 수 있도록 브랜치에서 작업하는 것이 좋습니다:"

#: src/01_intro/00_welcome.md:61
msgid ""
"All exercises are located in the `exercises` folder. Each exercise is "
"structured as a Rust package. The package contains the exercise itself, "
"instructions on what to do (in `src/lib.rs`), and a test suite to "
"automatically verify your solution."
msgstr ""
"모든 예제는 `exercises` 폴더에 있습니다. 각 문제는 Rust 패키지로 구성됩니다. "
"패키지에는 연습 자체, 수행할 작업에 대한 지침(`src/lib.rs`에 있음), 솔루션을 "
"자동으로 검증하기 위한 테스트 모음이 포함되어 있습니다."

#: src/01_intro/00_welcome.md:66
msgid "`wr`, the workshop runner"
msgstr "`wr`, 워크숍 러너"

#: src/01_intro/00_welcome.md:68
msgid ""
"To verify your solutions, we've provided a tool that will guide you through "
"the course. It is the `wr` CLI (short for \"workshop runner\"). Install it "
"with:"
msgstr ""
"솔루션을 검증하기 위해 코스 내내 당신을 도와줄 도구를 제공합니다. `wr` "
"CLI(\"워크숍 러너\"의 줄임말)입니다. 아래 명령을 사용하여 설치하세요:"

#: src/01_intro/00_welcome.md:76
msgid ""
"In a new terminal, navigate back to the top-level folder of the repository. "
"Run the `wr` command to start the course:"
msgstr ""
"새 터미널에서 리포지토리의 최상위 폴더로 이동합니다. 코스를 시작하려면 `wr` 명"
"령을 실행하세요:"

#: src/01_intro/00_welcome.md:83
msgid ""
"`wr` will verify the solution to the current exercise.  \n"
"Don't move on to the next section until you've solved the exercise for the "
"current one."
msgstr ""
"`wr`은 현재 연습에 대한 솔루션을 확인합니다.  \n"
"현재 연습문제를 풀 때까지 다음 섹션으로 넘어가지 마세요."

#: src/01_intro/00_welcome.md:86
msgid ""
"We recommend committing your solutions to Git as you progress through the "
"course, so you can easily track your progress and \"restart\" from a known "
"point if needed."
msgstr ""
"과정을 진행하면서 솔루션을 Git에 커밋하는 것이 좋습니다. 그러면 진행 상황을 쉽"
"게 추적하고 필요한 경우 특정 지점에서 \"다시 시작할\" 수 있습니다."

#: src/01_intro/00_welcome.md:89
msgid "Enjoy the course!"
msgstr "코스를 즐겨보세요!"

#: src/01_intro/00_welcome.md:91
msgid "Author"
msgstr "작성자"

#: src/01_intro/00_welcome.md:93
msgid ""
"This course was written by [Luca Palmieri](https://www.lpalmieri.com/), "
"Principal Engineering Consultant at [Mainmatter](https://mainmatter.com/rust-"
"consulting/).  \n"
"Luca has been working with Rust since 2018, initially at TrueLayer and then "
"at AWS.  \n"
"Luca is the author of [\"Zero to Production in Rust\"](https://zero2prod."
"com), the go-to resource for learning how to build backend applications in "
"Rust.  \n"
"He is also the author and maintainer of a variety of open-source Rust "
"projects, including [`cargo-chef`](https://github.com/LukeMathWalker/cargo-"
"chef), [Pavex](https://pavex.dev) and [`wiremock`](https://github.com/"
"LukeMathWalker/wiremock-rs)."
msgstr ""
"이 과정은 [Mainmatter](https://mainmatter.com/rust-consulting/)의 수석 엔지니"
"어링 컨설턴트인 [Luca Palmieri](https://www.lpalmieri.com/)가 작성했습니"
"다.  \n"
"Luca는 2018년부터 처음에는 TrueLayer에서, 그다음에는 AWS에서 Rust와 협력해 왔"
"습니다.  \n"
"Luca는 Rust에서 백엔드 애플리케이션을 구축하는 방법을 배우기 위한 유용한 리소"
"스인 [\"Zero to Production in Rust\"](https://zero2prod.com)의 저자입니다.  \n"
"그는 또한 [`cargo-chef`](https://github.com/LukeMathWalker/cargo-chef), "
"[Pavex](https://pavex.dev)와 [`wiremock`](https://github.com/LukeMathWalker/"
"wiremock-rs)을 포함한 다양한 오픈 소스 Rust 프로젝트의 저자이자 관리자이기도 "
"합니다."

#: src/01_intro/00_welcome.md:102 src/01_intro/01_syntax.md:117
#: src/02_basic_calculator/00_intro.md:18
#: src/02_basic_calculator/01_integers.md:136
#: src/02_basic_calculator/02_variables.md:102
#: src/02_basic_calculator/03_if_else.md:103
#: src/02_basic_calculator/04_panics.md:56
#: src/02_basic_calculator/05_factorial.md:13
#: src/02_basic_calculator/06_while.md:87 src/02_basic_calculator/07_for.md:66
#: src/02_basic_calculator/08_overflow.md:108
#: src/02_basic_calculator/09_saturating.md:41
#: src/02_basic_calculator/10_as_casting.md:103 src/03_ticket_v1/00_intro.md:20
#: src/03_ticket_v1/01_struct.md:140 src/03_ticket_v1/02_validation.md:23
#: src/03_ticket_v1/03_modules.md:116 src/03_ticket_v1/04_visibility.md:47
#: src/03_ticket_v1/05_encapsulation.md:61 src/03_ticket_v1/06_ownership.md:235
#: src/03_ticket_v1/07_setters.md:110 src/03_ticket_v1/08_stack.md:60
#: src/03_ticket_v1/09_heap.md:144
#: src/03_ticket_v1/10_references_in_memory.md:52
#: src/03_ticket_v1/11_destructor.md:171 src/03_ticket_v1/12_outro.md:7
#: src/04_traits/00_intro.md:22 src/04_traits/01_trait.md:129
#: src/04_traits/02_orphan_rule.md:114
#: src/04_traits/03_operator_overloading.md:100 src/04_traits/04_derive.md:105
#: src/04_traits/05_trait_bounds.md:174 src/04_traits/06_str_slice.md:118
#: src/04_traits/07_deref.md:93 src/04_traits/08_sized.md:81
#: src/04_traits/09_from.md:142 src/04_traits/10_assoc_vs_generic.md:148
#: src/04_traits/11_clone.md:109 src/04_traits/12_copy.md:115
#: src/04_traits/13_drop.md:54 src/04_traits/14_outro.md:29
#: src/05_ticket_v2/00_intro.md:17 src/05_ticket_v2/01_enum.md:45
#: src/05_ticket_v2/02_match.md:72 src/05_ticket_v2/03_variants_with_data.md:90
#: src/05_ticket_v2/04_if_let.md:68 src/05_ticket_v2/05_nullability.md:76
#: src/05_ticket_v2/06_fallibility.md:85 src/05_ticket_v2/07_unwrap.md:42
#: src/05_ticket_v2/08_error_enums.md:40 src/05_ticket_v2/09_error_trait.md:54
#: src/05_ticket_v2/10_packages.md:65 src/05_ticket_v2/11_dependencies.md:56
#: src/05_ticket_v2/12_thiserror.md:43 src/05_ticket_v2/13_try_from.md:42
#: src/05_ticket_v2/14_source.md:152 src/05_ticket_v2/15_outro.md:20
#: src/06_ticket_management/00_intro.md:20
#: src/06_ticket_management/01_arrays.md:83
#: src/06_ticket_management/02_vec.md:114
#: src/06_ticket_management/03_resizing.md:27
#: src/06_ticket_management/04_iterators.md:109
#: src/06_ticket_management/05_iter.md:44
#: src/06_ticket_management/06_lifetimes.md:86
#: src/06_ticket_management/07_combinators.md:109
#: src/06_ticket_management/08_impl_trait.md:71
#: src/06_ticket_management/09_impl_trait_2.md:34
#: src/06_ticket_management/10_slices.md:108
#: src/06_ticket_management/11_mutable_slices.md:43
#: src/06_ticket_management/12_two_states.md:69
#: src/06_ticket_management/13_index.md:39
#: src/06_ticket_management/14_index_mut.md:22
#: src/06_ticket_management/15_hashmap.md:118
#: src/06_ticket_management/16_btreemap.md:84 src/07_threads/00_intro.md:17
#: src/07_threads/01_threads.md:117 src/07_threads/02_static.md:116
#: src/07_threads/03_leak.md:48 src/07_threads/04_scoped_threads.md:75
#: src/07_threads/05_channels.md:75 src/07_threads/06_interior_mutability.md:116
#: src/07_threads/07_ack.md:18 src/07_threads/08_client.md:10
#: src/07_threads/09_bounded.md:45 src/07_threads/10_patch.md:41
#: src/07_threads/11_locks.md:224 src/07_threads/12_rw_lock.md:47
#: src/07_threads/13_without_channels.md:56 src/07_threads/14_sync.md:30
#: src/08_futures/00_intro.md:13 src/08_futures/01_async_fn.md:146
#: src/08_futures/02_spawn.md:124 src/08_futures/03_runtime.md:90
#: src/08_futures/04_future.md:167 src/08_futures/05_blocking.md:81
#: src/08_futures/06_async_aware_primitives.md:131
#: src/08_futures/07_cancellation.md:111 src/08_futures/08_outro.md:36
msgid "Exercise"
msgstr "예제"

#: src/01_intro/00_welcome.md:104
msgid ""
"The exercise for this section is located in [`01_intro/00_welcome`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/01_intro/00_welcome)"
msgstr ""
"이 섹션의 예제는 [`01_intro/00_welcome`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/01_intro/00_welcome)에 있습니다"

#: src/01_intro/01_syntax.md:5
msgid ""
"Don't jump ahead!  \n"
"Complete the exercise for the previous section before you start this one.  \n"
"It's located in `exercises/01_intro/00_welcome`, in the [course GitHub's "
"repository](https://github.com/mainmatter/100-exercises-to-learn-rust).  \n"
"Use [`wr`](00_welcome.md#wr-the-workshop-runner) to start the course and "
"verify your solutions."
msgstr ""
"앞으로 건너뛰지마세요!  \n"
"이 섹션을 시작하기 전에 이전 섹션의 연습을 완료하세요.  \n"
"이전 섹션은 [GitHub 저장소](https://github.com/mainmatter/100-exercises-to-"
"learn-rust)의 `exercises/01_intro/00_welcome`에 있습니다.  \n"
"[`wr`](00_welcome.md#wr-the-workshop-runner)을 사용하여 코스를 시작하고 솔루션"
"을 확인하세요."

#: src/01_intro/01_syntax.md:12
msgid ""
"The previous task doesn't even qualify as an exercise, but it already exposed "
"you to quite a bit of Rust **syntax**. We won't cover every single detail of "
"Rust's syntax used in the previous exercise. Instead, we'll cover _just "
"enough_ to keep going without getting stuck in the details.  \n"
"One step at a time!"
msgstr ""
"이전 작업은 연습으로도 적합하지 않지만 이미 꽤 많은 Rust **문법**을 노출시켰습"
"니다. 이전 연습에서 사용된 Rust 구문을 세세하게 다루지는 않을 것입니다. 대신, "
"_계속 진행할 수 있을 정도만_ 다루겠습니다.  \n"
"한 번에 한 걸음 씩!"

#: src/01_intro/01_syntax.md:17
msgid "Comments"
msgstr "코멘트"

#: src/01_intro/01_syntax.md:19
msgid "You can use `//` for single-line comments:"
msgstr "한 줄 주석에는 `//`를 사용할 수 있습니다:"

#: src/01_intro/01_syntax.md:22
msgid ""
"// This is a single-line comment\n"
"// Followed by another single-line comment\n"
msgstr ""
"// 이것은 한 줄 주석입니다\n"
"// 또 다른 한 줄 주석이 이어집니다\n"

#: src/01_intro/01_syntax.md:26
msgid "Functions"
msgstr "함수"

#: src/01_intro/01_syntax.md:28
msgid ""
"Functions in Rust are defined using the `fn` keyword, followed by the "
"function's name, its input parameters, and its return type. The function's "
"body is enclosed in curly braces `{}`."
msgstr ""
"Rust의 함수는 `fn` 키워드를 사용하여 정의되며 그 뒤에 함수 이름, 입력 매개변"
"수, 반환 유형이 옵니다. 함수 본문은 중괄호 `{}`로 감싸줍니다."

#: src/01_intro/01_syntax.md:32
msgid "In previous exercise, you saw the `greeting` function:"
msgstr "이전 연습에서는 `인사말` 기능을 보았습니다:"

#: src/01_intro/01_syntax.md:35
msgid ""
"// `fn` <function_name> ( <input parameters> ) -> <return_type> { <body> }\n"
msgstr ""
"// `fn` \\<function_name> ( <input parameters> ) -> \\<return_type> "
"{ <body> }\n"

#: src/01_intro/01_syntax.md:37
msgid ""
"// TODO: fix me 👇\n"
"    \"I'm ready to __!\""
msgstr ""
"// TODO: fix me 👇\n"
"    \"I'm ready to \\_\\_!\""

#: src/01_intro/01_syntax.md:42
msgid ""
"`greeting` has no input parameters and returns a reference to a string slice "
"(`&'static str`)."
msgstr ""
"`greeting`에는 입력 매개변수가 없으며 문자열 슬라이스 (`&'static str`)에 대한 "
"참조를 반환합니다."

#: src/01_intro/01_syntax.md:44
msgid "Return type"
msgstr "반환 유형"

#: src/01_intro/01_syntax.md:46
msgid ""
"The return type can be omitted from the signature if the function doesn't "
"return anything (i.e. if it returns `()`, Rust's unit type). That's what "
"happened with the `test_welcome` function:"
msgstr ""
"함수가 아무 것도 반환하지 않으면(즉, Rust의 단위 유형인 `()`를 반환하는 경우) "
"반환 유형을 시그니처에서 생략할 수 있습니다. 이것이 `test_welcome` 함수에서 있"
"었던 일입니다:"

#: src/01_intro/01_syntax.md:52 src/01_intro/01_syntax.md:62
#: src/01_intro/01_syntax.md:83
msgid "\"I'm ready to learn Rust!\""
msgstr "\"I'm ready to learn Rust!\""

#: src/01_intro/01_syntax.md:56
msgid "The above is equivalent to:"
msgstr "위의 내용은 다음과 동일합니다:"

#: src/01_intro/01_syntax.md:59
msgid ""
"// Spelling out the unit return type explicitly\n"
"//                   👇\n"
msgstr ""
"// Spelling out the unit return type explicitly\n"
"//                   👇\n"

#: src/01_intro/01_syntax.md:66
msgid "Returning values"
msgstr "반환 값"

#: src/01_intro/01_syntax.md:68
msgid "The last expression in a function is implicitly returned:"
msgstr "함수의 마지막 표현식은 암시적으로 반환됩니다:"

#: src/01_intro/01_syntax.md:72
msgid ""
"// This is the last expression in the function\n"
"    // Therefore its value is returned by `greeting`\n"
"    \"I'm ready to learn Rust!\""
msgstr ""
"// This is the last expression in the function\n"
"    // Therefore its value is returned by `greeting`\n"
"    \"I'm ready to learn Rust!\""

#: src/01_intro/01_syntax.md:78
msgid "You can also use the `return` keyword to return a value early:"
msgstr "중간에 값을 반환하려면 `return` 키워드를 사용할 수도 있습니다:"

#: src/01_intro/01_syntax.md:82
msgid "// Notice the semicolon at the end of the line!\n"
msgstr "// Notice the semicolon at the end of the line!\n"

#: src/01_intro/01_syntax.md:87
msgid "It is considered idiomatic to omit the `return` keyword when possible."
msgstr "가능하면 'return' 키워드를 생략하는 것이 관용적입니다."

#: src/01_intro/01_syntax.md:89
msgid "Input parameters"
msgstr "입력 매개변수"

#: src/01_intro/01_syntax.md:91
msgid ""
"Input parameters are declared inside the parentheses `()` that follow the "
"function's name.  \n"
"Each parameter is declared with its name, followed by a colon `:`, followed "
"by its type."
msgstr ""
"입력 매개변수는 함수 이름 뒤에 오는 괄호 '()' 안에 선언됩니다.  \n"
"각 매개변수는 `이름: 타입` 모양으로 선언됩니다."

#: src/01_intro/01_syntax.md:94
msgid ""
"For example, the `greet` function below takes a `name` parameter of type "
"`&str` (a \"string slice\"):"
msgstr ""
"예를 들어, 아래 `greet` 함수는 `&str` 타입(\"문자열 슬라이스\")의 `name` 매개"
"변수를 사용합니다:"

#: src/01_intro/01_syntax.md:97
msgid ""
"// An input parameter\n"
"//        👇\n"
msgstr ""
"// An input parameter\n"
"//        👇\n"

#: src/01_intro/01_syntax.md:100
msgid "\"Hello, {}!\""
msgstr "\"Hello, {}!\""

#: src/01_intro/01_syntax.md:104
msgid ""
"If there are multiple input parameters, they must be separated with commas."
msgstr "입력 매개변수가 여러 개인 경우 쉼표로 구분해야 합니다."

#: src/01_intro/01_syntax.md:106
msgid "Type annotations"
msgstr "타입 어노테이션"

#: src/01_intro/01_syntax.md:108
msgid ""
"Since we've been mentioned \"types\" a few times, let's state it clearly: "
"Rust is a **statically typed language**.  \n"
"Every single value in Rust has a type and that type must be known to the "
"compiler at compile-time."
msgstr ""
"우리는 \"타입\"에 대해 여러 번 언급했으므로 명확하게 말하겠습니다: Rust는 **정"
"적 타입 언어**입니다.  \n"
"Rust의 모든 단일 값에는 유형이 있으며 해당 유형은 컴파일 타임에 컴파일러가 알 "
"수 있어야 합니다."

#: src/01_intro/01_syntax.md:111
msgid ""
"Types are a form of **static analysis**.  \n"
"You can think of a type as a **tag** that the compiler attaches to every "
"value in your program. Depending on the tag, the compiler can enforce "
"different rules—e.g. you can't add a string to a number, but you can add two "
"numbers together. If leveraged correctly, types can prevent whole classes of "
"runtime bugs."
msgstr ""
"타입은 **static analysis**의 한 형태입니다.  \n"
"타입은 컴파일러가 프로그램의 모든 값에 첨부하는 **태그**로 생각할 수 있습니"
"다. 태그에 따라 컴파일러는 다른 규칙을 적용할 수 있습니다. 숫자에 문자열을 더"
"할 수는 없지만 두 숫자를 함께 더할 수는 있습니다. 타입을 올바르게 활용하면 모"
"든 종류의 런타임 버그를 방지할 수 있습니다."

#: src/01_intro/01_syntax.md:119
msgid ""
"The exercise for this section is located in [`01_intro/01_syntax`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/01_intro/01_syntax)"
msgstr ""
"이 섹션의 예제는 [`01_intro/01_syntax`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/01_intro/01_syntax)에 있습니다"

#: src/02_basic_calculator/00_intro.md:3
msgid ""
"In this chapter we'll learn how to use Rust as a **calculator**.  \n"
"It might not sound like much, but it'll give us a chance to cover a lot of "
"Rust's basics, such as:"
msgstr ""
"이번 장에서는 Rust를 **계산기**로 사용하는 방법을 배우겠습니다.  \n"
"별것 아닌 것처럼 들리겠지만, 다음과 같은 Rust의 기본기를 많이 다룰 수 있는 기"
"회를 제공할 것입니다:"

#: src/02_basic_calculator/00_intro.md:6
msgid "How to define and call functions"
msgstr "함수를 정의하고 호출하는 방법"

#: src/02_basic_calculator/00_intro.md:7
msgid "How to declare and use variables"
msgstr "변수 선언 및 사용 방법"

#: src/02_basic_calculator/00_intro.md:8
msgid "Primitive types (integers and booleans)"
msgstr "원시 타입(정수 와 불리언)"

#: src/02_basic_calculator/00_intro.md:9
msgid "Arithmetic operators (including overflow and underflow behavior)"
msgstr "산술 연산자(오버플로 및 언더플로 동작 포함)"

#: src/02_basic_calculator/00_intro.md:10
#: src/02_basic_calculator/03_if_else.md:73
msgid "Comparison operators"
msgstr "비교 연산자"

#: src/02_basic_calculator/00_intro.md:11
msgid "Control flow"
msgstr "흐름 제어"

#: src/02_basic_calculator/00_intro.md:14
msgid ""
"Nailing the basics with a few exercises will get the language flowing under "
"your fingers. When we move on to more complex topics, such as traits and "
"ownership, you'll be able to focus on the new concepts without getting bogged "
"down by the syntax or other trivial details."
msgstr ""
"몇 가지 연습을 통해 기본기를 익히면 언어가 물흐르듯 써지게 됩니다. Trait와 소"
"유권같은 더 복잡한 주제로 넘어갈 때 문법이나 기타 사소한 세부사항에 얽매이지 "
"않고 새로운 개념에 집중할 수 있습니다."

#: src/02_basic_calculator/00_intro.md:20
msgid ""
"The exercise for this section is located in [`02_basic_calculator/00_intro`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/00_intro)"
msgstr ""
"이 섹션의 예제는 [`02_basic_calculator/00_intro`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/00_intro)에 있습니다"

#: src/02_basic_calculator/01_integers.md:1
msgid "Types, part 1"
msgstr "Types, part 1"

#: src/02_basic_calculator/01_integers.md:3
msgid ""
"In the [\"Syntax\" section](../01_intro/01_syntax.md) `compute`'s input "
"parameters were of type `u32`.  \n"
"Let's unpack what that _means_."
msgstr ""
"[\"문법\" section](../01_intro/01_syntax.md)섹션에서 `compute`의 입력 매개변수"
"는 `u32` 타입이었습니다.  \n"
"그것이 _의미_ 무엇인지 풀어봅시다."

#: src/02_basic_calculator/01_integers.md:6
msgid "Primitive types"
msgstr "원시 타입"

#: src/02_basic_calculator/01_integers.md:8
msgid ""
"`u32` is one of Rust's **primitive types**. Primitive types are the most "
"basic building blocks of a language. They're built into the language itself—i."
"e. they are not defined in terms of other types."
msgstr ""
"`u32`는 Rust의 **원시 타입** 중 하나입니다. 원시 타입은 언어의 가장 기본적인 "
"구성 요소입니다. 이는 언어 자체에 내장되어 있습니다. 다른 타입처럼 정의되지 않"
"습니다."

#: src/02_basic_calculator/01_integers.md:11
msgid ""
"You can combine these primitive types to create more complex types. We'll see "
"how soon enough."
msgstr ""
"이러한 원시 타입을 결합하여 더 복잡한 타입을 만들 수 있습니다. 곧 배우게 되실"
"겁니다."

#: src/02_basic_calculator/01_integers.md:15
msgid "`u32`, in particular, is an **unsigned 32-bit integer**."
msgstr "`u32`는 **부호 없는 32비트 정수**입니다."

#: src/02_basic_calculator/01_integers.md:17
msgid ""
"An integer is a number that can be written without a fractional component. E."
"g. `1` is an integer, while `1.2` is not."
msgstr ""
"정수는 분수없이 나타낼 수 있는 숫자입니다. 예: '1'은 정수이지만 '1.2'는 정수"
"가 아닙니다."

#: src/02_basic_calculator/01_integers.md:19
msgid "Signed vs. unsigned"
msgstr "Signed vs. unsigned"

#: src/02_basic_calculator/01_integers.md:21
msgid ""
"An integer can be **signed** or **unsigned**.  \n"
"An unsigned integer can only represent non-negative numbers (i.e. `0` or "
"greater). A signed integer can represent both positive and negative numbers "
"(e.g. `-1`, `12`, etc.)."
msgstr ""
"정수는 **signed** 또는 **unsigned**일 수 있습니다.  \n"
"부호 없는 정수는 음수가 아닌 숫자(예: '0' 이상)만 나타낼 수 있습니다. 부호 있"
"는 정수는 양수와 음수를 모두 나타낼 수 있습니다(예: '-1', '12' 등)."

#: src/02_basic_calculator/01_integers.md:25
msgid ""
"The `u` in `u32` stands for **unsigned**.  \n"
"The equivalent type for signed integer is `i32`, where the `i` stands for "
"integer (i.e. any integer, positive or negative)."
msgstr ""
"`u32`의 `u`는 **unsigned**를 의미합니다.  \n"
"부호 있는 정수에 해당하는 유형은 'i32'입니다. 여기서 'i'는 정수(예: 양수 또는 "
"음수)를 나타냅니다."

#: src/02_basic_calculator/01_integers.md:29
#: src/02_basic_calculator/01_integers.md:48
msgid "Bit width"
msgstr "비트 폭"

#: src/02_basic_calculator/01_integers.md:31
msgid ""
"The `32` in `u32` refers to the **number of bits[^bit]** used to represent "
"the number in memory.  \n"
"The more bits, the larger the range of numbers that can be represented."
msgstr ""
"'u32'의 '32'는 메모리의 숫자를 나타내는 데 사용되는 **비트 수[^bit]**를 나타냅"
"니다.  \n"
"비트가 많을수록 표현할 수 있는 숫자의 범위가 커집니다."

#: src/02_basic_calculator/01_integers.md:34
msgid ""
"Rust supports multiple bit widths for integers: `8`, `16`, `32`, `64`, `128`."
msgstr ""
"Rust는 정수에 대해 `8`, `16`, `32`, `64`, `128`과 같은 다중 비트 너비를 지원합"
"니다."

#: src/02_basic_calculator/01_integers.md:36
msgid ""
"With 32 bits, `u32` can represent numbers from `0` to `2^32 - 1` (a.k.a. "
"[`u32::MAX`](https://doc.rust-lang.org/std/primitive.u32."
"html#associatedconstant.MAX)).  \n"
"With the same number of bits, a signed integer (`i32`) can represent numbers "
"from `-2^31` to `2^31 - 1` (i.e. from [`i32::MIN`](https://doc.rust-lang.org/"
"std/primitive.i32.html#associatedconstant.MIN) to [`i32::MAX`](https://doc."
"rust-lang.org/std/primitive.i32.html#associatedconstant.MAX)).  \n"
"The maximum value for `i32` is smaller than the maximum value for `u32` "
"because one bit is used to represent the sign of the number. Check out the "
"[two's complement](https://en.wikipedia.org/wiki/Two%27s_complement) "
"representation for more details on how signed integers are represented in "
"memory."
msgstr ""
"32비트를 사용하면 `u32`는 `0`부터 `2^32 - 1`(즉, [`u32::MAX`](https://doc."
"rust-lang.org/std/primitive.u32.html#associatedconstant.MAX))까지의 숫자를 나"
"타낼 수 있습니다.  \n"
"동일한 비트 수를 사용하여 부호 있는 정수(`i32`)는 `-2^31`부터 `2^31 - 1`까지"
"(즉, [`i32::MIN`](https://doc.rust-lang.org/std/primitive.i32."
"html#associatedconstant.MIN)부터 [`i32::MAX`](https://doc.rust-lang.org/std/"
"primitive.i32.html#associatedconstant.MAX)까지)의 숫자를 나타낼 수 있습니"
"다.  \n"
"'i32'의 최대값은 'u32'의 최대값보다 작습니다. 1비트가 숫자의 부호를 나타내는 "
"데 사용되기 때문입니다. 부호 있는 정수가 메모리에 어떻게 표현되는지에 대한 자"
"세한 내용은 [2의 보수](https://en.wikipedia.org/wiki/Two%27s_complement)를 확"
"인하세요."

#: src/02_basic_calculator/01_integers.md:46
msgid ""
"Combining the two variables (signed/unsigned and bit width), we get the "
"following integer types:"
msgstr ""
"두 변수(signed/unsigned와 비트 폭)를 결합하면 다음과 같은 정수 유형을 얻을 수 "
"있습니다:"

#: src/02_basic_calculator/01_integers.md:48
msgid "Signed"
msgstr "Signed"

#: src/02_basic_calculator/01_integers.md:48
msgid "Unsigned"
msgstr "Unsigned"

#: src/02_basic_calculator/01_integers.md:50
msgid "8-bit"
msgstr "8-bit"

#: src/02_basic_calculator/01_integers.md:50
msgid "`i8`"
msgstr "`i8`"

#: src/02_basic_calculator/01_integers.md:50
msgid "`u8`"
msgstr "`u8`"

#: src/02_basic_calculator/01_integers.md:51
msgid "16-bit"
msgstr "16-bit"

#: src/02_basic_calculator/01_integers.md:51
msgid "`i16`"
msgstr "`i16`"

#: src/02_basic_calculator/01_integers.md:51
msgid "`u16`"
msgstr "`u16`"

#: src/02_basic_calculator/01_integers.md:52
msgid "32-bit"
msgstr "32-bit"

#: src/02_basic_calculator/01_integers.md:52
msgid "`i32`"
msgstr "`i32`"

#: src/02_basic_calculator/01_integers.md:52
msgid "`u32`"
msgstr "`u32`"

#: src/02_basic_calculator/01_integers.md:53
msgid "64-bit"
msgstr "64-bit"

#: src/02_basic_calculator/01_integers.md:53
msgid "`i64`"
msgstr "`i64`"

#: src/02_basic_calculator/01_integers.md:53
msgid "`u64`"
msgstr "`u64`"

#: src/02_basic_calculator/01_integers.md:54
msgid "128-bit"
msgstr "128-bit"

#: src/02_basic_calculator/01_integers.md:54
msgid "`i128`"
msgstr "`i128`"

#: src/02_basic_calculator/01_integers.md:54
msgid "`u128`"
msgstr "`u128`"

#: src/02_basic_calculator/01_integers.md:56
msgid "Literals"
msgstr "리터럴"

#: src/02_basic_calculator/01_integers.md:58
msgid ""
"A **literal** is a notation for representing a fixed value in source code.  \n"
"For example, `42` is a Rust literal for the number forty-two."
msgstr ""
"**리터럴**은 소스 코드에서 고정된 값을 나타내는 표기법입니다.  \n"
"예를 들어 '42'는 숫자 42에 대한 Rust 리터럴입니다."

#: src/02_basic_calculator/01_integers.md:61
msgid "Type annotations for literals"
msgstr "타입 어노테이션 리터럴"

#: src/02_basic_calculator/01_integers.md:63
msgid "But all values in Rust have a type, so... what's the type of `42`?"
msgstr ""
"하지만 Rust의 모든 값에는 유형이 있습니다. 그렇다면... '42'의 타입은 무엇일까"
"요?"

#: src/02_basic_calculator/01_integers.md:65
msgid ""
"The Rust compiler will try to infer the type of a literal based on how it's "
"used.  \n"
"If you don't provide any context, the compiler will default to `i32` for "
"integer literals.  \n"
"If you want to use a different type, you can add the desired integer type as "
"a suffix—e.g. `2u64` is a 2 that's explicitly typed as a `u64`."
msgstr ""
"Rust 컴파일러는 리터럴이 사용되는 방식에 따라 리터럴의 타입을 추론하려고 시도"
"합니다.  \n"
"컨텍스트를 제공하지 않으면 컴파일러는 정수 리터럴에 대해 기본적으로 `i32`를 사"
"용합니다.  \n"
"다른 타입을 사용하려면 원하는 정수 타입을 접미사로 추가할 수 있습니다. "
"'2u64'는 명시적으로 'u64'라고 정해진 2입니다."

#: src/02_basic_calculator/01_integers.md:70
msgid "Underscores in literals"
msgstr "리터럴에서의 밑줄"

#: src/02_basic_calculator/01_integers.md:72
msgid ""
"You can use underscores `_` to improve the readability of large numbers.  \n"
"For example, `1_000_000` is the same as `1000000`."
msgstr ""
"밑줄 '_'을 사용하면 큰 숫자의 가독성을 높일 수 있습니다.  \n"
"예를 들어 '1_000_000'은 '1000000'과 동일합니다."

#: src/02_basic_calculator/01_integers.md:75
msgid "Arithmetic operators"
msgstr "산술 연산자"

#: src/02_basic_calculator/01_integers.md:77
msgid "Rust supports the following arithmetic operators[^traits] for integers:"
msgstr "Rust는 정수에 대해 다음과 같은 산술 연산자[^traits]를 지원합니다:"

#: src/02_basic_calculator/01_integers.md:79
msgid "`+` for addition"
msgstr "`+` 더하기"

#: src/02_basic_calculator/01_integers.md:80
msgid "`-` for subtraction"
msgstr "`-` 빼기"

#: src/02_basic_calculator/01_integers.md:81
msgid "`*` for multiplication"
msgstr "`*` 곱하기"

#: src/02_basic_calculator/01_integers.md:82
msgid "`/` for division"
msgstr "`/` 나누기"

#: src/02_basic_calculator/01_integers.md:83
msgid "`%` for remainder"
msgstr "`%` 나머지"

#: src/02_basic_calculator/01_integers.md:85
msgid ""
"Precedence and associativity rules for these operators are the same as in "
"mathematics.  \n"
"You can use parentheses to override the default precedence. E.g. `2 * (3 + "
"4)`."
msgstr ""
"이러한 연산자의 우선순위 및 결합성 규칙은 수학과 동일합니다.  \n"
"괄호를 사용하여 기본 우선 순위를 재정의할 수 있습니다. 예: `2 * (3 + 4)`."

#: src/02_basic_calculator/01_integers.md:88
msgid "⚠️ **Warning**"
msgstr "⚠️ **경고**"

#: src/02_basic_calculator/01_integers.md:90
msgid ""
"The division operator `/` performs integer division when used with integer "
"types. I.e. the result is truncated towards zero. For example, `5 / 2` is "
"`2`, not `2.5`."
msgstr ""
"나누기 연산자 '/'는 정수 유형과 함께 사용될 때 정수 나누기를 수행합니다. 즉. "
"결과는 0쪽으로 잘립니다. 예를 들어 '5/2'는 '2.5'가 아니라 '2'입니다."

#: src/02_basic_calculator/01_integers.md:93
msgid "No automatic type coercion"
msgstr "자동 타입 변환 없음"

#: src/02_basic_calculator/01_integers.md:95
msgid ""
"As we discussed in the previous exercise, Rust is a statically typed "
"language.  \n"
"In particular, Rust is quite strict about type coercion. It won't "
"automatically convert a value from one type to another[^coercion], even if "
"the conversion is lossless. You have to do it explicitly."
msgstr ""
"이전 연습에서 논의한 것처럼 Rust는 정적으로 타입이 지정된 언어입니다.  \n"
"특히 Rust는 타입 강제에 대해 상당히 엄격합니다. 타입 변환이 무손실이더라도 자"
"동으로 값을 한 타입에서 다른 타입으로 변환[^coercion]하지 않습니다. 명시적으"
"로 해야 합니다."

#: src/02_basic_calculator/01_integers.md:100
msgid ""
"For example, you can't assign a `u8` value to a variable with type `u32`, "
"even though all `u8` values are valid `u32` values:"
msgstr ""
"예를 들어, 모든 `u8` 값이 유효한 `u32` 값이더라도 `u32` 타입에 `u8`타입의 값"
"을 할당할 수 없습니다:"

#: src/02_basic_calculator/01_integers.md:108
msgid "It'll throw a compilation error:"
msgstr "컴파일 오류가 발생합니다:"

#: src/02_basic_calculator/01_integers.md:120
msgid ""
"We'll see how to convert between types [later in this course]"
"(../04_traits/09_from.md)."
msgstr ""
"[이 코스의 뒷부분](../04_traits/09_from.md)에서 타입 간 변환 방법을 살펴보겠습"
"니다."

#: src/02_basic_calculator/01_integers.md:122
#: src/02_basic_calculator/04_panics.md:44
#: src/02_basic_calculator/06_while.md:83 src/02_basic_calculator/07_for.md:57
#: src/02_basic_calculator/08_overflow.md:103
#: src/02_basic_calculator/10_as_casting.md:97
#: src/03_ticket_v1/02_validation.md:18 src/04_traits/02_orphan_rule.md:108
#: src/04_traits/04_derive.md:100 src/05_ticket_v2/15_outro.md:15
#: src/06_ticket_management/07_combinators.md:103
#: src/07_threads/02_static.md:112 src/07_threads/11_locks.md:218
#: src/08_futures/05_blocking.md:76 src/08_futures/07_cancellation.md:101
msgid "Further reading"
msgstr "읽을거리"

#: src/02_basic_calculator/01_integers.md:124
msgid ""
"[The integer types section](https://doc.rust-lang.org/book/ch03-02-data-types."
"html#integer-types) in the official Rust book"
msgstr ""
"공식 Rust book의 [정수 타입 섹션](https://doc.rust-lang.org/book/ch03-02-data-"
"types.html#integer-types)"

#: src/02_basic_calculator/01_integers.md:126
msgid ""
"A bit is the smallest unit of data in a computer. It can only have two "
"values: `0` or `1`."
msgstr ""
"비트는 컴퓨터의 가장 작은 데이터 단위입니다. '0' 또는 '1'의 두 가지 값만 가질 "
"수 있습니다."

#: src/02_basic_calculator/01_integers.md:128
msgid ""
"Rust doesn't let you define custom operators, but it puts you in control of "
"how the built-in operators behave. We'll talk about operator overloading "
"[later in the course](../04_traits/03_operator_overloading.md), after we've "
"covered traits."
msgstr ""
"Rust에서는 사용자 정의 연산자를 정의할 수 없지만 내장 연산자의 작동 방식을 제"
"어할 수 있습니다. 나중에 Trait에 대해 다룬 후 연산자 오버로딩에 대해 설명하겠"
"습니다."

#: src/02_basic_calculator/01_integers.md:132
msgid ""
"There are some exceptions to this rule, mostly related to references, smart "
"pointers and ergonomics. We'll cover those [later on](../04_traits/07_deref."
"md). A mental model of \"all conversions are explicit\" will serve you well "
"in the meantime."
msgstr ""
"이 규칙에는 주로 참조, 스마트 포인터 및 인체 공학과 관련된 몇 가지 예외가 있습"
"니다. 이에 대해서는 [나중에](../04_traits/07_deref.md) 다루겠습니다. 그 전까지"
"는 \"모든 타입 변환이 명시적\"이라는 정신이 도움이 될 것입니다."

#: src/02_basic_calculator/01_integers.md:138
msgid ""
"The exercise for this section is located in "
"[`02_basic_calculator/01_integers`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/01_integers)"
msgstr ""
"이 섹션의 예제는 [`02_basic_calculator/01_integers`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/01_integers)에 있습니다"

#: src/02_basic_calculator/02_variables.md:3
msgid ""
"In Rust, you can use the `let` keyword to declare **variables**.  \n"
"For example:"
msgstr ""
"Rust에서는 `let` 키워드를 사용하여 **변수**를 선언할 수 있습니다.  \n"
"예시:"

#: src/02_basic_calculator/02_variables.md:10
msgid "Above we defined a variable `x` and assigned it the value `42`."
msgstr "위에서는 변수 `x`를 정의하고 값 `42`를 할당했습니다."

#: src/02_basic_calculator/02_variables.md:12
msgid "Type"
msgstr "타입"

#: src/02_basic_calculator/02_variables.md:14
msgid ""
"Every variable in Rust must have a type. It can either be inferred by the "
"compiler or explicitly specified by the developer."
msgstr ""
"Rust의 모든 변수에는 타입이 있어야 합니다. 이는 컴파일러에 의해 유추되거나 개"
"발자가 명시적으로 지정할 수 있습니다."

#: src/02_basic_calculator/02_variables.md:17
msgid "Explicit type annotation"
msgstr "명시적 타입 어노테이션"

#: src/02_basic_calculator/02_variables.md:19
msgid ""
"You can specify the variable type by adding a colon `:` followed by the type "
"after the variable name. For example:"
msgstr ""
"변수 이름 뒤에 콜론 `:`을 추가하고 타입을 추가하여 변수 타입을 지정할 수 있습"
"니다. 예시:"

#: src/02_basic_calculator/02_variables.md:22
msgid "// let <variable_name>: <type> = <expression>;\n"
msgstr "// let <variable_name>: <type> = <expression>;\n"

#: src/02_basic_calculator/02_variables.md:26
msgid ""
"In the example above, we explicitly constrained the type of `x` to be `u32`."
msgstr "위의 예에서는 `x`의 타입을 `u32`로 명시적으로 제한했습니다."

#: src/02_basic_calculator/02_variables.md:28
msgid "Type inference"
msgstr "타입 추론"

#: src/02_basic_calculator/02_variables.md:30
msgid ""
"If we don't specify the type of a variable, the compiler will try to infer it "
"based on the context in which the variable is used."
msgstr ""
"변수 타입을 지정하지 않으면 컴파일러는 변수가 사용되는 컨텍스트를 기반으로 변"
"수 타입을 추론하려고 시도합니다."

#: src/02_basic_calculator/02_variables.md:38
msgid ""
"In the example above, we didn't specify the type of `x`.  \n"
"`x` is later assigned to `y`, which is explicitly typed as `u32`. Since Rust "
"doesn't perform automatic type coercion, the compiler infers the type of `x` "
"to be `u32`—the same as `y` and the only type that will allow the program to "
"compile without errors."
msgstr ""
"위의 예에서는 `x`의 타입을 지정하지 않았습니다.  \n"
"`x`는 나중에 명시적으로 `u32`로 입력되는 `y`에 할당됩니다. Rust는 자동 타입 강"
"제 변환을 수행하지 않기 때문에 컴파일러는 `x`의 타입을 `u32`로 추론합니다. 이"
"는 `y`와 동일하고 프로그램이 오류 없이 컴파일할 수 있게 해주는 유일한 타입입니"
"다."

#: src/02_basic_calculator/02_variables.md:43
msgid "Inference limitations"
msgstr "추론의 한계"

#: src/02_basic_calculator/02_variables.md:45
msgid ""
"The compiler sometimes needs a little help to infer the correct variable type "
"based on its usage.  \n"
"In those cases you'll get a compilation error and the compiler will ask you "
"to provide an explicit type hint to disambiguate the situation."
msgstr ""
"컴파일러는 사용법에 따라 올바른 변수 타입을 유추하기 위해 약간의 도움이 필요"
"한 경우가 있습니다.  \n"
"이러한 경우 컴파일 오류가 발생하고 컴파일러는 상황을 명확하게 하기 위해 명시적"
"인 타입 힌트를 제공하도록 요청합니다."

#: src/02_basic_calculator/02_variables.md:49
msgid "Function arguments are variables"
msgstr "함수 인수는 변수입니다"

#: src/02_basic_calculator/02_variables.md:51
msgid ""
"Not all heroes wear capes, not all variables are declared with `let`.  \n"
"Function arguments are variables too!"
msgstr ""
"모든 영웅이 망토를 입는 것은 아니며, 모든 변수가 `let`으로 선언되는 것은 아닙"
"니다.  \n"
"함수 인수도 변수입니다!"

#: src/02_basic_calculator/02_variables.md:60
msgid ""
"In the example above, `x` is a variable of type `u32`.  \n"
"The only difference between `x` and a variable declared with `let` is that "
"functions arguments **must** have their type explicitly declared. The "
"compiler won't infer it for you.  \n"
"This constraint allows the Rust compiler (and us humans!) to understand the "
"function's signature without having to look at its implementation. That's a "
"big boost for compilation speed[^speed]!"
msgstr ""
"위의 예에서 `x`는 `u32` 타입의 변수입니다.  \n"
"`x`와 `let`으로 선언된 변수의 유일한 차이점은 함수 인수 **반드시** 해당 타입"
"이 명시적으로 선언되어야 한다는 것입니다. 컴파일러는 이를 추론하지 않습니"
"다.  \n"
"이 제약은 Rust 컴파일러(그리고 우리 인간도!)가 구현을 살펴보지 않고도 함수의 "
"시그니처를 이해할 수 있게 해줍니다. 이는 컴파일 속도[^speed]를 크게 향상시킵니"
"다!"

#: src/02_basic_calculator/02_variables.md:66
msgid "Initialization"
msgstr "초기화"

#: src/02_basic_calculator/02_variables.md:68
msgid ""
"You don't have to initialize a variable when you declare it.  \n"
"For example"
msgstr ""
"변수를 선언할 때 변수를 초기화할 필요는 없습니다.  \n"
"예를 들어"

#: src/02_basic_calculator/02_variables.md:75
msgid ""
"is a valid variable declaration.  \n"
"However, you must initialize the variable before using it. The compiler will "
"throw an error if you don't:"
msgstr ""
"유효한 변수 선언입니다.  \n"
"그러나 변수를 사용하기 전에 초기화해야 합니다. 다음을 수행하지 않으면 컴파일러"
"에서 오류가 발생합니다:"

#: src/02_basic_calculator/02_variables.md:83
msgid "will throw a compilation error:"
msgstr "컴파일 오류가 발생합니다:"

#: src/02_basic_calculator/02_variables.md:100
msgid ""
"The Rust compiler needs all the help it can get when it comes to compilation "
"speed."
msgstr "Rust 컴파일러는 컴파일 속도를 위한 어떤 도움이라도 필요로합니다."

#: src/02_basic_calculator/02_variables.md:104
msgid ""
"The exercise for this section is located in "
"[`02_basic_calculator/02_variables`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/02_variables)"
msgstr ""
"이 섹션의 예제는 [`02_basic_calculator/02_variables`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/02_variables)에 있습니다"

#: src/02_basic_calculator/03_if_else.md:1
msgid "Control flow, part 1"
msgstr "흐름 제어, part 1"

#: src/02_basic_calculator/03_if_else.md:3
msgid ""
"All our programs so far have been pretty straightforward.  \n"
"A sequence of instructions is executed from top to bottom, and that's it."
msgstr ""
"지금까지 우리의 모든 프로그램은 매우 간단했습니다.  \n"
"일련의 명령이 위에서 아래로 실행됩니다."

#: src/02_basic_calculator/03_if_else.md:6
msgid "It's time to introduce some **branching**."
msgstr "이제 몇 가지 **분기**를 소개할 시간입니다."

#: src/02_basic_calculator/03_if_else.md:8
msgid "`if` clauses"
msgstr "`if` 문"

#: src/02_basic_calculator/03_if_else.md:10
msgid ""
"The `if` keyword is used to execute a block of code only if a condition is "
"true."
msgstr "`if` 키워드는 조건이 참인 경우에만 코드 블록을 실행하는 데 사용됩니다."

#: src/02_basic_calculator/03_if_else.md:12
msgid "Here's a simple example:"
msgstr "간단한 예는 다음과 같습니다:"

#: src/02_basic_calculator/03_if_else.md:17
#: src/02_basic_calculator/03_if_else.md:33
msgid "\"`number` is smaller than 5\""
msgstr "\"`number` is smaller than 5\""

#: src/02_basic_calculator/03_if_else.md:21
msgid ""
"This program will print `number is smaller than 5` because the condition "
"`number < 5` is true."
msgstr ""
"이 프로그램은 `number < 5` 조건이 true이기 때문에 `number is less than 5`를 프"
"린트합니다."

#: src/02_basic_calculator/03_if_else.md:23
msgid "`else` clauses"
msgstr "`else` 문"

#: src/02_basic_calculator/03_if_else.md:25
msgid ""
"Like most programming languages, Rust supports an optional `else` branch to "
"execute a block of code when the condition in an `if` expression is false.  \n"
"For example:"
msgstr ""
"대부분의 프로그래밍 언어와 마찬가지로 Rust는 `if` 표현식의 조건이 거짓일 때 코"
"드 블록을 실행하기 위한 선택적인 `else` 분기를 지원합니다.  \n"
"예시:"

#: src/02_basic_calculator/03_if_else.md:35
msgid "\"`number` is greater than or equal to 5\""
msgstr "\"`number` is greater than or equal to 5\""

#: src/02_basic_calculator/03_if_else.md:39
msgid "Booleans"
msgstr "불리언"

#: src/02_basic_calculator/03_if_else.md:41
msgid ""
"The condition in an `if` expression must be of type `bool`, a **boolean**.  \n"
"Booleans, just like integers, are a primitive type in Rust."
msgstr ""
"`if` 표현식의 조건은 `bool` 타입의 **불리언**이어야 합니다.  \n"
"정수와 마찬가지로 불리언도 Rust의 원시 타입입니다."

#: src/02_basic_calculator/03_if_else.md:44
msgid "A boolean can have one of two values: `true` or `false`."
msgstr "불리언은 `true` 또는 `false`라는 두 가지 값 중 하나를 가질 수 있습니다."

#: src/02_basic_calculator/03_if_else.md:46
msgid "No truthy or falsy values"
msgstr "참 혹은 거짓이 아닌 경ㅇ"

#: src/02_basic_calculator/03_if_else.md:48
msgid ""
"If the condition in an `if` expression is not a boolean, you'll get a "
"compilation error."
msgstr "`if` 표현식의 조건이 불리언이 아닌 경우 컴파일 오류가 발생합니다."

#: src/02_basic_calculator/03_if_else.md:50
msgid "For example, the following code will not compile:"
msgstr "예를 들어 다음 코드는 컴파일되지 않습니다:"

#: src/02_basic_calculator/03_if_else.md:55
msgid "\"`number` is not zero\""
msgstr "\"`number` is not zero\""

#: src/02_basic_calculator/03_if_else.md:59
msgid "You'll get the following compilation error:"
msgstr "다음과 같은 컴파일 오류가 발생합니다:"

#: src/02_basic_calculator/03_if_else.md:69
msgid ""
"This follows from Rust's philosophy around type coercion: there's no "
"automatic conversion from non-boolean types to booleans. Rust doesn't have "
"the concept of **truthy** or **falsy** values, like JavaScript or Python.  \n"
"You have to be explicit about the condition you want to check."
msgstr ""
"이는 타입 강제에 관한 Rust의 철학을 따른 것입니다. 즉, 불리언이 아닌 타입에서 "
"불리언으로의 자동 변환은 없습니다. Rust에는 JavaScript나 Python처럼 **참** 또"
"는 **거짓** 값이라는 개념이 없습니다.  \n"
"확인하려는 조건에 대해 명시적으로 설명해야 합니다."

#: src/02_basic_calculator/03_if_else.md:75
msgid ""
"It's quite common to use comparison operators to build conditions for `if` "
"expressions.  \n"
"Here are the comparison operators available in Rust when working with "
"integers:"
msgstr ""
"`if` 표현식의 조건을 작성하기 위해 비교 연산자를 사용하는 것은 매우 일반적입니"
"다.  \n"
"정수로 작업할 때 Rust에서 사용할 수 있는 비교 연산자는 다음과 같습니다:"

#: src/02_basic_calculator/03_if_else.md:78
msgid "`==`: equal to"
msgstr "`==`: 같음"

#: src/02_basic_calculator/03_if_else.md:79
msgid "`!=`: not equal to"
msgstr "`!=`: 같지 않음"

#: src/02_basic_calculator/03_if_else.md:80
msgid "`<`: less than"
msgstr "`<`: 미만"

#: src/02_basic_calculator/03_if_else.md:81
msgid "`>`: greater than"
msgstr "`>`: 초과"

#: src/02_basic_calculator/03_if_else.md:82
msgid "`<=`: less than or equal to"
msgstr "`<=`: 작거나 같음"

#: src/02_basic_calculator/03_if_else.md:83
msgid "`>=`: greater than or equal to"
msgstr "`>=`: 크거나 같음"

#: src/02_basic_calculator/03_if_else.md:85
msgid "`if/else` is an expression"
msgstr "`if/else`는 표현식입니다"

#: src/02_basic_calculator/03_if_else.md:87
msgid ""
"In Rust, `if` expressions are **expressions**, not statements: they return a "
"value.  \n"
"That value can be assigned to a variable or used in other expressions. For "
"example:"
msgstr ""
"Rust에서 `if` 표현식은 명령문이 아닌 **표현식**입니다. 즉, 값을 반환합니"
"다.  \n"
"해당 값은 변수에 할당되거나 다른 표현식에 사용될 수 있습니다. 예시:"

#: src/02_basic_calculator/03_if_else.md:93
msgid "\"smaller than 5\""
msgstr "\"smaller than 5\""

#: src/02_basic_calculator/03_if_else.md:95
msgid "\"greater than or equal to 5\""
msgstr "\"greater than or equal to 5\""

#: src/02_basic_calculator/03_if_else.md:99
msgid ""
"In the example above, each branch of the `if` evaluates to a string literal, "
"which is then assigned to the `message` variable.  \n"
"The only requirement is that both `if` branches return the same type."
msgstr ""
"위의 예에서 `if`의 각 분기는 문자열 리터럴로 평가된 다음 `message` 변수에 할당"
"됩니다.  \n"
"유일한 요구 사항은 두 `if` 분기가 동일한 타입을 반환한다는 것입니다."

#: src/02_basic_calculator/03_if_else.md:105
msgid ""
"The exercise for this section is located in [`02_basic_calculator/03_if_else`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/03_if_else)"
msgstr ""
"이 섹션의 예제는 [`02_basic_calculator/03_if_else`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/03_if_else)에 있습니다"

#: src/02_basic_calculator/04_panics.md:3
msgid ""
"Let's go back to the `speed` function you wrote for the [\"Variables\" "
"section](02_variables.md). It probably looked something like this:"
msgstr ""
"[\"변수\" 섹션](02_variables.md)에 작성한 `speed` 함수로 돌아가 보겠습니다. 아"
"마도 다음과 같았을 것입니다:"

#: src/02_basic_calculator/04_panics.md:13
msgid ""
"If you have a keen eye, you might have spotted one issue[^one]: what happens "
"if `time_elapsed` is zero?"
msgstr ""
"예리한 눈을 갖고 계시다면 한 가지 문제를 발견하셨을 것입니다[^one]: "
"`time_elapsed`가 0이면 어떻게 될까요?"

#: src/02_basic_calculator/04_panics.md:15
msgid ""
"You can try it out [on the Rust playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=36e5ddbe3b3f741dfa9f74c956622bac)!  \n"
"The program will exit with the following error message:"
msgstr ""
"[Rust playground에서](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=36e5ddbe3b3f741dfa9f74c956622bac) "
"해 볼 수 있습니다!  \n"
"프로그램은 다음 오류 메시지와 함께 종료됩니다:"

#: src/02_basic_calculator/04_panics.md:24
msgid ""
"This is known as a **panic**.  \n"
"A panic is Rust's way to signal that something went so wrong that the program "
"can't continue executing, it's an **unrecoverable error**[^catching]. "
"Division by zero classifies as such an error."
msgstr ""
"이를 **패닉**이라고 합니다.  \n"
"패닉은 무언가 잘못되어 프로그램이 계속 실행될 수 없음을 알리는 Rust의 방법입니"
"다. 이는 **복구할 수 없는 오류**[^catching]입니다. 0으로 나누는 것은 이러한 오"
"류로 분류됩니다."

#: src/02_basic_calculator/04_panics.md:29
msgid "The panic! macro"
msgstr "panic! 매크로"

#: src/02_basic_calculator/04_panics.md:31
msgid ""
"You can intentionally trigger a panic by calling the `panic!` macro[^macro]:"
msgstr ""
"`panic!` 매크로[^macro]를 호출하여 의도적으로 패닉을 유발할 수 있습니다:"

#: src/02_basic_calculator/04_panics.md:35
msgid "\"This is a panic!\""
msgstr "\"This is a panic!\""

#: src/02_basic_calculator/04_panics.md:36
msgid "// The line below will never be executed\n"
msgstr "// 아래 줄은 절대 실행되지 않습니다\n"

#: src/02_basic_calculator/04_panics.md:41
msgid ""
"There are other mechanisms to work with recoverable errors in Rust, which "
"[we'll cover later](../05_ticket_v2/06_fallibility.md). For the time being "
"we'll stick with panics as a brutal but simple stopgap solution."
msgstr ""
"Rust에는 복구 가능한 오류를 처리하는 다른 메커니즘이 있는데, 이에 대해서는 [나"
"중에 다루겠습니다](../05_ticket_v2/06_fallibility.md). 당분간 우리는 무식하지"
"만 간단한 임시방편으로 패닉을 고수할 것입니다."

#: src/02_basic_calculator/04_panics.md:46
msgid ""
"[The panic! macro documentation](https://doc.rust-lang.org/std/macro.panic."
"html)"
msgstr "[panic! 매크로 문서](https://doc.rust-lang.org/std/macro.panic.html)"

#: src/02_basic_calculator/04_panics.md:48
msgid ""
"There's another issue with `speed` that we'll address soon enough. Can you "
"spot it?"
msgstr ""
"우리가 곧 다루게 될 `speed` 와 관련된 또 다른 문제가 있습니다. 발견하셨나요?"

#: src/02_basic_calculator/04_panics.md:50
msgid ""
"You can try to catch a panic, but it should be a last resort attempt reserved "
"for very specific circumstances."
msgstr ""
"패닉을 catch 시도할 수 있지만 이는 매우 특정한 상황에서의 최후의 수단으로 시도"
"해야합니다."

#: src/02_basic_calculator/04_panics.md:53
msgid ""
"If it's followed by a `!`, it's a macro invocation. Think of macros as spicy "
"functions for now. We'll cover them in more detail later in the course."
msgstr ""
"뒤에 `!`가 오면 매크로 호출입니다. 지금은 매크로를 양념 함수로 생각하세요. 이 "
"코스의 뒷부분에서 이에 대해 더 자세히 다루겠습니다."

#: src/02_basic_calculator/04_panics.md:58
msgid ""
"The exercise for this section is located in [`02_basic_calculator/04_panics`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/04_panics)"
msgstr ""
"이 섹션의 예제는 [`02_basic_calculator/04_panics`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/04_panics)에 있습니다"

#: src/02_basic_calculator/05_factorial.md:3
msgid "So far you've learned:"
msgstr "지금까지 배운 내용:"

#: src/02_basic_calculator/05_factorial.md:5
msgid "How to define a function"
msgstr "함수를 정의하는 방법"

#: src/02_basic_calculator/05_factorial.md:6
msgid "How to call a function"
msgstr "함수를 호출하는 방법"

#: src/02_basic_calculator/05_factorial.md:7
msgid "Which integer types are available in Rust"
msgstr "Rust에서 사용할 수 있는 정수 타입"

#: src/02_basic_calculator/05_factorial.md:8
msgid "Which arithmetic operators are available for integers"
msgstr "정수에 사용할 수 있는 산술 연산자"

#: src/02_basic_calculator/05_factorial.md:9
msgid ""
"How to execute conditional logic via comparisons and `if`/`else` expressions"
msgstr "비교 및 `if`/`else` 표현식을 통해 조건 로직 실행하는 방법"

#: src/02_basic_calculator/05_factorial.md:11
msgid "It looks like you're ready to tackle factorials!"
msgstr "팩토리얼을 다룰 준비가 된 것 같습니다!"

#: src/02_basic_calculator/05_factorial.md:15
msgid ""
"The exercise for this section is located in "
"[`02_basic_calculator/05_factorial`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/05_factorial)"
msgstr ""
"이 섹션의 예제는 [`02_basic_calculator/05_factorial`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/05_factorial)에 있습니다"

#: src/02_basic_calculator/06_while.md:1
msgid "Loops, part 1: `while`"
msgstr "루프, part 1: `while`"

#: src/02_basic_calculator/06_while.md:3
msgid ""
"Your implementation of `factorial` has been forced to use recursion.  \n"
"This may feel natural to you, especially if you're coming from a functional "
"programming background. Or it may feel strange, if you're used to more "
"imperative languages like C or Python."
msgstr ""
"`factorial` 구현에서는 재귀를 사용해야 합니다.  \n"
"이는 특히 함수형 프로그래밍에 대한 배경 지식이 있는 경우 자연스럽게 느껴질 수 "
"있습니다. 또는 C나 Python과 같은 명령형 언어에 익숙하다면 이상하게 느껴질 수"
"도 있습니다."

#: src/02_basic_calculator/06_while.md:7
msgid ""
"Let's see how you can implement the same functionality using a **loop** "
"instead."
msgstr "대신 **루프**를 사용하여 동일한 기능을 구현하는 방법을 살펴보겠습니다."

#: src/02_basic_calculator/06_while.md:9
msgid "The `while` loop"
msgstr "`while` 루프"

#: src/02_basic_calculator/06_while.md:11
msgid ""
"A `while` loop is a way to execute a block of code as long as a **condition** "
"is true.  \n"
"Here's the general syntax:"
msgstr ""
"`while` 루프는 **조건**이 true인 동안 코드 블록을 실행하는 방법입니다.  \n"
"일반적인 문법은 다음과 같습니다:"

#: src/02_basic_calculator/06_while.md:16 src/02_basic_calculator/07_for.md:14
msgid "// code to execute\n"
msgstr "// 실행할 코드\n"

#: src/02_basic_calculator/06_while.md:20
msgid "For example, we might want to sum the numbers from 1 to 5:"
msgstr "예를 들어 1부터 5까지의 숫자를 더하려할 때:"

#: src/02_basic_calculator/06_while.md:24
msgid "// \"while i is less than or equal to 5\"\n"
msgstr "// \"i가 5보다 작거나 같은 동안\"\n"

#: src/02_basic_calculator/06_while.md:27
msgid "// `+=` is a shorthand for `sum = sum + i`\n"
msgstr "// `+=`는 `sum = sum + i`의 약어입니다.\n"

#: src/02_basic_calculator/06_while.md:33
msgid ""
"This will keep adding 1 to `i` and `i` to `sum` until `i` is no longer less "
"than or equal to 5."
msgstr ""
"이는 `i`가 더 이상 5보다 작거나 같지 않을 때까지 `i`에 1을 계속 추가하고 `sum`"
"에 `i`를 추가합니다."

#: src/02_basic_calculator/06_while.md:35
msgid "The `mut` keyword"
msgstr "`mut` 키워드"

#: src/02_basic_calculator/06_while.md:37
msgid "The example above won't compile as is. You'll get an error like:"
msgstr ""
"위의 예는 있는 그대로 컴파일되지 않습니다. 다음과 같은 오류가 발생합니다:"

#: src/02_basic_calculator/06_while.md:65
msgid ""
"This is because variables in Rust are **immutable** by default.  \n"
"You can't change their value once it has been assigned."
msgstr ""
"이는 Rust의 변수가 기본적으로 **immutable**이기 때문입니다.  \n"
"일단 할당된 값은 수저할 수 없습니다."

#: src/02_basic_calculator/06_while.md:68
msgid ""
"If you want to allow modifications, you have to declare the variable as "
"**mutable** using the `mut` keyword:"
msgstr ""
"수정을 허용하려면 `mut` 키워드를 사용하여 변수를 **mutable**으로 선언해야 합니"
"다:"

#: src/02_basic_calculator/06_while.md:71
msgid "// `sum` and `i` are mutable now!\n"
msgstr "// `sum`과 `i`는 이제 수정 가능합니다!\n"

#: src/02_basic_calculator/06_while.md:81
msgid "This will compile and run without errors."
msgstr "그러면 오류 없이 컴파일되고 실행됩니다."

#: src/02_basic_calculator/06_while.md:85
msgid ""
"[`while` loop documentation](https://doc.rust-lang.org/std/keyword.while.html)"
msgstr "[`while` 루프 문서](https://doc.rust-lang.org/std/keyword.while.html)"

#: src/02_basic_calculator/06_while.md:89
msgid ""
"The exercise for this section is located in [`02_basic_calculator/06_while`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/06_while)"
msgstr ""
"이 섹션의 예제는 [`02_basic_calculator/06_while`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/06_while)에 있습니다"

#: src/02_basic_calculator/07_for.md:1
msgid "Loops, part 2: `for`"
msgstr "루프, part 2: `for`"

#: src/02_basic_calculator/07_for.md:3
msgid ""
"Having to manually increment a counter variable is somewhat tedious. The "
"pattern is also extremely common!  \n"
"To make this easier, Rust provides a more concise way to iterate over a range "
"of values: the `for` loop."
msgstr ""
"카운터 변수를 수동으로 증가시키는 것은 다소 지루한 일입니다. 굉장히 흔한 패턴"
"이기도해요!  \n"
"이를 더 쉽게 만들기 위해 Rust는 다양한 값을 반복하는 보다 간결한 방법인 `for` "
"루프를 제공합니다."

#: src/02_basic_calculator/07_for.md:6
msgid "The `for` loop"
msgstr "`for` 루프"

#: src/02_basic_calculator/07_for.md:8
msgid ""
"A `for` loop is a way to execute a block of code for each element in an "
"iterator[^iterator]."
msgstr ""
"`for` 루프는 반복자[^iterator]의 각 요소에 대해 코드 블록을 실행하는 방법입니"
"다."

#: src/02_basic_calculator/07_for.md:10
msgid "Here's the general syntax:"
msgstr "일반적인 문법은 다음과 같습니다:"

#: src/02_basic_calculator/07_for.md:18
msgid "Ranges"
msgstr "범위"

#: src/02_basic_calculator/07_for.md:20
msgid ""
"Rust's standard library provides **range** type that can be used to iterate "
"over a sequence of numbers[^weird-ranges]."
msgstr ""
"Rust의 표준 라이브러리는 일련의 숫자[^weird-ranges]를 반복하는 데 사용할 수 있"
"는 **range** 타입을 제공합니다."

#: src/02_basic_calculator/07_for.md:22
msgid "For example, if we want to sum the numbers from 1 to 5:"
msgstr "예를 들어 1부터 5까지의 합을 구한다면 다음과 같습니다:"

#: src/02_basic_calculator/07_for.md:31
msgid ""
"Every time the loop runs, `i` will be assigned the next value in the range "
"before executing the block of code."
msgstr ""
"루프가 실행될 때마다 `i`에는 코드 블록을 실행하기 전에 범위의 다음 값이 할당됩"
"니다."

#: src/02_basic_calculator/07_for.md:33
msgid "There are five kinds of ranges in Rust:"
msgstr "Rust에는 5가지 종류의 범위가 있습니다:"

#: src/02_basic_calculator/07_for.md:35
msgid ""
"`1..5`: A (half-open) range. It includes all numbers from 1 to 4. It doesn't "
"include the last value, 5."
msgstr ""
"`1..5`: A (half-open) 범위. 여기에는 1부터 4까지의 모든 숫자가 포함됩니다. 마"
"지막 값인 5는 포함되지 않습니다."

#: src/02_basic_calculator/07_for.md:36
msgid ""
"`1..=5`: An inclusive range. It includes all numbers from 1 to 5. It includes "
"the last value, 5."
msgstr ""
"`1..=5`: 포함 범위입니다. 여기에는 1부터 5까지의 모든 숫자가 포함됩니다. 마지"
"막 값인 5도 포함됩니다."

#: src/02_basic_calculator/07_for.md:37
msgid ""
"`1..`: An open-ended range. It includes all numbers from 1 to infinity (well, "
"until the maximum value of the integer type)."
msgstr ""
"`1..`: 개방형 범위입니다. 1부터 무한대(정수형의 최대값까지)까지의 모든 숫자를 "
"포함합니다."

#: src/02_basic_calculator/07_for.md:38
msgid ""
"`..5`: A range that starts at the minimum value for the integer type and ends "
"at 4. It doesn't include the last value, 5."
msgstr ""
"`..5`: 정수형의 최소값에서 시작하여 4로 끝나는 범위입니다. 마지막 값인 5는 포"
"함되지 않습니다."

#: src/02_basic_calculator/07_for.md:39
msgid ""
"`..=5`: A range that starts at the minimum value for the integer type and "
"ends at 5. It includes the last value, 5."
msgstr ""
"`..=5`: 정수형의 최소값에서 시작하여 5로 끝나는 범위. 마지막 값인 5를 포함합니"
"다."

#: src/02_basic_calculator/07_for.md:41
msgid ""
"You can use a `for` loop with the first three kinds of ranges, where the "
"starting point is explicitly specified. The last two range types are used in "
"other contexts, that we'll cover later."
msgstr ""
"시작점이 명시적으로 지정된 처음 세 종류의 범위에 `for` 루프를 사용할 수 있습니"
"다. 마지막 두 가지 범위 타입은 나중에 다루게 될 다른 상황에서 사용됩니다."

#: src/02_basic_calculator/07_for.md:44
msgid ""
"The extreme values of a range don't have to be integer literals—they can be "
"variables or expressions too!"
msgstr ""
"범위의 극단값은 정수 리터럴일 필요는 없습니다—변수나 표현식일 수도 있습니다!"

#: src/02_basic_calculator/07_for.md:46
#: src/02_basic_calculator/10_as_casting.md:12
#: src/03_ticket_v1/06_ownership.md:188 src/04_traits/02_orphan_rule.md:51
#: src/04_traits/09_from.md:55 src/05_ticket_v2/14_source.md:112
#: src/07_threads/01_threads.md:47
msgid "For example:"
msgstr "예시:"

#: src/02_basic_calculator/07_for.md:59
msgid ""
"[`for` loop documentation](https://doc.rust-lang.org/std/keyword.for.html)"
msgstr "[`for` 루프 문서](https://doc.rust-lang.org/std/keyword.for.html)"

#: src/02_basic_calculator/07_for.md:61
msgid ""
"Later in the course we'll give a precise definition of what counts as an "
"\"iterator\". For now, think of it as a sequence of values that you can loop "
"over. [^weird-ranges]: You can use ranges with other types too (e.g. "
"characters and IP addresses), but integers are definitely the most common "
"case in day-to-day Rust programming."
msgstr ""
"이 과정의 후반부에서 \"반복자\"로 간주되는 것이 무엇인지에 대한 정확한 정의를 "
"제공할 것입니다. 지금은 이를 반복할 수 있는 일련의 값으로 생각하세요. [^weird-"
"ranges]: 다른 타입(예: 문자 및 IP 주소)에도 범위를 사용할 수 있지만 일상적인 "
"Rust 프로그래밍에서는 확실히 정수가 가장 일반적인 경우입니다."

#: src/02_basic_calculator/07_for.md:68
msgid ""
"The exercise for this section is located in [`02_basic_calculator/07_for`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/07_for)"
msgstr ""
"이 섹션의 예제는 [`02_basic_calculator/07_for`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/07_for)에 있습니다"

#: src/02_basic_calculator/08_overflow.md:1
msgid "Overflow"
msgstr "오버플로우"

#: src/02_basic_calculator/08_overflow.md:3
msgid ""
"The factorial of a number grows quite fast.  \n"
"For example, the factorial of 20 is 2,432,902,008,176,640,000. That's already "
"bigger than the maximum value for a 32-bit integer, 2,147,483,647."
msgstr ""
"팩토리얼은 매우 빠르게 증가합니다.  \n"
"예를 들어, 팩토리얼 20은 2,432,902,008,176,640,000입니다. 이는 이미 32비트 정"
"수의 최대값인 2,147,483,647보다 큽니다."

#: src/02_basic_calculator/08_overflow.md:7
msgid ""
"When the result of an arithmetic operation is bigger than the maximum value "
"for a given integer type, we are talking about **an integer overflow**."
msgstr ""
"산술 연산의 결과가 주어진 정수 유형의 최대값보다 큰 경우 **정수 오버플로우**"
"에 대해 이야기합니다."

#: src/02_basic_calculator/08_overflow.md:10
msgid ""
"Integer overflows are an issue because they violate the contract for "
"arithmetic operations.  \n"
"The result of an arithmetic operation between two integers of a given type "
"should be another integer of the same type. But the _mathematically correct "
"result_ doesn't fit into that integer type!"
msgstr ""
"정수 오버플로우는 산술 연산 정의를 위반하기 때문에 문제가 됩니다.  \n"
"주어진 타입의 두 정수 사이의 산술 연산 결과는 동일한 타입의 또 다른 정수여야 "
"합니다. 하지만 _수학적으로 올바른 결과_는 해당 정수 타입에 맞지 않습니다!"

#: src/02_basic_calculator/08_overflow.md:14
msgid ""
"If the result is smaller than the minimum value for a given integer type, we "
"refer to the event as **an integer underflow**.  \n"
"For brevity, we'll only talk about integer overflows for the rest of this "
"section, but keep in mind that everything we say applies to integer "
"underflows as well."
msgstr ""
"결과가 특정 정수 유형의 최소값보다 작은 경우 해당 상황을 **정수 언더플로우**라"
"고 합니다.  \n"
"간결하게 하기 위해 이 섹션의 나머지 부분에서는 정수 오버플로우에 대해서만 설명"
"하겠습니다. 하지만 우리가 말하는 모든 내용은 정수 언더플로우에도 적용된다는 점"
"을 명심하세요."

#: src/02_basic_calculator/08_overflow.md:19
msgid ""
"The `speed` function you wrote in the [\"Variables\" section](02_variables."
"md) underflowed for some input combinations. E.g. if `end` is smaller than "
"`start`, `end - start` will underflow the `u32` type since the result is "
"supposed to be negative but `u32` can't represent negative numbers."
msgstr ""
"[\"변수\" 섹션](02_variables.md)에 작성한 `speed`함수는 일부 입력 조합에 대해 "
"언더플로우됩니다. 예: `end`가 `start`보다 작으면 `end - start`는 결과가 음수"
"로 가정되지만 `u32`는 음수를 나타낼 수 없으므로 `u32` 타입으로 언더플로우됩니"
"다."

#: src/02_basic_calculator/08_overflow.md:24
msgid "No automatic promotion"
msgstr "자동 승격 없음"

#: src/02_basic_calculator/08_overflow.md:26
msgid ""
"One possible approach would be automatically promote the result to a bigger "
"integer type. E.g. if you're summing two `u8` integers and the result is 256 "
"(`u8::MAX + 1`), Rust could choose to interpret the result as `u16`, the next "
"integer type that's big enough to hold 256."
msgstr ""
"한 가지 가능한 접근 방식은 결과를 더 큰 정수 타입으로 자동 승격시키는 것입니"
"다. 예: 두 개의 `u8` 정수를 합산하고 그 결과가 256(`u8::MAX + 1`)이라면 Rust"
"는 그 결과를 256을 수용할 만큼 큰 다음 정수 타입인 `u16`으로 해석하도록 선택"
"할 수 있습니다."

#: src/02_basic_calculator/08_overflow.md:30
msgid ""
"But, as we've discussed before, Rust is quite picky about type conversions. "
"Automatic integer promotion is not Rust's solution to the integer overflow "
"problem."
msgstr ""
"그러나 이전에 논의한 것처럼 Rust는 타입 변환에 대해 매우 까다롭습니다. 자동 정"
"수 승격은 정수 오버플로우 문제에 대한 Rust의 솔루션이 아닙니다."

#: src/02_basic_calculator/08_overflow.md:33
msgid "Alternatives"
msgstr "대안"

#: src/02_basic_calculator/08_overflow.md:35
msgid ""
"Since we ruled out automatic promotion, what can we do when an integer "
"overflow occurs?  \n"
"It boils down to two different approaches:"
msgstr ""
"자동 승격을 배제했으므로 정수 오버플로우가 발생하면 어떻게 해야 할까요?  \n"
"이는 두 가지 접근 방식으로 요약됩니다:"

#: src/02_basic_calculator/08_overflow.md:38
#: src/02_basic_calculator/08_overflow.md:41
msgid "Reject the operation"
msgstr "작업 거부"

#: src/02_basic_calculator/08_overflow.md:39
msgid ""
"Come up with a \"sensible\" result that fits into the expected integer type"
msgstr "예상되는 정수 타입에 맞는 \"합리적인\" 결과를 생각해 보세요."

#: src/02_basic_calculator/08_overflow.md:43
msgid ""
"This is the most conservative approach: we stop the program when an integer "
"overflow occurs.  \n"
"That's done via a panic, the mechanism we've already seen in the [\"Panics\" "
"section](04_panics.md)."
msgstr ""
"이것은 가장 보수적인 접근 방식입니다. 정수 오버플로우가 발생하면 프로그램을 중"
"지합니다.  \n"
"이는 [\"패닉\" 섹션](04_panics.md)에서 이미 본 메커니즘인 패닉을 통해 수행됩니"
"다."

#: src/02_basic_calculator/08_overflow.md:46
msgid "Come up with a \"sensible\" result"
msgstr "\"합리적인\" 결과를 내세요"

#: src/02_basic_calculator/08_overflow.md:48
msgid ""
"When the result of an arithmetic operation is bigger than the maximum value "
"for a given integer type, you can choose to **wrap around**.  \n"
"If you think of all the possible values for a given integer type as a circle, "
"wrapping around means that when you reach the maximum value, you start again "
"from the minimum value."
msgstr ""
"산술 연산의 결과가 특정 정수 타입의 최대값보다 큰 경우 **wrap around**를 선택"
"할 수 있습니다.  \n"
"주어진 정수형에 가능한 모든 값을 원으로 생각한다면, wrap around는 최대값에 도"
"달하면 최소값부터 다시 시작한다는 뜻입니다."

#: src/02_basic_calculator/08_overflow.md:53
msgid ""
"For example, if you do a **wrapping addition** between 1 and 255 (=`u8::"
"MAX`), the result is 0 (=`u8::MIN`). If you're working with signed integers, "
"the same principle applies. E.g. adding 1 to 127 (=`i8::MAX`) with wrapping "
"will give you -128 (=`i8::MIN`)."
msgstr ""
"예를 들어, 1과 255(=`u8::MAX`)에 **wrapping addition**를 수행하면 결과는 "
"0(=`u8::MIN`)입니다. 부호 있는 정수로 작업하는 경우에도 동일한 원칙이 적용됩니"
"다. 예: 127(=`i8::MAX`)에 wrapping와 함께 1을 더하면 -128(=`i8::MIN`)이 됩니"
"다."

#: src/02_basic_calculator/08_overflow.md:57
msgid "`overflow-checks`"
msgstr "`오버플로우 검사`"

#: src/02_basic_calculator/08_overflow.md:59
msgid ""
"Rust lets you, the developer, choose which approach to use when an integer "
"overflow occurs. The behaviour is controlled by the `overflow-checks` profile "
"setting."
msgstr ""
"Rust를 사용하면 개발자가 정수 오버플로우가 발생할 때 사용할 접근 방식을 선택"
"할 수 있습니다. 동작은 `overflow-checks` 프로필 설정에 의해 제어됩니다."

#: src/02_basic_calculator/08_overflow.md:62
msgid ""
"If `overflow-checks` is set to `true`, Rust will **panic at runtime** when an "
"integer operation overflows. If `overflow-checks` is set to `false`, Rust "
"will **wrap around** when an integer operation overflows."
msgstr ""
"`overflow-checks`가 `true`로 설정되면 Rust는 정수 연산이 오버플로우될 때 **런"
"타임에 패닉**을 일으킬 것입니다. `overflow-checks`가 `false`로 설정되면 Rust"
"는 정수 연산이 오버플로될 때 **wrap around**합니다."

#: src/02_basic_calculator/08_overflow.md:65
msgid "You may be wondering—what is a profile setting? Let's get into that!"
msgstr "프로필 설정이 무엇인지 궁금하실 겁니다. 그것에 대해 살펴 보겠습니다!"

#: src/02_basic_calculator/08_overflow.md:67
msgid "Profiles"
msgstr "프로필"

#: src/02_basic_calculator/08_overflow.md:69
msgid ""
"A [**profile**](https://doc.rust-lang.org/cargo/reference/profiles.html) is a "
"set of configuration options that can be used to customize the way Rust code "
"is compiled."
msgstr ""
"[**프로필**](https://doc.rust-lang.org/cargo/reference/profiles.html)은 Rust "
"코드가 컴파일되는 방식을 사용자 정의하는 데 사용할 수 있는 구성 옵션 세트입니"
"다."

#: src/02_basic_calculator/08_overflow.md:72
msgid ""
"Cargo provides two built-in profiles: `dev` and `release`.  \n"
"The `dev` profile is used every time you run `cargo build`, `cargo run` or "
"`cargo test`. It's aimed at local development, therefore it sacrifices "
"runtime performance in favor of faster compilation times and a better "
"debugging experience.  \n"
"The `release` profile, instead, is optimized for runtime performance but "
"incurs longer compilation times. You need to explicitly request via the `--"
"release` flag—e.g. `cargo build --release` or `cargo run --release`."
msgstr ""
"Cargo는 `dev`와 `release`라는 두 가지 내장 프로필을 제공합니다.  \n"
"`dev` 프로필은 `cargo build`, `cargo run` 또는 `cargo test`를 실행할 때마다 사"
"용됩니다. 로컬 개발을 목표로 하므로 더 빠른 컴파일 시간과 더 나은 디버깅 환경"
"을 위해 런타임 성능을 희생합니다.  \n"
"대신 `release` 프로필은 런타임 성능에 최적화되어 있지만 컴파일 시간이 더 길어"
"집니다. `--release` 플래그를 통해 명시적으로 요청해야 합니다. `cargo build --"
"release` 또는 `cargo run --release`."

#: src/02_basic_calculator/08_overflow.md:79
msgid ""
"\"Have you built your project in release mode?\" is almost a meme in the Rust "
"community.  \n"
"It refers to developers who are not familiar with Rust and complain about its "
"performance on social media (e.g. Reddit, Twitter, etc.) before realizing "
"they haven't built their project in release mode."
msgstr ""
"\"릴리스 모드에서 프로젝트를 빌드하셨나요?\"라는 말은 Rust 커뮤니티에서 거의 "
"밈이 되었습니다.  \n"
"이는 Rust에 익숙하지 않고 릴리스 모드에서 자신의 프로젝트를 빌드하지 않았다는 "
"사실을 깨닫기도 전에 소셜 미디어(예: Reddit, Twitter 등)에서 Rust의 성능에 대"
"해 불평하는 개발자에게 사용하는 밈입니다."

#: src/02_basic_calculator/08_overflow.md:84
msgid "You can also define custom profiles or customize the built-in ones."
msgstr ""
"사용자 정의 프로필을 정의하거나 기본 제공 프로필을 사용자 정의할 수도 있습니"
"다."

#: src/02_basic_calculator/08_overflow.md:86
msgid "`overflow-check`"
msgstr "`overflow-check`"

#: src/02_basic_calculator/08_overflow.md:88
msgid "By default, `overflow-checks` is set to:"
msgstr "기본적으로 `overflow-checks`는 다음과 같이 설정됩니다:"

#: src/02_basic_calculator/08_overflow.md:90
msgid "`true` for the `dev` profile"
msgstr "`dev` 프로필의 경우 `true`"

#: src/02_basic_calculator/08_overflow.md:91
msgid "`false` for the `release` profile"
msgstr "`release` 프로필의 경우 `false`"

#: src/02_basic_calculator/08_overflow.md:93
msgid ""
"This is in line with the goals of the two profiles.  \n"
"`dev` is aimed at local development, so it panics in order to highlight "
"potential issues as early as possible.  \n"
"`release`, instead, is tuned for runtime performance: checking for overflows "
"would slow down the program, so it prefers to wrap around."
msgstr ""
"이는 두 프로필의 목표와 일치합니다.  \n"
"`dev`는 로컬 개발을 목표로 하기 때문에 잠재적인 문제를 조기에 부각시키기 위해 "
"패닉합니다.  \n"
"반면에 `release`는 런타임 성능에 맞게 조정됩니다. 오버플로우를 확인하면 프로그"
"램 속도가 느려지므로 wrap around를 선호합니다."

#: src/02_basic_calculator/08_overflow.md:98
msgid ""
"At the same time, having different behaviours for the two profiles can lead "
"to subtle bugs.  \n"
"Our recommendation is to enable `overflow-checks` for both profiles: it's "
"better to crash than to silently produce incorrect results. The runtime "
"performance hit is negligible in most cases; if you're working on a "
"performance-critical application, you can run benchmarks to decide if it's "
"something you can afford."
msgstr ""
"동시에 두 프로파일에 대해 다른 동작을 하면 미묘한 버그가 발생할 수 있습니다.\n"
"두 프로파일 모두에서 `overflow-check`를 사용할 수 있도록 하는 것이 좋습니다. "
"조용히 잘못된 결과를 내는 것보다 크래시나는 것이 좋습니다. 런타임 성능 문제는 "
"대부분의 경우 무시할 수 있습니다. 성능이 중요한 애플리케이션을 사용하는 경우 "
"벤치마크를 실행하여 감당 가능한 수준인지 결정할 수 있습니다."

#: src/02_basic_calculator/08_overflow.md:105
msgid ""
"Check out [\"Myths and legends about integer overflow in Rust\"](https://"
"huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-"
"rust/) for an in-depth discussion about integer overflow in Rust."
msgstr ""
"Rust의 정수 오버플로에 대한 심층적인 논의는 [\"Myths and legends about "
"integer overflow in Rust\"](https://huonw.github.io/blog/2016/04/myths-and-"
"legends-about-integer-overflow-in-rust/)을 확인하세요."

#: src/02_basic_calculator/08_overflow.md:110
msgid ""
"The exercise for this section is located in "
"[`02_basic_calculator/08_overflow`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/08_overflow)"
msgstr ""
"이 섹션의 예제는 [`02_basic_calculator/08_overflow`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/08_overflow)에 있습니다"

#: src/02_basic_calculator/09_saturating.md:1
msgid "Case-by-case behavior"
msgstr "사례별 동작"

#: src/02_basic_calculator/09_saturating.md:3
msgid ""
"`overflow-checks` is a blunt tool: it's a global setting that affects the "
"whole program.  \n"
"It often happens that you want to handle integer overflows differently "
"depending on the context: sometimes wrapping is the right choice, other times "
"panicking is preferable."
msgstr ""
"`overflow-checks`는 무뚝뚝한 도구입니다. 전체 프로그램에 영향을 미치는 전역 설"
"정입니다.  \n"
"상황에 따라 정수 오버플로우를 다르게 처리하려는 경우가 종종 있습니다. 때로는 "
"래핑이 올바른 선택이고, 다른 경우에는 패닉이 더 좋습니다."

#: src/02_basic_calculator/09_saturating.md:7
msgid "`wrapping_` methods"
msgstr "`wrapping_` 메소드"

#: src/02_basic_calculator/09_saturating.md:9
msgid ""
"You can opt into wrapping arithmetic on a per-operation basis by using the "
"`wrapping_` methods[^method].  \n"
"For example, you can use `wrapping_add` to add two integers with wrapping:"
msgstr ""
"`wrapping_` 메소드[^method]를 사용하여 연산별로 래핑 산술을 선택할 수 있습니"
"다.  \n"
"예를 들어 `wrapping_add`를 사용하여 래핑으로 두 개의 정수를 더할 수 있습니다:"

#: src/02_basic_calculator/09_saturating.md:19
msgid "`saturating_` methods"
msgstr "`saturating_` 메소드"

#: src/02_basic_calculator/09_saturating.md:21
msgid ""
"Alternatively, you can opt into **saturating arithmetic** by using the "
"`saturating_` methods.  \n"
"Instead of wrapping around, saturating arithmetic will return the maximum or "
"minimum value for the integer type. For example:"
msgstr ""
"또는 `saturating_` 메서드를 사용하여 **포화 산술**을 선택할 수도 있습니다.  \n"
"래핑 대신 포화 산술은 정수 타입의 최대값 또는 최소값을 반환합니다. 예시:"

#: src/02_basic_calculator/09_saturating.md:32
msgid ""
"Since `255 + 1` is `256`, which is bigger than `u8::MAX`, the result is `u8::"
"MAX` (255).  \n"
"The opposite happens for underflows: `0 - 1` is `-1`, which is smaller than "
"`u8::MIN`, so the result is `u8::MIN` (0)."
msgstr ""
"`255 + 1`은 `256`이며 이는 `u8::MAX`보다 크므로 결과는 `u8::MAX` (255)입니"
"다.  \n"
"언더플로우의 경우 반대가 발생합니다. `0 - 1`은 `-1`이며 이는 `u8::MIN`보다 작"
"으므로 결과는 `u8::MIN` (0)입니다."

#: src/02_basic_calculator/09_saturating.md:35
msgid ""
"You can't get saturating arithmetic via the `overflow-checks` profile setting—"
"you have to explicitly opt into it when performing the arithmetic operation."
msgstr ""
"`overflow-checks` 프로필 설정을 통해 포화 산술을 할 수 없습니다. 산술 연산을 "
"수행할 때 이를 명시적으로 선택해야 합니다."

#: src/02_basic_calculator/09_saturating.md:38
msgid ""
"You can think of methods as functions that are \"attached\" to a specific "
"type. We'll cover methods (and how to define them) in the next chapter."
msgstr ""
"메소드를 특정 유형에 \"연결된\" 함수로 생각할 수 있습니다. 다음 장에서는 메서"
"드(그리고 이를 정의하는 방법)를 다룰 것입니다."

#: src/02_basic_calculator/09_saturating.md:43
msgid ""
"The exercise for this section is located in "
"[`02_basic_calculator/09_saturating`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/09_saturating)"
msgstr ""
"이 섹션의 예제는 [`02_basic_calculator/09_saturating`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/09_saturating)에 있습니다"

#: src/02_basic_calculator/10_as_casting.md:1
msgid "Conversions, pt. 1"
msgstr "변환, pt. 1"

#: src/02_basic_calculator/10_as_casting.md:3
msgid ""
"We've repeated over and over again that Rust won't perform implicit type "
"conversions for integers.  \n"
"How do you perform _explicit_ conversions then?"
msgstr ""
"우리는 Rust가 정수에 대해 암묵적인 타입 변환을 수행하지 않는다는 점을 계속해"
"서 반복했습니다.  \n"
"그렇다면 _명시적_ 변환을 어떻게 수행할까요?"

#: src/02_basic_calculator/10_as_casting.md:7
msgid "`as`"
msgstr "`as`"

#: src/02_basic_calculator/10_as_casting.md:9
msgid ""
"You can use the `as` operator to convert between integer types.  \n"
"`as` conversions are **infallible**."
msgstr ""
"`as` 연산자를 사용하여 정수 타입 간에 변환할 수 있습니다.  \n"
"`as` 변환은 **infallible**입니다."

#: src/02_basic_calculator/10_as_casting.md:16
msgid "// Cast `a` into the `u64` type\n"
msgstr "// `a`를 `u64` 타입으로 캐스트\n"

#: src/02_basic_calculator/10_as_casting.md:19
msgid ""
"// You can use `_` as the target type\n"
"// if it can be correctly inferred \n"
"// by the compiler. For example:\n"
msgstr ""
"// 컴파일러가\n"
"// 올바르게 추론할 수 있는 경우\n"
"// `_`를 대상 타입으로 사용할 수 있습니다. 예시:\n"

#: src/02_basic_calculator/10_as_casting.md:26
msgid ""
"The semantics of this conversion are what you expect: all `u32` values are "
"valid `u64` values."
msgstr ""
"이 변환의 의미는 여러분이 예상하는 것과 같습니다. 모든 `u32` 값은 유효한 "
"`u64` 값입니다."

#: src/02_basic_calculator/10_as_casting.md:29
msgid "Truncation"
msgstr "Truncation"

#: src/02_basic_calculator/10_as_casting.md:31
msgid "Things get more interesting if we go in the opposite direction:"
msgstr "반대 방향으로 가면 상황이 더 흥미로워집니다:"

#: src/02_basic_calculator/10_as_casting.md:34
msgid ""
"// A number that's too big \n"
"// to fit into a `u8`\n"
msgstr ""
"// 너무 커서\n"
"// `u8`에 들어갈 수 없는 숫자\n"

#: src/02_basic_calculator/10_as_casting.md:40
msgid ""
"This program will run without issues, because `as` conversions are "
"infallible. But what is the value of `b`? When going from a larger integer "
"type to a smaller, the Rust compiler will perform a **truncation**."
msgstr ""
"`as` 변환에는 오류가 없기 때문에 이 프로그램은 문제 없이 실행됩니다. 그런데 "
"`b`의 값은 무엇입니까? 더 큰 정수 타입에서 더 작은 타입으로 전환할 때 Rust 컴"
"파일러는 **truncation**을 수행합니다."

#: src/02_basic_calculator/10_as_casting.md:45
msgid ""
"To understand what happens, let's start by looking at how `256u16` is "
"represented in memory, as a sequence of bits:"
msgstr ""
"무슨 일이 일어나는지 이해하기 위해 `256u16`이 메모리에 비트 시퀀스로 어떻게 표"
"시되는지부터 살펴보겠습니다:"

#: src/02_basic_calculator/10_as_casting.md:55
msgid ""
"When converting to a `u8`, the Rust compiler will keep the last 8 bits of a "
"`u16` memory representation:"
msgstr ""
"`u8`로 변환할 때 Rust 컴파일러는 `u16` 메모리 표현의 마지막 8비트를 유지합니"
"다:"

#: src/02_basic_calculator/10_as_casting.md:65
msgid ""
"Hence `256 as u8` is equal to `0`. That's... not ideal, in most scenarios.  \n"
"In fact, the Rust compiler will actively try to stop you if it sees you "
"trying to cast a literal value which will result in a truncation:"
msgstr ""
"따라서 `256 as u8`은 `0`과 같습니다. 그건... 대부분의 시나리오에서 이상적이지 "
"않습니다.  \n"
"실제로, Rust 컴파일러는 여러분이 리터럴 값을 캐스팅하려고 시도하는 것을 발견하"
"면 적극적으로 여러분을 막으려고 노력할 것입니다:"

#: src/02_basic_calculator/10_as_casting.md:80
msgid "Recommendation"
msgstr "추천하는 방식"

#: src/02_basic_calculator/10_as_casting.md:82
msgid ""
"As a rule of thumb, be quite careful with `as` casting.  \n"
"Use it _exclusively_ for going from a smaller type to a larger type. To "
"convert from a larger to smaller integer type, rely on the [_fallible_ "
"conversion machinery](../05_ticket_v2/13_try_from.md) that we'll explore "
"later in the course."
msgstr ""
"경험상 `as` 캐스팅할 때는 매우 주의해야 합니다.  \n"
"더 작은 타입에서 더 큰 타입으로 전환하려면 _독점적으로_ 사용하세요. 더 큰 정"
"수 타입에서 더 작은 정수 타입으로 변환하려면 이 과정의 뒷부분에서 살펴볼 "
"[_fallible_ 변환 메커니즘](../05_ticket_v2/13_try_from.md)을 사용하세요."

#: src/02_basic_calculator/10_as_casting.md:88
#: src/06_ticket_management/11_mutable_slices.md:21
msgid "Limitations"
msgstr "한계점"

#: src/02_basic_calculator/10_as_casting.md:90
msgid ""
"Surprising behaviour is not the only downside of `as` casting. It is also "
"fairly limited: you can only rely on `as` casting for primitive types and a "
"few other special cases.  \n"
"When working with composite types, you'll have to rely on different "
"conversion mechanisms ([fallible](../05_ticket_v2/13_try_from.md) and "
"[infallible](../04_traits/09_from.md)), which we'll explore later on."
msgstr ""
"놀라운 동작이 as 캐스팅의 유일한 단점은 아닙니다. as 캐스팅은 상당히 제한적이"
"어서, 원시 타입과 몇 가지 특별한 경우에만 사용할 수 있습니다.  \n"
"복합 타입으로 작업할 때 나중에 살펴보게 될 다양한 변환 메커니즘([fallible]"
"(../05_ticket_v2/13_try_from.md)과 [infallible](../04_traits/09_from.md))를 사"
"용해야합니다."

#: src/02_basic_calculator/10_as_casting.md:99
msgid ""
"Check out [Rust's official reference](https://doc.rust-lang.org/reference/"
"expressions/operator-expr.html#numeric-cast) to learn the precise behaviour "
"of `as` casting for each source/target combination, as well as the exhaustive "
"list of allowed conversions."
msgstr ""
"각 소스/타겟 조합에 대한 `as` 캐스팅의 정확한 동작과 허용되는 변환의 전체 목록"
"을 알아보려면 [Rust's official reference](https://doc.rust-lang.org/reference/"
"expressions/operator-expr.html#numeric-cast)를 확인하세요."

#: src/02_basic_calculator/10_as_casting.md:105
msgid ""
"The exercise for this section is located in "
"[`02_basic_calculator/10_as_casting`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/10_as_casting)"
msgstr ""
"이 섹션의 예제는 [`02_basic_calculator/10_as_casting`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/02_basic_calculator/10_as_casting)에 있습니다"

#: src/03_ticket_v1/00_intro.md:1
msgid "Modelling A Ticket"
msgstr "티켓 모델링"

#: src/03_ticket_v1/00_intro.md:3
msgid ""
"The first chapter should have given you a good grasp over some of Rust's "
"primitive types, operators and basic control flow constructs.  \n"
"In this chapter we'll go one step further and cover what makes Rust truly "
"unique: **ownership**.  \n"
"Ownership is what enables Rust to be both memory-safe and performant, with no "
"garbage collector."
msgstr ""
"첫 번째 장에서는 Rust의 원시 타입, 연산자 및 기본 흐름 제어 구성 중 일부에 대"
"해 잘 이해할 수 있었을 것입니다.  \n"
"이번 장에서 우리는 한 단계 더 나아가 Rust를 진정으로 독특하게 만드는 요소인 **"
"소유권**을 다룰 것입니다.  \n"
"소유권은 Rust가 가비지콜렉터 없이도 메모리 안전과 성능을 모두 발휘할 수 있게 "
"해줍니다."

#: src/03_ticket_v1/00_intro.md:8
msgid ""
"As our running example, we'll use a (JIRA-like) ticket, the kind you'd use to "
"track bugs, features, or tasks in a software project.  \n"
"We'll take a stab at modeling it in Rust. It'll be the first iteration—it "
"won't be perfect nor very idiomatic by the end of the chapter. It'll be "
"enough of a challenge though!  \n"
"To move forward you'll have to pick up several new Rust concepts, such as:"
msgstr ""
"실행 예제로서 소프트웨어 프로젝트에서 버그, 기능 또는 작업을 추적하는 데 사용"
"하는 종류의 (JIRA와 유사한) 티켓을 사용합니다.  \n"
"우리는 Rust에서 모델링을 시도해 볼 것입니다. 이것은 첫 번째 반복이 될 것입니"
"다. 이 장의 끝까지 완벽하지도 않고 매우 관용적이지도 않을 것입니다. 그래도 충"
"분히 도전할 수 있을 거예요!  \n"
"앞으로 나아가려면 다음과 같은 몇 가지 새로운 Rust 개념을 선택해야 합니다:"

#: src/03_ticket_v1/00_intro.md:14
msgid "`struct`s, one of Rust's ways to define custom types"
msgstr "`struct`, 사용자 정의 타입을 정의하는 Rust의 방법 중 하나"

#: src/03_ticket_v1/00_intro.md:15
msgid "Ownership, references and borrowing"
msgstr "소유권, 참조 및 차용"

#: src/03_ticket_v1/00_intro.md:16
msgid "Memory management: stack, heap, pointers, data layout, destructors"
msgstr "메모리 관리: 스택, 힙, 포인터, 데이터 레이아웃, 소멸자"

#: src/03_ticket_v1/00_intro.md:17
msgid "Modules and visibility"
msgstr "모듈 및 가시성"

#: src/03_ticket_v1/00_intro.md:18
msgid "Strings"
msgstr "문자열"

#: src/03_ticket_v1/00_intro.md:22
msgid ""
"The exercise for this section is located in [`03_ticket_v1/00_intro`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/00_intro)"
msgstr ""
"이 섹션의 예제는 [`03_ticket_v1/00_intro`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/00_intro)에 있습니다"

#: src/03_ticket_v1/01_struct.md:3
msgid "We need to keep track of three pieces of information for each ticket:"
msgstr "우리는 각 티켓에 대해 세 가지 정보를 추적해야 합니다:"

#: src/03_ticket_v1/01_struct.md:5
msgid "A title"
msgstr "제목"

#: src/03_ticket_v1/01_struct.md:6
msgid "A description"
msgstr "설명"

#: src/03_ticket_v1/01_struct.md:7
msgid "A status"
msgstr "상태"

#: src/03_ticket_v1/01_struct.md:9
msgid ""
"We can start by using a [`String`](https://doc.rust-lang.org/std/string/"
"struct.String.html) to represent them. `String` is the type defined in Rust's "
"standard library to represent [UTF-8 encoded](https://en.wikipedia.org/wiki/"
"UTF-8) text."
msgstr ""
"이를 표현하기 위해 [`String`](https://doc.rust-lang.org/std/string/struct."
"String.html)을 사용하는 것부터 시작할 수 있습니다. `String`은 [UTF-8로 인코딩"
"된](https://en.wikipedia.org/wiki/UTF-8) 텍스트를 나타내기 위해 Rust의 표준 라"
"이브러리에 정의된 타입입니다."

#: src/03_ticket_v1/01_struct.md:13
msgid ""
"But how do we **combine** these three pieces of information into a single "
"entity?"
msgstr "하지만 이 세 가지 정보를 어떻게 단일 항목으로 **결합**할 수 있을까요?"

#: src/03_ticket_v1/01_struct.md:15
msgid "Defining a `struct`"
msgstr "`구조체` 정의"

#: src/03_ticket_v1/01_struct.md:17
msgid "A `struct` defines a **new Rust type**."
msgstr "`struct`는 **새로운 Rust 타입**을 정의합니다."

#: src/03_ticket_v1/01_struct.md:27
msgid ""
"A struct is quite similar to what you would call a class or an object in "
"other programming languages."
msgstr ""
"구조체는 다른 프로그래밍 언어에서 클래스나 개체라고 부르는 것과 매우 유사합니"
"다."

#: src/03_ticket_v1/01_struct.md:29
msgid "Defining fields"
msgstr "필드 정의"

#: src/03_ticket_v1/01_struct.md:31
msgid ""
"The new type is built by combining other types as **fields**.  \n"
"Each field must have a name and a type, separated by a colon, `:`. If there "
"are multiple fields, they are separated by a comma, `,`."
msgstr ""
"새로운 유형은 다른 유형을 **필드**로 결합하여 구축됩니다.  \n"
"각 필드에는 콜론 `:`으로 구분된 이름과 유형이 있어야 합니다. 필드가 여러 개인 "
"경우 쉼표 `,`로 구분합니다."

#: src/03_ticket_v1/01_struct.md:34
msgid ""
"Fields don't have to be of the same type, as you can see in the "
"`Configuration` struct below:"
msgstr ""
"아래 `Configuration` 구조체에서 볼 수 있듯이 필드는 동일한 유형일 필요는 없습"
"니다:"

#: src/03_ticket_v1/01_struct.md:43
msgid "Instantiation"
msgstr "인스턴스화"

#: src/03_ticket_v1/01_struct.md:45
msgid ""
"You can create an instance of a struct by specifying the values for each "
"field:"
msgstr "각 필드의 값을 지정하여 구조체의 인스턴스를 만들 수 있습니다:"

#: src/03_ticket_v1/01_struct.md:48
msgid "// Syntax: <StructName> { <field_name>: <value>, ... }\n"
msgstr "// 문법: <StructName> { <field_name>: <value>, ... }\n"

#: src/03_ticket_v1/01_struct.md:50 src/03_ticket_v1/05_encapsulation.md:32
msgid "\"Build a ticket system\""
msgstr "\"Build a ticket system\""

#: src/03_ticket_v1/01_struct.md:51 src/03_ticket_v1/05_encapsulation.md:33
msgid "\"Create a system that can manage tickets across a Kanban board\""
msgstr "\"Create a system that can manage tickets across a Kanban board\""

#: src/03_ticket_v1/01_struct.md:52 src/03_ticket_v1/01_struct.md:73
#: src/03_ticket_v1/05_encapsulation.md:34
msgid "\"Open\""
msgstr "\"Open\""

#: src/03_ticket_v1/01_struct.md:56
msgid "Accessing fields"
msgstr "필드에 접근하기"

#: src/03_ticket_v1/01_struct.md:58
msgid "You can access the fields of a struct using the `.` operator:"
msgstr "`.` 연산자를 사용하여 구조체의 필드에 액세스할 수 있습니다:"

#: src/03_ticket_v1/01_struct.md:61
msgid "// Field access\n"
msgstr "// 필드 접근\n"

#: src/03_ticket_v1/01_struct.md:65
msgid "Methods"
msgstr "메서드"

#: src/03_ticket_v1/01_struct.md:67
msgid ""
"We can attach behaviour to our structs by defining **methods**.  \n"
"Using the `Ticket` struct as an example:"
msgstr ""
"**메서드**를 정의하여 구조체에 동작을 연결할 수 있습니다.  \n"
"예를 들어 `Ticket` 구조체를 사용하면 다음과 같습니다:"

#: src/03_ticket_v1/01_struct.md:76
msgid ""
"// Syntax:\n"
"// impl <StructName> {\n"
"//    fn <method_name>(<parameters>) -> <return_type> {\n"
"//        // Method body\n"
"//    }\n"
"// }\n"
msgstr ""
"// 문법:\n"
"// impl <StructName> {\n"
"//    fn <method_name>(<parameters>) -> <return_type> {\n"
"//        // Method body\n"
"//    }\n"
"// }\n"

#: src/03_ticket_v1/01_struct.md:85
msgid "Methods are pretty similar to functions, with two key differences:"
msgstr "메소드는 함수와 매우 유사하지만 두 가지 주요 차이점이 있습니다:"

#: src/03_ticket_v1/01_struct.md:87
msgid "methods must be defined inside an **`impl` block**"
msgstr "메소드는 **`impl` 블록** 안에 정의되어야 합니다"

#: src/03_ticket_v1/01_struct.md:88
msgid ""
"methods may use `self` as their first parameter. `self` is a keyword and "
"represents the instance of the struct the method is being called on."
msgstr ""
"메소드는 `self`를 첫 번째 매개변수로 사용할 수 있습니다. `self`는 키워드이며 "
"메소드가 호출되는 구조체의 인스턴스를 나타냅니다."

#: src/03_ticket_v1/01_struct.md:91
msgid "`self`"
msgstr "`self`"

#: src/03_ticket_v1/01_struct.md:93
msgid ""
"If a method takes `self` as its first parameter, it can be called using the "
"**method call syntax**:"
msgstr ""
"메소드가 `self`를 첫 번째 매개변수로 사용하는 경우 **메서드 호출 문법**을 사용"
"하여 호출할 수 있습니다."

#: src/03_ticket_v1/01_struct.md:96
msgid "// Method call syntax: <instance>.<method_name>(<parameters>)\n"
msgstr "// 메소드 호출 문법: <instance>.<method_name>(<parameters>)\n"

#: src/03_ticket_v1/01_struct.md:100
msgid ""
"This is the same calling syntax you used to perform saturating arithmetic "
"operations on `u32` values in [the previous chapter]"
"(../02_basic_calculator/09_saturating.md)."
msgstr ""
"이는 이전 장에서 `u32` 값에 대해 포화 산술 연산을 수행하는 데 사용한 것과 동일"
"한 호출 문법입니다."

#: src/03_ticket_v1/01_struct.md:103
msgid "Static methods"
msgstr "정적 메서드"

#: src/03_ticket_v1/01_struct.md:105
msgid ""
"If a method doesn't take `self` as its first parameter, it's a **static "
"method**."
msgstr ""
"메소드가 `self`를 첫 번째 매개변수로 사용하지 않으면 **정적 메서드**입니다."

#: src/03_ticket_v1/01_struct.md:114
msgid "// `default` is a static method on `Configuration`\n"
msgstr "// `default`는 `Configuration`의 정적 메서드입니다.\n"

#: src/03_ticket_v1/01_struct.md:121
msgid ""
"The only way to call a static method is by using the **function call syntax**:"
msgstr ""
"정적 메서드를 호출하는 유일한 방법은 **함수 호출 문법**을 사용하는 것입니다."

#: src/03_ticket_v1/01_struct.md:124
msgid "// Function call syntax: <StructName>::<method_name>(<parameters>)\n"
msgstr "// 함수 호출 문법: <StructName>::<method_name>(<parameters>)\n"

#: src/03_ticket_v1/01_struct.md:128
msgid "Equivalence"
msgstr "등가"

#: src/03_ticket_v1/01_struct.md:130
msgid ""
"You can use the function call syntax even for methods that take `self` as "
"their first parameter:"
msgstr ""
"`self`를 첫 번째 매개변수로 사용하는 메소드의 경우에도 함수 호출 문법을 사용"
"할 수 있습니다."

#: src/03_ticket_v1/01_struct.md:133
msgid ""
"// Function call syntax: <StructName>::<method_name>(<instance>, "
"<parameters>)\n"
msgstr ""
"// 함수 호출 문법: <StructName>::<method_name>(<instance>, <parameters>)\n"

#: src/03_ticket_v1/01_struct.md:137
msgid ""
"The function call syntax makes it quite clear that `ticket` is being used as "
"`self`, the first parameter of the method, but it's definitely more verbose. "
"Prefer the method call syntax when possible."
msgstr ""
"함수 호출 구문을 보면 `ticket`이 메서드의 첫 번째 매개변수인 `self`로 사용되"
"고 있음이 분명하지만 확실히 더 장황합니다. 가능하면 메서드 호출 문법을 사용하"
"세요."

#: src/03_ticket_v1/01_struct.md:142
msgid ""
"The exercise for this section is located in [`03_ticket_v1/01_struct`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/01_struct)"
msgstr ""
"이 섹션의 예제는 [`03_ticket_v1/01_struct`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/01_struct)에 있습니다"

#: src/03_ticket_v1/02_validation.md:3
msgid "Let's go back to our ticket definition:"
msgstr "티켓 정의로 돌아가 보겠습니다:"

#: src/03_ticket_v1/02_validation.md:13
msgid ""
"We are using \"raw\" types for the fields of our `Ticket` struct. This means "
"that users can create a ticket with an empty title, a suuuuuuuper long "
"description or a nonsensical status (e.g. \"Funny\").  \n"
"We can do better than that!"
msgstr ""
"우리는 `Ticket` 구조체의 필드에 \"원시\" 타입을 사용하고 있습니다. 즉, 사용자"
"는 빈 제목, 어어어엄청나게 긴 설명 또는 의미없는 상태(예: \"재미있음\")로 티켓"
"을 만들 수 있습니다.  \n"
"우리는 이것보다 더 잘할 수 있습니다!"

#: src/03_ticket_v1/02_validation.md:20
msgid ""
"Check out [`String`'s documentation](https://doc.rust-lang.org/std/string/"
"struct.String.html) for a thorough overview of the methods it provides. "
"You'll need it for the exercise!"
msgstr ""
"제공되는 메소드에 대한 철저한 개요는 [`String`의 문서](https://doc.rust-lang."
"org/std/string/struct.String.html)를 확인하세요. 예제를 풀 때 꼭 필요해요!"

#: src/03_ticket_v1/02_validation.md:25
msgid ""
"The exercise for this section is located in [`03_ticket_v1/02_validation`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/02_validation)"
msgstr ""
"이 섹션의 예제는 [`03_ticket_v1/02_validation`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/02_validation)에 있습니다"

#: src/03_ticket_v1/03_modules.md:3
msgid ""
"The `new` method you've just defined is trying to enforce some "
"**constraints** on the field values for `Ticket`. But are those invariants "
"really enforced? What prevents a developer from creating a `Ticket` without "
"going through `Ticket::new`?"
msgstr ""
"방금 정의한 `new` 메소드는 `Ticket`의 필드 값에 일부 **제약조건**을 적용하려"
"고 합니다. 그러나 이러한 불변성이 실제로 지켜지나요? 개발자가 `Ticket::new`를 "
"거치지 않고 `Ticket`을 생성하는 것을 막는게 있나요?"

#: src/03_ticket_v1/03_modules.md:7
msgid ""
"To get proper **encapsulation** you need to become familiar with two new "
"concepts: **visibility** and **modules**. Let's start with modules."
msgstr ""
"적절한 **캡슐화**를 얻으려면 **가시성**과 **모듈**이라는 두 가지 새로운 개념"
"에 익숙해져야 합니다. 모듈부터 시작해 보겠습니다."

#: src/03_ticket_v1/03_modules.md:10
msgid "What is a module?"
msgstr "모듈이란 무엇입니까?"

#: src/03_ticket_v1/03_modules.md:12
msgid ""
"In Rust a **module** is a way to group related code together, under a common "
"namespace (i.e. the module's name).  \n"
"You've already seen modules in action: the unit tests that verify the "
"correctness of your code are defined in a different module, named `tests`."
msgstr ""
"Rust에서 **모듈**은 관련 코드를 공통 네임스페이스(예: 모듈 이름) 아래에 함께 "
"그룹화하는 방법입니다.  \n"
"여러분은 이미 작동 중인 모듈을 보았습니다. 코드의 정확성을 확인하는 단위 테스"
"트는 `tests`라는 다른 모듈에 정의되어 있습니다."

#: src/03_ticket_v1/03_modules.md:19 src/03_ticket_v1/03_modules.md:69
#: src/03_ticket_v1/03_modules.md:75 src/03_ticket_v1/03_modules.md:97
#: src/03_ticket_v1/06_ownership.md:217 src/04_traits/02_orphan_rule.md:40
#: src/04_traits/04_derive.md:21 src/04_traits/04_derive.md:43
#: src/04_traits/05_trait_bounds.md:134 src/04_traits/05_trait_bounds.md:156
#: src/04_traits/07_deref.md:78 src/04_traits/09_from.md:18
#: src/04_traits/10_assoc_vs_generic.md:97
#: src/04_traits/10_assoc_vs_generic.md:123 src/05_ticket_v2/01_enum.md:18
#: src/06_ticket_management/05_iter.md:19 src/06_ticket_management/05_iter.md:33
#: src/06_ticket_management/06_lifetimes.md:47
#: src/06_ticket_management/06_lifetimes.md:68
#: src/06_ticket_management/15_hashmap.md:40
#: src/07_threads/06_interior_mutability.md:8 src/08_futures/01_async_fn.md:27
#: src/08_futures/01_async_fn.md:61 src/08_futures/02_spawn.md:76
#: src/08_futures/02_spawn.md:80 src/08_futures/02_spawn.md:109
#: src/08_futures/05_blocking.md:62
#: src/08_futures/06_async_aware_primitives.md:29
#: src/08_futures/07_cancellation.md:16
msgid "// [...]\n"
msgstr "// [...]\n"

#: src/03_ticket_v1/03_modules.md:23
msgid "Inline modules"
msgstr "인라인 모듈"

#: src/03_ticket_v1/03_modules.md:25
msgid ""
"The `tests` module above is an example of an **inline module**: the module "
"declaration (`mod tests`) and the module contents (the stuff inside `{ ... }"
"`) are next to each other."
msgstr ""
"위의 `tests` 모듈은 **인라인 모듈**의 예입니다. 모듈 선언(`mod tests`)과 모듈 "
"내용(`{ ... }` 내부의 항목)이 바로 옆에 있습니다."

#: src/03_ticket_v1/03_modules.md:28
msgid "Module tree"
msgstr "모듈 트리"

#: src/03_ticket_v1/03_modules.md:30
msgid ""
"Modules can be nested, forming a **tree** structure.  \n"
"The root of the tree is the **crate** itself, which is the top-level module "
"that contains all the other modules. For a library crate, the root module is "
"usually `src/lib.rs` (unless its location has been customized). The root "
"module is also known as the **crate root**."
msgstr ""
"모듈은 중첩되어 **트리** 구조를 형성할 수 있습니다.  \n"
"트리의 루트는 다른 모든 모듈을 포함하는 최상위 모듈인 **크레이트** 자체입니"
"다. 라이브러리 크레이트의 경우 루트 모듈은 일반적으로 `src/lib.rs`입니다(위치"
"가 사용자 정의 되지 않은 경우). 루트 모듈은 **크레이트 루트**라고도 합니다."

#: src/03_ticket_v1/03_modules.md:35
msgid ""
"The crate root can have submodules, which in turn can have their own "
"submodules, and so on."
msgstr ""
"크레이트 루트에는 하위 모듈이 있을 수 있으며, 이 하위 모듈은 자체 하위 모듈을 "
"가질 수도 있습니다."

#: src/03_ticket_v1/03_modules.md:37
msgid "External modules and the filesystem"
msgstr "외부 모듈과 파일 시스템"

#: src/03_ticket_v1/03_modules.md:39
msgid ""
"Inline modules are useful for small pieces of code, but as your project grows "
"you'll want to split your code into multiple files. In the parent module, you "
"declare the existence of a submodule using the `mod` keyword."
msgstr ""
"인라인 모듈은 작은 코드 조각에 유용하지만 프로젝트가 커지면 코드를 여러 파일"
"로 분할하고 싶을 것입니다. 상위 모듈에서는 `mod` 키워드를 사용하여 하위 모듈"
"의 존재를 선언합니다."

#: src/03_ticket_v1/03_modules.md:46
msgid ""
"`cargo`, Rust's build tool, is then in charge of finding the file that "
"contains the module implementation.  \n"
"If your module is declared in the root of your crate (e.g. `src/lib.rs` or "
"`src/main.rs`), `cargo` expects the file to be named either:"
msgstr ""
"Rust의 빌드 도구인 `cargo`는 모듈 구현이 포함된 파일을 찾는 일을 담당합니"
"다.  \n"
"모듈이 크레이트 루트(예: `src/lib.rs` 또는 `src/main.rs`)에 선언된 경우 "
"`cargo`는 파일 이름이 다음 중 하나로 지정될 것으로 예상합니다:"

#: src/03_ticket_v1/03_modules.md:51
msgid "`src/<module_name>.rs`"
msgstr "`src/<module_name>.rs`"

#: src/03_ticket_v1/03_modules.md:52
msgid "`src/<module_name>/mod.rs`"
msgstr "`src/<module_name>/mod.rs`"

#: src/03_ticket_v1/03_modules.md:54
msgid ""
"If your module is a submodule of another module, the file should be named:"
msgstr "모듈이 다른 모듈의 하위 모듈인 경우 파일 이름은 다음과 같아야 합니다:"

#: src/03_ticket_v1/03_modules.md:56
msgid "`[..]/<parent_module>/<module_name>.rs`"
msgstr "`[..]/<parent_module>/<module_name>.rs`"

#: src/03_ticket_v1/03_modules.md:57
msgid "`[..]/<parent_module>/<module_name>/mod.rs`"
msgstr "`[..]/<parent_module>/<module_name>/mod.rs`"

#: src/03_ticket_v1/03_modules.md:59
msgid ""
"E.g. `src/animals/dog.rs` or `src/animals/dog/mod.rs` if `dog` is a submodule "
"of `animals`."
msgstr ""
"예: `dog`가 `animals`의 하위 모듈인 경우 `src/animals/dog.rs` 또는 `src/"
"animals/dog/mod.rs`."

#: src/03_ticket_v1/03_modules.md:61
msgid ""
"Your IDE might help you create these files automatically when you declare a "
"new module using the `mod` keyword."
msgstr ""
"IDE는 `mod` 키워드를 사용하여 새 모듈을 선언할 때 이러한 파일을 자동으로 생성"
"하는 데 도움이 될 수 있습니다."

#: src/03_ticket_v1/03_modules.md:63
msgid "Item paths and `use` statements"
msgstr "아이템 경로와 `use` 문"

#: src/03_ticket_v1/03_modules.md:65
msgid ""
"You can access items defined in the same module without any special syntax. "
"You just use their name."
msgstr ""
"특별한 문법 없이 동일한 모듈에 정의된 항목에 액세스할 수 있습니다. 항목들의 이"
"름을 사용하면 됩니다."

#: src/03_ticket_v1/03_modules.md:71
msgid ""
"// No need to qualify `Ticket` in any way here\n"
"// because we're in the same module\n"
msgstr ""
"// 여기서는 `Ticket`을 어떤 식으로든 정해줄 필요가 없습니다.\n"
"// 왜냐하면 우리는 동일한 모듈에 있기 때문입니다.\n"

#: src/03_ticket_v1/03_modules.md:79
msgid ""
"That's not the case if you want to access an entity from a different "
"module.  \n"
"You have to use a **path** pointing to the entity you want to access."
msgstr ""
"다른 모듈에서 엔터티에 액세스하려는 경우에는 그렇지 않습니다.  \n"
"액세스하려는 엔터티를 가리키는 **경로**를 사용해야 합니다."

#: src/03_ticket_v1/03_modules.md:82
msgid "You can compose the path in various ways:"
msgstr "다양한 방법으로 경로를 구성할 수 있습니다:"

#: src/03_ticket_v1/03_modules.md:84
msgid ""
"starting from the root of the current crate, e.g. `crate::module_1::module_2::"
"MyStruct`"
msgstr ""
"현재 크레이트의 루트부터 시작합니다. 예: `crate::module_1::module_2::MyStruct`"

#: src/03_ticket_v1/03_modules.md:85
msgid "starting from the parent module, e.g. `super::my_function`"
msgstr "상위 모듈에서 시작합니다. 예: `super::my_function`"

#: src/03_ticket_v1/03_modules.md:86
msgid "starting from the current module, e.g. `sub_module_1::MyStruct`"
msgstr "현재 모듈에서 시작합니다. 예: `sub_module_1::MyStruct`"

#: src/03_ticket_v1/03_modules.md:88
msgid ""
"Having to write the full path every time you want to refer to a type can be "
"cumbersome. To make your life easier, you can introduce a `use` statement to "
"bring the entity into scope."
msgstr ""
"타입을 참조할 때마다 전체 경로를 작성해야 하는 것은 번거로울 수 있습니다. 인생"
"을 더 쉽게 만들기 위해 `use` 문을 사용해 엔터티를 스코프로 가져올 수 있습니다."

#: src/03_ticket_v1/03_modules.md:92
msgid "// Bring `MyStruct` into scope\n"
msgstr "// `MyStruct`를 스코프로 가져옵니다.\n"

#: src/03_ticket_v1/03_modules.md:94
msgid "// Now you can refer to `MyStruct` directly\n"
msgstr "// 이제 `MyStruct`를 직접 참조할 수 있습니다.\n"

#: src/03_ticket_v1/03_modules.md:101
msgid "Star imports"
msgstr "별표 임포트"

#: src/03_ticket_v1/03_modules.md:103
msgid ""
"You can also import all the items from a module with a single `use` statement."
msgstr "단일 `use` 문을 사용하여 모듈의 모든 항목을 가져올 수도 있습니다."

#: src/03_ticket_v1/03_modules.md:109
msgid ""
"This is known as a **star import**.  \n"
"It is generally discouraged because it can pollute the current namespace, "
"making it hard to understand where each name comes from and potentially "
"introducing name conflicts.  \n"
"Nonetheless, it can be useful in some cases, like when writing unit tests. "
"You might have noticed that most of our test modules start with a `use super::"
"*;` statement to bring all the items from the parent module (the one being "
"tested) into scope."
msgstr ""
"이것을 **별표 임포트**라고 합니다.\n"
"일반적으로 현재 네임스페이스를 오염시킬 수 있어 각 이름이 어디에서 왔는지 이해"
"하기 어렵게 만들고 잠재적으로 이름 충돌을 일으킬 수 있기 때문에 권장되지 않습"
"니다.\n"
"그럼에도 불구하고, 유닛 테스트를 작성할 때처럼 유용한 경우가 있습니다. 대부분"
"의 테스트 모듈이 `use super::*;` 문으로 시작하여 부모 모듈(테스트 중인 모듈)"
"의 모든 항목을 스코프에 가져오는 것을 눈치챘을 겁입니다."

#: src/03_ticket_v1/03_modules.md:118
msgid ""
"The exercise for this section is located in [`03_ticket_v1/03_modules`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/03_modules)"
msgstr ""
"이 섹션의 예제는 [`03_ticket_v1/03_modules`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/03_modules)에 있습니다"

#: src/03_ticket_v1/04_visibility.md:3
msgid ""
"When you start breaking down your code into multiple modules, you need to "
"start thinking about **visibility**. Visibility determines which regions of "
"your code (or other people's code) can access a given entity, be it a struct, "
"a function, a field, etc."
msgstr ""
"코드를 여러 모듈로 나누기 시작할 때 **가시성**에 대해 생각해야 합니다. 가시성"
"은 구조체, 함수, 필드 등 특정 엔터티에 액세스할 수 있는 코드(또는 다른 사람의 "
"코드) 영역을 결정합니다."

#: src/03_ticket_v1/04_visibility.md:7
msgid "Private by default"
msgstr "기본적으로 비공개"

#: src/03_ticket_v1/04_visibility.md:9
msgid ""
"By default, everything in Rust is **private**.  \n"
"A private entity can only be accessed:"
msgstr ""
"기본적으로 Rust의 모든 것은 **비공개**입니다.  \n"
"프라이빗 엔터티에는 다음 경우에만 액세스할 수 있습니다:"

#: src/03_ticket_v1/04_visibility.md:12
msgid "within the same module where it's defined, or"
msgstr "정의된 동일한 모듈 내에서 또는"

#: src/03_ticket_v1/04_visibility.md:13
msgid "by one of its submodules"
msgstr "하위 모듈 중 하나에 의해"

#: src/03_ticket_v1/04_visibility.md:15
msgid "We've used this extensively in the previous exercises:"
msgstr "이전 예제에서는 이를 광범위하게 사용했습니다."

#: src/03_ticket_v1/04_visibility.md:17
msgid ""
"`create_todo_ticket` worked (once you added a `use` statement) because "
"`helpers` is a submodule of the crate root, where `Ticket` is defined. "
"Therefore, `create_todo_ticket` can access `Ticket` without any issues even "
"though `Ticket` is private."
msgstr ""
"`create_todo_ticket`이 작동했습니다(`use` 문을 추가한 후). `helpers`는 "
"`Ticket`이 정의된 크레이트 루트의 하위 모듈이기 때문입니다. 따라서 "
"`create_todo_ticket`은 `Ticket`이 비공개인 경우에도 문제 없이 `Ticket`에 액세"
"스할 수 있습니다."

#: src/03_ticket_v1/04_visibility.md:20
msgid ""
"All our unit tests are defined in a submodule of the code they're testing, so "
"they can access everything without restrictions."
msgstr ""
"모든 단위 테스트는 테스트 중인 코드의 하위 모듈에 정의되어 있으므로 제한 없이 "
"모든 것에 액세스할 수 있습니다."

#: src/03_ticket_v1/04_visibility.md:23
msgid "Visibility modifiers"
msgstr "가시성 수정자"

#: src/03_ticket_v1/04_visibility.md:25
msgid ""
"You can modify the default visibility of an entity using a **visibility "
"modifier**.  \n"
"Some common visibility modifiers are:"
msgstr ""
"**가시성 수정자**를 사용하여 엔터티의 기본 가시성을 수정할 수 있습니다.  \n"
"몇 가지 일반적인 가시성 수정자는 다음과 같습니다:"

#: src/03_ticket_v1/04_visibility.md:28
msgid ""
"`pub`: makes the entity **public**, i.e. accessible from outside the module "
"where it's defined, potentially from other crates."
msgstr ""
"`pub`: 엔터티를 **공개**로 만듭니다. 즉, 엔터티가 정의된 모듈 외부, 잠재적으"
"로 다른 크레이트에서 액세스할 수 있습니다."

#: src/03_ticket_v1/04_visibility.md:30
msgid ""
"`pub(crate)`: makes the entity public within the same **crate**, but not "
"outside of it."
msgstr ""
"`pub(crate)`: 동일한 **크레이트** 내에서 엔터티를 공개하지만 외부에서는 공개하"
"지 않습니다."

#: src/03_ticket_v1/04_visibility.md:31
msgid "`pub(super)`: makes the entity public within the parent module."
msgstr "`pub(super)`: 상위 모듈 내에서 엔터티를 공개합니다."

#: src/03_ticket_v1/04_visibility.md:32
msgid ""
"`pub(in path::to::module)`: makes the entity public within the specified "
"module."
msgstr "`pub(in path::to::module)`: 지정된 모듈 내에서 엔터티를 공개합니다."

#: src/03_ticket_v1/04_visibility.md:34
msgid ""
"You can use these modifiers on modules, structs, functions, fields, etc. For "
"example:"
msgstr ""
"모듈, 구조체, 함수, 필드 등에 이러한 수정자를 사용할 수 있습니다. 예를 들면 다"
"음과 같습니다:"

#: src/03_ticket_v1/04_visibility.md:44
msgid ""
"`Configuration` is public, but you can only access the `version` field from "
"within the same crate. The `active` field, instead, is private and can only "
"be accessed from within the same module or one of its submodules."
msgstr ""
"`Configuration`은 공개되지만 동일한 크레이트 내에서는 `version` 필드에만 액세"
"스할 수 있습니다. 대신 `active` 필드는 비공개이며 동일한 모듈이나 해당 하위 모"
"듈 중 하나에서만 액세스할 수 있습니다."

#: src/03_ticket_v1/04_visibility.md:49
msgid ""
"The exercise for this section is located in [`03_ticket_v1/04_visibility`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/04_visibility)"
msgstr ""
"이 섹션의 예제는 [`03_ticket_v1/04_visibility`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/04_visibility)에 있습니다"

#: src/03_ticket_v1/05_encapsulation.md:3
msgid ""
"Now that we have a basic understanding of modules and visibility, let's "
"circle back to **encapsulation**.  \n"
"Encapsulation is the practice of hiding the internal representation of an "
"object. It is most commonly used to enforce some **invariants** on the "
"object's state."
msgstr ""
"이제 모듈과 가시성에 대한 기본적인 이해를 마쳤으므로 다시 **캡슐화**로 돌아가"
"겠습니다.  \n"
"캡슐화는 객체의 내부 표현을 숨기는 방법입니다. 객체의 상태에 일부 **불변성**"
"을 적용하는 데 가장 일반적으로 사용됩니다."

#: src/03_ticket_v1/05_encapsulation.md:7
msgid "Going back to our `Ticket` struct:"
msgstr "`Ticket` 구조체로 돌아가면:"

#: src/03_ticket_v1/05_encapsulation.md:17
msgid ""
"If all fields are made public, there is no encapsulation.  \n"
"You must assume that the fields can be modified at any time, set to any value "
"that's allowed by their type. You can't rule out that a ticket might have an "
"empty title or a status that doesn't make sense."
msgstr ""
"모든 필드가 공개되면 캡슐화되지 않습니다.  \n"
"필드는 언제든지 수정될 수 있고 해당 유형에서 허용되는 값으로 설정될 수 있다고 "
"가정해야 합니다. 티켓의 제목이 비어 있거나 의미가 없는 상태일 수 있다는 점을 "
"배제할 수 없습니다."

#: src/03_ticket_v1/05_encapsulation.md:22
msgid ""
"To enforce stricter rules, we must keep the fields private[^newtype]. We can "
"then provide public methods to interact with a `Ticket` instance. Those "
"public methods will have the responsibility of upholding our invariants (e.g. "
"a title must not be empty)."
msgstr ""
"더 엄격한 규칙을 적용하려면 필드를 비공개로 유지해야 합니다[^newtype]. 그런 다"
"음 `Ticket` 인스턴스와 상호 작용하는 공개 메서드를 제공할 수 있습니다. 이러한 "
"공개 메소드는 우리의 불변성을 유지하는 책임을 갖습니다(예: 제목은 비어 있으면 "
"안 됩니다)."

#: src/03_ticket_v1/05_encapsulation.md:26
msgid ""
"If all fields are private, it is no longer possible to create a `Ticket` "
"instance directly using the struct instantiation syntax:"
msgstr ""
"모든 필드가 비공개인 경우 더 이상 구조체 인스턴스화 구문을 사용하여 'Ticket' "
"인스턴스를 직접 생성할 수 없습니다:"

#: src/03_ticket_v1/05_encapsulation.md:30
msgid "// This won't work!\n"
msgstr "// 이것은 작동하지 않습니다!\n"

#: src/03_ticket_v1/05_encapsulation.md:38
msgid ""
"You've seen this in action in the previous exercise on visibility.  \n"
"We now need to provide one or more public **constructors**—i.e. static "
"methods or functions that can be used from outside the module to create a new "
"instance of the struct.  \n"
"Luckily enough we already have one: `Ticket::new`, as implemented in [a "
"previous exercise](02_validation.md)."
msgstr ""
"가시성에 대한 이전 연습에서 이 내용을 확인했습니다.  \n"
"이제 하나 이상의 공개 **생성자**를 제공해야 합니다. 구조체의 새 인스턴스를 생"
"성하기 위해 모듈 외부에서 사용할 수 있는 정적 메서드 또는 함수.  \n"
"운 좋게도 이전 연습에서 구현한 `Ticket::new`가 이미 있습니다."

#: src/03_ticket_v1/05_encapsulation.md:43
msgid "Accessor methods"
msgstr "접근자 메서드"

#: src/03_ticket_v1/05_encapsulation.md:45
msgid "In summary:"
msgstr "요약:"

#: src/03_ticket_v1/05_encapsulation.md:47
msgid "All `Ticket` fields are private"
msgstr "모든 `Ticket` 필드는 비공개입니다."

#: src/03_ticket_v1/05_encapsulation.md:48
msgid ""
"We provide a public constructor, `Ticket::new`, that enforces our validation "
"rules on creation"
msgstr ""
"우리는 생성 시 유효성 검사 규칙을 적용하는 공개 생성자 `Ticket::new`를 제공합"
"니다"

#: src/03_ticket_v1/05_encapsulation.md:50
msgid ""
"That's a good start, but it's not enough: apart from creating a `Ticket`, we "
"also need to interact with it. But how can we access the fields if they're "
"private?"
msgstr ""
"좋은 시작이지만 충분하지 않습니다. `Ticket`을 만드는 것 외에도 티켓과 상호 작"
"용해야 합니다. 하지만 비공개 필드인 경우 어떻게 해당 필드에 액세스할 수 있겠습"
"니까?"

#: src/03_ticket_v1/05_encapsulation.md:53
msgid ""
"We need to provide **accessor methods**.  \n"
"Accessor methods are public methods that allow you to read the value of a "
"private field (or fields) of a struct."
msgstr ""
"**접속자 메서드**를 제공해야 합니다.  \n"
"접근자 메서드는 구조체의 비공개 필드 값을 읽을 수 있는 공개 메서드입니다."

#: src/03_ticket_v1/05_encapsulation.md:56
msgid ""
"Rust doesn't have a built-in way to generate accessor methods for you, like "
"some other languages do. You have to write them yourself—they're just regular "
"methods."
msgstr ""
"Rust에는 다른 언어처럼 접근자 메서드를 생성하는 내장된 방법이 없습니다. 직접 "
"작성해야 합니다. 이는 단지 일반적인 메서드일 뿐입니다."

#: src/03_ticket_v1/05_encapsulation.md:59
msgid ""
"Or refine their type, a technique we'll explore [later on]"
"(../05_ticket_v2/15_outro.md)."
msgstr ""
"또는 타입을 세분화하는 방법, 이 테크닉은 [나중에](../05_ticket_v2/15_outro."
"md) 살펴보겠습니다."

#: src/03_ticket_v1/05_encapsulation.md:63
msgid ""
"The exercise for this section is located in [`03_ticket_v1/05_encapsulation`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/05_encapsulation)"
msgstr ""
"이 섹션의 예제는 [`03_ticket_v1/05_encapsulation`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/05_encapsulation)에 있습니다"

#: src/03_ticket_v1/06_ownership.md:3
msgid ""
"If you solved the previous exercise using what this course has taught you so "
"far, your accessor methods probably look like this:"
msgstr ""
"지금까지 이 과정에서 배운 내용을 사용하여 이전 연습을 해결했다면 접근자 메서드"
"는 다음과 같을 것입니다:"

#: src/03_ticket_v1/06_ownership.md:22
msgid ""
"Those methods compile and are enough to get tests to pass, but in a real-"
"world scenario they won't get you very far. Consider this snippet:"
msgstr ""
"이러한 메서드는 컴파일되고 테스트를 통과하기에 충분하지만 실제 시나리오에서는 "
"그리 큰 도움이 되진 않습니다. 다음 코드를 고려해보세요:"

#: src/03_ticket_v1/06_ownership.md:26 src/03_ticket_v1/07_setters.md:53
#: src/03_ticket_v1/07_setters.md:91 src/04_traits/09_from.md:6
msgid "\"To-Do\""
msgstr "\"To-Do\""

#: src/03_ticket_v1/06_ownership.md:27
msgid ""
"// We haven't covered the `println!` macro yet,\n"
"    // but for now it's enough to know that it prints \n"
"    // a (templated) message to the console\n"
msgstr ""
"// 아직 `println!` 매크로를 다루지 않았습니다.\n"
"    // 지금은 이 매크로가 콘솔에 (템플릿화된) 메시지를\n"
"    // 인쇄한다는 것만 알면 충분합니다.\n"

#: src/03_ticket_v1/06_ownership.md:30
msgid "\"Your next task is: {}\""
msgstr "\"Your next task is: {}\""

#: src/03_ticket_v1/06_ownership.md:34
msgid "If you try to compile it, you'll get an error:"
msgstr "컴파일하려고 하면 오류가 발생합니다:"

#: src/03_ticket_v1/06_ownership.md:36 src/03_ticket_v1/06_ownership.md:122
msgid ""
"```text\n"
"error[E0382]: use of moved value: `ticket`\n"
"  --> src/main.rs:30:43\n"
"   |\n"
"25 |     let ticket = Ticket::new(/* */);\n"
"   |         ------ move occurs because `ticket` has type `Ticket`, \n"
"   |                which does not implement the `Copy` trait\n"
"26 |     if ticket.status() == \"To-Do\" {\n"
"   |               -------- `ticket` moved due to this method call\n"
"...\n"
"30 |         println!(\"Your next task is: {}\", ticket.title());\n"
"   |                                           ^^^^^^ value used here after "
"move\n"
"   |\n"
"note: `Ticket::status` takes ownership of the receiver `self`, which moves "
"`ticket`\n"
"  --> src/main.rs:12:23\n"
"   |\n"
"12 |         pub fn status(self) -> String {\n"
"   |                       ^^^^\n"
"```"
msgstr ""
"```text\n"
"error[E0382]: use of moved value: `ticket`\n"
"  --> src/main.rs:30:43\n"
"   |\n"
"25 |     let ticket = Ticket::new(/* */);\n"
"   |         ------ move occurs because `ticket` has type `Ticket`, \n"
"   |                which does not implement the `Copy` trait\n"
"26 |     if ticket.status() == \"To-Do\" {\n"
"   |               -------- `ticket` moved due to this method call\n"
"...\n"
"30 |         println!(\"Your next task is: {}\", ticket.title());\n"
"   |                                           ^^^^^^ value used here after "
"move\n"
"   |\n"
"note: `Ticket::status` takes ownership of the receiver `self`, which moves "
"`ticket`\n"
"  --> src/main.rs:12:23\n"
"   |\n"
"12 |         pub fn status(self) -> String {\n"
"   |                       ^^^^\n"
"```"

#: src/03_ticket_v1/06_ownership.md:56
msgid "Congrats, this is your first borrow-checker error!"
msgstr "축하합니다. 첫 번째 차용 검사기 오류입니다!"

#: src/03_ticket_v1/06_ownership.md:58
msgid "The perks of Rust's ownership system"
msgstr "Rust 소유권 시스템의 장점"

#: src/03_ticket_v1/06_ownership.md:60
msgid "Rust's ownership system is designed to ensure that:"
msgstr "Rust의 소유권 시스템은 다음을 보장하도록 설계되었습니다:"

#: src/03_ticket_v1/06_ownership.md:62 src/03_ticket_v1/06_ownership.md:166
msgid "Data is never mutated while it's being read"
msgstr "데이터를 읽는 동안에는 데이터가 변경되지 않습니다"

#: src/03_ticket_v1/06_ownership.md:63 src/03_ticket_v1/06_ownership.md:167
msgid "Data is never read while it's being mutated"
msgstr "데이터가 변경되는 동안에는 데이터를 읽을 수 없습니다"

#: src/03_ticket_v1/06_ownership.md:64
msgid "Data is never accessed after it has been destroyed"
msgstr "데이터가 파기된 후에는 절대 액세스할 수 없습니다"

#: src/03_ticket_v1/06_ownership.md:66
msgid ""
"These constraints are enforced by the **borrow checker**, a subsystem of the "
"Rust compiler, often the subject of jokes and memes in the Rust community."
msgstr ""
"이러한 제약은 Rust 커뮤니티에서 종종 농담과 밈의 주제가 되는 Rust 컴파일러의 "
"하위 시스템인 **차용 검사기**에 의해 시행됩니다."

#: src/03_ticket_v1/06_ownership.md:69
msgid ""
"Ownership is a key concept in Rust, and it's what makes the language unique. "
"Ownership enables Rust to provide **memory safety without compromising "
"performance**. All these things are true at the same time for Rust:"
msgstr ""
"소유권은 Rust의 핵심 개념이며 언어를 독특하게 만드는 요소입니다. 소유권을 통"
"해 Rust는 **성능 저하 없는 메모리 안전**을 제공할 수 있습니다. Rust에서는 이 "
"모든 것들이 동시에 적용됩니다:"

#: src/03_ticket_v1/06_ownership.md:73
msgid "There is no runtime garbage collector"
msgstr "런타임 가비지 콜렉터가 없습니다"

#: src/03_ticket_v1/06_ownership.md:74
msgid "As a developer, you rarely have to manage memory directly"
msgstr "개발자로서 메모리를 직접 관리해야 하는 경우는 거의 없습니다"

#: src/03_ticket_v1/06_ownership.md:75
msgid ""
"You can't cause dangling pointers, double frees, and other memory-related bugs"
msgstr "댕글링 포인터, 더블 프리, 기타 메모리 관련 버그를 일으킬 수 없습니다."

#: src/03_ticket_v1/06_ownership.md:77
msgid ""
"Languages like Python, JavaScript, and Java give you 2. and 3., but not 1.  \n"
"Language like C or C++ give you 1., but neither 2. nor 3."
msgstr ""
"Python, JavaScript, Java와 같은 언어는 2와 3을 제공하지만 1은 제공하지 않습니"
"다.  \n"
"C나 C++ 같은 언어는 1.을 제공하지만 2.도 3도 제공하지 않습니다."

#: src/03_ticket_v1/06_ownership.md:80
msgid ""
"Depending on your background, 3. might sound a bit arcane: what is a "
"\"dangling pointer\"? What is a \"double free\"? Why are they dangerous?  \n"
"Don't worry: we'll cover these concepts in more details during the rest of "
"the course."
msgstr ""
"3. 배경에 따라 다소 난해하게 들릴 수도 있습니다. \"댕글링 포인터\"란 무엇입니"
"까? \"더블 프리\"란 무엇입니까? 왜 위험합니까?  \n"
"걱정하지 마십시오. 나머지 과정에서 이러한 개념을 더 자세히 다룰 것입니다."

#: src/03_ticket_v1/06_ownership.md:84
msgid ""
"For now, though, let's focus on learning how to work within Rust's ownership "
"system."
msgstr ""
"하지만 지금은 Rust의 소유권 시스템 내에서 작업하는 방법을 배우는 데 집중하겠습"
"니다."

#: src/03_ticket_v1/06_ownership.md:86
msgid "The owner"
msgstr "소유자"

#: src/03_ticket_v1/06_ownership.md:88
msgid ""
"In Rust, each value has an **owner**, statically determined at compile-time. "
"There is only one owner for each value at any given time."
msgstr ""
"Rust에서 각 값에는 컴파일 타임에 정적으로 결정되는 **소유자**가 있습니다. 주어"
"진 시간에 각 값에 대한 소유자는 단 한 명뿐입니다."

#: src/03_ticket_v1/06_ownership.md:91
#, fuzzy
msgid "Move semantics"
msgstr "의미론 이동"

#: src/03_ticket_v1/06_ownership.md:93
msgid "Ownership can be transferred."
msgstr "소유권을 이전할 수 있습니다."

#: src/03_ticket_v1/06_ownership.md:95
msgid ""
"If you own a value, for example, you can transfer ownership to another "
"variable:"
msgstr "예를 들어, 값을 소유한 경우 소유권을 다른 변수로 이전할 수 있습니다:"

#: src/03_ticket_v1/06_ownership.md:98
msgid "\"hello, world\""
msgstr "\"hello, world\""

#: src/03_ticket_v1/06_ownership.md:98
msgid "// <--- `a` is the owner of the String\n"
msgstr "// <--- `a` 는 문자열의 소유자입니다\n"

#: src/03_ticket_v1/06_ownership.md:99
msgid "// <--- `b` is now the owner of the String\n"
msgstr "// <--- `b` 는 이제 문자열의 소유자입니다\n"

#: src/03_ticket_v1/06_ownership.md:102
msgid ""
"Rust's ownership system is baked into the type system: each function has to "
"declare in its signature _how_ it wants to interact with its arguments."
msgstr ""
"Rust의 소유권 시스템은 타입 시스템에 적용됩니다. 각 함수는 인수와 상호 작용하"
"는 방법을 시그니처에 선언해야 합니다."

#: src/03_ticket_v1/06_ownership.md:105
msgid ""
"So far, all our methods and functions have **consumed** their arguments: "
"they've taken ownership of them. For example:"
msgstr ""
"지금까지 우리의 모든 메소드와 함수는 인수를 **소비**했습니다. 즉, 인수의 소유"
"권을 얻었습니다. 예시:"

#: src/03_ticket_v1/06_ownership.md:116
msgid ""
"`Ticket::description` takes ownership of the `Ticket` instance it's called "
"on.  \n"
"This is known as **move semantics**: ownership of the value (`self`) is "
"**moved** from the caller to the callee, and the caller can't use it anymore."
msgstr ""
"`Ticket::description`은 호출된 `Ticket` 인스턴스의 소유권을 갖습니다.  \n"
"이를 **move semantics**라고 합니다. 값 (`self`)의 소유권이 호출자에서 호출 수"
"신자로 **이동**하고 호출자는 더 이상 이를 사용할 수 없습니다."

#: src/03_ticket_v1/06_ownership.md:120
msgid ""
"That's exactly the language used by the compiler in the error message we saw "
"earlier:"
msgstr "이는 앞서 본 오류 메시지에서 컴파일러가 사용한 언어와 정확히 같습니다:"

#: src/03_ticket_v1/06_ownership.md:142
msgid ""
"In particular, this is the sequence of events that unfold when we call "
"`ticket.status()`:"
msgstr ""
"특히, 다음은 `ticket.status()`를 호출할 때 펼쳐지는 일련의 이벤트입니다:"

#: src/03_ticket_v1/06_ownership.md:144
msgid "`Ticket::status` takes ownership of the `Ticket` instance"
msgstr "`Ticket::status`는 `Ticket` 인스턴스의 소유권을 갖습니다"

#: src/03_ticket_v1/06_ownership.md:145
msgid ""
"`Ticket::status` extracts `status` from `self` and transfers ownership of "
"`status` back to the caller"
msgstr ""
"`Ticket::status`는 `self`에서 `status`를 추출하고 `status`의 소유권을 호출자에"
"게 다시 이전합니다"

#: src/03_ticket_v1/06_ownership.md:146
msgid ""
"The rest of the `Ticket` instance is discarded (`title` and `description`)"
msgstr "나머지 `Ticket` 인스턴스는 삭제됩니다(`title` 및 `description`)"

#: src/03_ticket_v1/06_ownership.md:148
msgid ""
"When we try to use `ticket` again via `ticket.title()`, the compiler "
"complains: the `ticket` value is gone now, we no longer own it, therefore we "
"can't use it anymore."
msgstr ""
"`ticket.title()`을 통해 `ticket`을 다시 사용하려고 하면 컴파일러는 `ticket` 값"
"이 이제 사라졌고 더 이상 소유하지 않으므로 더 이상 사용할 수 없다고 불평합니"
"다."

#: src/03_ticket_v1/06_ownership.md:151
msgid ""
"To build _useful_ accessor methods we need to start working with "
"**references**."
msgstr "_유용한_ 접근자 메소드를 구축하려면 **참조** 작업을 시작해야 합니다."

#: src/03_ticket_v1/06_ownership.md:153
msgid "Borrowing"
msgstr "차용"

#: src/03_ticket_v1/06_ownership.md:155
msgid ""
"It is desirable to have methods that can read the value of a variable without "
"taking ownership of it.  \n"
"Programming would be quite limited otherwise. In Rust, that's done via "
"**borrowing**."
msgstr ""
"변수의 소유권을 가져오지 않고 변수의 값을 읽을 수 있는 메서드를 갖는 것이 바람"
"직합니다.  \n"
"그렇지 않으면 프로그래밍이 상당히 제한될 것입니다. Rust에서는 **차용**을 통해 "
"이를 수행합니다."

#: src/03_ticket_v1/06_ownership.md:158
msgid ""
"Whenever you borrow a value, you get a **reference** to it.  \n"
"References are tagged with their privileges[^refine]:"
msgstr ""
"값을 빌릴 때마다 해당 가치에 대한 **참조**를 얻게 됩니다.  \n"
"참조에는 해당 권한이 태그로 지정됩니다[^refine]:"

#: src/03_ticket_v1/06_ownership.md:161
msgid ""
"Immutable references (`&`) allow you to read the value, but not to mutate it"
msgstr "불변 참조(`&`)를 사용하면 값을 읽을 수 있지만 변경할 수는 없습니다"

#: src/03_ticket_v1/06_ownership.md:162
msgid "Mutable references (`&mut`) allow you to read and mutate the value"
msgstr "변경 가능한 참조(`&mut`)를 사용하면 값을 읽고 변경할 수 있습니다"

#: src/03_ticket_v1/06_ownership.md:164
msgid "Going back to the goals of Rust's ownership system:"
msgstr "Rust의 소유권 시스템의 목표로 돌아가면:"

#: src/03_ticket_v1/06_ownership.md:169
msgid ""
"To ensure these two properties, Rust has to introduce some restrictions on "
"references:"
msgstr ""
"이 두 가지 속성을 보장하기 위해 Rust는 참조에 몇 가지 제한 사항을 도입해야 합"
"니다:"

#: src/03_ticket_v1/06_ownership.md:171
msgid ""
"You can't have a mutable reference and an immutable reference to the same "
"value at the same time"
msgstr ""
"동일한 값에 대한 변경 가능한 참조와 변경 불가능한 참조를 동시에 가질 수 없습니"
"다"

#: src/03_ticket_v1/06_ownership.md:172
msgid ""
"You can't have more than one mutable reference to the same value at the same "
"time"
msgstr ""
"동일한 값에 대해 동시에 두 개 이상의 변경 가능한 참조를 가질 수 없습니다"

#: src/03_ticket_v1/06_ownership.md:173
msgid "The owner can't mutate the value while it's being borrowed"
msgstr "소유자는 값을 빌리는 동안 값을 변경할 수 없습니다"

#: src/03_ticket_v1/06_ownership.md:174
msgid ""
"You can have as many immutable references as you want, as long as there are "
"no mutable references"
msgstr "변경 가능한 참조가 없는 한 원하는 만큼 불변 참조를 가질 수 있습니다"

#: src/03_ticket_v1/06_ownership.md:176
msgid ""
"In a way, you can think of an immutable reference as a \"read-only\" lock on "
"the value, while a mutable reference is like a \"read-write\" lock."
msgstr ""
"어떤 면에서는 불변 참조를 값에 대한 \"read-only\" 잠금으로 생각할 수 있는 반"
"면, 변경 가능 참조는 \"read-write\" 잠금과 비슷하다고 생각할 수 있습니다."

#: src/03_ticket_v1/06_ownership.md:179
msgid ""
"All these restrictions are enforced at compile-time by the borrow checker."
msgstr "이러한 모든 제한 사항은 차용 검사기에 의해 컴파일 타임에 적용됩니다."

#: src/03_ticket_v1/06_ownership.md:183
msgid ""
"How do you borrow a value, in practice?  \n"
"By adding `&` or `&mut` **in front a variable**, you're borrowing its value. "
"Careful though! The same symbols (`&` and `&mut`) in **front of a type** have "
"a different meaning: they denote a different type, a reference to the "
"original type."
msgstr ""
"실제로 값을 어떻게 빌리나요?  \n"
"변수 앞에 `&` 또는 `&mut`를 추가하면 해당 값을 빌릴 수 있습니다. 그래도 조심하"
"세요! **타입 앞**에 있는 동일한 기호(`&` 및 `&mut`)는 다른 의미를 갖습니다. "
"즉, 원래 타입에 대한 참조인 또 다른 타입을 나타냅니다."

#: src/03_ticket_v1/06_ownership.md:201
msgid ""
"// `b` is a reference to the `version` field of `config`.\n"
"    // The type of `b` is `&u32`, since it contains a reference to a `u32` "
"value.\n"
"    // We create a reference by borrowing `config.version`, using the `&` "
"operator.\n"
"    // Same symbol (`&`), different meaning depending on the context!\n"
msgstr ""
"// `b`는 `config`의 `version` 필드에 대한 참조입니다.\n"
"    // `b`의 타입은 `u32` 값에 대한 참조를 포함하므로 `&u32`입니다.\n"
"    // `&` 연산자를 사용하여 `config.version`을 빌려 참조를 생성합니다.\n"
"    // 같은 기호(`&`), 상황에 따라 다른 의미!\n"

#: src/03_ticket_v1/06_ownership.md:206
msgid ""
"//     ^ The type annotation is not necessary, \n"
"    //       it's just there to clarify what's going on\n"
msgstr ""
"//     ^ 타입 어노테이션은 중요하지 않습니다.\n"
"    //       단지 무슨 일이 일어나고 있는지 명확히 하기 위해 존재합니다.\n"

#: src/03_ticket_v1/06_ownership.md:211
msgid "The same concept applies to function arguments and return types:"
msgstr "함수 인수와 반환 유형에도 동일한 개념이 적용됩니다:"

#: src/03_ticket_v1/06_ownership.md:214
msgid ""
"// `f` takes a mutable reference to a `u32` as an argument, \n"
"// bound to the name `number`\n"
msgstr ""
"// `f`는 `u32`에 대한 변경 가능한 참조를 인수로 사용하고\n"
"// `number`라는 이름에 바인딩됩니다\n"

#: src/03_ticket_v1/06_ownership.md:221
msgid "Breathe in, breathe out"
msgstr "진정하고 심호흡하세요"

#: src/03_ticket_v1/06_ownership.md:223
msgid ""
"Rust's ownership system can be a bit overwhelming at first.  \n"
"But don't worry: it'll become second nature with practice.  \n"
"And you're going to get a lot of practice over the rest of this chapter, as "
"well as the rest of the course! We'll revisit each concept multiple times to "
"make sure you get familiar with them and truly understand how they work."
msgstr ""
"Rust의 소유권 시스템은 처음에는 다소 부담스러울 수 있습니다.  \n"
"하지만 걱정하지 마십시오. 연습을 하면 자연스럽게 익숙해질 것입니다.  \n"
"그리고 이 장의 나머지 부분과 과정의 나머지 부분에 걸쳐 많은 연습을 하게 될 것"
"입니다! 우리는 각 개념을 여러 번 재검토하여 여러분이 개념에 익숙해지고 작동 방"
"식을 진정으로 이해할 수 있도록 할 것입니다."

#: src/03_ticket_v1/06_ownership.md:229
msgid ""
"Towards the end of this chapter we'll explain _why_ Rust's ownership system "
"is designed the way it is. For the time being, focus on understanding the "
"_how_. Take each compiler error as a learning opportunity!"
msgstr ""
"이 장의 마지막 부분에서 우리는 Rust의 소유권 시스템이 그런 방식으로 설계된 _이"
"유_를 설명할 것입니다. 당분간은 _어떻게_를 이해하는 데 집중하세요. 각각의 컴파"
"일러 오류를 학습 기회로 삼으세요!"

#: src/03_ticket_v1/06_ownership.md:232
msgid ""
"This is a great mental model to start out, but it doesn't capture the _full_ "
"picture. We'll refine our understanding of references [later in the course]"
"(../07_threads/06_interior_mutability.md)."
msgstr ""
"이것은 시작하기에 훌륭한 정신적 모델이지만 _전체_ 그림을 포착하지는 못합니다. "
"[이 코스의 뒷부분](../07_threads/06_interior_mutability.md)에서 참조에 대한 이"
"해를 더욱 구체화할 것입니다."

#: src/03_ticket_v1/06_ownership.md:237
msgid ""
"The exercise for this section is located in [`03_ticket_v1/06_ownership`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/06_ownership)"
msgstr ""
"이 섹션의 예제는 [`03_ticket_v1/06_ownership`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/06_ownership)에 있습니다"

#: src/03_ticket_v1/07_setters.md:1
msgid "Mutable references"
msgstr "변경 가능한 참조"

#: src/03_ticket_v1/07_setters.md:3
msgid "Your accessor methods should look like this now:"
msgstr "이제 접근자 메서드는 다음과 같아야 합니다:"

#: src/03_ticket_v1/07_setters.md:21
msgid ""
"A sprinkle of `&` here and there did the trick!  \n"
"We now have a way to access the fields of a `Ticket` instance without "
"consuming it in the process. Let's see how we can enhance our `Ticket` struct "
"with **setter methods** next."
msgstr ""
"여기저기에 `&`를 뿌리면 효과가 있습니다!  \n"
"이제 프로세스에서 이를 사용하지 않고 `Ticket` 인스턴스의 필드에 액세스할 수 있"
"는 방법이 있습니다. 다음에는 **setter 메서드**를 사용하여 `Ticket` 구조체를 어"
"떻게 개선할 수 있는지 살펴보겠습니다."

#: src/03_ticket_v1/07_setters.md:27
msgid ""
"Setter methods allow users to change the values of `Ticket`'s private fields "
"while making sure that its invariants are respected (i.e. you can't set a "
"`Ticket`'s title to an empty string)."
msgstr ""
"Setter 메서드를 사용하면 사용자는 `Ticket`의 비공개 필드 값을 변경하는 동시에 "
"해당 불변성을 준수할 수 있습니다(예: `Ticket` 제목을 빈 문자열로 설정할 수 없"
"음)."

#: src/03_ticket_v1/07_setters.md:30
msgid "There are two common ways to implement setters in Rust:"
msgstr "Rust에서 setter를 구현하는 두 가지 일반적인 방법이 있습니다:"

#: src/03_ticket_v1/07_setters.md:32
msgid "Taking `self` as input."
msgstr "`self`를 인풋으로 받기."

#: src/03_ticket_v1/07_setters.md:33
msgid "Taking `&mut self` as input."
msgstr "`&mut self`를 인풋으로 받기."

#: src/03_ticket_v1/07_setters.md:35
msgid "Taking `self` as input"
msgstr "'self'를 인풋으로 받기"

#: src/03_ticket_v1/07_setters.md:37
msgid "The first approach looks like this:"
msgstr "첫 번째 접근 방식은 다음과 같습니다:"

#: src/03_ticket_v1/07_setters.md:42 src/03_ticket_v1/07_setters.md:78
msgid "// Validate the new title [...]\n"
msgstr "// 새 제목 검증 [...]\n"

#: src/03_ticket_v1/07_setters.md:49
msgid ""
"It takes ownership of `self`, changes the title, and returns the modified "
"`Ticket` instance.  \n"
"This is how you'd use it:"
msgstr ""
"`self`의 소유권을 가져와 제목을 변경하고 수정된 `Ticket` 인스턴스를 반환합니"
"다.  \n"
"사용 방법은 다음과 같습니다:"

#: src/03_ticket_v1/07_setters.md:53 src/03_ticket_v1/07_setters.md:91
msgid "\"Title\""
msgstr "\"Title\""

#: src/03_ticket_v1/07_setters.md:53 src/03_ticket_v1/07_setters.md:91
msgid "\"Description\""
msgstr "\"Description\""

#: src/03_ticket_v1/07_setters.md:54 src/03_ticket_v1/07_setters.md:66
#: src/03_ticket_v1/07_setters.md:92 src/03_ticket_v1/07_setters.md:105
msgid "\"New title\""
msgstr "\"New title\""

#: src/03_ticket_v1/07_setters.md:57
msgid ""
"Since `set_title` takes ownership of `self` (i.e. it **consumes it**), we "
"need to reassign the result to a variable. In the example above we take "
"advantage of **variable shadowing** to reuse the same variable name: when you "
"declare a new variable with the same name as an existing one, the new "
"variable **shadows** the old one. This is a common pattern in Rust code."
msgstr ""
"`set_title`은 `self`의 소유권을 갖기 때문에(즉 **소비**) 결과를 변수에 다시 할"
"당해야 합니다. 위의 예에서는 **변수 섀도잉**을 활용하여 동일한 변수 이름을 재"
"사용합니다. 기존 변수와 동일한 이름으로 새 변수를 선언하면 새 변수가 이전 변수"
"를 **섀도우**합니다. 이는 Rust 코드의 일반적인 패턴입니다."

#: src/03_ticket_v1/07_setters.md:62
msgid ""
"`self`\\-setters work quite nicely when you need to change multiple fields at "
"once: you can chain multiple calls together!"
msgstr ""
"`self`\\-setter는 여러 필드를 한 번에 변경해야 할 때 아주 잘 작동합니다. 여러 "
"호출을 함께 연결할 수 있습니다!"

#: src/03_ticket_v1/07_setters.md:67 src/03_ticket_v1/07_setters.md:106
msgid "\"New description\""
msgstr "\"New description\""

#: src/03_ticket_v1/07_setters.md:68 src/03_ticket_v1/07_setters.md:107
msgid "\"In Progress\""
msgstr "\"In Progress\""

#: src/03_ticket_v1/07_setters.md:71
msgid "Taking `&mut self` as input"
msgstr "`&mut self`를 인풋으로 받기"

#: src/03_ticket_v1/07_setters.md:73
msgid ""
"The second approach to setters, using `&mut self`, looks like this instead:"
msgstr ""
"`&mut self`를 사용하는 세터에 대한 두 번째 접근 방식은 대신 다음과 같습니다:"

#: src/03_ticket_v1/07_setters.md:85
msgid ""
"This time the method takes a mutable reference to `self` as input, changes "
"the title, and that's it. Nothing is returned."
msgstr ""
"이번에는 메서드가 'self'에 대한 변경 가능한 참조를 입력으로 사용하고 제목을 변"
"경하면 그게 전부입니다. 아무것도 반환되지 않습니다."

#: src/03_ticket_v1/07_setters.md:88
msgid "You'd use it like this:"
msgstr "다음과 같이 사용할 수 있습니다:"

#: src/03_ticket_v1/07_setters.md:93
msgid "// Use the modified ticket\n"
msgstr "// 수정된 티켓 사용\n"

#: src/03_ticket_v1/07_setters.md:97
msgid ""
"Ownership stays with the caller, so the original `ticket` variable is still "
"valid. We don't need to reassign the result. We need to mark `ticket` as "
"mutable though, because we're taking a mutable reference to it."
msgstr ""
"소유권은 호출자에게 있으므로 원래 `ticket` 변수는 여전히 유효합니다. 결과를 다"
"시 할당할 필요는 없습니다. 하지만 `ticket`에 대한 변경 가능한 참조를 사용하고 "
"있으므로 변경 가능으로 표시해야 합니다."

#: src/03_ticket_v1/07_setters.md:100
msgid ""
"`&mut`\\-setters have a downside: you can't chain multiple calls together. "
"Since they don't return the modified `Ticket` instance, you can't call "
"another setter on the result of the first one. You have to call each setter "
"separately:"
msgstr ""
"`&mut`\\-setter에는 단점이 있습니다. 여러 호출을 함께 연결할 수 없습니다. 수정"
"된 `Ticket` 인스턴스를 반환하지 않으므로 첫 번째 결과에 대해 다른 setter를 호"
"출할 수 없습니다. 각 setter를 별도로 호출해야 합니다:"

#: src/03_ticket_v1/07_setters.md:112
msgid ""
"The exercise for this section is located in [`03_ticket_v1/07_setters`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/07_setters)"
msgstr ""
"이 섹션의 예제는 [`03_ticket_v1/07_setters`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/07_setters)에 있습니다"

#: src/03_ticket_v1/08_stack.md:1 src/04_traits/06_str_slice.md:17
#: src/06_ticket_management/02_vec.md:71
#: src/06_ticket_management/10_slices.md:55
msgid "Memory layout"
msgstr "메모리 레이아웃"

#: src/03_ticket_v1/08_stack.md:3
msgid ""
"We've looked at ownership and references from an operational point of view—"
"what you can and can't do with them. Now it's a good time to take a look "
"under the hood: let's talk about **memory**."
msgstr ""
"우리는 운영 관점에서 소유권과 참조를 살펴보았습니다. 즉, 이를 사용하여 무엇을 "
"할 수 있고 무엇을 할 수 없는지 살펴보았습니다. 이제 내부를 살펴볼 좋은 시간입"
"니다. **메모리**에 대해 이야기해 보겠습니다."

#: src/03_ticket_v1/08_stack.md:6
msgid "Stack and heap"
msgstr "스택과 힙"

#: src/03_ticket_v1/08_stack.md:8
msgid ""
"When discussing memory, you'll often hear people talk about the **stack** and "
"the **heap**.  \n"
"These are two different memory regions used by programs to store data."
msgstr ""
"메모리에 관해 논의할 때 사람들이 **스택**과 **힙**에 관해 이야기하는 것을 자"
"주 듣게 됩니다.  \n"
"이는 프로그램에서 데이터를 저장하는 데 사용되는 두 가지 다른 메모리 영역입니"
"다."

#: src/03_ticket_v1/08_stack.md:11
msgid "Let's start with the stack."
msgstr "스택부터 시작해 보겠습니다."

#: src/03_ticket_v1/08_stack.md:15
msgid ""
"The **stack** is a **LIFO** (Last In, First Out) data structure.  \n"
"When you call a function, a new **stack frame** is added on top of the stack. "
"That stack frame stores the function's arguments, local variables and a few "
"\"bookkeeping\" values.  \n"
"When the function returns, the stack frame is popped off the stack[^stack-"
"overflow]."
msgstr ""
"**스택**은 **LIFO**(Last In, First Out) 데이터 구조입니다.  \n"
"함수를 호출하면 새로운 **스택 프레임**이 스택 위에 추가됩니다. 해당 스택 프레"
"임은 함수의 인수, 로컬 변수와 몇 가지 \"부가적인\" 값을 저장합니다.  \n"
"함수가 반환되면 스택 프레임이 스택에서 팝됩니다[^stack-overflow]."

#: src/03_ticket_v1/08_stack.md:28
msgid ""
"From an operational point of view, stack allocation/de-allocation is **very "
"fast**.  \n"
"We are always pushing and popping data from the top of the stack, so we don't "
"need to search for free memory. We also don't have to worry about "
"fragmentation: the stack is a single contiguous block of memory."
msgstr ""
"운영 관점에서 스택 할당/할당 해제는 **매우 빠릅니다**.  \n"
"우리는 항상 스택 상단에서 데이터를 푸시하고 팝하므로 여유 메모리를 검색할 필요"
"가 없습니다. 또한 조각화에 대해 걱정할 필요가 없습니다. 스택은 단일 연속 메모"
"리 블록입니다."

#: src/03_ticket_v1/08_stack.md:32
msgid "Rust"
msgstr "Rust"

#: src/03_ticket_v1/08_stack.md:34
msgid ""
"Rust will often allocate data on the stack.  \n"
"You have a `u32` input argument in a function? Those 32 bits will be on the "
"stack.  \n"
"You define a local variable of type `i64`? Those 64 bits will be on the "
"stack.  \n"
"It all works quite nicely because the size of those integers is known at "
"compile time, therefore the compiled program knows how much space it needs to "
"reserve on the stack for them."
msgstr ""
"Rust는 종종 스택에 데이터를 할당합니다.  \n"
"함수에 'u32' 입력 인수가 있나요? 해당 32비트는 스택에 저장됩니다.  \n"
"`i64` 타입의 로컬 변수를 정의하시겠습니까? 해당 64비트는 스택에 저장됩니"
"다.  \n"
"이러한 정수의 크기는 컴파일 타임에 알려지기 때문에 모든 것이 매우 잘 작동합니"
"다. 따라서 컴파일된 프로그램은 이를 위해 스택에 예약해야 하는 공간의 양을 알"
"고 있습니다."

#: src/03_ticket_v1/08_stack.md:40
msgid "`std::mem::size_of`"
msgstr "`std::mem::size_of`"

#: src/03_ticket_v1/08_stack.md:42
msgid ""
"You can verify how much space a type would take on the stack using the [`std::"
"mem::size_of`](https://doc.rust-lang.org/std/mem/fn.size_of.html) function."
msgstr ""
"[`std::mem::size_of`](https://doc.rust-lang.org/std/mem/fn.size_of.html) 함수"
"를 사용하여 유형이 스택에서 차지하는 공간을 확인할 수 있습니다."

#: src/03_ticket_v1/08_stack.md:45
msgid "For a `u8`, for example:"
msgstr "예를 들어 'u8'의 경우:"

#: src/03_ticket_v1/08_stack.md:48
msgid ""
"// We'll explain this funny-looking syntax (`::<u8>`) later on.\n"
"// Ignore it for now.\n"
msgstr ""
"// 이 재미있어 보이는 구문(`::<u8>`)에 대해서는 나중에 설명하겠습니다.\n"
"// 지금은 무시하세요.\n"

#: src/03_ticket_v1/08_stack.md:53
msgid "1 makes sense, because a `u8` is 8 bits long, or 1 byte."
msgstr "'u8'의 길이가 8비트, 즉 1바이트이기 때문에 1이 말이 됩니다."

#: src/03_ticket_v1/08_stack.md:55
msgid ""
"If you have nested function calls, each function pushes its data onto the "
"stack when it's called but it doesn't pop it off until the innermost function "
"returns. If you have too many nested function calls, you can run out of stack "
"space—the stack is not infinite! That's called a [**stack overflow**](https://"
"en.wikipedia.org/wiki/Stack_overflow)."
msgstr ""
"중첩된 함수 호출이 있는 경우 각 함수는 호출될 때 해당 데이터를 스택에 푸시하지"
"만 가장 안쪽 함수가 반환될 때까지 데이터를 팝하지 않습니다. 중첩된 함수 호출"
"이 너무 많으면 스택 공간이 부족해질 수 있습니다. 스택은 무한하지 않습니다! 이"
"를 **스택 오버플로**라고 합니다."

#: src/03_ticket_v1/08_stack.md:62
msgid ""
"The exercise for this section is located in [`03_ticket_v1/08_stack`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/08_stack)"
msgstr ""
"이 섹션의 예제는 [`03_ticket_v1/08_stack`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/08_stack)에 있습니다"

#: src/03_ticket_v1/09_heap.md:3
msgid ""
"The stack is great, but it can't solve all our problems. What about data "
"whose size is not known at compile time? Collections, strings, and other "
"dynamically-sized data cannot be (entirely) stack-allocated. That's where the "
"**heap** comes in."
msgstr ""
"스택은 훌륭하지만 모든 문제를 해결할 수는 없습니다. 컴파일 타임에 크기를 알 "
"수 없는 데이터는 어떻게 되나요? 컬렉션, 문자열 및 기타 동적으로 크기가 조정된 "
"데이터는 (전체) 스택에 할당될 수 없습니다. **힙**이 필요한 곳이 바로 여기입니"
"다."

#: src/03_ticket_v1/09_heap.md:7
msgid "Heap allocations"
msgstr "힙 할당"

#: src/03_ticket_v1/09_heap.md:9
msgid ""
"You can visualize the heap as a big chunk of memory—a huge array, if you "
"will.  \n"
"Whenever you need to store data on the heap, you ask a special program, the "
"**allocator**, to reserve for you a subset of the heap. We call this "
"interaction (and the memory you reserved) a **heap allocation**. If the "
"allocation succeeds, the allocator will give you a **pointer** to the start "
"of the reserved block."
msgstr ""
"힙을 큰 메모리 덩어리, 즉 거대한 배열로 시각화할 수 있습니다.  \n"
"힙에 데이터를 저장해야 할 때마다 특수 프로그램인 **할당자**에 요청하여 힙의 하"
"위 집합을 예약합니다. 우리는 이 상호 작용(및 예약한 메모리)을 **힙 할당**이라"
"고 부릅니다. 할당이 성공하면 할당자는 예약된 블록의 시작에 대한 **포인터**를 "
"제공합니다."

#: src/03_ticket_v1/09_heap.md:14
msgid "No automatic de-allocation"
msgstr "자동 할당 해제 없음"

#: src/03_ticket_v1/09_heap.md:16
msgid ""
"The heap is structured quite differently from the stack.  \n"
"Heap allocations are not contiguous, they can be located anywhere inside the "
"heap."
msgstr ""
"힙은 스택과 구조가 상당히 다릅니다.  \n"
"힙 할당은 연속적이지 않으며 힙 내부 어디에나 위치할 수 있습니다."

#: src/03_ticket_v1/09_heap.md:25
msgid ""
"It's the allocator's job to keep track of which parts of the heap are in use "
"and which are free. The allocator won't automatically free the memory you "
"allocated, though: you need to be deliberate about it, calling the allocator "
"again to **free** the memory you no longer need."
msgstr ""
"힙의 어느 부분이 사용 중이고 어느 부분이 사용 가능한지 추적하는 것이 할당자의 "
"임무입니다. 그러나 할당자는 할당한 메모리를 자동으로 해제하지 않습니다. 더 이"
"상 필요하지 않은 메모리를 **해제**하려면 할당자를 다시 호출하여 이에 대해 신중"
"하게 생각해야 합니다."

#: src/03_ticket_v1/09_heap.md:29 src/06_ticket_management/01_arrays.md:62
msgid "Performance"
msgstr "성능"

#: src/03_ticket_v1/09_heap.md:31
msgid ""
"The heap's flexibility comes at a cost: heap allocations are **slower** than "
"stack allocations. There's a lot more bookkeeping involved!  \n"
"If you read articles about performance optimization you'll often be advised "
"to minimize heap allocations and prefer stack-allocated data whenever "
"possible."
msgstr ""
"힙의 유연성에는 비용이 따릅니다. 힙 할당은 스택 할당보다 **느립니다**. 장부에 "
"관련된 일이 훨씬 더 많습니다!  \n"
"성능 최적화에 대한 기사를 읽으면 가능하면 힙 할당을 최소화하고 스택 할당 데이"
"터를 선호하는 것이 좋습니다."

#: src/03_ticket_v1/09_heap.md:36
msgid "`String`'s memory layout"
msgstr "`String`의 메모리 레이아웃"

#: src/03_ticket_v1/09_heap.md:38
msgid ""
"When you create a local variable of type `String`, Rust is forced to allocate "
"on the heap[^empty]: it doesn't know in advance how much text you're going to "
"put in it, so it can't reserve the right amount of space on the stack.  \n"
"But a `String` is not _entirely_ heap-allocated, it also keeps some data on "
"the stack. In particular:"
msgstr ""
"`String` 타입의 로컬 변수를 만들 때 Rust는 강제로 힙에 할당합니다[^empty]: 거"
"기에 얼마나 많은 텍스트를 넣을지 미리 알지 못하므로 예약할 수 없습니다. 스택"
"에 적절한 양의 공간이 있습니다.  \n"
"하지만 `String`은 _완전히_ 힙에 할당되지 않으며 일부 데이터를 스택에 유지하기"
"도 합니다. 특히:"

#: src/03_ticket_v1/09_heap.md:43 src/06_ticket_management/02_vec.md:101
msgid "The **pointer** to the heap region you reserved."
msgstr "예약한 힙 영역에 대한 **포인터**."

#: src/03_ticket_v1/09_heap.md:44
msgid "The **length** of the string, i.e. how many bytes are in the string."
msgstr "문자열의 **길이**, 즉 문자열에 몇 바이트가 있는지 나타냅니다."

#: src/03_ticket_v1/09_heap.md:45
msgid ""
"The **capacity** of the string, i.e. how many bytes have been reserved on the "
"heap."
msgstr "문자열의 **용량**, 즉 힙에 예약된 바이트 수입니다."

#: src/03_ticket_v1/09_heap.md:47
msgid "Let's look at an example to understand this better:"
msgstr "이를 더 잘 이해하기 위해 예를 살펴보겠습니다:"

#: src/03_ticket_v1/09_heap.md:53
msgid "If you run this code, memory will be laid out like this:"
msgstr "이 코드를 실행하면 메모리가 다음과 같이 배치됩니다:"

#: src/03_ticket_v1/09_heap.md:68
msgid ""
"We asked for a `String` that can hold up to 5 bytes of text.  \n"
"`String::with_capacity` goes to the allocator and asks for 5 bytes of heap "
"memory. The allocator returns a pointer to the start of that memory block.  \n"
"The `String` is empty, though. On the stack, we keep track of this "
"information by distinguishing between the length and the capacity: this "
"`String` can hold up to 5 bytes, but it currently holds 0 bytes of actual "
"text."
msgstr ""
"우리는 최대 5바이트의 텍스트를 담을 수 있는 `String`을 요청했습니다.  \n"
"`String::with_capacity`는 할당자로 가서 5바이트의 힙 메모리를 요청합니다. 할당"
"자는 해당 메모리 블록의 시작에 대한 포인터를 반환합니다.  \n"
"하지만 `String`은 비어 있습니다. 스택에서는 길이와 용량을 구별하여 이 정보를 "
"추적합니다. 이 `String`은 최대 5바이트를 저장할 수 있지만 현재 실제 텍스트는 0"
"바이트를 포함합니다."

#: src/03_ticket_v1/09_heap.md:75
msgid "If you push some text into the `String`, the situation will change:"
msgstr "일부 텍스트를 `String`에 넣으면 상황이 변경됩니다:"

#: src/03_ticket_v1/09_heap.md:78 src/03_ticket_v1/10_references_in_memory.md:19
msgid "\"Hey\""
msgstr "\"Hey\""

#: src/03_ticket_v1/09_heap.md:94
msgid ""
"`s` now holds 3 bytes of text. Its length is updated to 3, but capacity "
"remains 5. Three of the five bytes on the heap are used to store the "
"characters `H`, `e`, and `y`."
msgstr ""
"`s`는 이제 3바이트의 텍스트를 보유합니다. 길이는 3으로 업데이트되지만 용량은 5"
"로 유지됩니다. 힙의 5바이트 ​​중 3바이트는 `H`, `e` 및 `y` 문자를 저장하는 데 사"
"용됩니다."

#: src/03_ticket_v1/09_heap.md:97
msgid "`usize`"
msgstr "`usize`"

#: src/03_ticket_v1/09_heap.md:99
msgid ""
"How much space do we need to store pointer, length and capacity on the "
"stack?  \n"
"It depends on the **architecture** of the machine you're running on."
msgstr ""
"스택에 포인터, 길이 및 용량을 저장하려면 얼마나 많은 공간이 필요합니까?  \n"
"실행 중인 머신의 **아키텍처**에 따라 다릅니다."

#: src/03_ticket_v1/09_heap.md:102
msgid ""
"Every memory location on your machine has an [**address**](https://en."
"wikipedia.org/wiki/Memory_address), commonly represented as an unsigned "
"integer. Depending on the maximum size of the address space (i.e. how much "
"memory your machine can address), this integer can have a different size. "
"Most modern machines use either a 32-bit or a 64-bit address space."
msgstr ""
"컴퓨터의 모든 메모리 위치에는 일반적으로 부호 없는 정수로 표시되는 [**주소**]"
"(https://en.wikipedia.org/wiki/Memory_address)가 있습니다. 주소 공간의 최대 크"
"기(즉, 컴퓨터가 주소를 지정할 수 있는 메모리 양)에 따라 이 정수의 크기가 다를 "
"수 있습니다. 대부분의 최신 컴퓨터는 32비트 또는 64비트 주소 공간을 사용합니다."

#: src/03_ticket_v1/09_heap.md:107
msgid ""
"Rust abstracts away these architecture-specific details by providing the "
"`usize` type: an unsigned integer that's as big as the number of bytes needed "
"to address memory on your machine. On a 32-bit machine, `usize` is equivalent "
"to `u32`. On a 64-bit machine, it matches `u64`."
msgstr ""
"Rust는 `usize` 유형을 제공하여 이러한 아키텍처별 세부 정보를 추상화합니다. 이"
"는 머신의 메모리 주소를 지정하는 데 필요한 바이트 수만큼 큰 부호 없는 정수입니"
"다. 32비트 시스템에서 `usize`는 `u32`와 동일합니다. 64비트 시스템에서는 "
"'u64'와 일치합니다."

#: src/03_ticket_v1/09_heap.md:111
msgid ""
"Capacity, length and pointers are all represented as `usize`s in "
"Rust[^equivalence]."
msgstr "용량, 길이, 포인터는 모두 Rust[^equivalence]에서 `usize`로 표시됩니다."

#: src/03_ticket_v1/09_heap.md:113
msgid "No `std::mem::size_of` for the heap"
msgstr "힙에는 `std::mem::size_of`가 없습니다"

#: src/03_ticket_v1/09_heap.md:115
msgid ""
"`std::mem::size_of` returns the amount of space a type would take on the "
"stack, which is also known as the **size of the type**."
msgstr ""
"`std::mem::size_of`는 타입이 스택에서 차지할 공간의 양을 반환하며, 이는 **타입"
"의 크기**라고도 알려져 있습니다."

#: src/03_ticket_v1/09_heap.md:118
msgid ""
"What about the memory buffer that `String` is managing on the heap? Isn't "
"that part of the size of `String`?"
msgstr ""
"`String`이 힙에서 관리하는 메모리 버퍼는 어떻습니까? 그것은 `String` 크기의 일"
"부가 아닐까요?"

#: src/03_ticket_v1/09_heap.md:121
msgid ""
"No!  \n"
"That heap allocation is a **resource** that `String` is managing. It's not "
"considered to be part of the `String` type by the compiler."
msgstr ""
"아니요!  \n"
"해당 힙 할당은 `String`이 관리하는 **리소스**입니다. 컴파일러는 `String` 유형"
"의 일부로 간주하지 않습니다."

#: src/03_ticket_v1/09_heap.md:125
msgid ""
"`std::mem::size_of` doesn't know (or care) about additional heap-allocated "
"data that a type might manage or refer to via pointers, as is the case with "
"`String`, therefore it doesn't track its size."
msgstr ""
"`std::mem::size_of`는 `String`의 경우처럼 유형이 포인터를 통해 관리하거나 참조"
"할 수 있는 추가 힙 할당 데이터에 대해 알지(또는 신경 쓰지) 않으므로 해당 데이"
"터의 크기를 추적하지 않습니다."

#: src/03_ticket_v1/09_heap.md:129
msgid ""
"Unfortunately there is no equivalent of `std::mem::size_of` to measure the "
"amount of heap memory that a certain value is allocating at runtime. Some "
"types might provide methods to inspect their heap usage (e.g. `String`'s "
"`capacity` method), but there is no general-purpose \"API\" to retrieve "
"runtime heap usage in Rust.  \n"
"You can, however, use a memory profiler tool (e.g. [DHAT](https://valgrind."
"org/docs/manual/dh-manual.html) or [a custom allocator](https://docs.rs/dhat/"
"latest/dhat/)) to inspect the heap usage of your program."
msgstr ""
"불행하게도 특정 값이 런타임에 할당하는 힙 메모리의 양을 측정하는 `std::mem::"
"size_of`와 동등한 것은 없습니다. 일부 유형은 힙 사용량을 검사하는 메서드(예: "
"`String`의 `capacity` 메서드)를 제공할 수 있지만 Rust에는 런타임 힙 사용량을 "
"검색하는 범용 \"API\"가 없습니다.  \n"
"그러나 메모리 프로파일러 도구(예: DHAT 또는 사용자 정의 할당자)를 사용하여 프"
"로그램의 힙 사용량을 검사할 수 있습니다."

#: src/03_ticket_v1/09_heap.md:136
msgid ""
"`std` doesn't allocate if you create an **empty** `String` (i.e. `String::"
"new()`). Heap memory will be reserved when you push data into it for the "
"first time."
msgstr ""
"**빈** `String`(예: `String::new()`)을 생성하면 `std`는 힙을 할당하지 않습니"
"다. 힙 메모리는 처음으로 데이터를 푸시할 때 예약됩니다."

#: src/03_ticket_v1/09_heap.md:139
msgid ""
"The size of a pointer depends on the operating system too. In certain "
"environments, a pointer is **larger** than a memory address (e.g. [CHERI]"
"(https://blog.acolyer.org/2019/05/28/cheri-abi/)). Rust makes the simplifying "
"assumption that pointers are the same size as memory addresses, which is true "
"for most modern systems you're likely to encounter."
msgstr ""
"포인터의 크기는 운영 체제에 따라 다릅니다. 특정 환경에서는 포인터가 메모리 주"
"소(예: CHERI)보다 **더 큽니다**. Rust는 포인터가 메모리 주소와 동일한 크기라"
"는 단순화된 가정을 하고 있으며, 이는 여러분이 접하게 될 대부분의 최신 시스템"
"에 해당됩니다."

#: src/03_ticket_v1/09_heap.md:146
msgid ""
"The exercise for this section is located in [`03_ticket_v1/09_heap`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/09_heap)"
msgstr ""
"이 섹션의 예제는 [`03_ticket_v1/09_heap`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/09_heap)에 있습니다"

#: src/03_ticket_v1/10_references_in_memory.md:1
#: src/06_ticket_management/06_lifetimes.md:80
msgid "References"
msgstr "참조"

#: src/03_ticket_v1/10_references_in_memory.md:3
msgid ""
"What about references, like `&String` or `&mut String`? How are they "
"represented in memory?"
msgstr ""
"`&String` 또는 `&mut String`과 같은 참조는 어떨까요? 메모리에서 어떻게 표현될"
"까요?"

#: src/03_ticket_v1/10_references_in_memory.md:5
msgid ""
"Most references[^fat] in Rust are represented, in memory, as a pointer to a "
"memory location.  \n"
"It follows that their size is the same as the size of a pointer, a `usize`."
msgstr ""
"Rust에서 대부분의 참조[^fat]는 메모리에서 메모리 위치에 대한 포인터로 표시됩니"
"다.  \n"
"그 크기는 포인터의 크기인 `usize`와 동일합니다."

#: src/03_ticket_v1/10_references_in_memory.md:8
msgid "You can verify this using `std::mem::size_of`:"
msgstr "`std::mem::size_of`를 사용하여 이를 확인할 수 있습니다:"

#: src/03_ticket_v1/10_references_in_memory.md:15
msgid ""
"A `&String`, in particular, is a pointer to the memory location where the "
"`String`'s metadata is stored.  \n"
"If you run this snippet:"
msgstr ""
"특히 `&String`은 `String`의 메타데이터가 저장되는 메모리 위치에 대한 포인터입"
"니다.  \n"
"이 스니펫을 실행하면:"

#: src/03_ticket_v1/10_references_in_memory.md:23
msgid "you'll get something like this in memory:"
msgstr "메모리에 다음과 같은 내용이 표시됩니다:"

#: src/03_ticket_v1/10_references_in_memory.md:40
msgid ""
"It's a pointer to a pointer to the heap-allocated data, if you will. The same "
"goes for `&mut String`."
msgstr ""
"원한다면 힙 할당 데이터에 대한 포인터에 대한 포인터입니다. `&mut String`도 마"
"찬가지입니다."

#: src/03_ticket_v1/10_references_in_memory.md:43
msgid "Not all pointers point to the heap"
msgstr "모든 포인터가 힙을 가리키는 것은 아닙니다"

#: src/03_ticket_v1/10_references_in_memory.md:45
msgid ""
"The example above should clarify one thing: not all pointers point to the "
"heap.  \n"
"They just point to a memory location, which _may_ be on the heap, but doesn't "
"have to be."
msgstr ""
"위의 예에서는 한 가지를 명확히 해야 합니다. 모든 포인터가 힙을 가리키는 것은 "
"아닙니다.  \n"
"그들은 단지 힙에 있을 수도 있지만 반드시 그럴 필요는 없는 메모리 위치를 가리"
"킬 뿐입니다."

#: src/03_ticket_v1/10_references_in_memory.md:48
msgid ""
"[Later in the course](../04_traits/06_str_slice.md) we'll talk about **fat "
"pointers**, i.e. pointers with additional metadata. As the name implies, they "
"are larger than the pointers we discussed in this chapter, also known as "
"**thin pointers**."
msgstr ""
"[이 코스의 뒷부분](../04_traits/06_str_slice.md)에서는 **팻 포인터**, 즉 추가 "
"메타데이터가 포함된 포인터에 대해 설명하겠습니다. 이름에서 알 수 있듯이 이 장"
"에서 논의한 포인터(**얇은 포인터**라고도 함)보다 큽니다."

#: src/03_ticket_v1/10_references_in_memory.md:54
msgid ""
"The exercise for this section is located in "
"[`03_ticket_v1/10_references_in_memory`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/10_references_in_memory)"
msgstr ""
"이 섹션의 예제는 [`03_ticket_v1/10_references_in_memory`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/10_references_in_memory)에 있습니다"

#: src/03_ticket_v1/11_destructor.md:3
msgid ""
"When introducing the heap, we mentioned that you're responsible for freeing "
"the memory you allocate.  \n"
"When introducing the borrow-checker, we also stated that you rarely have to "
"manage memory directly in Rust."
msgstr ""
"힙을 소개할 때 할당한 메모리를 해제할 책임은 사용자에게 있다고 언급했습니"
"다.  \n"
"차용 검사기를 소개할 때 우리는 Rust에서 직접 메모리를 관리할 필요가 거의 없다"
"고 언급했습니다."

#: src/03_ticket_v1/11_destructor.md:6
msgid ""
"These two statements might seem contradictory at first. Let's see how they "
"fit together by introducing **scopes** and **destructors**."
msgstr ""
"이 두 진술은 처음에는 모순되는 것처럼 보일 수 있습니다. **범위**와 **소멸자**"
"를 도입하여 이들이 어떻게 조화를 이루는지 살펴보겠습니다."

#: src/03_ticket_v1/11_destructor.md:9
msgid "Scopes"
msgstr "스코프"

#: src/03_ticket_v1/11_destructor.md:11
msgid ""
"The **scope** of a variable is the region of Rust code where that variable is "
"valid, or **alive**."
msgstr ""
"변수의 **스코프**는 해당 변수가 유효하거나 **살아있는** Rust 코드의 영역입니"
"다."

#: src/03_ticket_v1/11_destructor.md:13
msgid ""
"The scope of a variable starts with its declaration. It ends when one of the "
"following happens:"
msgstr "변수의 범위는 선언부터 시작됩니다. 다음 중 하나가 발생하면 종료됩니다:"

#: src/03_ticket_v1/11_destructor.md:16
msgid ""
"the block (i.e. the code between `{}`) where the variable was declared ends"
msgstr "변수가 선언된 블록(즉 `{}` 사이의 코드)이 끝날 "

#: src/03_ticket_v1/11_destructor.md:19
msgid "// `x` is not yet in scope here\n"
msgstr "// `x`는 아직 스코프에 포함되지 않습니다\n"

#: src/03_ticket_v1/11_destructor.md:20 src/03_ticket_v1/11_destructor.md:32
#: src/03_ticket_v1/11_destructor.md:54 src/03_ticket_v1/11_destructor.md:64
#: src/03_ticket_v1/11_destructor.md:82 src/03_ticket_v1/11_destructor.md:98
#: src/03_ticket_v1/11_destructor.md:115 src/04_traits/06_str_slice.md:26
#: src/04_traits/06_str_slice.md:74 src/04_traits/08_sized.md:13
msgid "\"Hello\""
msgstr "\"Hello\""

#: src/03_ticket_v1/11_destructor.md:21 src/03_ticket_v1/11_destructor.md:55
#: src/03_ticket_v1/11_destructor.md:65
msgid "\"World\""
msgstr "\"World\""

#: src/03_ticket_v1/11_destructor.md:21
msgid "// <-- x's scope starts here...\n"
msgstr "// <-- x's 스코프는 여기서 시작됩니다...\n"

#: src/03_ticket_v1/11_destructor.md:22 src/03_ticket_v1/11_destructor.md:56
#: src/03_ticket_v1/11_destructor.md:66
msgid "\"!\""
msgstr "\"!\""

#: src/03_ticket_v1/11_destructor.md:22
msgid "//   |\n"
msgstr "//   |\n"

#: src/03_ticket_v1/11_destructor.md:23
msgid "//  <-------------- ...and ends here\n"
msgstr "// \\<\\--------------- ...그리고 여기서 끝납니다\n"

#: src/03_ticket_v1/11_destructor.md:25
msgid ""
"ownership of the variable is transferred to someone else (e.g. a function or "
"another variable)"
msgstr "변수의 소유권이 다른 사람에게 이전될 때(예: 함수 또는 다른 변수)"

#: src/03_ticket_v1/11_destructor.md:28 src/03_ticket_v1/11_destructor.md:78
#: src/03_ticket_v1/11_destructor.md:91
msgid "// Do something [...]\n"
msgstr "// 뭐든 하세요 [...]\n"

#: src/03_ticket_v1/11_destructor.md:32
msgid "// <-- s's scope starts here...\n"
msgstr "// <-- s의 스코프는 여기서 시작됩니다...\n"

#: src/03_ticket_v1/11_destructor.md:33
msgid "//                    | \n"
msgstr "//                    | \n"

#: src/03_ticket_v1/11_destructor.md:34
msgid "// <------------------- ..and ends here\n"
msgstr "// <------------------- ..그리고 여기서 끝납니다\n"

#: src/03_ticket_v1/11_destructor.md:35
msgid "//   because `s` is moved into `compute`\n"
msgstr "//   `s`가 `compute`로 이동되었기 때문입니다\n"

#: src/03_ticket_v1/11_destructor.md:41
msgid ""
"When the owner of a value goes out of scope, Rust invokes its "
"**destructor**.  \n"
"The destructor tries to clean up the resources used by that value—in "
"particular, whatever memory it allocated."
msgstr ""
"값의 소유자가 스코프를 벗어나면 Rust는 해당 **소멸자**를 호출합니다.  \n"
"소멸자는 해당 값에 사용된 리소스, 특히 할당한 메모리를 정리하려고 합니다."

#: src/03_ticket_v1/11_destructor.md:44
msgid ""
"You can manually invoke the destructor of a value by passing it to `std::mem::"
"drop`.  \n"
"That's why you'll often hear Rust developers saying \"that value has been "
"**dropped**\" as a way to state that a value has gone out of scope and its "
"destructor has been invoked."
msgstr ""
"값을 `std::mem::drop`에 전달하여 값의 소멸자를 수동으로 호출할 수 있습니"
"다.  \n"
"이것이 바로 Rust 개발자가 값이 범위를 벗어나 해당 소멸자가 호출되었음을 나타내"
"는 방법으로 \"해당 값이 **삭제되었습니다**\"라고 말하는 것을 자주 듣게 되는 이"
"유입니다."

#: src/03_ticket_v1/11_destructor.md:48
msgid "Visualizing drop points"
msgstr "드롭 포인트 시각화"

#: src/03_ticket_v1/11_destructor.md:50
msgid ""
"We can insert explicit calls to `drop` to \"spell out\" what the compiler "
"does for us. Going back to the previous example:"
msgstr ""
"우리는 drop에 명시적으로 호출을 삽입할 수 있습니다. 이는 컴파일러가 우리를 위"
"해 수행하는 작업을 명확하게 설명해 줍니다. 이전 예제로 돌아가보겠습니다:"

#: src/03_ticket_v1/11_destructor.md:60
msgid "It's equivalent to:"
msgstr "이는 다음과 같습니다:"

#: src/03_ticket_v1/11_destructor.md:67
msgid "// Variables are dropped in reverse order of declaration\n"
msgstr "// 변수는 선언의 역순으로 삭제됩니다\n"

#: src/03_ticket_v1/11_destructor.md:74
msgid ""
"Let's look at the second example instead, where `s`'s ownership is "
"transferred to `compute`:"
msgstr "대신 `s`의 소유권이 `compute`로 이전되는 두 번째 예를 살펴보겠습니다:"

#: src/03_ticket_v1/11_destructor.md:87
msgid "It's equivalent to this:"
msgstr "이는 다음과 동일합니다:"

#: src/03_ticket_v1/11_destructor.md:92
msgid ""
"// <-- Assuming `t` wasn't dropped or moved \n"
"             //     before this point, the compiler will call \n"
"             //     `drop` here, when it goes out of scope\n"
msgstr ""
"// <-- 이 지점 이전에 `t`가 삭제되거나 이동되지 않았다고 가정하면 \n"
"             //     컴파일러는 스코프를 벗어날 때 \n"
"             //     여기에서 `drop`을 호출합니다.\n"

#: src/03_ticket_v1/11_destructor.md:103
msgid ""
"Notice the difference: even though `s` is no longer valid after `compute` is "
"called in `main`, there is no `drop(s)` in `main`. When you transfer "
"ownership of a value to a function, you're also **transferring the "
"responsibility of cleaning it up**."
msgstr ""
"차이점에 주목하십시오. `main`에서 `compute`이 호출된 후에 `s`가 더 이상 유효하"
"지 않더라도 `main`에는 `drop(s)`이 없습니다. 값의 소유권을 함수로 이전하면 **"
"값 정리 책임**도 이전됩니다."

#: src/03_ticket_v1/11_destructor.md:107
msgid ""
"This ensures that the destructor for a value is called **at most[^leak] "
"once**, preventing [double free bugs](https://owasp.org/www-community/"
"vulnerabilities/Doubly_freeing_memory) by design."
msgstr ""
"이렇게 하면 값에 대한 소멸자가 **최대로[^leak] 한 번** 호출되어 설계상 [더블 "
"프리 버그](https://owasp.org/www-community/vulnerabilities/"
"Doubly_freeing_memory)를 방지할 수 있습니다."

#: src/03_ticket_v1/11_destructor.md:110
msgid "Use after drop"
msgstr "삭제 후 사용"

#: src/03_ticket_v1/11_destructor.md:112
msgid "What happens if you try to use a value after it's been dropped?"
msgstr "값이 삭제된 후에 값을 사용하려고 하면 어떻게 될까요?"

#: src/03_ticket_v1/11_destructor.md:117 src/03_ticket_v1/11_destructor.md:128
#: src/06_ticket_management/04_iterators.md:10
#: src/06_ticket_management/04_iterators.md:16
#: src/06_ticket_management/04_iterators.md:31
#: src/06_ticket_management/04_iterators.md:92
#: src/06_ticket_management/04_iterators.md:101
#: src/06_ticket_management/09_impl_trait_2.md:9
#: src/06_ticket_management/09_impl_trait_2.md:23
#: src/08_futures/03_runtime.md:85 src/08_futures/04_future.md:40
#: src/08_futures/04_future.md:131
msgid "\"{}\""
msgstr "\"{}\""

#: src/03_ticket_v1/11_destructor.md:120
msgid "If you try to compile this code, you'll get an error:"
msgstr "이 코드를 컴파일하려고 하면 오류가 발생합니다:"

#: src/03_ticket_v1/11_destructor.md:132
msgid ""
"Drop **consumes** the value it's called on, meaning that the value is no "
"longer valid after the call.  \n"
"The compiler will therefore prevent you from using it, avoiding [use-after-"
"free bugs](https://owasp.org/www-community/vulnerabilities/"
"Using_freed_memory)."
msgstr ""
"Drop은 호출된 값을 **소비**합니다. 즉, 호출 후에는 해당 값이 더 이상 유효하지 "
"않습니다.  \n"
"따라서 컴파일러는 사용자가 이를 사용하지 못하게 하여 [use-after-free 버그]"
"(https://owasp.org/www-community/vulnerabilities/Using_freed_memory)를 방지합"
"니다."

#: src/03_ticket_v1/11_destructor.md:135
msgid "Dropping references"
msgstr "참조 삭제"

#: src/03_ticket_v1/11_destructor.md:137
msgid ""
"What if a variable contains a reference?  \n"
"For example:"
msgstr ""
"변수에 참조가 포함되어 있으면 어떻게 되나요?  \n"
"예를 들어:"

#: src/03_ticket_v1/11_destructor.md:146
msgid ""
"When you call `drop(y)`... nothing happens.  \n"
"If you actually try to compile this code, you'll get a warning:"
msgstr ""
"`drop(y)`를 호출하면... 아무 일도 일어나지 않습니다.  \n"
"실제로 이 코드를 컴파일하려고 하면 다음과 같은 경고가 표시됩니다:"

#: src/03_ticket_v1/11_destructor.md:161
msgid ""
"It goes back to what we said earlier: we only want to call the destructor "
"once.  \n"
"You can have multiple references to the same value—if we called the "
"destructor for the value they point at when one of them goes out of scope, "
"what would happen to the others? They would refer to a memory location that's "
"no longer valid: a so-called [**dangling pointer**](https://en.wikipedia.org/"
"wiki/Dangling_pointer), a close relative of [**use-after-free bugs**](https://"
"owasp.org/www-community/vulnerabilities/Using_freed_memory). Rust's ownership "
"system rules out these kinds of bugs by design."
msgstr ""
"이전에 말한 내용으로 돌아갑니다. 소멸자를 한 번만 호출하려고 합니다.  \n"
"동일한 값에 대한 참조가 여러 개 있을 수 있습니다. 그 중 하나가 범위를 벗어날 "
"때 가리키는 값에 대해 소멸자를 호출하면 다른 참조에는 어떤 일이 발생할까요? 그"
"들은 더 이상 유효하지 않은 메모리 위치, 즉 [**use-after-free 버그**](https://"
"owasp.org/www-community/vulnerabilities/Using_freed_memory)와 가까운 친척인 "
"[**댕글링 포인터**](https://en.wikipedia.org/wiki/Dangling_pointer)를 참조합니"
"다. Rust의 소유권 시스템은 설계상 이러한 종류의 버그를 배제합니다."

#: src/03_ticket_v1/11_destructor.md:168
msgid ""
"Rust doesn't guarantee that destructors will run. They won't, for example, if "
"you explicitly choose to [leak memory](../07_threads/03_leak.md)."
msgstr ""
"Rust는 소멸자가 실행된다는 것을 보장하지 않습니다. 예를 들어 명시적으로 [메모"
"리 누수](../07_threads/03_leak.md)를 선택한 경우에는 그렇지 않습니다."

#: src/03_ticket_v1/11_destructor.md:173
msgid ""
"The exercise for this section is located in [`03_ticket_v1/11_destructor`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/11_destructor)"
msgstr ""
"이 섹션의 예제는 [`03_ticket_v1/11_destructor`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/11_destructor)에 있습니다"

#: src/03_ticket_v1/12_outro.md:1 src/04_traits/14_outro.md:1
#: src/05_ticket_v2/15_outro.md:1
msgid "Wrapping up"
msgstr "마무리"

#: src/03_ticket_v1/12_outro.md:3
msgid ""
"We've covered a lot of foundational Rust concepts in this chapter.  \n"
"Before moving on, let's go through one last exercise to consolidate what "
"we've learned. You'll have minimal guidance this time—just the exercise "
"description and the tests to guide you."
msgstr ""
"우리는 이번 장에서 Rust의 기초 개념을 많이 다루었습니다.  \n"
"계속 진행하기 전에 마지막 연습을 통해 배운 내용을 통합해 보겠습니다. 이번에는 "
"최소한의 지침만 제공됩니다. 연습 설명과 안내할 테스트만 제공됩니다."

#: src/03_ticket_v1/12_outro.md:9
msgid ""
"The exercise for this section is located in [`03_ticket_v1/12_outro`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/03_ticket_v1/12_outro)"
msgstr ""
"이 섹션의 예제는 [`03_ticket_v1/12_outro`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/12_outro)에 있습니다"

#: src/04_traits/00_intro.md:3
msgid ""
"In the previous chapter we covered the basics of Rust's type and ownership "
"system.  \n"
"It's time to dig deeper: we'll explore **traits**, Rust's take on interfaces."
msgstr ""
"이전 장에서 우리는 Rust의 유형과 소유권 시스템의 기본을 다루었습니다.  \n"
"이제 더 깊이 파고들 시간입니다. Rust의 인터페이스, **Trait**를 살펴보겠습니다."

#: src/04_traits/00_intro.md:6
msgid ""
"Once you learn about traits, you'll start seeing their fingerprints all over "
"the place.  \n"
"In fact, you've already seen traits in action throughout the previous "
"chapter, e.g. `.into()` invocations as well as operators like `==` and `+`."
msgstr ""
"특성에 대해 배우고 나면 곳곳에서 그들의 흔적이 보일겁니다.  \n"
"사실, 이전 장 전체에서 이미 트레잇이 작동하는 것을 보았습니다. `.into()` 호출 "
"및 `==`나 `+`와 같은 연산자들 말입니다."

#: src/04_traits/00_intro.md:10
msgid ""
"On top of traits as a concept, we'll also cover some of the key traits that "
"are defined in Rust's standard library:"
msgstr ""
"개념으로서의 트레잇 외에도 Rust의 표준 라이브러리에 정의된 주요 트레잇 중 일부"
"도 다룰 것입니다:"

#: src/04_traits/00_intro.md:12
msgid "Operator traits (e.g. `Add`, `Sub`, `PartialEq`, etc.)"
msgstr "연산자 특성(예: `Add`, `Sub`, `PartialEq` 등)"

#: src/04_traits/00_intro.md:13
msgid "`From` and `Into`, for infallible conversions"
msgstr "`From`과 `Into`, 오류 없는 변환을 위해"

#: src/04_traits/00_intro.md:14
msgid "`Clone` and `Copy`, for copying values"
msgstr "`Clone`과 `Copy`, 값 복사를 위해"

#: src/04_traits/00_intro.md:15
msgid "`Deref` and deref coercion"
msgstr "`Deref`와 deref 변환"

#: src/04_traits/00_intro.md:16
msgid "`Sized`, to mark types with a known size"
msgstr "`Sized`, 타입의 크기가 정해졌음을 나타내기위해"

#: src/04_traits/00_intro.md:17
msgid "`Drop`, for custom cleanup logic"
msgstr "'Drop', 커스텀 클린업 로직을 위해"

#: src/04_traits/00_intro.md:19
msgid ""
"Since we'll be talking about conversions, we'll seize the opportunity to plug "
"some of the \"knowledge gaps\" from the previous chapter—e.g. what is `\"A "
"title\"`, exactly? Time to learn more about slices too!"
msgstr ""
"변환에 관해 이야기할 것이므로 이전 장의 \"지식 격차\"를 메울 수 있는 시간을 가"
"지겠습니다. ``제목''이란게 정확히 무엇이었나요? 슬라이스에 대해서도 자세히 알"
"아보겠습니다!"

#: src/04_traits/00_intro.md:24
msgid ""
"The exercise for this section is located in [`04_traits/00_intro`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/00_intro)"
msgstr ""
"이 섹션의 예제는 [`04_traits/00_intro`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/04_traits/00_intro)에 있습니다"

#: src/04_traits/01_trait.md:3
msgid "Let's look again at our `Ticket` type:"
msgstr "'Ticket' 타입을 다시 살펴보겠습니다."

#: src/04_traits/01_trait.md:13
msgid ""
"All our tests, so far, have been making assertions using `Ticket`'s fields."
msgstr "지금까지 우리의 모든 테스트는 `Ticket`의 필드를 사용하여 비교했습니다."

#: src/04_traits/01_trait.md:16
msgid "\"A new title\""
msgstr "\"A new title\""

#: src/04_traits/01_trait.md:19
msgid "What if we wanted to compare two `Ticket` instances directly?"
msgstr ""
"만약 두 개의 `Ticket` 인스턴스를 직접 비교하고 싶다면 어떻게 해야 할까요?"

#: src/04_traits/01_trait.md:22 src/04_traits/01_trait.md:23
msgid "/* ... */"
msgstr "/* ... */"

#: src/04_traits/01_trait.md:27
msgid "The compiler will stop us:"
msgstr "컴파일러는 우리를 멈출 것입니다:"

#: src/04_traits/01_trait.md:41
msgid ""
"`Ticket` is a new type. Out of the box, there is **no behavior attached to "
"it**.  \n"
"Rust doesn't magically infer how to compare two `Ticket` instances just "
"because they contain `String`s."
msgstr ""
"`Ticket`은 새로운 유형입니다. 기본적으로는 **연관된 동작이 없습니다**.  \n"
"Rust는 단지 `String`을 포함하고 있다는 이유만으로 두 개의 `Ticket` 인스턴스를 "
"비교하는 방법을 마법처럼 추론하지 않습니다."

#: src/04_traits/01_trait.md:44
msgid ""
"The Rust compiler is nudging us in the right direction though: it's "
"suggesting that we might be missing an implementation of `PartialEq`. "
"`PartialEq` is a **trait**!"
msgstr ""
"Rust 컴파일러는 우리를 올바른 방향으로 인도하고 있습니다: 이는 `PartialEq` 구"
"현이 누락되었을 수 있음을 알려줍니다. `PartialEq`는 **트레잇**입니다!"

#: src/04_traits/01_trait.md:47
msgid "What are traits?"
msgstr "트레잇이란 무엇입니까?"

#: src/04_traits/01_trait.md:49
msgid ""
"Traits are Rust's way of defining **interfaces**.  \n"
"A trait defines a set of methods that a type must implement to satisfy the "
"trait's contract."
msgstr ""
"트레잇은 **인터페이스**를 정의하는 Rust의 방식입니다.  \n"
"트레잇은 트레잇의 요구사항을 충족하기 위해 타입이 구현해야 하는 메서드 집합을 "
"정의합니다."

#: src/04_traits/01_trait.md:52
msgid "Defining a trait"
msgstr "트레잇 정의"

#: src/04_traits/01_trait.md:54
msgid "The syntax for a trait definition goes like this:"
msgstr "트레잇 정의의 구문은 다음과 같습니다."

#: src/04_traits/01_trait.md:62
msgid ""
"We might, for example, define a trait named `MaybeZero` that requires its "
"implementors to define an `is_zero` method:"
msgstr ""
"예를 들어, 구현자가 `is_zero` 메소드를 정의하도록 요구하는 `MaybeZero`라는 트"
"레잇을 정의할 수 있습니다:"

#: src/04_traits/01_trait.md:70
msgid "Implementing a trait"
msgstr "트레잇 구현"

#: src/04_traits/01_trait.md:72
msgid ""
"To implement a trait for a type we use the `impl` keyword, just like we do "
"for regular[^inherent] methods, but the syntax is a bit different:"
msgstr ""
"타입에 대한 트레잇을 구현하려면 일반[^inherent] 메소드에서와 마찬가지로 "
"`impl` 키워드를 사용하지만 구문은 약간 다릅니다."

#: src/04_traits/01_trait.md:78
msgid "// Method body\n"
msgstr "// 메서드 본문\n"

#: src/04_traits/01_trait.md:83
msgid ""
"For example, to implement the `MaybeZero` trait for a custom number type, "
"`WrappingU32`:"
msgstr ""
"예를 들어, 사용자 정의 숫자 유형 `WrappingU32`에 대해 `MaybeZero` 특성을 구현"
"하려면 다음을 수행하세요:"

#: src/04_traits/01_trait.md:97
msgid "Invoking a trait method"
msgstr "트레잇 메서드 호출"

#: src/04_traits/01_trait.md:99
msgid ""
"To invoke a trait method, we use the `.` operator, just like we do with "
"regular methods:"
msgstr ""
"트레잇 메서드를 호출하려면 일반 메서드와 마찬가지로 `.` 연산자를 사용합니다:"

#: src/04_traits/01_trait.md:106
msgid "To invoke a trait method, two things must be true:"
msgstr "트레잇 메서드를 호출하려면 다음 두 가지 사항이 충족되어야 합니다:"

#: src/04_traits/01_trait.md:108
msgid "The type must implement the trait."
msgstr "타입은 트레잇을 구현해야 합니다."

#: src/04_traits/01_trait.md:109
msgid "The trait must be in scope."
msgstr "트레잇은 스코프 내에 있어야 합니다."

#: src/04_traits/01_trait.md:111
msgid ""
"To satisfy the latter, you may have to add a `use` statement for the trait:"
msgstr "후자를 만족시키려면 해당 특성에 `use` 문을 추가해야 할 수도 있습니다:"

#: src/04_traits/01_trait.md:117
msgid "This is not necessary if:"
msgstr "다음과 같은 경우에는 필요하지 않습니다:"

#: src/04_traits/01_trait.md:119
msgid "The trait is defined in the same module where the invocation occurs."
msgstr "트레잇이 호출이 발생하는 동일한 모듈에서 정의될 때."

#: src/04_traits/01_trait.md:120
msgid ""
"The trait is defined in the standard library's **prelude**. The prelude is a "
"set of traits and types that are automatically imported into every Rust "
"program. It's as if `use std::prelude::*;` was added at the beginning of "
"every Rust module."
msgstr ""
"트레잇이 **prelude**에 정의되어있을 때. 프렐류드는 모든 러스트 프로그램에 자동"
"으로 임포트되는 트레잇과 타입의 집합입니다. 마치 모든 러스트 모듈의 시작 부분"
"에 `use std::prelude::*;`가 추가된 것과 같습니다."

#: src/04_traits/01_trait.md:124
msgid ""
"You can find the list of traits and types in the prelude in the [Rust "
"documentation](https://doc.rust-lang.org/std/prelude/index.html)."
msgstr ""
"[Rust 문서](https://doc.rust-lang.org/std/prelude/index.html)의 프렐류드 부분"
"에서 트레잇과 타입들을 찾을 수 있습니다."

#: src/04_traits/01_trait.md:127
msgid ""
"A method defined directly on a type, without using a trait, is also known as "
"an **inherent method**."
msgstr ""
"트레잇을 사용하지 않고 타입에 직접 정의된 메서드를 **고유 메서드**라고도 합니"
"다."

#: src/04_traits/01_trait.md:131
msgid ""
"The exercise for this section is located in [`04_traits/01_trait`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/01_trait)"
msgstr ""
"이 섹션의 예제는 [`04_traits/01_trait`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/04_traits/01_trait)에 있습니다"

#: src/04_traits/02_orphan_rule.md:1
msgid "Implementing traits"
msgstr "트레잇 구현"

#: src/04_traits/02_orphan_rule.md:3
msgid ""
"When a type is defined in another crate (e.g. `u32`, from Rust's standard "
"library), you can't directly define new methods for it. If you try:"
msgstr ""
"유형이 다른 크레이트(예: Rust 표준 라이브러리의 `u32`)에 정의되면 해당 유형에 "
"대한 새 메서드를 직접 정의할 수 없습니다. 다음의 경우:"

#: src/04_traits/02_orphan_rule.md:14 src/05_ticket_v2/02_match.md:43
msgid "the compiler will complain:"
msgstr "컴파일러는 다음과 같이 불평할 것입니다:"

#: src/04_traits/02_orphan_rule.md:25
msgid "Extension trait"
msgstr "확장 트레잇"

#: src/04_traits/02_orphan_rule.md:27
msgid ""
"An **extension trait** is a trait whose primary purpose is to attach new "
"methods to foreign types, such as `u32`. That's exactly the pattern you "
"deployed in the previous exercise, by defining the `IsEven` trait and then "
"implementing it for `i32` and `u32`. You are then free to call `is_even` on "
"those types as long as `IsEven` is in scope."
msgstr ""
"**확장 트레잇**은 `u32`와 같은 외부 타입에 새로운 메소드를 추가하기위한 트레잇"
"입니다. 이것이 바로 이전 예제에서 `IsEven` 트레잇을 정의한 다음 `i32` 및 `u32`"
"에 대해 구현하여 배포한 패턴입니다. 그러면 `IsEven`이 스코프 내에 있는 한 타입"
"에 대해 `is_even`을 자유롭게 호출할 수 있습니다."

#: src/04_traits/02_orphan_rule.md:34
msgid "// Bring the trait in scope\n"
msgstr "// 트레잇을 스코프로 가져옵니다\n"

#: src/04_traits/02_orphan_rule.md:38
msgid "// Invoke its method on a type that implements it\n"
msgstr "// 이를 구현하는 타입에서 해당 메서드를 호출합니다.\n"

#: src/04_traits/02_orphan_rule.md:45
msgid "One implementation"
msgstr "하나의 구현"

#: src/04_traits/02_orphan_rule.md:47
msgid ""
"There are limitations to the trait implementations you can write.  \n"
"The simplest and most straight-forward one: you can't implement the same "
"trait twice, in a crate, for the same type."
msgstr ""
"트레잇을 구현하는데에는 제약사항이 있습니다.  \n"
"가장 간단하고 단순한 것은 동일한 타입에 대해 크레이트에서 동일한 트레잇을 두 "
"번 구현할 수 없다는 것입니다."

#: src/04_traits/02_orphan_rule.md:71
msgid "The compiler will reject it:"
msgstr "컴파일러는 이를 거부합니다:"

#: src/04_traits/02_orphan_rule.md:83
msgid ""
"There can be no ambiguity as to what trait implementation should be used when "
"`IsEven::is_even` is invoked on a `u32` value, therefore there can only be "
"one."
msgstr ""
"`IsEven::is_even`이 `u32` 값에 대해 호출될 때 어떤 트레잇 구현을 사용해야 하는"
"지에 모호하기때문에 트레잇 구현은 하나만 있어야합니다."

#: src/04_traits/02_orphan_rule.md:88
msgid ""
"Things get more nuanced when multiple crates are involved. In particular, at "
"least one of the following must be true:"
msgstr ""
"여러 크레이트가 관련되면 상황이 더욱 미묘해집니다. 특히 다음 중 하나 이상이 충"
"족되어야 합니다:"

#: src/04_traits/02_orphan_rule.md:91
msgid "The trait is defined in the current crate"
msgstr "트레잇은 현재 크레이트에 정의되어있어야합니다"

#: src/04_traits/02_orphan_rule.md:92
msgid "The implementor type is defined in the current crate"
msgstr "타입의 구현은 현재 크레이트에서 정의되어야합니다."

#: src/04_traits/02_orphan_rule.md:94
msgid ""
"This is known as Rust's **orphan rule**. Its goal is to make the method "
"resolution process unambiguous."
msgstr ""
"이것은 Rust의 **고아 규칙**으로 알려져 있습니다. 이 규칙의 목적은 매서드 해석 "
"과정을 명확하게 만드는 것입니다."

#: src/04_traits/02_orphan_rule.md:97
msgid "Imagine the following situation:"
msgstr "다음 상황을 상상해 보세요:"

#: src/04_traits/02_orphan_rule.md:99
msgid "Crate `A` defines the `IsEven` trait"
msgstr "`A` 크레이트는 `IsEven` 트레잇을 정의합니다"

#: src/04_traits/02_orphan_rule.md:100
msgid "Crate `B` implements `IsEven` for `u32`"
msgstr "`B` 크레이트는 `u32`에 대해 `IsEven`을 구현합니다"

#: src/04_traits/02_orphan_rule.md:101
msgid ""
"Crate `C` provides a (different) implementation of the `IsEven` trait for "
"`u32`"
msgstr "`C` 크레이트는 `u32`에 대한 `IsEven` 트레잇의 (다른) 구현을 제공합니다"

#: src/04_traits/02_orphan_rule.md:102
msgid "Crate `D` depends on both `B` and `C` and calls `1.is_even()`"
msgstr "크레이트 `D`는 `B`와 `C` 모두에 의존하며 `1.is_even()`을 호출합니다"

#: src/04_traits/02_orphan_rule.md:104
msgid ""
"Which implementation should be used? The one defined in `B`? Or the one "
"defined in `C`?  \n"
"There's no good answer, therefore the orphan rule was defined to prevent this "
"scenario. Thanks to the orphan rule, neither crate `B` nor crate `C` would "
"compile."
msgstr ""
"어떤 구현을 사용해야 합니까? `B`에 정의된 것? 아니면 `C`에 정의된 것인가"
"요?  \n"
"정답이 없으므로 이 시나리오를 방지하기 위해 고아 규칙이 정의되었습니다. 고아 "
"규칙 덕분에 `B` 상자나 `C` 상자는 모두 컴파일되지 않습니다."

#: src/04_traits/02_orphan_rule.md:110
msgid ""
"There are some caveats and exceptions to the orphan rule as stated above. "
"Check out [the reference](https://doc.rust-lang.org/reference/items/"
"implementations.html#trait-implementation-coherence) if you want to get "
"familiar with its nuances."
msgstr ""
"위에서 설명한 대로 고아 규칙에는 몇 가지 주의 사항과 예외가 있습니다. 그 뉘앙"
"스에 익숙해지고 싶다면 [참고 자료]((https://doc.rust-lang.org/reference/items/"
"implementations.html#trait-implementation-coherence))를 확인하세요."

#: src/04_traits/02_orphan_rule.md:116
msgid ""
"The exercise for this section is located in [`04_traits/02_orphan_rule`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/02_orphan_rule)"
msgstr ""
"이 섹션의 예제는 [`04_traits/02_orphan_rule`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/02_orphan_rule)에 있습니다"

#: src/04_traits/03_operator_overloading.md:3
msgid ""
"Now that we have a basic understanding of what traits are, let's circle back "
"to **operator overloading**. Operator overloading is the ability to define "
"custom behavior for operators like `+`, `-`, `*`, `/`, `==`, `!=`, etc."
msgstr ""
"이제 특성이 무엇인지 기본적으로 이해했으므로 **연산자 오버로딩**으로 돌아가 보"
"겠습니다. 연산자 오버로딩은 `+`, `-`, `*`, `/`, `==`, `!=` 등과 같은 연산자에 "
"대한 사용자 정의 동작을 정의하는 기능입니다."

#: src/04_traits/03_operator_overloading.md:6
msgid "Operators are traits"
msgstr "연산자는 트레잇입니다"

#: src/04_traits/03_operator_overloading.md:8
msgid ""
"In Rust, operators are traits.  \n"
"For each operator, there is a corresponding trait that defines the behavior "
"of that operator. By implementing that trait for your type, you **unlock** "
"the usage of the corresponding operators."
msgstr ""
"Rust에서 연산자는 트레잇입니다.  \n"
"각 연산자에는 해당 연산자의 동작을 정의하는 해당 트레잇이 있습니다. 타입에 해"
"당 트레잇을 구현함으로써 해당 연산자의 사용을 **잠금 해제**할 수 있습니다."

#: src/04_traits/03_operator_overloading.md:12
msgid ""
"For example, the [`PartialEq` trait](https://doc.rust-lang.org/std/cmp/trait."
"PartialEq.html) defines the behavior of the `==` and `!=` operators:"
msgstr ""
"예를 들어 [`PartialEq` trait](https://doc.rust-lang.org/std/cmp/trait."
"PartialEq.html) 특성은 `==`와 `!=` 연산자의 동작을 정의합니다:"

#: src/04_traits/03_operator_overloading.md:16
msgid ""
"// The `PartialEq` trait definition, from Rust's standard library\n"
"// (It is *slightly* simplified, for now)\n"
msgstr ""
"// Rust의 표준 라이브러리에 있는 `PartialEq` 특성 정의\n"
"// (지금은 _약간_ 단순화되었습니다)\n"

#: src/04_traits/03_operator_overloading.md:19
msgid ""
"// Required method\n"
"    //\n"
"    // `Self` is a Rust keyword that stands for \n"
"    // \"the type that is implementing the trait\"\n"
msgstr ""
"// 필수 메서드\n"
"    //\n"
"    // `Self`는 \"트레잇을 구현하는 타입\"을\n"
"    // 의미하는 Rust 키워드입니다\n"

#: src/04_traits/03_operator_overloading.md:25
msgid "// Provided method\n"
msgstr "// 제공되는 메서드\n"

#: src/04_traits/03_operator_overloading.md:30
msgid ""
"When you write `x == y` the compiler will look for an implementation of the "
"`PartialEq` trait for the types of `x` and `y` and replace `x == y` with `x."
"eq(y)`. It's syntactic sugar!"
msgstr ""
"`x == y`를 작성하면 컴파일러는 `x` 및 `y` 타입에 대한 `PartialEq` 트레잇의 구"
"현을 찾고 `x == y`를 `x.eq(y)`로 대체합니다. 이는 문법적 설탕(syntactic sugar)"
"입니다!"

#: src/04_traits/03_operator_overloading.md:33
msgid "This is the correspondence for the main operators:"
msgstr "주요 연산자에 대한 트레잇은 다음과 같습니다:"

#: src/04_traits/03_operator_overloading.md:35
msgid "Operator"
msgstr "연산자"

#: src/04_traits/03_operator_overloading.md:37
msgid "`+`"
msgstr "`+`"

#: src/04_traits/03_operator_overloading.md:37
msgid "[`Add`](https://doc.rust-lang.org/std/ops/trait.Add.html)"
msgstr "[`Add`](https://doc.rust-lang.org/std/ops/trait.Add.html)"

#: src/04_traits/03_operator_overloading.md:38
msgid "`-`"
msgstr "`-`"

#: src/04_traits/03_operator_overloading.md:38
msgid "[`Sub`](https://doc.rust-lang.org/std/ops/trait.Sub.html)"
msgstr "[`Sub`](https://doc.rust-lang.org/std/ops/trait.Sub.html)"

#: src/04_traits/03_operator_overloading.md:39
msgid "`*`"
msgstr "`*`"

#: src/04_traits/03_operator_overloading.md:39
msgid "[`Mul`](https://doc.rust-lang.org/std/ops/trait.Mul.html)"
msgstr "[`Mul`](https://doc.rust-lang.org/std/ops/trait.Mul.html)"

#: src/04_traits/03_operator_overloading.md:40
msgid "`/`"
msgstr "`/`"

#: src/04_traits/03_operator_overloading.md:40
msgid "[`Div`](https://doc.rust-lang.org/std/ops/trait.Div.html)"
msgstr "[`Div`](https://doc.rust-lang.org/std/ops/trait.Div.html)"

#: src/04_traits/03_operator_overloading.md:41
msgid "`%`"
msgstr "`%`"

#: src/04_traits/03_operator_overloading.md:41
msgid "[`Rem`](https://doc.rust-lang.org/std/ops/trait.Rem.html)"
msgstr "[`Rem`](https://doc.rust-lang.org/std/ops/trait.Rem.html)"

#: src/04_traits/03_operator_overloading.md:42
msgid "`==` and `!=`"
msgstr "`==`와 `!=`"

#: src/04_traits/03_operator_overloading.md:42
msgid "[`PartialEq`](https://doc.rust-lang.org/std/cmp/trait.PartialEq.html)"
msgstr "[`PartialEq`](https://doc.rust-lang.org/std/cmp/trait.PartialEq.html)"

#: src/04_traits/03_operator_overloading.md:43
msgid "`<`, `>`, `<=`, and `>=`"
msgstr "`<`, `>`, `<=` 그리고 `>=`"

#: src/04_traits/03_operator_overloading.md:43
msgid "[`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html)"
msgstr "[`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html)"

#: src/04_traits/03_operator_overloading.md:45
msgid ""
"Arithmetic operators live in the [`std::ops`](https://doc.rust-lang.org/std/"
"ops/index.html) module, while comparison ones live in the [`std::cmp`]"
"(https://doc.rust-lang.org/std/cmp/index.html) module."
msgstr ""
"산술 연산자는 [`std::ops`](https://doc.rust-lang.org/std/ops/index.html) 모듈"
"에 있고, 비교 연산자는 [`std::cmp`](https://doc.rust-lang.org/std/cmp/index."
"html) 모듈에 있습니다."

#: src/04_traits/03_operator_overloading.md:48
msgid "Default implementations"
msgstr "기본 구현"

#: src/04_traits/03_operator_overloading.md:50
msgid ""
"The comment on `PartialEq::ne` states that \"`ne` is a provided method\".  \n"
"It means that `PartialEq` provides a **default implementation** for `ne` in "
"the trait definition—the `{ ... }` elided block in the definition snippet.  \n"
"If we expand the elided block, it looks like this:"
msgstr ""
"`PartialEq::ne`에 대한 주석에는 \"`ne`이 제공되는 메서드입니다\"라고 명시되어 "
"있습니다.  \n"
"이는 `PartialEq`가 특성 정의의 `ne`에 대한 **기본 구현**을 제공한다는 의미입니"
"다(정의 조각에서 생략된 `{ ... }` 블록).  \n"
"생략된 블록을 확장하면 다음과 같습니다."

#: src/04_traits/03_operator_overloading.md:65
msgid ""
"It's what you expect: `ne` is the negation of `eq`.  \n"
"Since a default implementation is provided, you can skip implementing `ne` "
"when you implement `PartialEq` for your type. It's enough to implement `eq`:"
msgstr ""
"예상한 대로입니다. 'ne'은 'eq'의 부정입니다.  \n"
"기본 구현이 제공되므로 유형에 대해 `PartialEq`를 구현할 때 `ne` 구현을 건너뛸 "
"수 있습니다. `eq`를 구현하는 것으로 충분합니다:"

#: src/04_traits/03_operator_overloading.md:79
msgid "// No `ne` implementation here\n"
msgstr "// 여기에는 `ne` 구현이 없습니다\n"

#: src/04_traits/03_operator_overloading.md:83
msgid ""
"You are not forced to use the default implementation though. You can choose "
"to override it when you implement the trait:"
msgstr ""
"하지만 무조건 기본 구현을 사용해야 하는 것은 아닙니다. 트레잇을 구현할 때 이"
"를 재정의할 수 있습니다."

#: src/04_traits/03_operator_overloading.md:91
#: src/04_traits/03_operator_overloading.md:95
msgid "// Custom implementation\n"
msgstr "// 사용자 정의 구현\n"

#: src/04_traits/03_operator_overloading.md:102
msgid ""
"The exercise for this section is located in "
"[`04_traits/03_operator_overloading`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/04_traits/03_operator_overloading)"
msgstr ""
"이 섹션의 예제는 [`04_traits/03_operator_overloading`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/03_operator_overloading)에 있습니다"

#: src/04_traits/04_derive.md:3
msgid ""
"Implementing `PartialEq` for `Ticket` was a bit tedious, wasn't it? You had "
"to manually compare each field of the struct."
msgstr ""
"`Ticket`에 대해 `PartialEq`를 구현하는 것은 약간 지루한 일이었죠, 그렇죠? 구조"
"체의 각 필드를 수동으로 비교해야 했습니다."

#: src/04_traits/04_derive.md:6
msgid "Destructuring syntax"
msgstr "구조 분해 구문"

#: src/04_traits/04_derive.md:8
msgid ""
"Furthermore, the implementation is brittle: if the struct definition changes "
"(e.g. a new field is added), you have to remember to update the `PartialEq` "
"implementation."
msgstr ""
"구현이 불안정합니다. 구조체 정의가 변경되면(예: 새 필드가 추가되는 경우) "
"`PartialEq` 구현을 업데이트해줘야합니다."

#: src/04_traits/04_derive.md:11
msgid ""
"You can mitigate the risk by **destructuring** the struct into its fields:"
msgstr "구조체를 해당 필드로 **구조 분해**하여 위험을 줄일 수 있습니다:"

#: src/04_traits/04_derive.md:26
msgid ""
"If the definition of `Ticket` changes, the compiler will error out, "
"complaining that your destructuring is no longer exhaustive.  \n"
"You can also rename struct fields, to avoid variable shadowing:"
msgstr ""
"`Ticket`의 정의가 변경되면 컴파일러는 구조 분해가 더 이상 완전하지 않다고 불평"
"하면서 오류를 발생시킵니다.  \n"
"변수 섀도잉을 방지하기 위해 구조체 필드의 이름을 바꿀 수도 있습니다:"

#: src/04_traits/04_derive.md:48
msgid ""
"Destructuring is a useful pattern to have in your toolkit, but there's an "
"even more convenient way to do this: **derive macros**."
msgstr ""
"구조 분해는 자주 쓸 수 있는 유용한 패턴이지만 이 작업을 수행하는 훨씬 더 편리"
"한 방법이 있습니다: **파생 매크로**."

#: src/04_traits/04_derive.md:51
msgid "Macros"
msgstr "매크로"

#: src/04_traits/04_derive.md:53
msgid "You've already encountered a few macros in past exercises:"
msgstr "지난 예제에서 이미 몇 가지 매크로를 접했습니다:"

#: src/04_traits/04_derive.md:55
msgid "`assert_eq!` and `assert!`, in the test cases"
msgstr "테스트에는 `assert_eq!`와 `assert!`"

#: src/04_traits/04_derive.md:56
msgid "`println!`, to print to the console"
msgstr "`println!`, 콘솔에 프린트 할 때"

#: src/04_traits/04_derive.md:58
msgid ""
"Rust macros are **code generators**.  \n"
"They generate new Rust code based on the input you provide, and that "
"generated code is then compiled alongside the rest of your program. Some "
"macros are built into Rust's standard library, but you can also write your "
"own. We won't be creating our own macro in this course, but you can find some "
"useful pointers in the [\"Further reading\" section](#further-reading)."
msgstr ""
"Rust 매크로는 **코드 생성기**입니다.  \n"
"그들은 여러분이 제공한 입력을 기반으로 새로운 Rust 코드를 생성하고, 생성된 코"
"드는 프로그램의 나머지 부분과 함께 컴파일됩니다. 일부 매크로는 Rust의 표준 라"
"이브러리에 내장되어 있지만 직접 작성할 수도 있습니다. 이 과정에서는 자체 매크"
"로를 생성하지 않지만 [\"읽을거리\" section](#further-reading)섹션에서 몇 가지 "
"유용한 지침을 찾을 수 있습니다."

#: src/04_traits/04_derive.md:64
msgid "Inspection"
msgstr "분석"

#: src/04_traits/04_derive.md:66
msgid ""
"Some IDEs let you expand a macro to inspect the generated code. If that's not "
"possible, you can use [`cargo-expand`](https://github.com/dtolnay/cargo-"
"expand)."
msgstr ""
"일부 IDE에서는 매크로를 확장하여 생성된 코드를 분석할 수 있습니다. 이게 불가능"
"한 상황이라면 [`cargo-expand`](https://github.com/dtolnay/cargo-expand)를 사용"
"할 수도 있습니다."

#: src/04_traits/04_derive.md:71
msgid ""
"A **derive macro** is a particular flavour of Rust macro. It is specified as "
"an **attribute** on top of a struct."
msgstr ""
"**파생 매크로**는 Rust 매크로의 특별한 특징입니다. 구조체 상단에 **속성**으로 "
"지정됩니다."

#: src/04_traits/04_derive.md:82
msgid ""
"Derive macros are used to automate the implementation of common (and "
"\"obvious\") traits for custom types. In the example above, the `PartialEq` "
"trait is automatically implemented for `Ticket`. If you expand the macro, "
"you'll see that the generated code is functionally equivalent to the one you "
"wrote manually, although a bit more cumbersome to read:"
msgstr ""
"파생 매크로는 사용자 정의 유형에 대한 일반적인(그리고 \"명백한\") 특성의 구현"
"을 자동화하는 데 사용됩니다. 위의 예에서 `PartialEq` 특성은 `Ticket`에 대해 자"
"동으로 구현됩니다. 매크로를 확장하면 생성된 코드가 수동으로 작성한 코드와 기능"
"적으로 동일하다는 것을 알 수 있지만 읽기가 좀 더 불편합니다."

#: src/04_traits/04_derive.md:98
msgid "The compiler will nudge you to derive traits when possible."
msgstr "컴파일러는 가능하면 트레잇을 파생하도록 유도합니다."

#: src/04_traits/04_derive.md:102
msgid "[The little book of Rust macros](https://veykril.github.io/tlborm/)"
msgstr "[Rust 매크로에 관한 작은 문서]((https://veykril.github.io/tlborm/))"

#: src/04_traits/04_derive.md:103
msgid "[Proc macro workshop](https://github.com/dtolnay/proc-macro-workshop)"
msgstr "[Proc macro workshop](https://github.com/dtolnay/proc-macro-workshop)"

#: src/04_traits/04_derive.md:107
msgid ""
"The exercise for this section is located in [`04_traits/04_derive`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/04_derive)"
msgstr ""
"이 섹션의 예제는 [`04_traits/04_derive`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/04_traits/04_derive)에 있습니다"

#: src/04_traits/05_trait_bounds.md:3
msgid "We've seen two use cases for traits so far:"
msgstr "지금까지 트레잇에 대한 두 가지 사용 사례를 살펴보았습니다:"

#: src/04_traits/05_trait_bounds.md:5
msgid "Unlocking \"built-in\" behaviour (e.g. operator overloading)"
msgstr "\"빌트-인\" 동작 잠금 해제(예: 연산자 오버로드)"

#: src/04_traits/05_trait_bounds.md:6
msgid "Adding new behaviour to existing types (i.e. extension traits)"
msgstr "기존 타입에 새로운 동작 추가(예: 확장 특성)"

#: src/04_traits/05_trait_bounds.md:8
msgid "There's a third use case: **generic programming**."
msgstr "세 번째 사용 사례는 **제네릭 프로그래밍**입니다."

#: src/04_traits/05_trait_bounds.md:10 src/04_traits/09_from.md:11
msgid "The problem"
msgstr "문제"

#: src/04_traits/05_trait_bounds.md:12
msgid ""
"All our functions and methods, so far, have been working with **concrete "
"types**.  \n"
"Code that operates on concrete types is usually straightforward to write and "
"understand. But it's also limited in its reusability.  \n"
"Let's imagine, for example, that we want to write a function that returns "
"`true` if an integer is even. Working with concrete types, we'd have to write "
"a separate function for each integer type we want to support:"
msgstr ""
"지금까지 우리의 모든 함수와 메서드는 **구체적인 타입**으로 작업해 왔습니"
"다.  \n"
"구체적인 타입에서 작동하는 코드는 일반적으로 작성하고 이해하기 쉽습니다. 하지"
"만 재사용 가능성에 한계가 있습니다.  \n"
"예를 들어 정수가 짝수이면 `true`를 반환하는 함수를 작성한다고 가정해 보겠습니"
"다. 구체적인 타입으로 작업하려면 지원하려는 각 정수 타입에 대해 별도의 함수를 "
"작성해야 합니다."

#: src/04_traits/05_trait_bounds.md:27 src/04_traits/05_trait_bounds.md:49
msgid "// Etc.\n"
msgstr "// Etc.\n"

#: src/04_traits/05_trait_bounds.md:31
msgid ""
"Alternatively, we could write a single extension trait and then different "
"implementations for each integer type:"
msgstr ""
"또는 단일 확장 트레잇을 작성한 다음 각 정수 타입에 대해 서로 다른 구현을 작성"
"할 수 있습니다."

#: src/04_traits/05_trait_bounds.md:53
msgid "The duplication remains."
msgstr "중복이 발생합니다."

#: src/04_traits/05_trait_bounds.md:55
msgid "Generic programming"
msgstr "제네릭 프로그래밍"

#: src/04_traits/05_trait_bounds.md:57
msgid ""
"We can do better using **generics**.  \n"
"Generics allow us to write code that works with a **type parameter** instead "
"of a concrete type:"
msgstr ""
"**제네릭**을 사용하면 더 나은 결과를 얻을 수 있습니다.  \n"
"제네릭을 사용하면 구체적인 타입 대신 **타입 매개변수**로 작동하는 코드를 작성"
"할 수 있습니다:"

#: src/04_traits/05_trait_bounds.md:66 src/04_traits/05_trait_bounds.md:89
msgid "\"{n:?} is even\""
msgstr "\"{n:?} is even\""

#: src/04_traits/05_trait_bounds.md:71
msgid ""
"`print_if_even` is a **generic function**.  \n"
"It isn't tied to a specific input type. Instead, it works with any type `T` "
"that:"
msgstr ""
"`print_if_even`은 **제네릭 함수**입니다.  \n"
"특정 입력 타입에 제한되지않습니다. 대신 다음과 같은 모든 타입 `T`와 함께 작동"
"합니다."

#: src/04_traits/05_trait_bounds.md:74
msgid "Implements the `IsEven` trait."
msgstr "`IsEven` 트레잇을 구현할 떄."

#: src/04_traits/05_trait_bounds.md:75
msgid "Implements the `Debug` trait."
msgstr "`Debug` 트레잇을 구현할 때."

#: src/04_traits/05_trait_bounds.md:77
msgid ""
"This contract is expressed with a **trait bound**: `T: IsEven + Debug`.  \n"
"The `+` symbol is used to require that `T` implements multiple traits. `T: "
"IsEven + Debug` is equivalent to \"where `T` implements `IsEven` **and** "
"`Debug`\"."
msgstr ""
"이 요구사항은 **트레잇 바운드**: `T: IsEven + Debug`로 표현됩니다.  \n"
"`+` 기호는 `T`가 여러 트레잇을 구현하도록 요구하는 데 사용됩니다. `T: IsEven "
"+ Debug`는 \"`T`가 `IsEven` **그리고** `Debug`를 구현할 때\"라는 말과 같습니"
"다."

#: src/04_traits/05_trait_bounds.md:83
msgid ""
"What purpose do trait bounds serve in `print_if_even`?  \n"
"To find out, let's try to remove them:"
msgstr ""
"`print_if_even`에서 트레잇 바운드는 어떤 목적으로 사용될까요?  \n"
"알아보기 위해 이를 제거해 보겠습니다:"

#: src/04_traits/05_trait_bounds.md:94
msgid "This code won't compile:"
msgstr "이 코드는 컴파일되지 않습니다:"

#: src/04_traits/05_trait_bounds.md:96
msgid ""
"```text\n"
"error[E0599]: no method named `is_even` found for type parameter `T` in the "
"current scope\n"
" --> src/lib.rs:2:10\n"
"  |\n"
"1 | fn print_if_even<T>(n: T) {\n"
"  |                  - method `is_even` not found for this type parameter\n"
"2 |     if n.is_even() {\n"
"  |          ^^^^^^^ method not found in `T`\n"
"\n"
"error[E0277]: `T` doesn't implement `Debug`\n"
" --> src/lib.rs:3:19\n"
"  |\n"
"3 |         println!(\"{n:?} is even\");\n"
"  |                   ^^^^^ `T` cannot be formatted using `{:?}` because it "
"doesn't implement `Debug`\n"
"  |\n"
"help: consider restricting type parameter `T`\n"
"  |\n"
"1 | fn print_if_even<T: std::fmt::Debug>(n: T) {\n"
"  |                   +++++++++++++++++\n"
"```"
msgstr ""
"```text\n"
"error[E0599]: no method named `is_even` found for type parameter `T` in the "
"current scope\n"
" --> src/lib.rs:2:10\n"
"  |\n"
"1 | fn print_if_even<T>(n: T) {\n"
"  |                  - method `is_even` not found for this type parameter\n"
"2 |     if n.is_even() {\n"
"  |          ^^^^^^^ method not found in `T`\n"
"\n"
"error[E0277]: `T` doesn't implement `Debug`\n"
" --> src/lib.rs:3:19\n"
"  |\n"
"3 |         println!(\"{n:?} is even\");\n"
"  |                   ^^^^^ `T` cannot be formatted using `{:?}` because it "
"doesn't implement `Debug`\n"
"  |\n"
"help: consider restricting type parameter `T`\n"
"  |\n"
"1 | fn print_if_even<T: std::fmt::Debug>(n: T) {\n"
"  |                   +++++++++++++++++\n"
"```"

#: src/04_traits/05_trait_bounds.md:117
msgid ""
"Without trait bounds, the compiler doesn't know what `T` **can do**.  \n"
"It doesn't know that `T` has an `is_even` method, and it doesn't know how to "
"format `T` for printing. From the compiler point of view, a bare `T` has no "
"behaviour at all.  \n"
"Trait bounds restrict the set of types that can be used by ensuring that the "
"behaviour required by the function body is present."
msgstr ""
"트레잇 바운드가 없으면 컴파일러는 `T`가 **할 수 있는** 작업을 알 수 없습니"
"다.  \n"
"`T`에 `is_even` 메서드가 있다는 사실도 모르고, 프린트를 위해 `T` 타입을 포맷팅"
"하는 방법도 모릅니다. 컴파일러의 관점에서 보면 `T`로는 아무것도 할 수 없습니"
"다.  \n"
"트레잇 바운드는 함수 본문에서 요구하는 동작이 존재하는지 확인하여 함수에 사용"
"할 수 있는 타입들을 제한합니다."

#: src/04_traits/05_trait_bounds.md:123
msgid "Syntax: inlining trait bounds"
msgstr "구문: 인라인 트레잇 바운드"

#: src/04_traits/05_trait_bounds.md:125
msgid ""
"All the examples above used a **`where` clause** to specify trait bounds:"
msgstr ""
"위의 모든 예에서는 트레잇 바운드를 지정하기 위해 **`where` 절**을 사용했습니"
"다:"

#: src/04_traits/05_trait_bounds.md:130
msgid ""
"//  ^^^^^^^^^^^^^^^^^\n"
"//  This is a `where` clause\n"
msgstr ""
"//  ^^^^^^^^^^^^^^^^^\n"
"//  이게 `where` 절입니다\n"

#: src/04_traits/05_trait_bounds.md:138
msgid ""
"If the trait bounds are simple, you can **inline** them directly next to the "
"type parameter:"
msgstr ""
"트레잇 바운드가 단순한 경우 타입 매개변수 바로 옆에 **인라인**할 수 있습니다:"

#: src/04_traits/05_trait_bounds.md:142
msgid ""
"//           ^^^^^^^^^^^^^^^^^\n"
"    //           This is an inline trait bound\n"
"    // [...]\n"
msgstr ""
"//           ^^^^^^^^^^^^^^^^^\n"
"    //           이게 인라인 트레잇 바운드입니다\n"
"    // [...]\n"

#: src/04_traits/05_trait_bounds.md:148
msgid "Syntax: meaningful names"
msgstr "구문: 의미 있는 이름"

#: src/04_traits/05_trait_bounds.md:150
msgid ""
"In the examples above, we used `T` as the type parameter name. This is a "
"common convention when a function has only one type parameter.  \n"
"Nothing stops you from using a more meaningful name, though:"
msgstr ""
"위의 예에서는 `T`를 타입 매개변수 이름으로 사용했습니다. 이는 함수에 타입 매개"
"변수가 하나만 있는 경우 일반적인 규칙입니다.  \n"
"더 의미 있는 이름을 사용하셔도 됩니다:"

#: src/04_traits/05_trait_bounds.md:160
msgid ""
"It is actually **desirable** to use meaningful names when there are multiple "
"type parameters at play or when the name `T` doesn't convey enough "
"information about the type's role in the function. Maximize clarity and "
"readability when naming type parameters, just as you would with variables or "
"function parameters. Follow Rust's conventions, though: use [upper camel case "
"for type parameter names](https://rust-lang.github.io/api-guidelines/naming."
"html#casing-conforms-to-rfc-430-c-case)."
msgstr ""
"실제로 여러 타입 매개변수가 있거나 `T`라는 이름이 함수에서 해당 타입의 역할에 "
"대한 충분한 정보를 전달하지 못하는 경우 의미 있는 이름을 사용하는 것이 **바람"
"직합니다**. 변수나 함수 매개변수와 마찬가지로 타입 매개변수의 이름을 지정할 "
"때 명확성과 가독성을 최대화하세요. 동시에 Rust의 규칙도 지켜주세요. [타입 매개"
"변수 이름에는 대문자 카멜케이스](https://rust-lang.github.io/api-guidelines/"
"naming.html#casing-conforms-to-rfc-430-c-case)를 사용하십시오."

#: src/04_traits/05_trait_bounds.md:165
msgid "The function signature is king"
msgstr "함수 시그니처는 왕이다"

#: src/04_traits/05_trait_bounds.md:167
msgid ""
"You may wonder why we need trait bounds at all. Can't the compiler infer the "
"required traits from the function's body?  \n"
"It could, but it won't.  \n"
"The rationale is the same as for [explicit type annotations on function "
"parameters](../02_basic_calculator/02_variables.md#function-arguments-are-"
"variables): each function signature is a contract between the caller and the "
"callee, and the terms must be explicitly stated. This allows for better error "
"messages, better documentation, less unintentional breakages across versions, "
"and faster compilation times."
msgstr ""
"트레잇 바운드가 왜 필요한지 궁금할 수도 있습니다. 컴파일러가 함수 본문에서 필"
"요한 트레잇을 추론할 순 없나요?  \n"
"그럴 수도 있겠지만 실제론 그렇지 않습니다.  \n"
"그 근거는 함수 매개변수에 대한 명시적 타입 어노테이션의 경우와 동일합니다. 각 "
"함수 시그니처는 호출자와 호출 수신자 간의 계약이며 용어가 명시적으로 명시되어"
"야 합니다. 이를 통해 더 나은 오류 메시지, 더 나은 문서화, 버전 간 의도하지 않"
"은 문제 감소 그리고 더 빠른 컴파일이 가능해집니다."

#: src/04_traits/05_trait_bounds.md:176
msgid ""
"The exercise for this section is located in [`04_traits/05_trait_bounds`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/05_trait_bounds)"
msgstr ""
"이 섹션의 예제는 [`04_traits/05_trait_bounds`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/05_trait_bounds)에 있습니다"

#: src/04_traits/06_str_slice.md:3
msgid ""
"Throughout the previous chapters you've seen quite a few **string literals** "
"being used in the code, like `\"To-Do\"` or `\"A ticket description\"`. They "
"were always followed by a call to `.to_string()` or `.into()`. It's time to "
"understand why!"
msgstr ""
"이전 장 전체에서 `\"To-Do\"` 또는 `\"A ticket Description\"`과 같은 코드에서 "
"사용되는 **문자열 리터럴**을 꽤 많이 보았습니다. 그 뒤에는 항상 `."
"to_string()` 또는 `.into()`에 대한 호출이 이어졌습니다. 이제 그 이유를 이해할 "
"시간입니다!"

#: src/04_traits/06_str_slice.md:7
msgid "String literals"
msgstr "문자열 리터럴"

#: src/04_traits/06_str_slice.md:9
msgid "You define a string literal by enclosing the raw text in double quotes:"
msgstr "원시 텍스트를 큰따옴표로 묶어 문자열 리터럴을 정의합니다:"

#: src/04_traits/06_str_slice.md:12
msgid "\"Hello, world!\""
msgstr "\"Hello, world!\""

#: src/04_traits/06_str_slice.md:15
msgid "The type of `s` is `&str`, a **reference to a string slice**."
msgstr "`s`의 유형은 **문자열 슬라이스에 대한 참조**인 `&str`입니다."

#: src/04_traits/06_str_slice.md:19
msgid ""
"`&str` and `String` are different types—they're not interchangeable.  \n"
"Let's recall the memory layout of a `String` from our [previous exploration]"
"(../03_ticket_v1/09_heap.md). If we run:"
msgstr ""
"`&str`과 `String`은 서로 다른 유형이므로 서로 바꿔 사용할 수 없습니다.  \n"
"[이전 시간](../03_ticket_v1/09_heap.md)에서 본 `String`의 메모리 레이아웃을 떠"
"올려 보겠습니다. 다음을 실행하면:"

#: src/04_traits/06_str_slice.md:29
msgid "we'll get this scenario in memory:"
msgstr "우리는 이 상황에서 메모리는 다음과 같습니다:"

#: src/04_traits/06_str_slice.md:44
msgid ""
"If you remember, we've [also examined]"
"(../03_ticket_v1/10_references_in_memory.md) how a `&String` is laid out in "
"memory:"
msgstr ""
"`&String`이 메모리에 어떻게 배치되는지도 [살펴보았습니다]"
"(../03_ticket_v1/10_references_in_memory.md):"

#: src/04_traits/06_str_slice.md:62
msgid ""
"`&String` points to the memory location where the `String`'s metadata is "
"stored.  \n"
"If we follow the pointer, we get to the heap-allocated data. In particular, "
"we get to the first byte of the string, `H`."
msgstr ""
"`&String`은 `String`의 메타데이터가 저장되는 메모리 위치를 가리킵니다.  \n"
"포인터를 따라가면 힙에 할당된 데이터에 도달합니다. 정확히는, 문자열의 첫 번째 "
"바이트 `H`에 도달합니다."

#: src/04_traits/06_str_slice.md:65
msgid ""
"What if we wanted a type that represents a **substring** of `s`? E.g. `ello` "
"in `Hello`?"
msgstr ""
"`s`의 **서브스트링**을 나타내는 타입은 어떻게 표현할까요? 예: 'Hello'의 "
"'ello'같이?"

#: src/04_traits/06_str_slice.md:69
msgid ""
"A `&str` is a **view** into a string, a **reference** to a sequence of UTF-8 "
"bytes stored elsewhere. You can, for example, create a `&str` from a `String` "
"like this:"
msgstr ""
"`&str`은 문자열에 대한 **뷰**, 다른 곳에 저장된 UTF-8 바이트 시퀀스에 대한 **"
"참조**입니다. 예를 들어 다음과 같이 `String`에서 `&str`을 만들 수 있습니다."

#: src/04_traits/06_str_slice.md:74 src/04_traits/08_sized.md:13
msgid ""
"// Create a string slice reference from the `String`, skipping the first "
"byte.\n"
msgstr ""
"// `String`에서 문자열 슬라이스 참조를 생성하고 첫 번째 바이트를 건너뜁니다.\n"

#: src/04_traits/06_str_slice.md:79
msgid "In memory, it'd look like this:"
msgstr "메모리에서는 다음과 같습니다:"

#: src/04_traits/06_str_slice.md:98
msgid "`slice` stores two pieces of information on the stack:"
msgstr "`slice`는 스택에 두 가지 정보를 저장합니다:"

#: src/04_traits/06_str_slice.md:100
msgid "A pointer to the first byte of the slice."
msgstr "슬라이스의 첫 번째 바이트에 대한 포인터."

#: src/04_traits/06_str_slice.md:101
msgid "The length of the slice."
msgstr "슬라이스의 길이."

#: src/04_traits/06_str_slice.md:103
msgid ""
"`slice` doesn't own the data, it just points to it: it's a **reference** to "
"the `String`'s heap-allocated data.  \n"
"When `slice` is dropped, the heap-allocated data won't be deallocated, "
"because it's still owned by `s`. That's why `slice` doesn't have a `capacity` "
"field: it doesn't own the data, so it doesn't need to know how much space it "
"was allocated for it; it only cares about the data it references."
msgstr ""

#: src/04_traits/06_str_slice.md:108
msgid "`&str` vs `&String`"
msgstr "`&str` vs `&String`"

#: src/04_traits/06_str_slice.md:110
msgid ""
"As a rule of thumb, use `&str` rather than `&String` whenever you need a "
"reference to textual data.  \n"
"`&str` is more flexible and generally considered more idiomatic in Rust code."
msgstr ""
"경험상 텍스트 데이터에 대한 참조가 필요할 때는 `&String` 대신 `&str`을 사용하"
"는 것이 좋습니다.  \n"
"`&str`은 더 유연하고 일반적으로 Rust에서 더 관용적입니다."

#: src/04_traits/06_str_slice.md:113
msgid ""
"If a method returns a `&String`, you're promising that there is heap-"
"allocated UTF-8 text somewhere that **matches exactly** the one you're "
"returning a reference to.  \n"
"If a method returns a `&str`, instead, you have a lot more freedom: you're "
"just saying that _somewhere_ there's a bunch of text data and that a subset "
"of it matches what you need, therefore you're returning a reference to it."
msgstr ""
"메서드가 `&String`을 반환하면, 힙에 할당된 UTF-8 텍스트가 있으며, 해당 텍스트"
"가 반환되는 참조와 **정확히 일치**한다는 것을 의미합니다.\n"
"반면에 메서드가 `&str`을 반환하면, 훨씬 더 많은 자유를 가지게 됩니다: _어딘가"
"에_ 텍스트 데이터가 있으며, 그 일부가 필요한 것과 일치한다는 것만을 말하는 것"
"이므로 그 부분에 대한 참조를 반환하는 것입니다."

#: src/04_traits/06_str_slice.md:120
msgid ""
"The exercise for this section is located in [`04_traits/06_str_slice`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/06_str_slice)"
msgstr ""
"이 섹션의 예제는 [`04_traits/06_str_slice`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/04_traits/06_str_slice)에 있습니다"

#: src/04_traits/07_deref.md:3
msgid "In the previous exercise you didn't have to do much, did you?"
msgstr "이전 예제에서는 많은 일을 할 필요가 없었습니다. 그렇죠?"

#: src/04_traits/07_deref.md:5
msgid "Changing"
msgstr "이것을"

#: src/04_traits/07_deref.md:15
msgid "to"
msgstr "이렇게"

#: src/04_traits/07_deref.md:25
msgid ""
"was all you needed to do to get the code to compile and the tests to pass. "
"Some alarm bells should be ringing in your head though."
msgstr ""
"바꾸는 것이 코드를 컴파일하고 테스트를 통과하기 위해 해야 할 일의 전부였습니"
"다. 하지만 머리에 번뜩 떠오르는 것이 있어야 합니다."

#: src/04_traits/07_deref.md:28
msgid "It shouldn't work, but it does"
msgstr "작동하면 안 되지만 작동합니다"

#: src/04_traits/07_deref.md:30
msgid "Let's review the facts:"
msgstr "다음을 확인해봅시다:"

#: src/04_traits/07_deref.md:32
msgid "`self.title` is a `String`"
msgstr "`self.title`은 `String`입니다"

#: src/04_traits/07_deref.md:33
msgid "`&self.title` is, therefore, a `&String`"
msgstr "따라서 `&self.title`은 `&String`입니다"

#: src/04_traits/07_deref.md:34
msgid "The output of the (modified) `title` method is `&str`"
msgstr "(수정된) `title` 메소드의 출력은 `&str`입니다"

#: src/04_traits/07_deref.md:36
msgid ""
"You would expect a compiler error, wouldn't you? `Expected &String, found "
"&str` or something similar. Instead, it just works. **Why**?"
msgstr ""
"컴파일러 오류가 발생해야할 것 같지 않나요? `Expected &String, found &str`같은 "
"오류 말입니다. 근데 작동합니다. **왜**그럴까요?"

#: src/04_traits/07_deref.md:39
msgid "`Deref` to the rescue"
msgstr "`Deref`가 당신을 구원합니다"

#: src/04_traits/07_deref.md:41
msgid ""
"The `Deref` trait is the mechanism behind the language feature known as "
"[**deref coercion**](https://doc.rust-lang.org/std/ops/trait.Deref.html#deref-"
"coercion).  \n"
"The trait is defined in the standard library, in the `std::ops` module:"
msgstr ""
"`Deref` 트레잇은 [**deref coercion**](https://doc.rust-lang.org/std/ops/trait."
"Deref.html#deref-coercion)라고 알려진 언어 기능 뒤에 있는 메커니즘입니다.  \n"
"이 트레잇은 표준 라이브러리의 `std::ops` 모듈에 정의되어 있습니다."

#: src/04_traits/07_deref.md:45
msgid ""
"// I've slightly simplified the definition for now.\n"
"// We'll see the full definition later on.\n"
msgstr ""
"// 지금은 정의를 약간 단순화했습니다.\n"
"// 나중에 전체 정의를 살펴보겠습니다.\n"

#: src/04_traits/07_deref.md:54
msgid ""
"`type Target` is an **associated type**.  \n"
"It's a placeholder for a concrete type that must be specified when the trait "
"is implemented."
msgstr ""
"`type Target`은 **연관된 타입**입니다.  \n"
"이는 트레잇이 구현될 때 지정되어야 하는 구체적인 타입에 대한 플레이스 홀더입니"
"다."

#: src/04_traits/07_deref.md:57
msgid "Deref coercion"
msgstr "Deref coercion"

#: src/04_traits/07_deref.md:59
msgid ""
"By implementing `Deref<Target = U>` for a type `T` you're telling the "
"compiler that `&T` and `&U` are somewhat interchangeable.  \n"
"In particular, you get the following behavior:"
msgstr ""
"`T` 타입에 대해 `Deref<Target = U>`를 구현하면 컴파일러에게 `&T`와 `&U`가 어"
"느 정도 상호 교환 가능하다는 것을 알리게 됩니다.  \n"
"특히 다음과 같은 동작이 발생합니다:"

#: src/04_traits/07_deref.md:63
msgid ""
"References to `T` are implicitly converted into references to `U` (i.e. `&T` "
"becomes `&U`)"
msgstr ""
"`T`에 대한 참조는 암시적으로 `U`에 대한 참조로 변환됩니다(즉: `&T`는 `&U`가 됩"
"니다)."

#: src/04_traits/07_deref.md:64
msgid ""
"You can call on `&T` all the methods defined on `U` that take `&self` as "
"input."
msgstr ""
"`&self`를 입력으로 사용하는 `U`에 정의된 모든 메서드를 `&T`에서 호출할 수 있습"
"니다."

#: src/04_traits/07_deref.md:66
msgid ""
"There is one more thing around the dereference operator, `*`, but we don't "
"need it yet (see `std`'s docs if you're curious)."
msgstr ""
"역참조 연산자 `*`에는 한 가지가 더 있지만 아직은 필요하지 않습니다(궁금하시면 "
"`std` 문서를 참조하세요)."

#: src/04_traits/07_deref.md:69
msgid "`String` implements `Deref`"
msgstr "`String`은 `Deref`를 구현합니다"

#: src/04_traits/07_deref.md:71
msgid "`String` implements `Deref` with `Target = str`:"
msgstr "`String`은 `Target = str`을 사용하여 `Deref`를 구현합니다:"

#: src/04_traits/07_deref.md:83
msgid ""
"Thanks to this implementation and deref coercion, a `&String` is "
"automatically converted into a `&str` when needed."
msgstr ""
"이 구현과 Deref coercion 덕분에 `&String`은 필요할 때 자동으로 `&str`로 변환됩"
"니다."

#: src/04_traits/07_deref.md:85
msgid "Don't abuse deref coercion"
msgstr "deref coercion을 남용하지 마세요"

#: src/04_traits/07_deref.md:87
msgid ""
"Deref coercion is a powerful feature, but it can lead to confusion.  \n"
"Automatically converting types can make the code harder to read and "
"understand. If a method with the same name is defined on both `T` and `U`, "
"which one will be called?"
msgstr ""
"Deref coercion은 강력한 기능이지만 혼란을 초래할 수 있습니다.  \n"
"타입을 자동으로 변환하면 코드를 읽고 이해하기가 더 어려워질 수 있습니다. `T`"
"와 `U`에 동일한 이름의 메소드가 정의된 경우 어느 메소드가 호출될까요?"

#: src/04_traits/07_deref.md:91
msgid ""
"We'll examine later in the course the \"safest\" use cases for deref "
"coercion: smart pointers."
msgstr ""
"Deref coercion에 대한 \"가장 안전한\" 사용 사례인 스마트 포인터에 대해 나중에 "
"과정에서 살펴보겠습니다."

#: src/04_traits/07_deref.md:95
msgid ""
"The exercise for this section is located in [`04_traits/07_deref`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/07_deref)"
msgstr ""
"이 섹션의 예제는 [`04_traits/07_deref`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/04_traits/07_deref)에 있습니다"

#: src/04_traits/08_sized.md:1
msgid "`Sized`"
msgstr "`Sized`"

#: src/04_traits/08_sized.md:3
msgid ""
"There's more to `&str` than meets the eye, even after having investigated "
"deref coercion.  \n"
"From our previous [discussion on memory layouts]"
"(../03_ticket_v1/10_references_in_memory.md), it would have been reasonable "
"to expect `&str` to be represented as a single `usize` on the stack, a "
"pointer. That's not the case though. `&str` stores some **metadata** next to "
"the pointer: the length of the slice it points to. Going back to the example "
"from [a previous section](06_str_slice.md):"
msgstr ""
"Deref coercion에 대해 알아본 후에도 `&str`에는 눈에 보이는 것보다 더 많은 것"
"이 있습니다.  \n"
"메모리 레이아웃에 대한 이전 논의에서 `&str`이 스택에서 단일 `usize`인 포인터"
"로 표현될 것으로 예상하는 것이 합리적이었습니다. 하지만 그렇지 않습니다. "
"`&str`은 포인터 옆에 일부 **메타데이터**, 즉 포인터가 가리키는 슬라이스의 길이"
"를 저장합니다. 이전 섹션의 예로 돌아가면 다음과 같습니다:"

#: src/04_traits/08_sized.md:18
msgid "In memory, we get:"
msgstr "메모리는 다음과 같습니다:"

#: src/04_traits/08_sized.md:37
msgid "What's going on?"
msgstr "무슨 일일까요?"

#: src/04_traits/08_sized.md:39
msgid "Dynamically sized types"
msgstr "동적 크기 타입"

#: src/04_traits/08_sized.md:41
msgid ""
"`str` is a **dynamically sized type** (DST).  \n"
"A DST is a type whose size is not known at compile time. Whenever you have a "
"reference to a DST, like `&str`, it has to include additional information "
"about the data it points to. It is a **fat pointer**.  \n"
"In the case of `&str`, it stores the length of the slice it points to. We'll "
"see more examples of DSTs in the rest of the course."
msgstr ""
"`str`은 **동적 크기 타입**(DST)입니다.  \n"
"DST는 컴파일 타임에 크기를 알 수 없는 타입입니다. `&str`과 같은 DST에 대한 참"
"조가 있을 때마다 참조가 가리키는 데이터에 대한 추가 정보를 포함해야 합니다. **"
"팻 포인터**입니다.  \n"
"`&str`의 경우 가리키는 슬라이스의 길이를 저장합니다. 뒤에서는 DST의 더 많은 예"
"를 살펴보겠습니다."

#: src/04_traits/08_sized.md:48
msgid "The `Sized` trait"
msgstr "`Sized` 트레잇"

#: src/04_traits/08_sized.md:50
msgid "Rust's `std` library defines a trait called `Sized`."
msgstr "Rust의 `std` 라이브러리는 `Sized`라는 트레잇을 정의합니다."

#: src/04_traits/08_sized.md:54
msgid "// This is an empty trait, no methods to implement.\n"
msgstr "// 이것은 빈 특성이므로 구현할 메서드가 없습니다.\n"

#: src/04_traits/08_sized.md:58
msgid ""
"A type is `Sized` if its size is known at compile time. In other words, it's "
"not a DST."
msgstr "컴파일 타임에 크기가 알려지면 유형은 `Sized`입니다. 즉, DST가 아닙니다."

#: src/04_traits/08_sized.md:60
msgid "Marker traits"
msgstr "Marker 트레잇"

#: src/04_traits/08_sized.md:62
msgid ""
"`Sized` is your first example of a **marker trait**.  \n"
"A marker trait is a trait that doesn't require any methods to be implemented. "
"It doesn't define any behavior. It only serves to **mark** a type as having "
"certain properties. The mark is then leveraged by the compiler to enable "
"certain behaviors or optimizations."
msgstr ""
"`Sized`는 **marker 트레잇**의 첫 번째 예입니다.  \n"
"marker 트레잇은 구현하는 데 메서드가 필요하지 않은 특성입니다. 어떤 행동도 정"
"의하지 않습니다. 특정 속성이 있는 타입을 **표시**하는 역할만 합니다. 그런 다"
"음 컴파일러는 표시를 활용하여 특정 동작이나 최적화를 활성화합니다."

#: src/04_traits/08_sized.md:67
msgid "Auto traits"
msgstr "Auto 트레잇"

#: src/04_traits/08_sized.md:69
msgid ""
"In particular, `Sized` is also an **auto trait**.  \n"
"You don't need to implement it explicitly; the compiler implements it "
"automatically for you based on the type's definition."
msgstr ""
"사실, `Sized`도 **auto 트레잇**입니다.  \n"
"명시적으로 구현할 필요가 없으며, 컴파일러가 타입의 정의를 기반으로 자동으로 구"
"현해줍니다."

#: src/04_traits/08_sized.md:73
msgid "Examples"
msgstr "예시"

#: src/04_traits/08_sized.md:75
msgid ""
"All the types we've seen so far are `Sized`: `u32`, `String`, `bool`, etc."
msgstr ""
"지금까지 우리가 본 모든 타입은 `Sized`입니다: `u32`, `String`, `bool` 등."

#: src/04_traits/08_sized.md:77
msgid ""
"`str`, as we just saw, is not `Sized`.  \n"
"`&str` is `Sized` though! We know its size at compile time: two `usize`s, one "
"for the pointer and one for the length."
msgstr ""
"방금 본 것처럼 `str`은 `Sized`가 아닙니다.  \n"
"하지만 `&str`은 `Sized`입니다! 우리는 컴파일 타임에 그 크기를 알고 있습니다. "
"두 개의 `usize`, 하나는 포인터용이고 다른 하나는 길이용입니다."

#: src/04_traits/08_sized.md:83
msgid ""
"The exercise for this section is located in [`04_traits/08_sized`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/08_sized)"
msgstr ""
"이 섹션의 예제는 [`04_traits/08_sized`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/04_traits/08_sized)에 있습니다"

#: src/04_traits/09_from.md:1 src/04_traits/09_from.md:27
msgid "`From` and `Into`"
msgstr "`From`과 `Into`"

#: src/04_traits/09_from.md:3
msgid "Let's go back to where our string journey started:"
msgstr "문자열 여행이 시작된 곳으로 돌아가 보겠습니다:"

#: src/04_traits/09_from.md:6 src/04_traits/09_from.md:106
msgid "\"A title\""
msgstr "\"A title\""

#: src/04_traits/09_from.md:6
msgid "\"A description\""
msgstr "\"A description\""

#: src/04_traits/09_from.md:9
msgid "We now know enough to start unpacking what `.into()` is doing here."
msgstr ""
"이제 우리는 `.into()`가 여기서 무엇을 하는지 이해할 만큼 충분히 알고 있습니다."

#: src/04_traits/09_from.md:13
msgid "This is the signature of the `new` method:"
msgstr "이것은 `new` 메서드의 시그니처입니다:"

#: src/04_traits/09_from.md:23
msgid ""
"We've also seen that string literals (such as `\"A title\"`) are of type "
"`&str`.  \n"
"We have a type mismatch here: a `String` is expected, but we have a `&str`. "
"No magical coercion will come to save us this time; we need **to perform a "
"conversion**."
msgstr ""
"문자열 리터럴(예: \"A title\")이 `&str` 타입이라는 것도 보았습니다.\n"
"여기서 타입 불일치가 발생합니다: `String`일것으로 예상하지만 우리는 `&str`을 "
"가지고 있습니다. 이번에는 마법 같은 강제 변환이 우리를 구해주지 않을 것입니"
"다; 우리는 직접 **변환을 수행해야 합니다**."

#: src/04_traits/09_from.md:29
msgid ""
"The Rust standard library defines two traits for **infallible conversions**: "
"`From` and `Into`, in the `std::convert` module."
msgstr ""
"Rust 표준 라이브러리는 `std::convert` 모듈에서 **무결한 변환**에 대한 두 가지 "
"트레잇, 즉 `From`과 `Into`를 정의합니다."

#: src/04_traits/09_from.md:42
msgid ""
"These trait definitions showcase a few concepts that we haven't seen before: "
"**supertraits** and **implicit trait bounds**. Let's unpack those first."
msgstr ""
"이러한 트레잇 정의는 이전에 보지 못한 몇 가지 개념인 **슈퍼 트레잇** 및 **암시"
"적 트레잇 바운드**를 보여줍니다. 이것들을 먼저 살펴보겠습니다."

#: src/04_traits/09_from.md:45
msgid "Supertrait / Subtrait"
msgstr "슈퍼 트레잇 / 서브 트레잇"

#: src/04_traits/09_from.md:47
msgid ""
"The `From: Sized` syntax implies that `From` is a **subtrait** of `Sized`: "
"any type that implements `From` must also implement `Sized`. Alternatively, "
"you could say that `Sized` is a **supertrait** of `From`."
msgstr ""
"`From: Sized` 구문은 `From`이 `Sized`의 **서브 트레잇**임을 의미합니다. `From`"
"을 구현하는 모든 타입은 `Sized`도 구현해야 합니다. 또는 `Sized`가 `From`의 **"
"슈퍼 트레잇**이라고 말할 수도 있습니다."

#: src/04_traits/09_from.md:51
msgid "Implicit trait bounds"
msgstr "암시적 트레잇 바운드"

#: src/04_traits/09_from.md:53
msgid ""
"Every time you have a generic type parameter, the compiler implicitly assumes "
"that it's `Sized`."
msgstr ""
"일반 타입 매개변수가 있을 때마다 컴파일러는 암시적으로 해당 매개변수가 `Sized`"
"라고 가정합니다."

#: src/04_traits/09_from.md:63
msgid "is actually equivalent to:"
msgstr "실제로는 다음과 같습니다:"

#: src/04_traits/09_from.md:72
msgid "In the case of `From<T>`, the trait definition is equivalent to:"
msgstr "`From<T>`의 경우 트레잇 정의는 다음과 동일합니다:"

#: src/04_traits/09_from.md:80
msgid ""
"In other words, _both_ `T` and the type implementing `From<T>` must be "
"`Sized`, even though the former bound is implicit."
msgstr ""
"즉, `T`와 `From<T>`를 구현하는 유형은 _둘 다_ `Sized`여야 합니다. 전자의 바운"
"드가 암시적이라 할지라도 말이죠."

#: src/04_traits/09_from.md:83
msgid "Negative trait bounds"
msgstr "네거티브 트레잇 바운드"

#: src/04_traits/09_from.md:85
msgid ""
"You can opt out of the implicit `Sized` bound with a **negative trait bound**:"
msgstr ""
"**네거티브 트레잇 바운드**를 사용하여 암시적 `Sized` 바운드를 제외할 수 있습니"
"다."

#: src/04_traits/09_from.md:89
msgid ""
"//            ^^^^^^^\n"
"    //            This is a negative trait bound\n"
msgstr ""
"//            ^^^^^^^\n"
"    //            이게 네거티브 트레잇 바운드입니다\n"

#: src/04_traits/09_from.md:95
msgid ""
"This syntax reads as \"`T` may or may not be `Sized`\", and it allows you to "
"bind `T` to a DST (e.g. `Foo<str>`). It is a special case, though: negative "
"trait bounds are exclusive to `Sized`, you can't use them with other traits."
msgstr ""
"이 구문은 \"`T`는 `Sized`일 수도 있고 아닐 수도 있음\"으로 읽혀지며, 이를 통"
"해 `T`를 DST(예: `Foo<str>`)에 바인딩할 수 있습니다. 하지만 이것은 특별한 경우"
"입니다. 네거티브 트레잇 바운드는 `Sized`에만 적용되며 다른 특성에는 사용할 수 "
"없습니다."

#: src/04_traits/09_from.md:99
msgid "`&str` to `String`"
msgstr "`&str`을 `String`으로"

#: src/04_traits/09_from.md:101
msgid ""
"In [`std`'s documentation](https://doc.rust-lang.org/std/convert/trait.From."
"html#implementors) you can see which `std` types implement the `From` "
"trait.  \n"
"You'll find that `String` implements `From<&str> for String`. Thus, we can "
"write:"
msgstr ""
"[`std` 문서](https://doc.rust-lang.org/std/convert/trait.From."
"html#implementors)에서 어떤 `std` 타입이 `From` 트레잇을 구현하는지 확인할 수 "
"있습니다.  \n"
"`String`은 `From<&str> for String`을 구현한다는 것을 알 수 있습니다. 따라서 우"
"리는 다음과 같이 쓸 수 있습니다:"

#: src/04_traits/09_from.md:109
msgid ""
"We've been primarily using `.into()`, though.  \n"
"If you check out the [implementors of `Into`](https://doc.rust-lang.org/std/"
"convert/trait.Into.html#implementors) you won't find `Into<&str> for String`. "
"What's going on?"
msgstr ""
"하지만 우리는 주로 `.into()`를 사용해 왔습니다.  \n"
"`Into` 구현자를 확인해 보면 `Into<&str> for String`을 찾을 수 없습니다. 무슨 "
"일일까요?"

#: src/04_traits/09_from.md:113
msgid ""
"`From` and `Into` are **dual traits**.  \n"
"In particular, `Into` is implemented for any type that implements `From` "
"using a **blanket implementation**:"
msgstr ""
"`From`과 `Into`는 **듀얼 트레잇**입니다.  \n"
"특히 `Into`는 **블랭킷 구현**을 사용하여 `From`을 구현하는 모든 타입에 대해 구"
"현됩니다."

#: src/04_traits/09_from.md:127
msgid ""
"If a type `U` implements `From<T>`, then `Into<U> for T` is automatically "
"implemented. That's why we can write `let title = \"A title\".into();`."
msgstr ""
"타입 `U`가 `From<T>`를 구현하면, `Into<U> for T`는 자동으로 구현됩니다. 그래"
"서 `let title = \"A title\".into();`와 같이 쓸 수 있는 것입니다."

#: src/04_traits/09_from.md:130
msgid "`.into()`"
msgstr "`.into()`"

#: src/04_traits/09_from.md:132
msgid ""
"Every time you see `.into()`, you're witnessing a conversion between "
"types.  \n"
"What's the target type, though?"
msgstr ""
"`.into()`를 볼 때마다 타입 간의 변환을 목격하고 있는 것입니다.  \n"
"그런데 대상 타입은 무엇일까요?"

#: src/04_traits/09_from.md:135
msgid "In most cases, the target type is either:"
msgstr "대부분의 경우 대상 타입은 다음 중 하나입니다:"

#: src/04_traits/09_from.md:137
msgid ""
"Specified by the signature of a function/method (e.g. `Ticket::new` in our "
"example above)"
msgstr "함수/메서드의 시그니처로 지정된 것(예: 이전 예시의 `Ticket::new`)"

#: src/04_traits/09_from.md:138
msgid ""
"Specified in the variable declaration with a type annotation (e.g. `let "
"title: String = \"A title\".into();`)"
msgstr ""
"변수 선언때 타입 어노테이션으로 명시된 것 (예:` let title: String = \"A "
"title\".into();`)"

#: src/04_traits/09_from.md:140
msgid ""
"`.into()` will work out of the box as long as the compiler can infer the "
"target type from the context without ambiguity."
msgstr ""
"`.into()`는 컴파일러가 모호함 없이 컨텍스트에서 대상 타입을 추론할 수 있다면 "
"즉시 작동합니다."

#: src/04_traits/09_from.md:144
msgid ""
"The exercise for this section is located in [`04_traits/09_from`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/09_from)"
msgstr ""
"이 섹션의 예제는 [`04_traits/09_from`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/04_traits/09_from)에 있습니다"

#: src/04_traits/10_assoc_vs_generic.md:1
msgid "Generics and associated types"
msgstr "제네릭과 연관된 타입"

#: src/04_traits/10_assoc_vs_generic.md:3
msgid ""
"Let's re-examine the definition for two of the traits we studied so far, "
"`From` and `Deref`:"
msgstr ""
"지금까지 공부한 두 가지 트레잇인 `From`과 `Deref`에 대한 정의를 다시 살펴보겠"
"습니다:"

#: src/04_traits/10_assoc_vs_generic.md:17
msgid ""
"They both feature type parameters.  \n"
"In the case of `From`, it's a generic parameter, `T`.  \n"
"In the case of `Deref`, it's an associated type, `Target`."
msgstr ""
"둘 다 기능 유형 매개변수입니다.  \n"
"`From`의 경우에는 제네릭 매개변수인 `T`입니다.  \n"
"`Deref`의 경우 연관된 타입인 `Target`입니다."

#: src/04_traits/10_assoc_vs_generic.md:21
msgid "What's the difference? Why use one over the other?"
msgstr "뭐가 다를까요? 왜 두 개를 구분해서 쓸까요?"

#: src/04_traits/10_assoc_vs_generic.md:23
msgid "At most one implementation"
msgstr "최대 1개의 구현"

#: src/04_traits/10_assoc_vs_generic.md:25
msgid ""
"Due to how deref coercion works, there can only be one \"target\" type for a "
"given type. E.g. `String` can only deref to `str`. It's about avoiding "
"ambiguity: if you could implement `Deref` multiple times for a type, which "
"`Target` type should the compiler choose when you call a `&self` method?"
msgstr ""
"Deref coercion가 작동하는 방식으로 인해 특정 타입에 대해 하나의 \"대상\" 타입"
"만 존재해야합니다. 예: `String`은 `str`로만 역참조될 수 있습니다. 모호함을 피"
"하기 위함입니다. 한 타입에 대해 `Deref`를 여러 번 구현할 수 있다면 `&self` 메"
"서드를 호출할 때 컴파일러가 어떤 `Target` 타입을 선택해야 할까요?"

#: src/04_traits/10_assoc_vs_generic.md:30
msgid ""
"That's why `Deref` uses an associated type, `Target`.  \n"
"An associated type is uniquely determined **by the trait implementation**. "
"Since you can't implement `Deref` more than once, you'll only be able to "
"specify one `Target` for a given type and there won't be any ambiguity."
msgstr ""
"이것이 `Deref`가 연관 타입인 `Target`을 사용하는 이유입니다.  \n"
"연관 타입은 **특성 구현에 의해** 고유하게 결정됩니다. `Deref`를 두 번 이상 구"
"현할 수 없기 때문에 주어진 타입에 대해 하나의 `Target`만 지정할 수 있으며 모호"
"성은 없습니다."

#: src/04_traits/10_assoc_vs_generic.md:35
msgid "Generic traits"
msgstr "제네릭 트레잇"

#: src/04_traits/10_assoc_vs_generic.md:37
msgid ""
"On the other hand, you can implement `From` multiple times for a type, **as "
"long as the input type `T` is different**. For example, you can implement "
"`From` for `WrappingU32` using both `u32` and `u16` as input types:"
msgstr ""
"반면에 **입력 타입 `T`가 다른 한** 한 타입에 대해 `From`을 여러 번 구현할 수 "
"있습니다. 예를 들어 `u32`와 `u16`을 모두 입력 타입으로 사용하여 `WrappingU32`"
"에 대해 `From`을 구현할 수 있습니다."

#: src/04_traits/10_assoc_vs_generic.md:54
msgid ""
"This works because `From<u16>` and `From<u32>` are considered **different "
"traits**.  \n"
"There is no ambiguity: the compiler can determine which implementation to use "
"based on type of the value being converted."
msgstr ""
"이는 `From<u16>`과 `From<u32>`가 **다른 트레잇**으로 간주되기 때문에 작동합니"
"다.  \n"
"모호성은 없습니다. 컴파일러는 변환되는 값의 타입에 따라 사용할 구현을 결정할 "
"수 있습니다."

#: src/04_traits/10_assoc_vs_generic.md:57
msgid "Case study: `Add`"
msgstr "사례 연구: `Add`"

#: src/04_traits/10_assoc_vs_generic.md:59
msgid ""
"As a closing example, consider the `Add` trait from the standard library:"
msgstr "마지막 예로, 표준 라이브러리의 `Add` 트레잇을 생각해봅시다:"

#: src/04_traits/10_assoc_vs_generic.md:69
msgid "It uses both mechanisms:"
msgstr "두 가지 메커니즘을 모두 사용합니다:"

#: src/04_traits/10_assoc_vs_generic.md:71
msgid ""
"it has a generic parameter, `RHS` (right-hand side), which defaults to `Self`"
msgstr ""
"여기에는 `RHS`(오른쪽)라는 제네릭 매개변수가 있으며 기본값은 `Self`입니다"

#: src/04_traits/10_assoc_vs_generic.md:72
msgid ""
"it has an associated type, `Output`, the type of the result of the addition"
msgstr "여기에는 덧셈의 결과 타입인 `Output`이라는 연관 타입이 있습니다."

#: src/04_traits/10_assoc_vs_generic.md:74
msgid "`RHS`"
msgstr "`RHS`"

#: src/04_traits/10_assoc_vs_generic.md:76
msgid ""
"`RHS` is a generic parameter to allow for different types to be added "
"together.  \n"
"For example, you'll find these two implementations in the standard library:"
msgstr ""
"`RHS`는 다양한 타입을 함께 더할 수 있는 제네릭 매개변수입니다.  \n"
"예를 들어 표준 라이브러리에서 다음 두 가지 구현을 찾을 수 있습니다:"

#: src/04_traits/10_assoc_vs_generic.md:84
msgid ""
"//                      ^^^\n"
"      // This could be written as `Self::Output` instead.\n"
"      // The compiler doesn't care, as long as the type you\n"
"      // specify here matches the type you assigned to `Output` \n"
"      // right above.\n"
"      // [...]\n"
msgstr ""
"//                      ^^^\n"
"      // 대신 `Self::Output`으로 쓸 수도 있습니다.\n"
"      // 여기에 지정한 타입이\n"
"      // 바로 위의 `Output`에 할당한 \n"
"      // 타입과 일치하는 한 컴파일러는 상관하지 않습니다.\n"
"      // [...]\n"

#: src/04_traits/10_assoc_vs_generic.md:102
msgid "This allows the following code to compile:"
msgstr "이를 통해 다음 코드를 컴파일할 수 있습니다:"

#: src/04_traits/10_assoc_vs_generic.md:108
msgid "because `u32` implements `Add<&u32>` _as well as_ `Add<u32>`."
msgstr ""
"왜냐하면 `u32`는 `Add<u32>` _뿐만 아니라_ `Add<&u32>`도 구현하기 때문입니다."

#: src/04_traits/10_assoc_vs_generic.md:110
msgid "`Output`"
msgstr "`Output`"

#: src/04_traits/10_assoc_vs_generic.md:112
msgid "`Output` represents the type of the result of the addition."
msgstr "'Output'은 덧셈 결과의 타입을 나타냅니다."

#: src/04_traits/10_assoc_vs_generic.md:114
msgid ""
"Why do we need `Output` in the first place? Can't we just use `Self` as "
"output, the type implementing `Add`? We could, but it would limit the "
"flexibility of the trait. In the standard library, for example, you'll find "
"this implementation:"
msgstr ""
"애초에 `Output`이 필요한 이유는 무엇입니까? `Self`를 아웃풋으로 `Add`를 구현하"
"는 타입으로 사용할 수는 없나요? 할 수는 있지만 트레잇의 유연성이 제한됩니다. "
"예를 들어 표준 라이브러리에서는 다음과 같은 구현을 찾을 수 있습니다:"

#: src/04_traits/10_assoc_vs_generic.md:128
msgid ""
"The type they're implementing the trait for is `&u32`, but the result of the "
"addition is `u32`.  \n"
"It would be impossible[^flexible] to provide this implementation if `add` had "
"to return `Self`, i.e. `&u32` in this case. `Output` lets `std` decouple the "
"implementor from the return type, thus supporting this case."
msgstr ""
"트레잇을 구현하는 타입은 `&u32`이지만 덧셈 결과는 `u32`입니다.  \n"
"`add`가 `Self`를 반환해야 한다면(예: 이 경우 `&u32`) 이 구현을 제공하는 것은 "
"불가능[^flexible]합니다. `Output`을 사용하면 `std`가 구현자를 반환 타입에서 분"
"리하여 이 케이스를 지원합니다."

#: src/04_traits/10_assoc_vs_generic.md:132
msgid ""
"On the other hand, `Output` can't be a generic parameter. The output type of "
"the operation **must** be uniquely determined once the types of the operands "
"are known. That's why it's an associated type: for a given combination of "
"implementor and generic parameters, there is only one `Output` type."
msgstr ""
"반면에 `Output`은 제네릭 매개변수가 될 수 없습니다. 연산의 출력 타입은 피연산"
"자의 타입을 알고 나면 **반드시** 고유하게 결정되어야 합니다. 이것이 연관 타입"
"인 이유입니다. 구현자와 제네릭 매개변수의 특정 조합에 대해 `Output` 타입은 하"
"나만 존재합니다."

#: src/04_traits/10_assoc_vs_generic.md:136
msgid "Conclusion"
msgstr "결론"

#: src/04_traits/10_assoc_vs_generic.md:138
msgid "To recap:"
msgstr "요약하자면:"

#: src/04_traits/10_assoc_vs_generic.md:140
msgid ""
"Use an **associated type** when the type must be uniquely determined for a "
"given trait implementation."
msgstr ""
"특정 트레잇 구현에 대해 타입을 고유하게 결정해야 하는 경우 **연관 타입**을 사"
"용하세요."

#: src/04_traits/10_assoc_vs_generic.md:141
msgid ""
"Use a **generic parameter** when you want to allow multiple implementations "
"of the trait for the same type, with different input types."
msgstr ""
"다양한 입력 타입을 사용하여 동일한 타입에 대한 트레잇의 여러 구현을 허용하려"
"면 **제네릭 매개변수**를 사용하세요."

#: src/04_traits/10_assoc_vs_generic.md:144
msgid ""
"Flexibility is rarely free: the trait definition is more complex due to "
"`Output`, and implementors have to reason about what they want to return. The "
"trade-off is only justified if that flexibility is actually needed. Keep that "
"in mind when designing your own traits."
msgstr ""
"유연성이 공짜인 경우는 거의 없습니다. 트레잇 정의는 'Output'으로 인해 더 복잡"
"하며 구현자는 반환하려는 항목에 대해 추론해야 합니다. 유연성이 실제로 필요한 "
"경우에만 절충이 정당화됩니다. 자신만의 트레잇을 디자인할 때 이 점을 명심하세"
"요."

#: src/04_traits/10_assoc_vs_generic.md:150
msgid ""
"The exercise for this section is located in [`04_traits/10_assoc_vs_generic`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/10_assoc_vs_generic)"
msgstr ""
"이 섹션의 예제는 [`04_traits/10_assoc_vs_generic`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/10_assoc_vs_generic)에 있습니다"

#: src/04_traits/11_clone.md:1
msgid "Copying values, pt. 1"
msgstr "값 복사, pt. 1"

#: src/04_traits/11_clone.md:3
msgid ""
"In the previous chapter we introduced ownership and borrowing.  \n"
"We stated, in particular, that:"
msgstr ""
"이전 장에서는 소유권과 차용에 대해 소개했습니다.  \n"
"우리는 특히 다음과 같이 말했습니다:"

#: src/04_traits/11_clone.md:6
msgid "Every value in Rust has a single owner at any given time."
msgstr "Rust의 모든 값은 언제든지 단일 소유자를 갖습니다."

#: src/04_traits/11_clone.md:7
msgid ""
"When a function takes ownership of a value (\"it consumes it\"), the caller "
"can't use that value anymore."
msgstr ""
"함수가 값의 소유권을 가져오면(\"사용함\") 호출자는 더 이상 해당 값을 사용할 "
"수 없습니다."

#: src/04_traits/11_clone.md:9
msgid ""
"These restrictions can be somewhat limiting.  \n"
"Sometimes we might have to call a function that takes ownership of a value, "
"but we still need to use that value afterward."
msgstr ""
"이러한 제한은 다소 제한적일 수 있습니다.  \n"
"때로는 값의 소유권을 갖는 함수를 호출해야 할 수도 있지만 나중에 그 값을 사용해"
"야 하는 경우도 있습니다."

#: src/04_traits/11_clone.md:14 src/04_traits/11_clone.md:42
#: src/04_traits/12_copy.md:6 src/05_ticket_v2/03_variants_with_data.md:42
#: src/08_futures/03_runtime.md:52 src/08_futures/04_future.md:12
#: src/08_futures/07_cancellation.md:35 src/08_futures/07_cancellation.md:36
msgid "/* */"
msgstr "/* */"

#: src/04_traits/11_clone.md:17 src/04_traits/11_clone.md:45
msgid "\"hello\""
msgstr "\"hello\""

#: src/04_traits/11_clone.md:19 src/04_traits/11_clone.md:48
msgid "\", world!\""
msgstr "\", world!\""

#: src/04_traits/11_clone.md:19
msgid "// error: value borrowed here after move\n"
msgstr "// 오류: 소유권 이전 후 빌린 값\n"

#: src/04_traits/11_clone.md:23
msgid "That's where `Clone` comes in."
msgstr "이곳이 바로 `Clone`이 필요한 곳입니다."

#: src/04_traits/11_clone.md:25
msgid "`Clone`"
msgstr "`Clone`"

#: src/04_traits/11_clone.md:27
msgid "`Clone` is a trait defined in Rust's standard library:"
msgstr "`Clone`은 Rust의 표준 라이브러리에 정의된 트레잇입니다:"

#: src/04_traits/11_clone.md:35
msgid ""
"Its method, `clone`, takes a reference to `self` and returns a new **owned** "
"instance of the same type."
msgstr ""
"해당 메서드 `clone`은 `self`에 대한 참조를 가져와 동일한 타입의 새로운 **소유"
"** 인스턴스를 반환합니다."

#: src/04_traits/11_clone.md:37
msgid "In action"
msgstr "사용 사례"

#: src/04_traits/11_clone.md:39
msgid ""
"Going back to the example above, we can use `clone` to create a new `String` "
"instance before calling `consumer`:"
msgstr ""
"위의 예시로 돌아가서, `consumer`를 호출하기 전에 `clone`을 사용하여 새로운 "
"`String` 인스턴스를 생성할 수 있습니다:"

#: src/04_traits/11_clone.md:48
msgid "// no error\n"
msgstr "// 오류 없음\n"

#: src/04_traits/11_clone.md:52
msgid ""
"Instead of giving ownership of `s` to `consumer`, we create a new `String` "
"(by cloning `s`) and give that to `consumer` instead.  \n"
"`s` remains valid and usable after the call to `consumer`."
msgstr ""
"`s`의 소유권을 `consumer`에 부여하는 대신, 새로운 `String`을 생성하고(`s`를 복"
"제하여) 이를 대신 `consumer`에 제공합니다.  \n"
"`s`는 `consumer`를 호출한 후에도 유효하고 사용 가능한 상태로 유지됩니다."

#: src/04_traits/11_clone.md:56
msgid "In memory"
msgstr "메모리에서는"

#: src/04_traits/11_clone.md:58
msgid ""
"Let's look at what happened in memory in the example above. When `let mut s: "
"String::from(\"hello\");` is executed, the memory looks like this:"
msgstr ""
"위 예제에서 메모리에서 무슨 일이 일어났는지 살펴봅시다. `let mut s: String::"
"from(\"hello\");`가 실행되면, 메모리는 다음과 같습니다:"

#: src/04_traits/11_clone.md:75
msgid ""
"When `let t = s.clone()` is executed, a whole new region is allocated on the "
"heap to store a copy of the data:"
msgstr ""
"`let t = s.clone()`이 실행되면 데이터 복사본을 저장하기 위해 완전히 새로운 영"
"역이 힙에 할당됩니다:"

#: src/04_traits/11_clone.md:91
msgid ""
"If you're coming from a language like Java, you can think of `clone` as a way "
"to create a deep copy of an object."
msgstr ""
"Java와 같은 언어를 사용하는 경우 `clone`을 객체의 전체 복사본을 만드는 방법으"
"로 생각할 수 있습니다."

#: src/04_traits/11_clone.md:93
msgid "Implementing `Clone`"
msgstr "`Clone` 구현"

#: src/04_traits/11_clone.md:95
msgid ""
"To make a type `Clone`\\-able, we have to implement the `Clone` trait for "
"it.  \n"
"You almost always implement `Clone` by deriving it:"
msgstr ""
"`Clone` 타입을 가능하게 만들려면 `Clone` 트레잇을 구현해야 합니다.  \n"
"거의 항상 `Clone`은 파생 매크로로 구현합니다."

#: src/04_traits/11_clone.md:101
msgid "// fields\n"
msgstr "// 필드\n"

#: src/04_traits/11_clone.md:105
msgid ""
"The compiler implements `Clone` for `MyType` as you would expect: it clones "
"each field of `MyType` individually and then constructs a new `MyType` "
"instance using the cloned fields.  \n"
"Remember that you can use `cargo expand` (or your IDE) to explore the code "
"generated by `derive` macros."
msgstr ""
"컴파일러는 예상대로 `MyType`에 대해 `Clone`을 구현합니다. 즉, `MyType`의 각 필"
"드를 개별적으로 복제한 다음 복제된 필드를 사용하여 새로운 `MyType` 인스턴스를 "
"구성합니다.  \n"
"`cargo expand`(또는 IDE)를 사용하여 `파생` 매크로에 의해 생성된 코드를 탐색할 "
"수 있다는 점을 기억하세요."

#: src/04_traits/11_clone.md:111
msgid ""
"The exercise for this section is located in [`04_traits/11_clone`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/11_clone)"
msgstr ""
"이 섹션의 예제는 [`04_traits/11_clone`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/04_traits/11_clone)에 있습니다"

#: src/04_traits/12_copy.md:1
msgid "Copying values, pt. 2"
msgstr "값 복사, pt. 2"

#: src/04_traits/12_copy.md:3
msgid ""
"Let's consider the same example as before, but with a slight twist: using "
"`u32` rather than `String` as a type."
msgstr ""
"이전과 동일한 예를 약간 변형하여 살펴보겠습니다. 타입으로 `String` 대신 `u32`"
"를 사용하는 것입니다."

#: src/04_traits/12_copy.md:15
msgid ""
"It'll compile without errors! What's going on here? What's the difference "
"between `String` and `u32` that makes the latter work without `.clone()`?"
msgstr ""
"오류 없이 컴파일됩니다! 여기서 무슨 일이 일어나고 있는 걸까요? `.clone()` 없이"
"도 작동하도록 하는 `String`과 `u32`의 차이점은 무엇일까요?"

#: src/04_traits/12_copy.md:18
msgid "`Copy`"
msgstr "`Copy`"

#: src/04_traits/12_copy.md:20
msgid "`Copy` is another trait defined in Rust's standard library:"
msgstr "`Copy`는 Rust의 표준 라이브러리에 정의된 또 다른 트레잇입니다:"

#: src/04_traits/12_copy.md:26
msgid "It is a marker trait, just like `Sized`."
msgstr "이는 `Sized`와 마찬가지로 마커 트레잇입니다."

#: src/04_traits/12_copy.md:28
msgid ""
"If a type implements `Copy`, there's no need to call `.clone()` to create a "
"new instance of the type: Rust does it **implicitly** for you.  \n"
"`u32` is an example of a type that implements `Copy`, which is why the "
"example above compiles without errors: when `consumer(s)` is called, Rust "
"creates a new `u32` instance by performing a **bitwise copy** of `s`, and "
"then passes that new instance to `consumer`. It all happens behind the "
"scenes, without you having to do anything."
msgstr ""
"타입이 `Copy`를 구현하는 경우 해당 타입의 새 인스턴스를 생성하기 위해 `."
"clone()`을 호출할 필요가 없습니다. Rust가 이를 **암시적으로** 수행합니다.  \n"
"`u32`는 `Copy`를 구현하는 타입의 예입니다. 이것이 위의 예가 오류 없이 컴파일되"
"는 이유입니다. `consumer(s)`가 호출되면 Rust가 `s`를 **비트 단위 복사**해 새로"
"운 `u32` 인스턴스를 생성합니다. 그리고 그 새 인스턴스를 `consumer`에 전달합니"
"다. 이 모든 일은 사용자가 아무것도 하지 않아도 이루어집니다."

#: src/04_traits/12_copy.md:34
msgid "What can be `Copy`?"
msgstr "`Copy`란 무엇일까요?"

#: src/04_traits/12_copy.md:36
msgid ""
"`Copy` is not equivalent to \"automatic cloning\", although it implies it.  \n"
"Types must meet a few requirements in order to be allowed to implement `Copy`."
msgstr ""
"`Copy`는 \"자동 복제\"를 의미하지만 \"자동 복제\"와 동일하지 않습니다.  \n"
"`Copy` 구현을 허용하려면 타입이 몇 가지 요구 사항을 충족해야 합니다."

#: src/04_traits/12_copy.md:39
msgid ""
"First of all, it must implement `Clone`, since `Copy` is a subtrait of "
"`Clone`. This makes sense: if Rust can create a new instance of a type "
"_implicitly_, it should also be able to create a new instance _explicitly_ by "
"calling `.clone()`."
msgstr ""
"우선 `Copy`는 `Clone`의 하위 특성이므로 `Clone`을 구현해야 합니다. 이는 말이 "
"됩니다: Rust가 _암시적으로_ 타입의 새 인스턴스를 생성할 수 있다면 `.clone()`"
"을 호출하여 _명시적으로_ 새 인스턴스를 생성할 수도 있어야 합니다."

#: src/04_traits/12_copy.md:43
msgid "That's not all, though. A few more conditions must be met:"
msgstr "하지만 그게 전부는 아닙니다. 몇 가지 조건이 더 충족되어야 합니다:"

#: src/04_traits/12_copy.md:45
msgid ""
"The type doesn't manage any _additional_ resources (e.g. heap memory, file "
"handles, etc.) beyond the `std::mem::size_of` bytes that it occupies in "
"memory."
msgstr ""
"타입이 메모리에서 차지하는 `std::mem::size_of` 바이트를 초과하는 _추가_ 리소스"
"(예: 힙 메모리, 파일 핸들 등)를 관리하지 않아야합니다."

#: src/04_traits/12_copy.md:47
msgid "The type is not a mutable reference (`&mut T`)."
msgstr "타입이 변경 가능한 참조(`&mut T`)가 아니어야합니다."

#: src/04_traits/12_copy.md:49
msgid ""
"If both conditions are met, then Rust can safely create a new instance of the "
"type by performing a **bitwise copy** of the original instance—this is often "
"referred to as a `memcpy` operation, after the C standard library function "
"that performs the bitwise copy."
msgstr ""
"두 조건이 모두 충족되면 Rust는 원래 인스턴스의 **비트 복사**를 수행하여 해당 "
"타입의 새 인스턴스를 안전하게 생성할 수 있습니다. 이는 C 표준 라이브러리의 "
"`memcpy` 작업이라고도 합니다. 비트 단위 복사를 수행합니다."

#: src/04_traits/12_copy.md:53
msgid "Case study 1: `String`"
msgstr "사례 연구 1: `String`"

#: src/04_traits/12_copy.md:55
msgid ""
"`String` is a type that doesn't implement `Copy`.  \n"
"Why? Because it manages an additional resource: the heap-allocated memory "
"buffer that stores the string's data."
msgstr ""
"`String`은 `Copy`를 구현하지 않는 타입입니다.  \n"
"왜일까요? 추가 리소스, 즉 문자열의 데이터를 저장하는 힙 할당 메모리 버퍼를 관"
"리하기 때문입니다."

#: src/04_traits/12_copy.md:58
msgid ""
"Let's imagine that Rust allowed `String` to implement `Copy`.  \n"
"Then, when a new `String` instance is created by performing a bitwise copy of "
"the original instance, both the original and the new instance would point to "
"the same memory buffer:"
msgstr ""
"Rust가 `String`이 `Copy`를 구현하도록 허용했다고 상상해 봅시다.  \n"
"그런 다음 원본 인스턴스의 비트 단위 복사를 수행하여 새 `String` 인스턴스가 생"
"성되면 원본 인스턴스와 새 인스턴스 모두 동일한 메모리 버퍼를 가리킵니다:"

#: src/04_traits/12_copy.md:79
msgid ""
"This is bad! Both `String` instances would try to free the memory buffer when "
"they go out of scope, leading to a double-free error. You could also create "
"two distinct `&mut String` references that point to the same memory buffer, "
"violating Rust's borrowing rules."
msgstr ""
"이건 잘못되었습니다! 두 `String` 인스턴스 모두 스코프를 벗어날 때 메모리 버퍼"
"를 해제하려고 시도하여 더블 프리 오류가 발생합니다. 또한 동일한 메모리 버퍼를 "
"가리키는 두 개의 서로 다른 `&mut String` 참조를 생성하여 Rust의 차용 규칙을 위"
"반할 수도 있습니다."

#: src/04_traits/12_copy.md:85
msgid "Case study 2: `u32`"
msgstr "사례 연구 2: `u32`"

#: src/04_traits/12_copy.md:87
msgid ""
"`u32` implements `Copy`. All integer types do, in fact.  \n"
"An integer is \"just\" the bytes that represent the number in memory. There's "
"nothing more! If you copy those bytes, you get another perfectly valid "
"integer instance. Nothing bad can happen, so Rust allows it."
msgstr ""
"`u32`는 `Copy`를 구현합니다. 실제로 모든 정수 타입이 그렇습니다.  \n"
"정수는 메모리의 숫자를 나타내는 \"그냥\" 바이트입니다. 그게 전부입니다! 해당 "
"바이트를 복사하면 완벽하게 유효한 또 다른 정수 인스턴스를 얻게 됩니다. 나쁜 일"
"은 일어날 수 없으므로 Rust는 그것을 허용합니다."

#: src/04_traits/12_copy.md:92
msgid "Case study 3: `&mut u32`"
msgstr "사례 연구 3: `&mut u32`"

#: src/04_traits/12_copy.md:94
msgid ""
"When we introduced ownership and mutable borrows, we stated one rule quite "
"clearly: there can only ever be _one_ mutable borrow of a value at any given "
"time.  \n"
"That's why `&mut u32` doesn't implement `Copy`, even though `u32` does."
msgstr ""
"소유권과 변경 가능한 차용을 소개할 때 우리는 한 가지 규칙을 아주 명확하게 명시"
"했습니다. 즉, 주어진 시간에 값의 변경 가능한 차용은 _하나_만 있을 수 있다는 것"
"입니다.  \n"
"이것이 `u32`가 `Copy`를 구현하더라도 `&mut u32`는 `Copy`를 구현하지 않는 이유"
"입니다."

#: src/04_traits/12_copy.md:98
msgid ""
"If `&mut u32` implemented `Copy`, you could create multiple mutable "
"references to the same value and modify it in multiple places at the same "
"time. That'd be a violation of Rust's borrowing rules! It follows that `&mut "
"T` never implements `Copy`, no matter what `T` is."
msgstr ""
"`&mut u32`가 `Copy`를 구현한 경우 동일한 값에 대한 여러 개의 변경 가능한 참조"
"를 생성하고 동시에 여러 위치에서 수정할 수 있습니다. 그것은 Rust의 차용 규칙"
"을 위반하는 것입니다! 따라서 `&mut T`는 `T`가 무엇이든 관계없이 `Copy`를 구현"
"하지 않습니다."

#: src/04_traits/12_copy.md:103
msgid "Implementing `Copy`"
msgstr "`Copy` 구현"

#: src/04_traits/12_copy.md:105
msgid ""
"In most cases, you don't need to manually implement `Copy`. You can just "
"derive it, like this:"
msgstr ""
"대부분의 경우 `Copy`를 수동으로 구현할 필요가 없습니다. 다음과 같이 파생시킬 "
"수 있습니다:"

#: src/04_traits/12_copy.md:117
msgid ""
"The exercise for this section is located in [`04_traits/12_copy`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/12_copy)"
msgstr ""
"이 섹션의 예제는 [`04_traits/12_copy`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/04_traits/12_copy)에 있습니다"

#: src/04_traits/13_drop.md:1
msgid "The `Drop` trait"
msgstr "`Drop` 트레잇"

#: src/04_traits/13_drop.md:3
msgid ""
"When we introduced [destructors](../03_ticket_v1/11_destructor.md), we "
"mentioned that the `drop` function:"
msgstr ""
"[소멸자](../03_ticket_v1/11_destructor.md)를 소개했을 때 `drop` 함수에 대해 언"
"급했습니다."

#: src/04_traits/13_drop.md:6
msgid ""
"reclaims the memory occupied by the type (i.e. `std::mem::size_of` bytes)"
msgstr ""
"해당 타입이 차지하는 메모리를 회수합니다(예: `std::mem::size_of` 바이트)."

#: src/04_traits/13_drop.md:7
msgid ""
"cleans up any additional resources that the value might be managing (e.g. the "
"heap buffer of a `String`)"
msgstr "값이 관리할 수 있는 추가 리소스를 정리합니다(예: `String`의 힙 버퍼)."

#: src/04_traits/13_drop.md:9
msgid "Step 2. is where the `Drop` trait comes in."
msgstr "Step 2.는 `Drop` 트레잇이 필요한 곳입니다."

#: src/04_traits/13_drop.md:17
msgid ""
"The `Drop` trait is a mechanism for you to define _additional_ cleanup logic "
"for your types, beyond what the compiler does for you automatically.  \n"
"Whatever you put in the `drop` method will be executed when the value goes "
"out of scope."
msgstr ""
"`Drop` 트레잇은 컴파일러가 자동으로 수행하는 것 이상으로 타입에 대한 _추가_ 정"
"리 논리를 정의하는 메커니즘입니다.  \n"
"'drop' 메서드에 무엇을 넣었든 값이 스코프를 벗어나면 실행됩니다."

#: src/04_traits/13_drop.md:21
msgid "`Drop` and `Copy`"
msgstr "`Drop`과 `Copy`"

#: src/04_traits/13_drop.md:23
msgid ""
"When talking about the `Copy` trait, we said that a type can't implement "
"`Copy` if it manages additional resources beyond the `std::mem::size_of` "
"bytes that it occupies in memory."
msgstr ""
"`Copy` 트레잇에 대해 이야기할 때, 메모리에서 차지하는 `std::mem::size_of` 바이"
"트를 초과하는 추가 리소스를 관리하는 경우 타입은 `Copy`를 구현할 수 없다고 말"
"했습니다."

#: src/04_traits/13_drop.md:26
msgid ""
"You might wonder: how does the compiler know if a type manages additional "
"resources? That's right: `Drop` trait implementations!  \n"
"If your type has an explicit `Drop` implementation, the compiler will assume "
"that your type has additional resources attached to it and won't allow you to "
"implement `Copy`."
msgstr ""
"타입이 추가 리소스를 관리하는지 여부를 컴파일러가 어떻게 알 수 있는지 궁금할 "
"것입니다. 맞습니다: `Drop` 트레잇 구현입니다!  \n"
"타입에 명시적인 `Drop` 구현이 있는 경우 컴파일러는 타입에 추가 리소스가 첨부되"
"어 있다고 가정하고 `Copy` 구현을 허용하지 않습니다."

#: src/04_traits/13_drop.md:32
msgid "// This is a unit struct, i.e. a struct with no fields.\n"
msgstr "// 이것은 단위 구조체, 즉 필드가 없는 구조체입니다.\n"

#: src/04_traits/13_drop.md:38
msgid ""
"// We don't need to do anything here,\n"
"       // it's enough to have an \"empty\" Drop implementation\n"
msgstr ""
"// 여기서는 아무것도 할 필요가 없습니다.\n"
"       // \"빈\" Drop 구현만 있으면 충분합니다.\n"

#: src/04_traits/13_drop.md:44
msgid "The compiler will complain with this error message:"
msgstr "컴파일러는 다음 오류 메시지를 표시합니다:"

#: src/04_traits/13_drop.md:56
msgid ""
"The exercise for this section is located in [`04_traits/13_drop`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/13_drop)"
msgstr ""
"이 섹션의 예제는 [`04_traits/13_drop`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/04_traits/13_drop)에 있습니다"

#: src/04_traits/14_outro.md:3
msgid ""
"We've covered quite a few different traits in this chapter—and we've only "
"scratched the surface! It may feel like you have a lot to remember, but don't "
"worry: you'll bump into these traits so often when writing Rust code that "
"they'll soon become second nature."
msgstr ""
"우리는 이번 장에서 꽤 많은 다른 트레잇들을 다루었습니다. 하지만 우리는 표면적"
"인 부분만 살펴봤습니다! 기억할 것이 많다고 느껴질 수도 있지만 걱정하지 마십시"
"오. Rust 코드를 작성할 때 이러한 트레잇을 아주 많이 접하게 되므로 곧 본능이 "
"될 것입니다."

#: src/04_traits/14_outro.md:7
msgid "Closing thoughts"
msgstr "생각 정리"

#: src/04_traits/14_outro.md:9
msgid ""
"Traits are powerful, but don't overuse them.  \n"
"A few guidelines to keep in mind:"
msgstr ""
"트레잇은 강력하지만 남용하지 마십시오.  \n"
"명심해야 할 몇 가지 지침:"

#: src/04_traits/14_outro.md:12
msgid ""
"Don't make a function generic if it is always invoked with a single type. It "
"introduces indirection in your codebase, making it harder to understand and "
"maintain."
msgstr ""
"항상 단일 타입으로 호출되는 함수를 제네릭 함수로 만들지 마십시오. 코드베이스"
"에 간접 참조가 도입되어 이해하고 유지 관리가 더 어려워집니다."

#: src/04_traits/14_outro.md:14
msgid ""
"Don't create a trait if you only have one implementation. It's a sign that "
"the trait is not needed."
msgstr ""
"구현이 하나만 있는 경우 트레잇을 생성하지 마세요. 트레잇이 필요하지 않다는 신"
"호입니다."

#: src/04_traits/14_outro.md:15
msgid ""
"Implement standard traits for your types (`Debug`, `PartialEq`, etc.) "
"whenever it makes sense. It will make your types more idiomatic and easier to "
"work with, unlocking a lot of functionality provided by the standard library "
"and ecosystem crates."
msgstr ""
"필요할 때마다 타입에 대한 표준 특성을 구현하십시오(`Debug`, `PartialEq` 등). "
"이는 타입을 더욱 관용적이고 작업하기 쉽게 만들어 표준 라이브러리 및 생태계 상"
"자에서 제공하는 많은 기능을 사용할 수 있게 합니다."

#: src/04_traits/14_outro.md:18
msgid ""
"Implement traits from third-party crates if you need the functionality they "
"unlock within their ecosystem."
msgstr "외부 생태계의 기능이 필요한 경우 외부 크레이트의 트레잇을 구현하세요."

#: src/04_traits/14_outro.md:19
msgid ""
"Beware of making code generic solely to use mocks in your tests. The "
"maintainability cost of this approach can be high, and it's often better to "
"use a different testing strategy. Check out the [testing masterclass](https://"
"github.com/mainmatter/rust-advanced-testing-workshop) for details on high-"
"fidelity testing."
msgstr ""
"테스트에서 mock만을 위해 코드를 일반화하지 않도록 주의하세요. 이 접근 방식의 "
"유지 관리 비용은 높을 수 있으므로 다른 테스트 전략을 사용하는 것이 더 나은 경"
"우가 많습니다. 고충실도 테스트에 대한 자세한 내용은 [testing masterclass]"
"(https://github.com/mainmatter/rust-advanced-testing-workshop)를 확인하세요."

#: src/04_traits/14_outro.md:24
msgid "Testing your knowledge"
msgstr "지식 테스트"

#: src/04_traits/14_outro.md:26
msgid ""
"Before moving on, let's go through one last exercise to consolidate what "
"we've learned. You'll have minimal guidance this time—just the exercise "
"description and the tests to guide you."
msgstr ""
"계속 진행하기 전에 마지막 예제을 통해 배운 내용을 통합해 보겠습니다. 이번에는 "
"최소한의 지침만 제공됩니다. 예제 설명과 가이드할 테스트만 제공됩니다."

#: src/04_traits/14_outro.md:31
msgid ""
"The exercise for this section is located in [`04_traits/14_outro`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/04_traits/14_outro)"
msgstr ""
"이 섹션의 예제는 [`04_traits/14_outro`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/04_traits/14_outro)에 있습니다"

#: src/05_ticket_v2/00_intro.md:1
msgid "Modelling A Ticket, pt. 2"
msgstr "Ticket 모델링, pt. 2"

#: src/05_ticket_v2/00_intro.md:3
msgid ""
"The `Ticket` struct we worked on in the previous chapters is a good start, "
"but it still screams \"I'm a beginner Rustacean!\"."
msgstr ""
"이전 장에서 작업한 `Ticket` 구조체는 좋은 시작이지만 여전히 \"나는 초보자 "
"Rustacean입니다!\"라고 티를 냅니다."

#: src/05_ticket_v2/00_intro.md:6
msgid ""
"We'll use this chapter to refine our Rust domain modelling skills. We'll need "
"to introduce a few more concepts along the way:"
msgstr ""
"우리는 이 장에서 Rust 도메인 모델링 기술을 개선할 것입니다. 그 과정에서 몇 가"
"지 개념을 더 소개해야 합니다:"

#: src/05_ticket_v2/00_intro.md:9
msgid "`enum`s, one of Rust's most powerful features for data modeling"
msgstr "데이터 모델링을 위한 Rust의 가장 강력한 기능 중 하나인 `enum`"

#: src/05_ticket_v2/00_intro.md:10
msgid "The `Option` type, to model nullable values"
msgstr "Null 허용 값을 모델링하는 `Option` 타입"

#: src/05_ticket_v2/00_intro.md:11
msgid "The `Result` type, to model recoverable errors"
msgstr "복구 가능한 오류를 모델링하기 위한 `Result` 타입"

#: src/05_ticket_v2/00_intro.md:12
msgid "The `Debug` and `Display` traits, for printing"
msgstr "프린트용 `Debug` 및 `Display` 트레잇"

#: src/05_ticket_v2/00_intro.md:13
msgid "The `Error` trait, to mark error types"
msgstr "오류 타입을 표시하는 `Error` 트레잇"

#: src/05_ticket_v2/00_intro.md:14
msgid "The `TryFrom` and `TryInto` traits, for fallible conversions"
msgstr "오류가 있는 변환을 위한 `TryFrom`과 `TryInto` 트레잇"

#: src/05_ticket_v2/00_intro.md:15
msgid ""
"Rust's package system, explaining what's a library, what's a binary, how to "
"use third-party crates"
msgstr ""
"Rust의 패키지 시스템, 라이브러리가 무엇인지, 바이너리가 무엇인지, 외부 크레이"
"트를 사용하는 방법을 설명합니다"

#: src/05_ticket_v2/00_intro.md:19
msgid ""
"The exercise for this section is located in [`05_ticket_v2/00_intro`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/00_intro)"
msgstr ""
"이 섹션의 예제는 [`05_ticket_v2/00_intro`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/00_intro)에 있습니다"

#: src/05_ticket_v2/01_enum.md:1
msgid "Enumerations"
msgstr "열거"

#: src/05_ticket_v2/01_enum.md:3
msgid ""
"Based on the validation logic you wrote [in a previous chapter]"
"(../03_ticket_v1/02_validation.md), there are only a few valid statuses for a "
"ticket: `To-Do`, `InProgress` and `Done`.  \n"
"This is not obvious if we look at the `status` field in the `Ticket` struct "
"or at the type of the `status` parameter in the `new` method:"
msgstr ""
"[이전 장에서](../03_ticket_v1/02_validation.md) 작성한 유효성 검사 로직에 따르"
"면 티켓에는 `To-Do`, `InProgress`, `Done` 등 몇 가지 유효한 상태만 있습니"
"다.  \n"
"`Ticket` 구조체의 `status` 필드나 `new` 메소드의 `status` 매개변수 타입을 보"
"면 이는 명확하지 않습니다."

#: src/05_ticket_v2/01_enum.md:23
msgid ""
"In both cases we're using `String` to represent the `status` field. `String` "
"is a very general type—it doesn't immediately convey the information that the "
"`status` field has a limited set of possible values. Even worse, the caller "
"of `Ticket::new` will only find out **at runtime** if the status they "
"provided is valid or not."
msgstr ""
"두 경우 모두 `status` 필드를 나타내기 위해 `String`을 사용하고 있습니다. "
"`String`은 매우 일반적인 타입입니다. `status` 필드에 가능한 값이 제한되어 있다"
"는 정보를 직관적으로 알려주지 않습니다. 더 나쁜 것은 `Ticket::new` 호출자는 자"
"신이 제공한 상태가 유효한지 **런타임**에서만 알아낼 수 있다는 것입니다."

#: src/05_ticket_v2/01_enum.md:28
msgid "We can do better than that with **enumerations**."
msgstr "**열거**를 사용하면 그보다 더 나은 작업을 수행할 수 있습니다."

#: src/05_ticket_v2/01_enum.md:30
msgid "`enum`"
msgstr "`enum`"

#: src/05_ticket_v2/01_enum.md:32
msgid ""
"An enumeration is a type that can have a fixed set of values, called "
"**variants**.  \n"
"In Rust, you define an enumeration using the `enum` keyword:"
msgstr ""
"열거형은 **variants**이라고 불리는 고정된 값 집합을 가질 수 있는 타입입니"
"다.  \n"
"Rust에서는 `enum` 키워드를 사용하여 열거형을 정의합니다:"

#: src/05_ticket_v2/01_enum.md:43
msgid "`enum`, just like `struct`, defines **a new Rust type**."
msgstr "`enum`은 `struct`와 마찬가지로 **새로운 Rust 타입**을 정의합니다."

#: src/05_ticket_v2/01_enum.md:47
msgid ""
"The exercise for this section is located in [`05_ticket_v2/01_enum`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/01_enum)"
msgstr ""
"이 섹션의 예제는 [`05_ticket_v2/01_enum`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/01_enum)에 있습니다"

#: src/05_ticket_v2/02_match.md:1
msgid "`match`"
msgstr "`match`"

#: src/05_ticket_v2/02_match.md:3
msgid ""
"You may be wondering—what can you actually **do** with an enum?  \n"
"The most common operation is to **match** on it."
msgstr ""
"열거형을 사용하여 실제로 **할 수 있는** 작업이 무엇인지 궁금하실 것입니다.  \n"
"가장 일반적인 작업은 **match**입니다."

#: src/05_ticket_v2/02_match.md:17
msgid ""
"// The `|` operator lets you match multiple patterns.\n"
"            // It reads as \"either `Status::ToDo` or `Status::"
"InProgress`\".\n"
msgstr ""
"// `|` 연산자를 사용하면 여러 패턴을 일치시킬 수 있습니다.\n"
"            // \"`Status::ToDo` 또는 `Status::InProgress`\"로 인식합니다.\n"

#: src/05_ticket_v2/02_match.md:25
msgid ""
"A `match` statement that lets you compare a Rust value against a series of "
"**patterns**.  \n"
"You can think of it as a type-level `if`. If `status` is a `Done` variant, "
"execute the first block; if it's a `InProgress` or `ToDo` variant, execute "
"the second block."
msgstr ""
"`match` 문은 러스트 값을 여러 패턴과 비교할 수 있는 구문입니다.\n"
"타입 수준에서 볼 때, 이는 if문으로 볼 수 있습니다. 만약 `status`가 `Done` 배리"
"언트라면 첫 번째 블록을 실행하고, `InProgress` 또는 `ToDo` 배리언트라면 두 번"
"째 블록을 실행합니다."

#: src/05_ticket_v2/02_match.md:29
msgid "Exhaustiveness"
msgstr "철저함"

#: src/05_ticket_v2/02_match.md:31
msgid ""
"There's one key detail here: `match` is **exhaustive**. You must handle all "
"enum variants.  \n"
"If you forget to handle a variant, Rust will stop you **at compile-time** "
"with an error."
msgstr ""
"여기에는 한 가지 중요한 세부 사항이 있습니다: `match`는 **완전**하다는 것입니"
"다. 모든 열거형 배리언트를 처리해야 합니다.  \n"
"배리언트 처리를 깜빡하면 Rust는 **컴파일 타임**에 오류로 인해 중지됩니다."

#: src/05_ticket_v2/02_match.md:34
msgid "E.g. if we forget to handle the `ToDo` variant:"
msgstr "예: `ToDo` 배리언트를 처리하는 것을 깜빡한 경우:"

#: src/05_ticket_v2/02_match.md:53
msgid ""
"This is a big deal!  \n"
"Codebases evolve over time—you might add a new status down the line, e.g. "
"`Blocked`. The Rust compiler will emit an error for every single `match` "
"statement that's missing logic for the new variant. That's why Rust "
"developers often sing the praises of \"compiler-driven refactoring\"—the "
"compiler tells you what to do next, you just have to fix what it reports."
msgstr ""
"이건 큰일이에요!  \n"
"코드베이스는 시간이 지남에 따라 발전합니다. `Blocked`같은 새로운 상태를 추가"
"할 수도 있습니다. Rust 컴파일러는 새로운 배리언트에 대한 로직이 누락된 모든 "
"`match` 문에 대해 오류를 내보냅니다. 이것이 바로 Rust 개발자들이 종종 \"컴파일"
"러 중심 리팩토링\"을 칭찬하는 이유입니다. 컴파일러는 다음에 수행할 작업을 알려"
"주고, 알려준 작업을 수행하기만 하면 됩니다."

#: src/05_ticket_v2/02_match.md:59
msgid "Catch-all"
msgstr "Catch-all"

#: src/05_ticket_v2/02_match.md:61
msgid ""
"If you don't care about one or more variants, you can use the `_` pattern as "
"a catch-all:"
msgstr ""
"하나 이상의 배리언트에 관심이 없다면 `_` 패턴을 포괄적으로 사용할 수 있습니다."

#: src/05_ticket_v2/02_match.md:70
msgid ""
"The `_` pattern matches anything that wasn't matched by the previous patterns."
msgstr "`_` 패턴은 이전 패턴과 일치하지 않는 모든 항목과 일치합니다."

#: src/05_ticket_v2/02_match.md:74
msgid ""
"The exercise for this section is located in [`05_ticket_v2/02_match`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/02_match)"
msgstr ""
"이 섹션의 예제는 [`05_ticket_v2/02_match`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/02_match)에 있습니다"

#: src/05_ticket_v2/03_variants_with_data.md:1
msgid "Variants can hold data"
msgstr "배리언트는 데이터를 가질 수 있습니다"

#: src/05_ticket_v2/03_variants_with_data.md:11
msgid ""
"Our `Status` enum is what's usually called a **C-style enum**.  \n"
"Each variant is a simple label, a bit like a named constant. You can find "
"this kind of enum in many programming languages, like C, C++, Java, C#, "
"Python, etc."
msgstr ""
"우리의 `Status` 열거형은 일반적으로 **C 스타일 열거형**이라고 불리는 것입니"
"다.  \n"
"각 변형은 명명된 상수와 약간 유사한 간단한 레이블입니다. C, C++, Java, C#, "
"Python 등과 같은 많은 프로그래밍 언어에서 이러한 종류의 열거형을 찾을 수 있습"
"니다."

#: src/05_ticket_v2/03_variants_with_data.md:15
msgid ""
"Rust enums can go further though. We can **attach data to each variant**."
msgstr ""
"Rust 열거형은 더 나아갈 수 있습니다. **각 배리언트에 데이터를 첨부**할 수 있습"
"니다."

#: src/05_ticket_v2/03_variants_with_data.md:17
msgid "Variants"
msgstr "배리언트"

#: src/05_ticket_v2/03_variants_with_data.md:19
msgid ""
"Let's say that we want to store the name of the person who's currently "
"working on a ticket.  \n"
"We would only have this information if the ticket is in progress. It wouldn't "
"be there for a to-do ticket or a done ticket. We can model this by attaching "
"a `String` field to the `InProgress` variant:"
msgstr ""
"현재 티켓 작업을 하고 있는 사람의 이름을 저장하고 싶다고 가정해 보겠습니"
"다.  \n"
"티켓이 진행 중인 경우에만 이 정보를 얻을 수 있습니다. 할 일 티켓이나 완료된 티"
"켓에는 존재하지 않습니다. `InProgress` 배리언트에 `String` 필드를 연결하여 이"
"를 모델링할 수 있습니다:"

#: src/05_ticket_v2/03_variants_with_data.md:34
msgid ""
"`InProgress` is now a **struct-like variant**.  \n"
"The syntax mirrors, in fact, the one we used to define a struct—it's just "
"\"inlined\" inside the enum, as a variant."
msgstr ""
"`InProgress`는 이제 **구조체 유사 배리언트**입니다.  \n"
"실제로 구문은 구조체를 정의하는 데 사용한 구문을 사용합니다. 즉, 배리언트로 열"
"거형 내부에 \"인라인\"되어 있을 뿐입니다."

#: src/05_ticket_v2/03_variants_with_data.md:37
msgid "Accessing variant data"
msgstr "배리언트 데이터에 액세스"

#: src/05_ticket_v2/03_variants_with_data.md:39
msgid "If we try to access `assigned_to` on a `Status` instance,"
msgstr "`Status` 인스턴스의 `assigned_to`에 액세스하려고 하면,"

#: src/05_ticket_v2/03_variants_with_data.md:43
msgid "// This won't compile\n"
msgstr "// 컴파일되지 않습니다\n"

#: src/05_ticket_v2/03_variants_with_data.md:45
#: src/05_ticket_v2/03_variants_with_data.md:64
#: src/05_ticket_v2/03_variants_with_data.md:82
msgid "\"Assigned to: {}\""
msgstr "\"Assigned to: {}\""

#: src/05_ticket_v2/03_variants_with_data.md:48
msgid "the compiler will stop us:"
msgstr "컴파일러가 우리를 막을 것입니다:"

#: src/05_ticket_v2/03_variants_with_data.md:50
msgid ""
"```text\n"
"error[E0609]: no field `assigned_to` on type `Status`\n"
" --> src/main.rs:5:40\n"
"  |\n"
"5 |     println!(\"Assigned to: {}\", status.assigned_to);\n"
"  |                                        ^^^^^^^^^^^ unknown field\n"
"```"
msgstr ""
"```text\n"
"error[E0609]: no field `assigned_to` on type `Status`\n"
" --> src/main.rs:5:40\n"
"  |\n"
"5 |     println!(\"Assigned to: {}\", status.assigned_to);\n"
"  |                                        ^^^^^^^^^^^ unknown field\n"
"```"

#: src/05_ticket_v2/03_variants_with_data.md:58
msgid ""
"`assigned_to` is **variant-specific**, it's not available on all `Status` "
"instances.  \n"
"To access `assigned_to`, we need to use **pattern matching**:"
msgstr ""
"`assigned_to`는 **특정 배리언트**에 대한 것이므로 모든 `Status` 인스턴스에서 "
"사용할 수는 없습니다.  \n"
"`assigned_to`에 액세스하려면 **패턴 매칭**을 사용해야 합니다."

#: src/05_ticket_v2/03_variants_with_data.md:67
#: src/05_ticket_v2/03_variants_with_data.md:85
msgid "\"Done\""
msgstr "\"Done\""

#: src/05_ticket_v2/03_variants_with_data.md:72
msgid "Bindings"
msgstr "바인딩"

#: src/05_ticket_v2/03_variants_with_data.md:74
msgid ""
"In the match pattern `Status::InProgress { assigned_to }`, `assigned_to` is a "
"**binding**.  \n"
"We're **destructuring** the `Status::InProgress` variant and binding the "
"`assigned_to` field to a new variable, also named `assigned_to`.  \n"
"If we wanted, we could bind the field to a different variable name:"
msgstr ""
"`Status::InProgress { assigned_to }`매치 패턴에서, `assigned_to`는 **바인딩**"
"입니다.   \n"
"우리는 `Status::InProgress` 배리언트를 **구조 분해**하고 `assigned_to` 필드를 "
"`assigned_to`라는 새 변수에 바인딩합니다.  \n"
"원한다면 필드를 다른 변수 이름에 바인딩할 수 있습니다:"

#: src/05_ticket_v2/03_variants_with_data.md:92
msgid ""
"The exercise for this section is located in "
"[`05_ticket_v2/03_variants_with_data`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/03_variants_with_data)"
msgstr ""
"이 섹션의 예제는 [`05_ticket_v2/03_variants_with_data`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/03_variants_with_data)에 있습니다"

#: src/05_ticket_v2/04_if_let.md:1
msgid "Concise branching"
msgstr "간결한 분기"

#: src/05_ticket_v2/04_if_let.md:3
msgid "Your solution to the previous exercise probably looks like this:"
msgstr "이전 예제에 대한 솔루션은 아마도 다음과 같을 것입니다:"

#: src/05_ticket_v2/04_if_let.md:11 src/05_ticket_v2/04_if_let.md:36
#: src/05_ticket_v2/04_if_let.md:51
msgid "\"Only `In-Progress` tickets can be assigned to someone\""
msgstr "\"`In-Progress` 티켓만 누군가에게 할당될 수 있습니다\""

#: src/05_ticket_v2/04_if_let.md:18
msgid ""
"You only care about the `Status::InProgress` variant. Do you really need to "
"match on all the other variants?"
msgstr ""
"우린 `Status::InProgress` 배리언트에만 관심이 있습니다. 꼭 다른 모든 배리언트"
"를 매칭해야할까요?"

#: src/05_ticket_v2/04_if_let.md:21
msgid "New constructs to the rescue!"
msgstr "우리를 구원할 새로운 친구입니다!"

#: src/05_ticket_v2/04_if_let.md:23
msgid "`if let`"
msgstr "`if let`"

#: src/05_ticket_v2/04_if_let.md:25
msgid ""
"The `if let` construct allows you to match on a single variant of an enum, "
"without having to handle all the other variants."
msgstr ""
"`if let` 구조를 사용하면 다른 모든 배리언트를 처리할 필요 없이 열거형의 단일 "
"배리언트를 매칭할 수 있습니다."

#: src/05_ticket_v2/04_if_let.md:28
msgid "Here's how you can use `if let` to simplify the `assigned_to` method:"
msgstr ""
"`assigned_to` 메서드를 단순화하기 위해 `if let`을 사용하는 방법은 다음과 같습"
"니다:"

#: src/05_ticket_v2/04_if_let.md:42
msgid "`let/else`"
msgstr "`let/else`"

#: src/05_ticket_v2/04_if_let.md:44
msgid ""
"If the `else` branch is meant to return early (a panic counts as returning "
"early!), you can use the `let/else` construct:"
msgstr ""
"`else` 분기가 일찍 반환되도록 의도된 경우(패닉은 조기 반환으로 간주됩니다!) "
"`let/else` 구문을 사용할 수 있습니다:"

#: src/05_ticket_v2/04_if_let.md:58
msgid ""
"It allows you to assign the destructured variable without incurring any "
"\"right drift\", i.e. the variable is assigned at the same indentation level "
"as the code that precedes it."
msgstr ""
"이를 통해 \"오른쪽 드리프트\"를 발생시키지 않고 구조 해제된 변수를 할당할 수 "
"있습니다. 즉, 변수는 이전 코드와 동일한 들여쓰기 수준에서 할당됩니다."

#: src/05_ticket_v2/04_if_let.md:62
msgid "Style"
msgstr "스타일"

#: src/05_ticket_v2/04_if_let.md:64
msgid ""
"Both `if let` and `let/else` are idiomatic Rust constructs.  \n"
"Use them as you see fit to improve the readability of your code, but don't "
"overdo it: `match` is always there when you need it."
msgstr ""
"`if let`과 `let/else`는 둘 다 관용적인 Rust 구문입니다.  \n"
"코드의 가독성을 높이기 위해 적절하다고 생각되는 대로 사용하되, 너무 과도하게 "
"사용하지 마세요. `match`는 항상 필요할 때 그 자리에 있으니까요."

#: src/05_ticket_v2/04_if_let.md:70
msgid ""
"The exercise for this section is located in [`05_ticket_v2/04_if_let`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/04_if_let)"
msgstr ""
"이 섹션의 예제는 [`05_ticket_v2/04_if_let`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/04_if_let)에 있습니다"

#: src/05_ticket_v2/05_nullability.md:3
msgid ""
"Our implementation of the `assigned` method is fairly blunt: panicking for to-"
"do and done tickets is far from ideal.  \n"
"We can do better using **Rust's `Option` type**."
msgstr ""
"`assigned` 메소드의 구현은 상당히 무뚝뚝합니다. to-do 상태의 티켓과 완료된 티"
"켓에 대해 패닉하는 것은 이상적이지 않습니다.  \n"
"**Rust의 `Option` 타입**을 사용하면 더 나은 결과를 얻을 수 있습니다."

#: src/05_ticket_v2/05_nullability.md:6
msgid "`Option`"
msgstr "`Option`"

#: src/05_ticket_v2/05_nullability.md:8
msgid ""
"`Option` is a Rust type that represents **nullable values**.  \n"
"It is an enum, defined in Rust's standard library:"
msgstr ""
"`Option`은 **nullable 값**을 나타내는 Rust 타입입니다.  \n"
"이것은 Rust의 표준 라이브러리에 정의된 열거형입니다:"

#: src/05_ticket_v2/05_nullability.md:18
msgid ""
"`Option` encodes the idea that a value might be present (`Some(T)`) or absent "
"(`None`).  \n"
"It also forces you to **explicitly handle both cases**. You'll get a compiler "
"error if you are working with a nullable value and you forget to handle the "
"`None` case.  \n"
"This is a significant improvement over \"implicit\" nullability in other "
"languages, where you can forget to check for `null` and thus trigger a "
"runtime error."
msgstr ""
"`Option`은 값이 존재할 수도 있고(`Some(T)`) 없을 수도 있다는(`None`) 아이디어"
"를 인코딩합니다.  \n"
"또한 **두 경우를 모두 명시적으로 처리**해야 합니다. Null 허용 값으로 작업하고 "
"`None` 사례를 처리하는 것을 잊은 경우 컴파일러 오류가 발생합니다.  \n"
"이는 `null` 확인을 잊어버려 런타임 오류를 유발할 수 있는 다른 언어의 \"암시적"
"\" null 허용 여부에 비해 크게 개선된 것입니다."

#: src/05_ticket_v2/05_nullability.md:24
msgid "`Option`'s definition"
msgstr "`Option`의 정의"

#: src/05_ticket_v2/05_nullability.md:26
msgid ""
"`Option`'s definition uses a Rust construct that you haven't seen before: "
"**tuple-like variants**."
msgstr ""
"`Option`의 정의는 이전에 본 적이 없는 Rust 구성인 **튜플 유사 배리언트**를 사"
"용합니다."

#: src/05_ticket_v2/05_nullability.md:28
msgid "Tuple-like variants"
msgstr "튜플 유사 배리언트"

#: src/05_ticket_v2/05_nullability.md:30
msgid ""
"`Option` has two variants: `Some(T)` and `None`.  \n"
"`Some` is a **tuple-like variant**: it's a variant that holds **unnamed "
"fields**."
msgstr ""
"`Option`에는 `Some(T)`과 `None`이라는 두 가지 배리언트가 있습니다.  \n"
"`Some`은 **튜플 유사 배리언트**입니다. 이는 **이름이 지정되지 않은 필드**를 가"
"지는 배리언트입니다."

#: src/05_ticket_v2/05_nullability.md:33
msgid ""
"Tuple-like variants are often used when there is a single field to store, "
"especially when we're looking at a \"wrapper\" type like `Option`."
msgstr ""
"튜플형 배리언트는 저장할 단일 필드가 있을 때, 특히 `Option`과 같은 \"래퍼\" 타"
"입에 자주 사용됩니다."

#: src/05_ticket_v2/05_nullability.md:36
msgid "Tuple-like structs"
msgstr "튜플 유사 구조체"

#: src/05_ticket_v2/05_nullability.md:38
msgid "They're not specific to enums—you can define tuple-like structs too:"
msgstr ""
"이는 열거형에만 국한되지 않습니다. 튜플 유사 구조체도 정의할 수 있습니다:"

#: src/05_ticket_v2/05_nullability.md:44
msgid ""
"You can then access the two fields of a `Point` instance using their "
"positional index:"
msgstr ""
"그런 다음 위치 인덱스를 사용하여 `Point` 인스턴스의 두 필드에 액세스할 수 있습"
"니다:"

#: src/05_ticket_v2/05_nullability.md:52
msgid "Tuples"
msgstr "튜플"

#: src/05_ticket_v2/05_nullability.md:54
msgid ""
"It's weird to say that something is tuple-like when we haven't seen tuples "
"yet!  \n"
"Tuples are another example of a primitive Rust type. They group together a "
"fixed number of values with (potentially different) types:"
msgstr ""
"아직 튜플을 본 적이 없는데 뭔가가 튜플과 비슷하다고 말하는 것은 이상합니"
"다!  \n"
"튜플은 원시 Rust 타입의 또 다른 예입니다. (잠재적으로 다른) 타입을 사용하여 고"
"정된 개수의 값을 그룹화합니다."

#: src/05_ticket_v2/05_nullability.md:59
msgid "// Two values, same type\n"
msgstr "// 두 개의 값, 동일한 타입\n"

#: src/05_ticket_v2/05_nullability.md:60
msgid "// Three values, different types\n"
msgstr "// 세 가지 값, 다른 타입\n"

#: src/05_ticket_v2/05_nullability.md:65
msgid ""
"The syntax is simple: you list the types of the values between parentheses, "
"separated by commas. You can access the fields of a tuple using the dot "
"notation and the field index:"
msgstr ""
"문법은 간단합니다. 괄호 안에 값 타입을 쉼표로 구분하여 나열합니다. 점 표기법"
"과 필드 인덱스를 사용하여 튜플의 필드에 액세스할 수 있습니다."

#: src/05_ticket_v2/05_nullability.md:74
msgid ""
"Tuples are a convenient way of grouping values together when you can't be "
"bothered to define a dedicated struct type."
msgstr ""
"튜플은 전용 구조체 타입을 정의할 필요가 없을 때 값을 그룹화하는 편리한 방법입"
"니다."

#: src/05_ticket_v2/05_nullability.md:78
msgid ""
"The exercise for this section is located in [`05_ticket_v2/05_nullability`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/05_nullability)"
msgstr ""
"이 섹션의 예제는 [`05_ticket_v2/05_nullability`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/05_nullability)에 있습니다"

#: src/05_ticket_v2/06_fallibility.md:3
msgid "Let's revisit the `Ticket::new` function from the previous exercise:"
msgstr "이전 예제의 `Ticket::new` 함수를 다시 살펴보겠습니다."

#: src/05_ticket_v2/06_fallibility.md:9
msgid "\"Title cannot be empty\""
msgstr "\"Title cannot be empty\""

#: src/05_ticket_v2/06_fallibility.md:12
msgid "\"Title cannot be longer than 50 bytes\""
msgstr "\"Title cannot be longer than 50 bytes\""

#: src/05_ticket_v2/06_fallibility.md:15
msgid "\"Description cannot be empty\""
msgstr "\"Description cannot be empty\""

#: src/05_ticket_v2/06_fallibility.md:18
msgid "\"Description cannot be longer than 500 bytes\""
msgstr "\"Description cannot be longer than 500 bytes\""

#: src/05_ticket_v2/06_fallibility.md:30
msgid ""
"As soon as one of the checks fails, the function panics. This is not ideal, "
"as it doesn't give the caller a chance to **handle the error**."
msgstr ""
"검사 중 하나가 실패하자마자 함수는 패닉 상태가 됩니다. 이는 호출자에게 **오류"
"를 처리**할 기회를 주지 않기 때문에 이상적이지 않습니다."

#: src/05_ticket_v2/06_fallibility.md:33
msgid ""
"It's time to introduce the `Result` type, Rust's primary mechanism for error "
"handling."
msgstr ""
"이제 오류 처리를 위한 Rust의 주요 메커니즘인 `Result` 타입을 소개할 시간입니"
"다."

#: src/05_ticket_v2/06_fallibility.md:35
msgid "The `Result` type"
msgstr "`Result` 타입"

#: src/05_ticket_v2/06_fallibility.md:37
msgid "The `Result` type is an enum defined in the standard library:"
msgstr "`Result` 타입은 표준 라이브러리에 정의된 열거형입니다."

#: src/05_ticket_v2/06_fallibility.md:46
msgid "It has two variants:"
msgstr "여기에는 두 가지 배리언트가 있습니다."

#: src/05_ticket_v2/06_fallibility.md:48
msgid ""
"`Ok(T)`: represents a successful operation. It holds `T`, the output of the "
"operation."
msgstr "`Ok(T)`: 성공적인 작업을 나타냅니다. 연산의 결과인 `T`를 가집니다."

#: src/05_ticket_v2/06_fallibility.md:49
msgid ""
"`Err(E)`: represents a failed operation. It holds `E`, the error that "
"occurred."
msgstr "`Err(E)`: 실패한 작업을 나타냅니다. 발생한 오류인 `E`를 가집니다."

#: src/05_ticket_v2/06_fallibility.md:51
msgid ""
"Both `Ok` and `Err` are generic, allowing you to specify your own types for "
"the success and error cases."
msgstr ""
"`Ok`와 `Err`은 모두 일반적이므로 성공 및 오류 사례에 대해 고유한 타입을 지정"
"할 수 있습니다."

#: src/05_ticket_v2/06_fallibility.md:53
msgid "No exceptions"
msgstr "예외 없음"

#: src/05_ticket_v2/06_fallibility.md:55
msgid ""
"Recoverable errors in Rust are **represented as values**.  \n"
"They're just an instance of a type, being passed around and manipulated like "
"any other value. This is a significant difference from other languages, such "
"as Python or C#, where **exceptions** are used to signal errors."
msgstr ""
"Rust에서 복구 가능한 오류는 **값으로 표시**됩니다.  \n"
"이는 단지 타입의 인스턴스일 뿐이며 다른 값처럼 전달되고 조작됩니다. 이는 오류"
"를 알리기 위해 **예외**를 사용하는 Python이나 C# 등의 다른 언어와는 상당한 차"
"이가 있습니다."

#: src/05_ticket_v2/06_fallibility.md:59
msgid ""
"Exceptions create a separate control flow path that can be hard to reason "
"about.  \n"
"You don't know, just by looking at a function's signature, if it can throw an "
"exception or not. You don't know, just by looking at a function's signature, "
"**which** exception types it can throw.  \n"
"You must either read the function's documentation or look at its "
"implementation to find out."
msgstr ""
"예외는 추론하기 어려울 수 있는 별도의 제어 흐름 경로를 생성합니다.  \n"
"함수의 시그니처만 보면 예외가 발생할 수 있는지 여부를 알 수 없습니다. 함수의 "
"시그니처만 보면 **어떤** 예외 타입이 발생할 수 있는지 알 수 없습니다.  \n"
"알아내려면 함수의 문서를 읽거나 구현을 살펴봐야 합니다."

#: src/05_ticket_v2/06_fallibility.md:64
msgid ""
"Exception handling logic has very poor locality: the code that throws the "
"exception is far removed from the code that catches it, and there's no direct "
"link between the two."
msgstr ""
"예외 처리 로직은 지역성이 매우 낮습니다. 예외를 발생시키는 코드는 예외를 포착"
"하는 코드에서 멀리 떨어져 있으며 둘 사이에는 직접적인 링크가 없습니다."

#: src/05_ticket_v2/06_fallibility.md:67
msgid "Fallibility is encoded in the type system"
msgstr "오류 가능성은 타입 시스템에 인코딩되어 있습니다"

#: src/05_ticket_v2/06_fallibility.md:69
msgid ""
"Rust, with `Result`, forces you to **encode fallibility in the function's "
"signature**.  \n"
"If a function can fail (and you want the caller to have a shot at handling "
"the error), it must return a `Result`."
msgstr ""
"Rust는 `Result`를 사용하여 **함수 시그니처의 오류 가능성**을 인코딩하도록 강제"
"합니다.  \n"
"함수가 실패할 수 있는 경우(그리고 호출자가 오류를 처리하도록 하려는 경우) "
"`Result`를 반환해야 합니다."

#: src/05_ticket_v2/06_fallibility.md:73
msgid ""
"// Just by looking at the signature, you know that this function can fail.\n"
"// You can also inspect `ParseIntError` to see what kind of failures to "
"expect.\n"
msgstr ""
"// 시그니처만 봐도 이 함수가 실패할 수 있다는 것을 알 수 있습니다.\n"
"// `ParseIntError`를 확인해 어떤 종류의 실패가 예상되는지 알 수 있습니다.\n"

#: src/05_ticket_v2/06_fallibility.md:76 src/05_ticket_v2/07_unwrap.md:13
msgid "// ...\n"
msgstr "// ...\n"

#: src/05_ticket_v2/06_fallibility.md:80
msgid "That's the big advantage of `Result`: it makes fallibility explicit."
msgstr ""
"이것이 `Result`의 가장 큰 장점입니다. 즉, 오류 가능성을 명시적으로 만들어줍니"
"다."

#: src/05_ticket_v2/06_fallibility.md:82
msgid ""
"Keep in mind, though, that panics exist. They aren't tracked by the type "
"system, just like exceptions in other languages. But they're meant for "
"**unrecoverable errors** and should be used sparingly."
msgstr ""
"하지만 패닉이 존재한다는 점을 명심하십시오. 다른 언어의 예외와 마찬가지로 타"
"입 시스템으로 추적되지 않습니다. 그러나 **복구할 수 없는 오류**를 위한 것이므"
"로 드물게 사용해야 합니다."

#: src/05_ticket_v2/06_fallibility.md:87
msgid ""
"The exercise for this section is located in [`05_ticket_v2/06_fallibility`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/06_fallibility)"
msgstr ""
"이 섹션의 예제는 [`05_ticket_v2/06_fallibility`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/06_fallibility)에 있습니다"

#: src/05_ticket_v2/07_unwrap.md:1
msgid "Unwrapping"
msgstr "언랩핑"

#: src/05_ticket_v2/07_unwrap.md:3
msgid ""
"`Ticket::new` now returns a `Result` instead of panicking on invalid "
"inputs.  \n"
"What does this mean for the caller?"
msgstr ""
"`Ticket::new`는 이제 유효하지 않은 입력에 패닉하는 대신 `Result`를 반환합니"
"다.  \n"
"이는 호출하는 입장에서 무엇을 의미할까요?"

#: src/05_ticket_v2/07_unwrap.md:6
msgid "Failures can't be (implicitly) ignored"
msgstr "실패는 (암시적으로) 무시될 수 없습니다"

#: src/05_ticket_v2/07_unwrap.md:8
msgid ""
"Unlike exceptions, Rust's `Result` forces you to **handle errors at the call "
"site**.  \n"
"If you call a function that returns a `Result`, Rust won't allow you to "
"implicitly ignore the error case."
msgstr ""
"예외와 달리 Rust의 `Result`는 **호출한 곳에서 오류를 처리**하도록 강제합니"
"다.  \n"
"`Result`를 반환하는 함수를 호출하면 Rust는 에러 케이스를 암시적으로 무시하는 "
"것을 허용하지 않습니다."

#: src/05_ticket_v2/07_unwrap.md:15
msgid ""
"// This won't compile: we're not handling the error case.\n"
"// We must either use `match` or one of the combinators provided by `Result`\n"
"// to \"unwrap\" the success value or handle the error.\n"
msgstr ""
"// 컴파일되지 않습니다. 에러 케이스를 처리하지 않았습니다.\n"
"// 성공 값을 \"언랩\"하거나 오류를 처리하려면 `match` 또는 `Result`에서 제공하"
"는\n"
"// 결합자 중 하나를 사용해야 합니다.\n"

#: src/05_ticket_v2/07_unwrap.md:19 src/05_ticket_v2/07_unwrap.md:30
#: src/05_ticket_v2/07_unwrap.md:32 src/05_ticket_v2/07_unwrap.md:36
msgid "\"42\""
msgstr "\"42\""

#: src/05_ticket_v2/07_unwrap.md:22
msgid "You got a `Result`. Now what?"
msgstr "`Result`가 나왔습니다. 이걸로 뭘 할 수 있을까요?"

#: src/05_ticket_v2/07_unwrap.md:24
msgid ""
"When you call a function that returns a `Result`, you have two key options:"
msgstr "`Result`를 반환하는 함수를 호출할 때 두 가지 주요 옵션이 있습니다:"

#: src/05_ticket_v2/07_unwrap.md:26
msgid ""
"Panic if the operation failed. This is done using either the `unwrap` or "
"`expect` methods."
msgstr ""
"작업이 실패하면 패닉이 발생합니다. 이는 `unwrap` 또는 `expect` 메소드를 사용하"
"여 수행됩니다."

#: src/05_ticket_v2/07_unwrap.md:29
msgid "// Panics if `parse_int` returns an `Err`.\n"
msgstr "// `parse_int`가 `Err`을 반환하면 패닉이 발생합니다.\n"

#: src/05_ticket_v2/07_unwrap.md:31
msgid "// `expect` lets you specify a custom panic message.\n"
msgstr "// `expect`를 사용하면 사용자 정의 패닉 메시지를 지정할 수 있습니다.\n"

#: src/05_ticket_v2/07_unwrap.md:32
msgid "\"Failed to parse integer\""
msgstr "\"Failed to parse integer\""

#: src/05_ticket_v2/07_unwrap.md:34
msgid ""
"Destructure the `Result` using a `match` expression to deal with the error "
"case explicitly."
msgstr ""
"에러 케이스를 명시적으로 처리하려면 `match` 표현식을 사용하여 `Result`를 구조 "
"해제하세요."

#: src/05_ticket_v2/07_unwrap.md:37
msgid "\"Parsed number: {}\""
msgstr "\"Parsed number: {}\""

#: src/05_ticket_v2/07_unwrap.md:38
msgid "\"Error: {}\""
msgstr "\"Error: {}\""

#: src/05_ticket_v2/07_unwrap.md:44
msgid ""
"The exercise for this section is located in [`05_ticket_v2/07_unwrap`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/07_unwrap)"
msgstr ""
"이 섹션의 예제는 [`05_ticket_v2/07_unwrap`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/07_unwrap)에 있습니다"

#: src/05_ticket_v2/08_error_enums.md:3
msgid ""
"Your solution to the previous exercise may have felt awkward: matching on "
"strings is not ideal!  \n"
"A colleague might rework the error messages returned by `Ticket::new` (e.g. "
"to improve readability) and, all of a sudden, your calling code would break."
msgstr ""
"이전 예제에 대한 솔루션이 어색하게 느껴질 수 있습니다. 문자열 매칭은 이상적이"
"지 않습니다!  \n"
"동료가 `Ticket::new`에서 반환된 오류 메시지를 재작업할 수 있으며(예: 가독성을 "
"높이기 위해) 갑자기 호출하는 코드가 중단될 수 있습니다."

#: src/05_ticket_v2/08_error_enums.md:7
msgid "You already know the machinery required to fix this: enums!"
msgstr ""
"당신은 이 문제를 해결하는 데 필요한 메커니즘을 이미 알고 있습니다: 열거형!"

#: src/05_ticket_v2/08_error_enums.md:9
msgid "Reacting to errors"
msgstr "오류 처리"

#: src/05_ticket_v2/08_error_enums.md:11
msgid ""
"When you want to allow the caller to behave differently based on the specific "
"error that occurred, you can use an enum to represent the different error "
"cases:"
msgstr ""
"발생한 특정 오류에 따라 호출자가 다르게 동작하도록 허용하려면 열거형을 사용하"
"여 다양한 오류 사례를 나타낼 수 있습니다:"

#: src/05_ticket_v2/08_error_enums.md:15
msgid ""
"// An error enum to represent the different error cases\n"
"// that may occur when parsing a `u32` from a string.\n"
msgstr ""
"// 문자열에서 `u32`를 구문 분석할 때 발생할 수 있는\n"
"// 다양한 에러 케이스를 나타내는 오류 열거형입니다.\n"

#: src/05_ticket_v2/08_error_enums.md:24
msgid ""
"Using an error enum, you're encoding the different error cases in the type "
"system—they become part of the signature of the fallible function.  \n"
"This simplifies error handling for the caller, as they can use a `match` "
"expression to react to the different error cases:"
msgstr ""
"오류 열거형을 사용하여 타입 시스템의 다양한 에러 케이스를 인코딩합니다. 이는 "
"오류가 있는 함수 시그니처의 일부가 됩니다.  \n"
"이렇게 하면 호출자가 `match` 표현식을 사용하여 다양한 에러 케이스에 대응할 수 "
"있으므로 호출자의 오류 처리가 단순화됩니다."

#: src/05_ticket_v2/08_error_enums.md:35
msgid "\"Not a number: {}\""
msgstr "\"Not a number: {}\""

#: src/05_ticket_v2/08_error_enums.md:42
msgid ""
"The exercise for this section is located in [`05_ticket_v2/08_error_enums`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/08_error_enums)"
msgstr ""
"이 섹션의 예제는 [`05_ticket_v2/08_error_enums`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/08_error_enums)에 있습니다"

#: src/05_ticket_v2/09_error_trait.md:1
msgid "Error trait"
msgstr "Error 트레잇"

#: src/05_ticket_v2/09_error_trait.md:3
msgid "Error reporting"
msgstr "오류 보고"

#: src/05_ticket_v2/09_error_trait.md:5
msgid ""
"In the previous exercise you had to destructure the `TitleError` variant to "
"extract the error message and pass it to the `panic!` macro.  \n"
"This is a (rudimentary) example of **error reporting**: transforming an error "
"type into a representation that can be shown to a user, a service operator, "
"or a developer."
msgstr ""
"이전 예제에서는 오류 메시지를 추출하고 이를 `panic!` 매크로에 전달하기 위해 "
"`TitleError` 배리언트를 분해해야 했습니다.  \n"
"이는 **오류 보고**의 (초보적인) 예입니다. 오류 타입을 사용자, 서비스 운영자 또"
"는 개발자에게 표시될 수 있는 표현으로 변환합니다."

#: src/05_ticket_v2/09_error_trait.md:10
msgid ""
"It's not practical for each Rust developer to come up with their own error "
"reporting strategy: it'd be a waste of time and it wouldn't compose well "
"across projects. That's why Rust provides the `std::error::Error` trait."
msgstr ""
"각 Rust 개발자가 자신만의 오류 보고 전략을 생각해내는 것은 실용적이지 않습니"
"다. 이는 시간 낭비일 뿐 아니라 프로젝트 전반에 걸쳐 잘 구성되지 않을 것입니"
"다. 이것이 Rust가 `std::error::Error` 트레잇을 제공하는 이유입니다."

#: src/05_ticket_v2/09_error_trait.md:14
msgid "The `Error` trait"
msgstr "'Error' 트레잇"

#: src/05_ticket_v2/09_error_trait.md:16
msgid ""
"There are no constraints on the type of the `Err` variant in a `Result`, but "
"it's a good practice to use a type that implements the `Error` trait. `Error` "
"is the cornerstone of Rust's error handling story:"
msgstr ""
"`Result`의 `Err` 배리언트 타입에는 제한이 없지만 `Error` 트레잇을 구현하는 타"
"입을 사용하는 것이 좋습니다. `Error`는 Rust의 오류 처리 이야기의 초석입니다:"

#: src/05_ticket_v2/09_error_trait.md:21
msgid "// Slightly simplified definition of the `Error` trait\n"
msgstr "// `Error` 트레잇의 정의를 약간 단순화했습니다\n"

#: src/05_ticket_v2/09_error_trait.md:25
msgid ""
"You might recall the `:` syntax from [the `Sized` trait]"
"(../04_traits/08_sized.md)—it's used to specify **supertraits**. For `Error`, "
"there are two supertraits: `Debug` and `Display`. If a type wants to "
"implement `Error`, it must also implement `Debug` and `Display`."
msgstr ""
"`Sized` 트레잇에서 `:` 구문을 기억하실 수 있습니다. 이는 **슈퍼 트레잇**을 지"
"정하는 데 사용됩니다. `Error`에는 `Debug`와 `Display`라는 두 가지 슈퍼 트레잇"
"이 있습니다. 타입이 `Error`를 구현하려는 경우 `Debug` 및 `Display`도 구현해야 "
"합니다."

#: src/05_ticket_v2/09_error_trait.md:29
msgid "`Display` and `Debug`"
msgstr "`Display`와 `Debug`"

#: src/05_ticket_v2/09_error_trait.md:31
msgid ""
"We've already encountered the `Debug` trait in [a previous exercise]"
"(../04_traits/04_derive.md)—it's the trait used by `assert_eq!` to display "
"the values of the variables it's comparing when the assertion fails."
msgstr ""
"우리는 이전 예제에서 이미 `Debug` 트레잇을 접했습니다. 이는 어설션이 실패할 "
"때 비교하는 변수의 값을 표시하기 위해 `assert_eq!`에서 사용하는 트레잇입니다."

#: src/05_ticket_v2/09_error_trait.md:34
msgid ""
"From a \"mechanical\" perspective, `Display` and `Debug` are identical—they "
"encode how a type should be converted into a string-like representation:"
msgstr ""
"\"메카니컬한\" 관점에서 `Display`와 `Debug`는 동일합니다. 즉, 타입을 문자열과 "
"같은 표현으로 변환하는 방법을 인코딩합니다."

#: src/05_ticket_v2/09_error_trait.md:38
msgid "// `Debug`\n"
msgstr "// `Debug`\n"

#: src/05_ticket_v2/09_error_trait.md:42
msgid "// `Display`\n"
msgstr "// `Display`\n"

#: src/05_ticket_v2/09_error_trait.md:49
msgid ""
"The difference is in their _purpose_: `Display` returns a representation "
"that's meant for \"end-users\", while `Debug` provides a low-level "
"representation that's more suitable to developers and service operators.  \n"
"That's why `Debug` can be automatically implemented using the "
"`#[derive(Debug)]` attribute, while `Display` **requires** a manual "
"implementation."
msgstr ""
"차이점은 _목적_에 있습니다. `Display`는 \"최종 사용자\"를 위한 표현을 반환하"
"는 반면, `Debug`는 개발자와 서비스 운영자에게 더 적합한 낮은 수준의 표현을 제"
"공합니다.  \n"
"이것이 바로 `Debug`가 `#[derive(Debug)]` 속성을 사용하여 자동으로 구현될 수 있"
"는 반면, `Display`는 수동 구현이 **필요**한 이유입니다."

#: src/05_ticket_v2/09_error_trait.md:56
msgid ""
"The exercise for this section is located in [`05_ticket_v2/09_error_trait`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/09_error_trait)"
msgstr ""
"이 섹션의 예제는 [`05_ticket_v2/09_error_trait`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/09_error_trait)에 잇습니다"

#: src/05_ticket_v2/10_packages.md:1
msgid "Libraries and binaries"
msgstr "라이브러리와 바이너리"

#: src/05_ticket_v2/10_packages.md:3
msgid ""
"It took a bit of code to implement the `Error` trait for `TicketNewError`, "
"didn't it?  \n"
"A manual `Display` implementation, plus an `Error` impl block."
msgstr ""
"`TicketNewError`에 대한 `Error` 트레잇을 구현하려면 약간의 코드가 필요하지 않"
"습니까?  \n"
"수동 `Display` 구현과 `Error` impl 블록."

#: src/05_ticket_v2/10_packages.md:6
msgid ""
"We can remove some of the boilerplate by using [`thiserror`](https://docs.rs/"
"thiserror/latest/thiserror/), a Rust crate that provides a **procedural "
"macro** to simplify the creation of custom error types.  \n"
"But we're getting ahead of ourselves: `thiserror` is a third-party crate, "
"it'd be our first dependency!"
msgstr ""
"사용자 정의 오류 타입 생성을 단순화하기 위해 **절차적 매크로**를 제공하는 "
"Rust 크레이트인 `thiserror`를 사용하여 상용구 중 일부를 제거할 수 있습니"
"다.  \n"
"하지만 우리는 앞서 나가고 있습니다. `thiserror`는 서드파티 크레이트이며, 이것"
"이 우리의 첫 번째 디펜던시가 될 것입니다!"

#: src/05_ticket_v2/10_packages.md:10
msgid ""
"Let's take a step back to talk about Rust's packaging system before we dive "
"into dependencies."
msgstr ""
"디펜던시에 대해 자세히 알아보기 전에 한 걸음 물러나 Rust의 패키징 시스템에 대"
"해 이야기해 보겠습니다."

#: src/05_ticket_v2/10_packages.md:12
msgid "What is a package?"
msgstr "패키지란?"

#: src/05_ticket_v2/10_packages.md:14
msgid ""
"A Rust package is defined by the `[package]` section in a `Cargo.toml` file, "
"also known as its **manifest**. Within `[package]` you can set the package's "
"metadata, such as its name and version."
msgstr ""
"Rust 패키지는 **매니페스트**라고도 알려진 `Cargo.toml` 파일의 `[package]` 섹션"
"에 의해 정의됩니다. `[package]` 내에서 이름이나 버전과 같은 패키지의 메타데이"
"터를 설정할 수 있습니다."

#: src/05_ticket_v2/10_packages.md:17
msgid ""
"Go check the `Cargo.toml` file in the directory of this section's exercise!"
msgstr "이 섹션의 예제 디렉토리에 있는 `Cargo.toml` 파일을 확인해보세요!"

#: src/05_ticket_v2/10_packages.md:19
msgid "What is a crate?"
msgstr "크레이트란?"

#: src/05_ticket_v2/10_packages.md:21
msgid ""
"Inside a package, you can have one or more **crates**, also known as "
"**targets**.  \n"
"The two most common crate types are **binary crates** and **library crates**."
msgstr ""
"패키지 내부에는 **targets**라고 하는 하나 이상의 **크레이트**가 있을 수 있습니"
"다.  \n"
"가장 일반적인 두 가지 크레이트 타입은 **바이너리 크레이트**와 **라이브러리 크"
"레이트**입니다."

#: src/05_ticket_v2/10_packages.md:24
msgid "Binaries"
msgstr "바이너리"

#: src/05_ticket_v2/10_packages.md:26
msgid ""
"A binary is a program that can be compiled to an **executable file**.  \n"
"It must include a function named `main`—the program's entry point. `main` is "
"invoked when the program is executed."
msgstr ""
"바이너리는 **실행 파일**로 컴파일될 수 있는 프로그램입니다.  \n"
"여기에는 프로그램의 진입점인 `main`이라는 함수가 포함되어야 합니다. 프로그램"
"이 실행될 때 `main`이 호출됩니다."

#: src/05_ticket_v2/10_packages.md:29
msgid "Libraries"
msgstr "라이브러리"

#: src/05_ticket_v2/10_packages.md:31
msgid ""
"Libraries, on the other hand, are not executable on their own. You can't "
"_run_ a library, but you can _import its code_ from another package that "
"depends on it.  \n"
"A library groups together code (i.e. functions, types, etc.) that can be "
"leveraged by other packages as a **dependency**."
msgstr ""
"반면에 라이브러리는 자체적으로 실행될 수 없습니다. 라이브러리를 _실행_할 수는 "
"없지만 라이브러리에 의존하는 다른 패키지에서 _해당 코드_를 가져올 수 있습니"
"다.  \n"
"라이브러리는 다른 패키지에서 **디펜던시**으로 활용할 수 있는 코드(예: 함수, 타"
"입 등)를 그룹화합니다."

#: src/05_ticket_v2/10_packages.md:35
msgid ""
"All the exercises you've solved so far have been structured as libraries, "
"with a test suite attached to them."
msgstr ""
"지금까지 해결한 모든 연습 문제는 라이브러리로 구성되어 있으며 테스트 모음이 첨"
"부되어 있습니다."

#: src/05_ticket_v2/10_packages.md:37
msgid "Conventions"
msgstr "컨벤션"

#: src/05_ticket_v2/10_packages.md:39
msgid ""
"There are some conventions around Rust packages that you need to keep in mind:"
msgstr "Rust 패키지와 관련하여 염두에 두어야 할 몇 가지 규칙이 있습니다:"

#: src/05_ticket_v2/10_packages.md:41
msgid "The package's source code is usually located in the `src` directory."
msgstr "패키지의 소스 코드는 일반적으로 `src` 디렉토리에 있습니다."

#: src/05_ticket_v2/10_packages.md:42
msgid ""
"If there's a `src/lib.rs` file, `cargo` will infer that the package contains "
"a library crate."
msgstr ""
"`src/lib.rs` 파일이 있으면 `cargo`는 패키지에 라이브러리 크레이트가 포함되어 "
"있다고 추론합니다."

#: src/05_ticket_v2/10_packages.md:43
msgid ""
"If there's a `src/main.rs` file, `cargo` will infer that the package contains "
"a binary crate."
msgstr ""
"`src/main.rs` 파일이 있으면 `cargo`는 패키지에 바이너리 크레이트가 포함되어 있"
"다고 추론합니다."

#: src/05_ticket_v2/10_packages.md:45
msgid ""
"You can override these defaults by explicitly declaring your targets in the "
"`Cargo.toml` file—see [`cargo`'s documentation](https://doc.rust-lang.org/"
"cargo/reference/cargo-targets.html#cargo-targets) for more details."
msgstr ""
"`Cargo.toml` 파일에서 대상을 명시적으로 선언하여 이러한 기본값을 재정의할 수 "
"있습니다. 자세한 내용은 [`cargo` 문서](https://doc.rust-lang.org/cargo/"
"reference/cargo-targets.html#cargo-targets)를 참조하세요."

#: src/05_ticket_v2/10_packages.md:48
msgid ""
"Keep in mind that while a package can contain multiple crates, it can only "
"contain one library crate."
msgstr ""
"패키지에는 여러 크레이트가 포함될 수 있지만 라이브러리 크레이트는 하나만 포함"
"될 수 있습니다."

#: src/05_ticket_v2/10_packages.md:50
msgid "Scaffolding a new package"
msgstr "새 패키지 스캐폴딩하기"

#: src/05_ticket_v2/10_packages.md:52
msgid "You can use `cargo` to scaffold a new package:"
msgstr "새로운 패키지를 생성하기 위해 `cargo`를 사용할 수 있습니다:"

#: src/05_ticket_v2/10_packages.md:58
msgid ""
"This will create a new folder, `my-binary`, containing a new Rust package "
"with the same name and a single binary crate inside. If you want to create a "
"library crate instead, you can use the `--lib` flag:"
msgstr ""
"그러면 이름이 같은 새 Rust 패키지와 내부에 단일 바이너리 상자가 포함된 `my-"
"binary`라는 새 폴더가 생성됩니다. 대신 라이브러리 크레이트를 생성하려면 `--"
"lib` 플래그를 사용할 수 있습니다:"

#: src/05_ticket_v2/10_packages.md:67
msgid ""
"The exercise for this section is located in [`05_ticket_v2/10_packages`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/10_packages)"
msgstr ""
"이 섹션의 예제는 [`05_ticket_v2/10_packages`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/10_packages)에 있습니다"

#: src/05_ticket_v2/11_dependencies.md:3
msgid ""
"A package can depend on other packages by listing them in the "
"`[dependencies]` section of its `Cargo.toml` file.  \n"
"The most common way to specify a dependency is by providing its name and "
"version:"
msgstr ""
"패키지는 `Cargo.toml` 파일의 `[dependencies]` 섹션에 나열하여 다른 패키지에 의"
"존할 수 있습니다.  \n"
"디펜던시를 지정하는 가장 일반적인 방법은 해당 이름과 버전을 제공하는 것입니다."

#: src/05_ticket_v2/11_dependencies.md:6
msgid ""
"```toml\n"
"[dependencies]\n"
"thiserror = \"1\"\n"
"```"
msgstr ""
"```toml\n"
"[dependencies]\n"
"thiserror = \"1\"\n"
"```"

#: src/05_ticket_v2/11_dependencies.md:11
msgid ""
"This will add `thiserror` as a dependency to your package, with a **minimum** "
"version of `1.0.0`. `thiserror` will be pulled from [crates.io](https://"
"crates.io), Rust's official package registry. When you run `cargo build`, "
"`cargo` will go through a few stages:"
msgstr ""
"이렇게 하면 **최소** 버전 `1.0.0`과 함께 `thiserror`가 패키지에 대한 디펜던시"
"로 추가됩니다. `thiserror`는 Rust의 공식 패키지 레지스트리인 [crates.io]"
"(https://crates.io)에서 가져옵니다. `cargo build`를 실행하면 `cargo`는 몇 가"
"지 단계를 거칩니다:"

#: src/05_ticket_v2/11_dependencies.md:15
msgid "Dependency resolution"
msgstr "의존성 해결"

#: src/05_ticket_v2/11_dependencies.md:16
msgid "Downloading the dependencies"
msgstr "디펜던시 다운로드"

#: src/05_ticket_v2/11_dependencies.md:17
msgid "Compiling your project (your own code and the dependencies)"
msgstr "프로젝트 컴파일(자신의 코드와 디펜던시)"

#: src/05_ticket_v2/11_dependencies.md:19
msgid ""
"Dependency resolution is skipped if your project has a `Cargo.lock` file and "
"your manifest files are unchanged. A lockfile is automatically generated by "
"`cargo` after a successful round of dependency resolution: it contains the "
"exact versions of all dependencies used in your project, and is used to "
"ensure that the same versions are consistently used across different builds "
"(e.g. in CI). If you're working on a project with multiple developers, you "
"should commit the `Cargo.lock` file to your version control system."
msgstr ""
"프로젝트에 `Cargo.lock` 파일이 있고 매니페스트 파일이 변경되지 않은 경우 종속"
"성 해결을 건너뜁니다. lockfile은 종속성 해결이 성공적으로 완료된 후 `cargo`에 "
"의해 자동으로 생성됩니다. 여기에는 프로젝트에 사용된 모든 종속성의 정확한 버전"
"이 포함되어 있으며 동일한 버전이 다양한 빌드(예: CI)에서 일관되게 사용되도록 "
"하는 데 사용됩니다. . 여러 개발자와 함께 프로젝트를 진행하는 경우 `Cargo."
"lock` 파일을 버전 제어 시스템에 커밋해야 합니다."

#: src/05_ticket_v2/11_dependencies.md:25
msgid ""
"You can use `cargo update` to update the `Cargo.lock` file with the latest "
"(compatible) versions of all your dependencies."
msgstr ""
"`cargo update`를 사용하여 `Cargo.lock` 파일을 모든 디펜던시의 최신(호환) 버전"
"으로 업데이트할 수 있습니다."

#: src/05_ticket_v2/11_dependencies.md:27
msgid "Path dependencies"
msgstr "경로 디펜던시"

#: src/05_ticket_v2/11_dependencies.md:29
msgid ""
"You can also specify a dependency using a **path**. This is useful when "
"you're working on multiple local packages."
msgstr ""
"**경로**를 사용하여 디펜던시를 지정할 수도 있습니다. 이는 여러 로컬 패키지를 "
"작업할 때 유용합니다."

#: src/05_ticket_v2/11_dependencies.md:31
msgid ""
"```toml\n"
"[dependencies]\n"
"my-library = { path = \"../my-library\" }\n"
"```"
msgstr ""
"```toml\n"
"[dependencies]\n"
"my-library = { path = \"../my-library\" }\n"
"```"

#: src/05_ticket_v2/11_dependencies.md:36
msgid ""
"The path is relative to the `Cargo.toml` file of the package that's declaring "
"the dependency."
msgstr "경로는 디펜던시를 선언하는 패키지의 `Cargo.toml` 파일의 상대경로입니다."

#: src/05_ticket_v2/11_dependencies.md:38
msgid "Other sources"
msgstr "기타 소스"

#: src/05_ticket_v2/11_dependencies.md:40
msgid ""
"Check out the [Cargo documentation](https://doc.rust-lang.org/cargo/reference/"
"specifying-dependencies.html) for more details on where you can get "
"dependencies from and how to specify them in your `Cargo.toml` file."
msgstr ""
"종속성을 가져올 수 있는 위치와 이를 `Cargo.toml` 파일에 지정하는 방법에 대한 "
"자세한 내용은 [Cargo 문서](https://doc.rust-lang.org/cargo/reference/"
"specifying-dependencies.html)를 확인하세요."

#: src/05_ticket_v2/11_dependencies.md:43
msgid "Dev dependencies"
msgstr "개발용 디펜던시"

#: src/05_ticket_v2/11_dependencies.md:45
msgid ""
"You can also specify dependencies that are only needed for development—i.e. "
"they only get pulled in when you're running `cargo test`.  \n"
"They go in the `[dev-dependencies]` section of your `Cargo.toml` file:"
msgstr ""
"개발에만 필요한 디펜던시을 지정할 수도 있습니다. 이것들은 `cargo test`를 실행"
"할 때만 받아옵니다.  \n"
"`Cargo.toml` 파일의 `[dev-dependents]` 섹션에 들어갑니다:"

#: src/05_ticket_v2/11_dependencies.md:49
msgid ""
"```toml\n"
"[dev-dependencies]\n"
"static_assertions = \"1.1.0\"\n"
"```"
msgstr ""
"```toml\n"
"[dev-dependencies]\n"
"static_assertions = \"1.1.0\"\n"
"```"

#: src/05_ticket_v2/11_dependencies.md:54
msgid ""
"We've been using a few of these throughout the book to shorten our tests."
msgstr ""
"우리는 테스트를 단축하기 위해 책 전반에 걸쳐 이들 중 몇 가지를 사용해 왔습니"
"다."

#: src/05_ticket_v2/11_dependencies.md:58
msgid ""
"The exercise for this section is located in [`05_ticket_v2/11_dependencies`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/11_dependencies)"
msgstr ""
"이 섹션의 예제는 [`05_ticket_v2/11_dependencies`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/11_dependencies)에 있습니다"

#: src/05_ticket_v2/12_thiserror.md:3
msgid ""
"That was a bit of detour, wasn't it? But a necessary one!  \n"
"Let's get back on track now: custom error types and `thiserror`."
msgstr ""
"좀 빙 둘러왔어요, 그렇죠? 하지만 꼭 필요한 것이었어요!  \n"
"이제 다시 원래대로 돌아가 보겠습니다: 커스텀 에러 타입과 `thiserror`."

#: src/05_ticket_v2/12_thiserror.md:6
msgid "Custom error types"
msgstr "커스텀 에러 타입"

#: src/05_ticket_v2/12_thiserror.md:8
msgid ""
"We've seen how to implement the `Error` trait \"manually\" for a custom error "
"type.  \n"
"Imagine that you have to do this for most error types in your codebase. "
"That's a lot of boilerplate, isn't it?"
msgstr ""
"우리는 커스텀 에러 타입에 대해 `Error` 트레잇을 \"수동으로\" 구현하는 방법을 "
"살펴보았습니다.  \n"
"코드베이스에 있는 대부분의 에러 타입에 대해 이 작업을 수행해야 한다고 상상해 "
"보세요. 상용구가 너무 많죠, 그렇지않나요?"

#: src/05_ticket_v2/12_thiserror.md:11
msgid ""
"We can remove some of the boilerplate by using [`thiserror`](https://docs.rs/"
"thiserror/latest/thiserror/), a Rust crate that provides a **procedural "
"macro** to simplify the creation of custom error types."
msgstr ""
"커스텀 에러 타입 생성을 단순화하기 위해 **절차적 매크로**를 제공하는 Rust 크레"
"이트인 `thiserror`를 사용하여 상용구 중 일부를 제거할 수 있습니다."

#: src/05_ticket_v2/12_thiserror.md:17 src/05_ticket_v2/12_thiserror.md:19
msgid "\"{0}\""
msgstr "\"{0}\""

#: src/05_ticket_v2/12_thiserror.md:24
msgid "You can write your own macros"
msgstr "매크로를 직접 작성할 수 있습니다"

#: src/05_ticket_v2/12_thiserror.md:26
msgid ""
"All the `derive` macros we've seen so far were provided by the Rust standard "
"library.  \n"
"`thiserror::Error` is the first example of a **third-party** `derive` macro."
msgstr ""
"지금까지 본 모든 `derive` 매크로는 Rust 표준 라이브러리에서 제공되었습니"
"다.  \n"
"`thiserror::Error`는 **타사** `derive` 매크로의 첫 번째 예입니다."

#: src/05_ticket_v2/12_thiserror.md:29
msgid ""
"`derive` macros are a subset of **procedural macros**, a way to generate Rust "
"code at compile time. We won't get into the details of how to write a "
"procedural macro in this course, but it's important to know that you can "
"write your own!  \n"
"A topic to approach in a more advanced Rust course."
msgstr ""
"`derive` 매크로는 컴파일 타임에 Rust 코드를 생성하는 방법인 **절차적 매크로**"
"의 하위 집합입니다. 이 과정에서는 절차적 매크로를 작성하는 방법에 대해 자세히 "
"설명하지 않지만 직접 작성할 수 있다는 점을 아는 것이 중요합니다!  \n"
"좀 더 고급 Rust 코스에서 다뤄볼만한 주제입니다."

#: src/05_ticket_v2/12_thiserror.md:34
msgid "Custom syntax"
msgstr "커스텀 문법"

#: src/05_ticket_v2/12_thiserror.md:36
msgid ""
"Each procedural macro can define its own syntax, which is usually explained "
"in the crate's documentation. In the case of `thiserror`, we have:"
msgstr ""
"각 절차적 매크로는 자체 문법을 정의할 수 있으며 이는 일반적으로 크레이트 문서"
"에 설명되어 있습니다. `thiserror`의 경우 다음과 같습니다:"

#: src/05_ticket_v2/12_thiserror.md:39
msgid ""
"`#[derive(thiserror::Error)]`: this is the syntax to derive the `Error` trait "
"for a custom error type, helped by `thiserror`."
msgstr ""
"`#[derive(thiserror::Error)]`: 이것은 `thiserror`의 도움을 받아 사용자 정의 오"
"류 유형에 대한 `Error` 트레잇을 파생시키는 구문입니다."

#: src/05_ticket_v2/12_thiserror.md:40
msgid ""
"`#[error(\"{0}\")]`: this is the syntax to define a `Display` implementation "
"for each variant of the custom error type. `{0}` is replaced by the zero-th "
"field of the variant (`String`, in this case) when the error is displayed."
msgstr ""
"`#[error(\"{0}\")]`: 이는 커스텀 에러 타입의 각 배리언트에 대해 `Display` 구현"
"을 정의하는 구문입니다. 오류가 표시되면 `{0}`은 배리언트(이 경우 `String`)의 0"
"번째 필드로 대체됩니다."

#: src/05_ticket_v2/12_thiserror.md:45
msgid ""
"The exercise for this section is located in [`05_ticket_v2/12_thiserror`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/12_thiserror)"
msgstr ""
"이 섹션의 예제는 [`05_ticket_v2/12_thiserror`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/12_thiserror)에 있습니다"

#: src/05_ticket_v2/13_try_from.md:1 src/05_ticket_v2/13_try_from.md:10
msgid "`TryFrom` and `TryInto`"
msgstr "`TryFrom`과 `TryInto`"

#: src/05_ticket_v2/13_try_from.md:3
msgid ""
"In the previous chapter we looked at the [`From` and `Into` traits]"
"(../04_traits/09_from.md), Rust's idiomatic interfaces for **infallible** "
"type conversions.  \n"
"But what if the conversion is not guaranteed to succeed?"
msgstr ""
"이전 장에서 우리는 **무결한** 타입 변환을 위한 Rust의 관용적 인터페이스인 "
"[`From`과 `Into` 트레잇](../04_traits/09_from.md)을 살펴보았습니다.  \n"
"하지만 변환 성공이 보장되지 않으면 어떻게 될까요?"

#: src/05_ticket_v2/13_try_from.md:7
msgid ""
"We now know enough about errors to discuss the **fallible** counterparts of "
"`From` and `Into`: `TryFrom` and `TryInto`."
msgstr ""
"이제 우리는 `From`과 `Into`에 해당하는 **오류가 있는** 대응 요소인 `TryFrom`"
"과 `TryInto`를 논의할 만큼 오류에 대해 충분히 알고 있습니다."

#: src/05_ticket_v2/13_try_from.md:12
msgid ""
"Both `TryFrom` and `TryInto` are defined in the `std::convert` module, just "
"like `From` and `Into`."
msgstr ""
"`TryFrom`과 `TryInto`는 `From`과 `Into`처럼 `std::convert` 모듈에 정의됩니다."

#: src/05_ticket_v2/13_try_from.md:26
msgid ""
"The main difference between `From`/`Into` and `TryFrom`/`TryInto` is that the "
"latter return a `Result` type.  \n"
"This allows the conversion to fail, returning an error instead of panicking."
msgstr ""
"`From`/`Into`와 `TryFrom`/`TryInto`의 주요 차이점은 후자가 `Result` 유형을 반"
"환한다는 것입니다.  \n"
"이렇게 하면 변환이 실패했을 때 패닉하는 대신 오류가 반환됩니다."

#: src/05_ticket_v2/13_try_from.md:29
msgid "`Self::Error`"
msgstr "`Self::Error`"

#: src/05_ticket_v2/13_try_from.md:31
msgid ""
"Both `TryFrom` and `TryInto` have an associated `Error` type. This allows "
"each implementation to specify its own error type, ideally the most "
"appropriate for the conversion being attempted."
msgstr ""
"`TryFrom`과 `TryInto` 모두 연관 `Error` 타입이 있습니다. 이를 통해 각 구현은 "
"이상적으로는 시도 중인 변환에 가장 적합한 자체 에러 타입을 지정할 수 있습니다."

#: src/05_ticket_v2/13_try_from.md:35
msgid ""
"`Self::Error` is a way to refer to the `Error` associated type defined in the "
"trait itself."
msgstr ""
"`Self::Error`는 트레잇 자체에 정의된 `Error` 관련 타입을 참조하는 방법입니다."

#: src/05_ticket_v2/13_try_from.md:37
msgid "Duality"
msgstr "이중성"

#: src/05_ticket_v2/13_try_from.md:39
msgid ""
"Just like `From` and `Into`, `TryFrom` and `TryInto` are dual traits.  \n"
"If you implement `TryFrom` for a type, you get `TryInto` for free."
msgstr ""
"`From` 및 `Into`와 마찬가지로 `TryFrom`과 `TryInto`는 이중 트레잇입니다.  \n"
"타입에 대해 `TryFrom`을 구현하면 `TryInto`를 자동으로 얻을 수 있습니다."

#: src/05_ticket_v2/13_try_from.md:44
msgid ""
"The exercise for this section is located in [`05_ticket_v2/13_try_from`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/13_try_from)"
msgstr ""
"이 섹션의 예제는 [`05_ticket_v2/13_try_from`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/13_try_from)에 있습니다"

#: src/05_ticket_v2/14_source.md:3
msgid ""
"There's one more thing we need to talk about to complete our coverage of the "
"`Error` trait: the `source` method."
msgstr ""
"`Error` 트레잇을 완전히 다루기 위해 이야기해야 할 것이 하나 더 있습니다: "
"`source` 메서드입니다."

#: src/05_ticket_v2/14_source.md:6
msgid "// Full definition this time!\n"
msgstr "// 이번에는 완전한 정의!\n"

#: src/05_ticket_v2/14_source.md:14
msgid ""
"The `source` method is a way to access the **error cause**, if any.  \n"
"Errors are often chained, meaning that one error is the cause of another: you "
"have a high-level error (e.g. cannot connect to the database) that is caused "
"by a lower-level error (e.g. can't resolve the database hostname). The "
"`source` method allows you to \"walk\" the full chain of errors, often used "
"when capturing error context in logs."
msgstr ""
"`source` 메서드는 **오류 원인**(있는 경우)에 액세스하는 방법입니다.  \n"
"오류는 흔히 연쇄적으로 발생합니다. 즉, 하나의 오류가 다른 오류의 원인이 된다"
"는 의미입니다. 즉, 낮은 수준의 오류(예: 데이터베이스 호스트 이름을 확인할 수 "
"없음)로 인해 발생한 높은 수준의 오류(예: 데이터베이스에 연결할 수 없음)가 발생"
"한다는 것입니다. `source`메서드를 사용하면 로그에서 에러 컨텍스트를 캡처할 때 "
"자주 사용되는 전체 에러 체인을 `탐색`할 수 있습니다."

#: src/05_ticket_v2/14_source.md:19
msgid "Implementing `source`"
msgstr "`source` 구현"

#: src/05_ticket_v2/14_source.md:21
msgid ""
"The `Error` trait provides a default implementation that always returns "
"`None` (i.e. no underlying cause). That's why you didn't have to care about "
"`source` in the previous exercises.  \n"
"You can override this default implementation to provide a cause for your "
"error type."
msgstr ""
"`Error` 트레잇은 항상 `None`(즉, 근본적인 원인이 없음)을 반환하는 기본 구현을 "
"제공합니다. 그렇기 때문에 이전 연습에서는 `source`에 신경 쓸 필요가 없었습니"
"다.  \n"
"이 기본 구현을 재정의하여 에러 타입의 원인을 제공할 수 있습니다."

#: src/05_ticket_v2/14_source.md:35 src/05_ticket_v2/14_source.md:73
#: src/05_ticket_v2/14_source.md:85 src/05_ticket_v2/14_source.md:99
msgid "\"Failed to connect to the database\""
msgstr "\"Failed to connect to the database\""

#: src/05_ticket_v2/14_source.md:46
msgid ""
"In this example, `DatabaseError` wraps an `std::io::Error` as its source. We "
"then override the `source` method to return this source when called."
msgstr ""
"이 예시에서 `DatabaseError`는 `std::io::Error`를 소스로 래핑합니다. 그런 다음 "
"`source` 메서드를 재정의하여 호출 시 이 소스를 반환합니다."

#: src/05_ticket_v2/14_source.md:49
msgid "`&(dyn Error + 'static)`"
msgstr "`&(dyn Error + 'static)`"

#: src/05_ticket_v2/14_source.md:51
msgid ""
"What's this `&(dyn Error + 'static)` type?  \n"
"Let's unpack it:"
msgstr ""
"이 `&(dyn Error + 'static)` 타입은 무엇인가요?  \n"
"한번 까봅시다:"

#: src/05_ticket_v2/14_source.md:54
msgid ""
"`dyn Error` is a **trait object**. It's a way to refer to any type that "
"implements the `Error` trait."
msgstr ""
"`dyn Error`는 **트레잇 개체**입니다. 이는 `Error` 트레잇을 구현하는 모든 타입"
"을 참조하는 방법입니다."

#: src/05_ticket_v2/14_source.md:55
msgid ""
"`'static` is a special **lifetime specifier**. `'static` implies that the "
"reference is valid for \"as long as we need it\", i.e. the entire program "
"execution."
msgstr ""
"`'static`은 특별한 **수명 지정자**입니다. `'static`은 참조가 \"필요한 한\", "
"즉 전체 프로그램 실행 동안 유효함을 의미합니다."

#: src/05_ticket_v2/14_source.md:58
msgid ""
"Combined: `&(dyn Error + 'static)` is a reference to a trait object that "
"implements the `Error` trait and is valid for the entire program execution."
msgstr ""
"`&(dyn Error + 'static)`의 조합은 `Error` 트레잇을 구현하는 트레잇 개체에 대"
"한 참조이며 전체 프로그램 실행동안에 유효합니다."

#: src/05_ticket_v2/14_source.md:61
msgid ""
"Don't worry too much about either of these concepts for now. We'll cover them "
"in more detail in future chapters."
msgstr ""
"지금은 이러한 개념 중 하나에 대해 너무 걱정하지 마세요. 우리는 이후 장에서 이"
"에 대해 더 자세히 다룰 것입니다."

#: src/05_ticket_v2/14_source.md:63
msgid "Implementing `source` using `thiserror`"
msgstr "`thiserror`를 사용하여 `source` 구현"

#: src/05_ticket_v2/14_source.md:65
msgid ""
"`thiserror` provides three ways to automatically implement `source` for your "
"error types:"
msgstr ""
"`thiserror`는 에러 타입에 대해 `source`를 자동으로 구현하는 세 가지 방법을 제"
"공합니다:"

#: src/05_ticket_v2/14_source.md:67
msgid ""
"A field named `source` will automatically be used as the source of the error."
msgstr "`source`라는 필드가 자동으로 에러 소스로 사용됩니다."

#: src/05_ticket_v2/14_source.md:79
msgid ""
"A field annotated with the `#[source]` attribute will automatically be used "
"as the source of the error."
msgstr ""
"`#[source]` 속성의 어노테이션이 달린 필드는 자동으로 오류 소스로 사용됩니다."

#: src/05_ticket_v2/14_source.md:92
msgid ""
"A field annotated with the `#[from]` attribute will automatically be used as "
"the source of the error **and** `thiserror` will automatically generate a "
"`From` implementation to convert the annotated type into your error type."
msgstr ""
"`#[from]` 속성으로 주석이 달린 필드는 자동으로 오류의 소스로 사용됩니다 **그리"
"고** `thiserror`는 어노테이션이 달린 타입을 에러 타입으로 변환하기 위해 자동으"
"로 `From` 구현을 생성합니다."

#: src/05_ticket_v2/14_source.md:107
msgid "The `?` operator"
msgstr "`?` 연산자"

#: src/05_ticket_v2/14_source.md:109
msgid ""
"The `?` operator is a shorthand for propagating errors.  \n"
"When used in a function that returns a `Result`, it will return early with an "
"error if the `Result` is `Err`."
msgstr ""
"`?` 연산자는 오류 전파를 줄여서 표현한 것입니다.  \n"
"`Result`를 반환하는 함수에 사용될 때 `Result`가 `Err`인 경우 오류와 함께 조기"
"에 반환됩니다."

#: src/05_ticket_v2/14_source.md:118 src/05_ticket_v2/14_source.md:131
msgid "\"file.txt\""
msgstr "\"file.txt\""

#: src/05_ticket_v2/14_source.md:125
msgid "is equivalent to:"
msgstr "다음과 같습니다:"

#: src/05_ticket_v2/14_source.md:148
msgid ""
"You can use the `?` operator to shorten your error handling code "
"significantly.  \n"
"In particular, the `?` operator will automatically convert the error type of "
"the fallible operation into the error type of the function, if a conversion "
"is possible (i.e. if there is a suitable `From` implementation)"
msgstr ""
"`?` 연산자를 사용하면 오류 처리 코드를 대폭 단축할 수 있습니다.  \n"
"특히 `?` 연산자는 변환이 가능한 경우(즉, 적절한 `From` 구현이 있는 경우) 오류"
"가 있는 연산의 에러 타입을 함수의 에러 타입으로 자동 변환합니다."

#: src/05_ticket_v2/14_source.md:154
msgid ""
"The exercise for this section is located in [`05_ticket_v2/14_source`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/14_source)"
msgstr ""
"이 섹션의 예제는 [`05_ticket_v2/14_source`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/14_source)에 있습니다"

#: src/05_ticket_v2/15_outro.md:3
msgid ""
"When it comes to domain modelling, the devil is in the details.  \n"
"Rust offers a wide range of tools to help you represent the constraints of "
"your domain directly in the type system, but it takes some practice to get it "
"right and write code that looks idiomatic."
msgstr ""
"도메인 모델링에 있어서 악마는 디테일에 있습니다.  \n"
"Rust는 타입 시스템에서 도메인의 제약 조건을 직접 표현하는 데 도움이 되는 다양"
"한 도구를 제공하지만 이를 올바르게 구현하고 관용적으로 보이는 코드를 작성하려"
"면 약간의 연습이 필요합니다."

#: src/05_ticket_v2/15_outro.md:7
msgid ""
"Let's close the chapter with one final refinement of our `Ticket` model.  \n"
"We'll introduce a new type for each of the fields in `Ticket` to encapsulate "
"the respective constraints.  \n"
"Every time someone accesses a `Ticket` field, they'll get back a value that's "
"guaranteed to be valid—i.e. a `TicketTitle` instead of a `String`. They won't "
"have to worry about the title being empty elsewhere in the code: as long as "
"they have a `TicketTitle`, they know it's valid **by construction**."
msgstr ""
"`Ticket` 모델을 마지막으로 개선하면서 장을 마무리하겠습니다.  \n"
"각 제약 조건을 캡슐화하기 위해 `Ticket`의 각 필드에 새로운 타입을 도입하겠습니"
"다.  \n"
"누군가 `Ticket` 필드에 액세스할 때마다 유효하다고 보장된 값을 돌려받게 됩니"
"다. `String` 대신 `TicketTitle`. 코드의 다른 곳에서 제목이 비어 있는 것에 대"
"해 걱정할 필요가 없습니다. `TicketTitle`이 있는 한 해당 제목이 **구조상** 유효"
"하다는 것을 알 수 있습니다."

#: src/05_ticket_v2/15_outro.md:13
msgid ""
"This is just an example of how you can use Rust's type system to make your "
"code safer and more expressive."
msgstr ""
"이것은 Rust의 타입 시스템을 사용하여 코드를 더욱 안전하고 표현력 있게 만드는 "
"방법에 대한 예일 뿐입니다."

#: src/05_ticket_v2/15_outro.md:17
msgid ""
"[Parse, don't validate](https://lexi-lambda.github.io/blog/2019/11/05/parse-"
"don-t-validate/)"
msgstr ""
"[Parse, don't validate](https://lexi-lambda.github.io/blog/2019/11/05/parse-"
"don-t-validate/)"

#: src/05_ticket_v2/15_outro.md:18
msgid ""
"[Using types to guarantee domain invariants](https://www.lpalmieri.com/"
"posts/2020-12-11-zero-to-production-6-domain-modelling/)"
msgstr ""
"[Using types to guarantee domain invariants](https://www.lpalmieri.com/"
"posts/2020-12-11-zero-to-production-6-domain-modelling/)"

#: src/05_ticket_v2/15_outro.md:22
msgid ""
"The exercise for this section is located in [`05_ticket_v2/15_outro`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/05_ticket_v2/15_outro)"
msgstr ""
"이 섹션의 예제는 [`05_ticket_v2/15_outro`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/15_outro)에 있습니다"

#: src/06_ticket_management/00_intro.md:1 src/07_threads/00_intro.md:1
msgid "Intro"
msgstr "소개"

#: src/06_ticket_management/00_intro.md:3
msgid ""
"In the previous chapter we modelled `Ticket` in a vacuum: we defined its "
"fields and their constraints, we learned how to best represent them in Rust, "
"but we didn't consider how `Ticket` fits into a larger system. We'll use this "
"chapter to build a simple workflow around `Ticket`, introducing a "
"(rudimentary) management system to store and retrieve tickets."
msgstr ""
"이전 장에서 우리는 `Ticket`을 진공 상태에서 모델링했습니다. 필드와 제약 조건"
"을 정의하고 Rust에서 이를 가장 잘 표현하는 방법을 배웠지만 `Ticket`이 더 큰 시"
"스템에 어떻게 적합한지는 고려하지 않았습니다. 우리는 이 장을 사용하여 티켓을 "
"저장하고 검색하는 (기본) 관리 시스템을 소개하는 `Ticket`에 대한 간단한 작업 흐"
"름을 구축할 것입니다."

#: src/06_ticket_management/00_intro.md:8
msgid ""
"The task will give us an opportunity to explore new Rust concepts, such as:"
msgstr ""
"이 작업은 우리에게 다음과 같은 새로운 Rust 개념을 탐구할 수 있는 기회를 제공"
"할 것입니다:"

#: src/06_ticket_management/00_intro.md:10
msgid "Stack-allocated arrays"
msgstr "스택 할당 배열"

#: src/06_ticket_management/00_intro.md:11
msgid "`Vec`, a growable array type, and slices"
msgstr "확장 가능한 배열 유형인 `Vec`와 슬라이스"

#: src/06_ticket_management/00_intro.md:12
msgid "`Iterator` and `IntoIterator`, for iterating over collections"
msgstr "컬렉션 반복을 위한 `Iterator`와 `IntoIterator`"

#: src/06_ticket_management/00_intro.md:13
msgid "Slices (`&[T]`), to work with parts of a collection"
msgstr "컬렉션의 일부 작업을 위한 슬라이스(`&[T]`)"

#: src/06_ticket_management/00_intro.md:14
msgid "Lifetimes, to describe how long references are valid"
msgstr "참조가 유효한 기간을 설명하기 위한 수명"

#: src/06_ticket_management/00_intro.md:15
msgid "`HashMap` and `BTreeMap`, two key-value data structures"
msgstr "`HashMap`와 `BTreeMap`, 키-값 데이터 구조체"

#: src/06_ticket_management/00_intro.md:16
msgid "`Eq` and `Hash`, to compare keys in a `HashMap`"
msgstr "`HashMap`의 키를 비교하기 위한 `Eq`와 `Hash`"

#: src/06_ticket_management/00_intro.md:17
msgid "`Ord` and `PartialOrd`, to work with a `BTreeMap`"
msgstr "`BTreeMap`과 함께 작동하는 `Ord`와 `PartialOrd`"

#: src/06_ticket_management/00_intro.md:18
msgid "`Index` and `IndexMut`, to access elements in a collection"
msgstr "컬렉션의 요소에 액세스하기 위한 `Index`와 `IndexMut`"

#: src/06_ticket_management/00_intro.md:22
msgid ""
"The exercise for this section is located in [`06_ticket_management/00_intro`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/00_intro)"
msgstr ""
"이 섹션의 예제는 [`06_ticket_management/00_intro`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/00_intro)에 있습니다"

#: src/06_ticket_management/01_arrays.md:3
msgid ""
"As soon as we start talking about \"ticket management\" we need to think "
"about a way to store _multiple_ tickets. In turn, this means we need to think "
"about collections. In particular, homogeneous collections: we want to store "
"multiple instances of the same type."
msgstr ""
"\"티켓 관리\"에 대해 이야기를 시작하자마자 _다중_ 티켓을 저장하는 방법에 대해 "
"생각해야 합니다. 결과적으로 이는 컬렉션에 대해 생각해야 함을 의미합니다. 특"
"히, 동종 컬렉션: 동일한 타입의 여러 인스턴스를 저장하려고 합니다."

#: src/06_ticket_management/01_arrays.md:7
msgid "What does Rust have to offer in this regard?"
msgstr "이와 관련하여 Rust는 무엇을 제공해야 합니까?"

#: src/06_ticket_management/01_arrays.md:11
msgid ""
"A first attempt could be to use an **array**.  \n"
"Arrays in Rust are fixed-size collections of elements of the same type."
msgstr ""
"첫 번째 시도는 **배열**을 사용하는 것일 수 있습니다.  \n"
"Rust의 배열은 동일한 타입의 요소로 구성된 고정 크기 컬렉션입니다."

#: src/06_ticket_management/01_arrays.md:14
msgid "Here's how you can define an array:"
msgstr "배열을 정의하는 방법은 다음과 같습니다:"

#: src/06_ticket_management/01_arrays.md:17
msgid "// Array type syntax: [ <type> ; <number of elements> ]\n"
msgstr "// Array type syntax: [ <type> ; <number of elements> ]\n"

#: src/06_ticket_management/01_arrays.md:21
msgid ""
"This creates an array of 3 integers, initialized with the values `1`, `2`, "
"and `3`.  \n"
"The type of the array is `[u32; 3]`, which reads as \"an array of `u32`s with "
"a length of 3\"."
msgstr ""
"이 코드는 값 `1`, `2`, 그리고 `3`으로 초기화된 정수 3개를 포함하는 배열을 생성"
"합니다.\n"
"이 배열의 타입은 `[u32; 3]`이며, 이는 \"길이가 3인 `u32` 배열\"을 의미합니다."

#: src/06_ticket_management/01_arrays.md:24
#: src/06_ticket_management/02_vec.md:47
msgid "Accessing elements"
msgstr "요소에 접근하기"

#: src/06_ticket_management/01_arrays.md:26
msgid "You can access elements of an array using square brackets:"
msgstr "대괄호를 사용하여 배열 요소에 액세스할 수 있습니다:"

#: src/06_ticket_management/01_arrays.md:34
msgid ""
"The index must be of type `usize`.  \n"
"Arrays are **zero-indexed**, like everything in Rust. You've seen this before "
"with string slices and field indexing in tuples/tuple-like variants."
msgstr ""
"인덱스는 `usize` 타입이어야 합니다.  \n"
"배열은 Rust의 모든 것과 마찬가지로 **제로 인덱스**입니다. 이전에 문자열 조각"
"과 튜플/튜플 유사 배리언트의 필드 인덱싱을 통해 이를 본 적이 있습니다."

#: src/06_ticket_management/01_arrays.md:38
msgid "Out-of-bounds access"
msgstr "범위 밖 접근"

#: src/06_ticket_management/01_arrays.md:40
msgid "If you try to access an element that's out of bounds, Rust will panic:"
msgstr "범위를 벗어난 요소에 접근하려고 하면 Rust는 패닉을 일으킬 것입니다:"

#: src/06_ticket_management/01_arrays.md:44
msgid "// This will panic\n"
msgstr "// 패닉 상태가 됩니다\n"

#: src/06_ticket_management/01_arrays.md:47
msgid ""
"This is enforced at runtime using **bounds checking**. It comes with a small "
"performance overhead, but it's how Rust prevents buffer overflows.  \n"
"In some scenarios the Rust compiler can optimize away bounds checks, "
"especially if iterators are involved—we'll speak more about this later on."
msgstr ""
"이는 **경계 검사**를 사용하여 런타임에 적용됩니다. 약간의 성능 오버헤드가 있지"
"만 Rust가 버퍼 오버플로를 방지하는 방법입니다.  \n"
"일부 시나리오에서는 Rust 컴파일러가 경계 검사를 최적화할 수 있습니다. 특히 반"
"복자가 관련된 경우에는 더욱 그렇습니다. 이에 대해서는 나중에 자세히 설명하겠습"
"니다."

#: src/06_ticket_management/01_arrays.md:52
msgid ""
"If you don't want to panic, you can use the `get` method, which returns an "
"`Option<&T>`:"
msgstr ""
"패닉하지 않으려면 `Option<&T>`를 반환하는 `get` 메서드를 사용할 수 있습니다:"

#: src/06_ticket_management/01_arrays.md:56
#: src/06_ticket_management/02_vec.md:63
msgid ""
"// You get a `None` if you try to access an out-of-bounds index\n"
"// rather than a panic.\n"
msgstr ""
"// 범위를 벗어난 인덱스에 액세스하려고 하면\n"
"// 패닉이 아닌 `None`이 반환됩니다.\n"

#: src/06_ticket_management/01_arrays.md:64
msgid ""
"Since the size of an array is known at compile-time, the compiler can "
"allocate the array on the stack. If you run the following code:"
msgstr ""
"배열의 크기는 컴파일 타임에 알려지기 때문에 컴파일러는 배열을 스택에 할당할 "
"수 있습니다. 다음 코드를 실행하면:"

#: src/06_ticket_management/01_arrays.md:71
msgid "You'll get the following memory layout:"
msgstr "메모리 레이아웃은 다음과 같이 됩니다:"

#: src/06_ticket_management/01_arrays.md:79
msgid ""
"In other words, the size of an array is `std::mem::size_of::<T>() * N`, where "
"`T` is the type of the elements and `N` is the number of elements.  \n"
"You can access and replace each element in `O(1)` time."
msgstr ""
"즉, 배열의 크기는 `std::mem::size_of::<T>() * N`입니다. 여기서 `T`는 요소의 타"
"입이고 `N`은 요소의 수입니다.  \n"
"`O(1)` 시간 안에 각 요소에 액세스하고 교체할 수 있습니다."

#: src/06_ticket_management/01_arrays.md:85
msgid ""
"The exercise for this section is located in [`06_ticket_management/01_arrays`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/01_arrays)"
msgstr ""
"이 섹션의 예제는 [`06_ticket_management/01_arrays`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/01_arrays)에 있습니다"

#: src/06_ticket_management/02_vec.md:3
msgid ""
"Arrays' strength is also their weakness: their size must be known upfront, at "
"compile-time. If you try to create an array with a size that's only known at "
"runtime, you'll get a compilation error:"
msgstr ""
"배열의 장점은 약점이기도 합니다. 배열의 크기는 컴파일 타임에 미리 알려야 합니"
"다. 런타임에만 알려진 크기의 배열을 만들려고 하면 컴파일 오류가 발생합니다:"

#: src/06_ticket_management/02_vec.md:20
msgid ""
"Arrays wouldn't work for our ticket management system—we don't know how many "
"tickets we'll need to store at compile-time. This is where `Vec` comes in."
msgstr ""
"배열은 티켓 관리 시스템에서 작동하지 않습니다. 컴파일 타임에 얼마나 많은 티켓"
"을 저장해야 하는지 알 수 없습니다. 여기가 `Vec`이 필요한 시점입니다."

#: src/06_ticket_management/02_vec.md:23
msgid "`Vec`"
msgstr "`Vec`"

#: src/06_ticket_management/02_vec.md:25
msgid ""
"`Vec` is a growable array type, provided by the standard library.  \n"
"You can create an empty array using the `Vec::new` function:"
msgstr ""
"`Vec`은 표준 라이브러리에서 제공하는 확장 가능한 배열 타입입니다.  \n"
"`Vec::new` 함수를 사용하여 빈 배열을 만들 수 있습니다:"

#: src/06_ticket_management/02_vec.md:32
msgid "You would then push elements into the vector using the `push` method:"
msgstr "그런 다음 `push` 메서드를 사용하여 요소를 벡터에 밀어 넣습니다:"

#: src/06_ticket_management/02_vec.md:40
msgid ""
"New values are added to the end of the vector.  \n"
"You can also create an initialized vector using the `vec!` macro, if you know "
"the values at creation time:"
msgstr ""
"벡터 끝에 새 값이 추가됩니다.  \n"
"생성 시 값을 알고 있는 경우 `vec!` 매크로를 사용하여 초기화된 벡터를 생성할 수"
"도 있습니다:"

#: src/06_ticket_management/02_vec.md:49
msgid "The syntax for accessing elements is the same as with arrays:"
msgstr "요소에 액세스하는 구문은 배열과 동일합니다:"

#: src/06_ticket_management/02_vec.md:58
msgid ""
"The index must be of type `usize`.  \n"
"You can also use the `get` method, which returns an `Option<&T>`:"
msgstr ""
"인덱스는 `usize` 타입이어야 합니다.  \n"
"`Option<&T>`를 반환하는 `get` 메서드를 사용할 수도 있습니다:"

#: src/06_ticket_management/02_vec.md:69
msgid ""
"Access is bounds-checked, just like element access with arrays. It has O(1) "
"complexity."
msgstr ""
"배열을 사용한 요소 액세스와 마찬가지로 액세스 범위가 검사됩니다. O(1) 복잡도"
"를 갖습니다."

#: src/06_ticket_management/02_vec.md:73
msgid ""
"`Vec` is a heap-allocated data structure.  \n"
"When you create a `Vec`, it allocates memory on the heap to store the "
"elements."
msgstr ""
"`Vec`은 힙에 할당된 데이터 구조입니다.  \n"
"`Vec`을 생성하면 요소를 저장하기 위해 힙에 메모리를 할당합니다."

#: src/06_ticket_management/02_vec.md:76
msgid "If you run the following code:"
msgstr "다음 코드를 실행하면:"

#: src/06_ticket_management/02_vec.md:84
msgid "you'll get the following memory layout:"
msgstr "메모리 레이아웃은 다음과 같습니다:"

#: src/06_ticket_management/02_vec.md:99
msgid "`Vec` keeps track of three things:"
msgstr "`Vec`은 세 가지를 추적합니다:"

#: src/06_ticket_management/02_vec.md:102
msgid "The **length** of the vector, i.e. how many elements are in the vector."
msgstr "벡터의 **길이**, 즉 벡터에 포함된 요소 수."

#: src/06_ticket_management/02_vec.md:103
msgid ""
"The **capacity** of the vector, i.e. the number of elements that can fit in "
"the space reserved on the heap."
msgstr "벡터의 **용량**, 즉 힙에 예약된 공간에 들어갈 수 있는 요소의 수."

#: src/06_ticket_management/02_vec.md:105
msgid ""
"This layout should look familiar: it's exactly the same as `String`!  \n"
"That's not a coincidence: `String` is defined as a vector of bytes, "
"`Vec<u8>`, under the hood:"
msgstr ""
"이 레이아웃은 친숙해 보일 것입니다. `String`과 정확히 동일합니다!  \n"
"이는 우연이 아닙니다. `String`은 내부적으로 바이트 벡터 `Vec<u8>`로 정의됩니"
"다:"

#: src/06_ticket_management/02_vec.md:116
msgid ""
"The exercise for this section is located in [`06_ticket_management/02_vec`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/02_vec)"
msgstr ""
"이 섹션의 예제는 [`06_ticket_management/02_vec`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/02_vec)에 있습니다"

#: src/06_ticket_management/03_resizing.md:3
msgid ""
"We said that `Vec` is a \"growable\" vector type, but what does that mean? "
"What happens if you try to insert an element into a `Vec` that's already at "
"maximum capacity?"
msgstr ""
"우리는 `Vec`이 \"늘어날 수 있는\" 벡터 타입이라고 말했는데, 그게 무슨 뜻일까"
"요? 이미 최대 용량에 도달한 `Vec`에 요소를 삽입하려고 하면 어떻게 될까요?"

#: src/06_ticket_management/03_resizing.md:10
msgid "// Max capacity reached\n"
msgstr "// 최대 용량 도달\n"

#: src/06_ticket_management/03_resizing.md:11
msgid "// What happens here?\n"
msgstr "// 여기서는 어떻게 될까요?\n"

#: src/06_ticket_management/03_resizing.md:14
msgid ""
"The `Vec` will **resize** itself.  \n"
"It will ask the allocator for a new (larger) chunk of heap memory, copy the "
"elements over, and deallocate the old memory."
msgstr ""
"`Vec`은 자체적으로 **크기 조정**됩니다.  \n"
"할당자에게 새로운(더 큰) 힙 메모리 청크를 요청하고 요소를 복사한 다음 이전 메"
"모리 할당을 취소합니다."

#: src/06_ticket_management/03_resizing.md:17
msgid ""
"This operation can be expensive, as it involves a new memory allocation and "
"copying all existing elements."
msgstr ""
"이 작업에는 새로운 메모리 할당과 모든 기존 요소 복사가 포함되므로 비용이 많이 "
"들 수 있습니다."

#: src/06_ticket_management/03_resizing.md:19
msgid "`Vec::with_capacity`"
msgstr "`Vec::with_capacity`"

#: src/06_ticket_management/03_resizing.md:21
msgid ""
"If you have a rough idea of how many elements you'll store in a `Vec`, you "
"can use the `Vec::with_capacity` method to pre-allocate enough memory "
"upfront.  \n"
"This can avoid a new allocation when the `Vec` grows, but it may waste memory "
"if you overestimate actual usage."
msgstr ""
"`Vec`에 저장할 요소 수를 대략적으로 알고 있다면 `Vec::with_capacity` 메서드를 "
"사용하여 충분한 메모리를 미리 할당할 수 있습니다.  \n"
"이렇게 하면 `Vec`이 커질 때 새로운 할당을 피할 수 있지만 실제 사용량을 과대평"
"가하면 메모리가 낭비될 수 있습니다."

#: src/06_ticket_management/03_resizing.md:25
msgid "Evaluate on a case-by-case basis."
msgstr "상황에 맞게 사용하세요."

#: src/06_ticket_management/03_resizing.md:29
msgid ""
"The exercise for this section is located in "
"[`06_ticket_management/03_resizing`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/06_ticket_management/03_resizing)"
msgstr ""
"이 섹션의 예제는 [`06_ticket_management/03_resizing`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/03_resizing)에 있습니다"

#: src/06_ticket_management/04_iterators.md:1
msgid "Iteration"
msgstr "반복"

#: src/06_ticket_management/04_iterators.md:3
msgid ""
"During the very first exercises, you learned that Rust lets you iterate over "
"collections using `for` loops. We were looking at ranges at that point (e.g. "
"`0..5`), but the same holds true for collections like arrays and vectors."
msgstr ""
"첫 번째 예제에서 Rust를 사용하면 `for` 루프를 사용하여 컬렉션을 반복할 수 있다"
"는 것을 배웠습니다. 우리는 그 시점에서 범위(예: `0..5`)를 다루고 있었지만 배열"
"이나 벡터와 같은 컬렉션에도 마찬가지입니다."

#: src/06_ticket_management/04_iterators.md:7
msgid "// It works for `Vec`s\n"
msgstr "// `Vec`에서도 작동합니다\n"

#: src/06_ticket_management/04_iterators.md:12
msgid "// It also works for arrays\n"
msgstr "// 배열에서도 작동합니다\n"

#: src/06_ticket_management/04_iterators.md:20
msgid "It's time to understand how this works under the hood."
msgstr "이제 이것이 내부적으로 어떻게 작동하는지 이해할 시간입니다."

#: src/06_ticket_management/04_iterators.md:22
msgid "`for` desugaring"
msgstr "`for` 디슈가링"

#: src/06_ticket_management/04_iterators.md:24
msgid ""
"Every time you write a `for` loop in Rust, the compiler _desugars_ it into "
"the following code:"
msgstr ""
"Rust에서 `for` 루프를 작성할 때마다 컴파일러는 이를 다음 코드처럼 _디슈가링_합"
"니다:"

#: src/06_ticket_management/04_iterators.md:38
msgid ""
"`loop` is another looping construct, on top of `for` and `while`.  \n"
"A `loop` block will run forever, unless you explicitly `break` out of it."
msgstr ""
"`loop`는 `for`와 `while` 위에 있는 또 다른 반복 구조입니다.  \n"
"`loop` 블록은 명시적으로 `break`하지 않는 한 영원히 실행됩니다."

#: src/06_ticket_management/04_iterators.md:41
msgid "`Iterator` trait"
msgstr "`Iterator` 트레잇"

#: src/06_ticket_management/04_iterators.md:43
msgid ""
"The `next` method in the previous code snippet comes from the `Iterator` "
"trait. The `Iterator` trait is defined in Rust's standard library and "
"provides a shared interface for types that can produce a sequence of values:"
msgstr ""
"이전 코드 조각의 `next` 메서드는 `Iterator` 트레잇에서 나왔습니다. `Iterator` "
"트레잇은 Rust의 표준 라이브러리에 정의되어 있으며일련의 값을 생성할 수 있는 타"
"입에 대한 공유 인터페이스를 제공합니다:"

#: src/06_ticket_management/04_iterators.md:54
msgid ""
"The `Item` associated type specifies the type of the values produced by the "
"iterator."
msgstr "`Item` 관련 타입은 반복자가 생성하는 값의 타입을 지정합니다."

#: src/06_ticket_management/04_iterators.md:56
msgid ""
"`next` returns the next value in the sequence.  \n"
"It returns `Some(value)` if there's a value to return, and `None` when there "
"isn't."
msgstr ""
"`next`는 시퀀스의 다음 값을 반환합니다.  \n"
"반환할 값이 있으면 `Some(value)`를 반환하고, 없으면 `None`을 반환합니다."

#: src/06_ticket_management/04_iterators.md:59
msgid ""
"Be careful: there is no guarantee that an iterator is exhausted when it "
"returns `None`. That's only guaranteed if the iterator implements the (more "
"restrictive) [`FusedIterator`](https://doc.rust-lang.org/std/iter/trait."
"FusedIterator.html) trait."
msgstr ""
"주의하세요: `None`을 반환할 때 반복자가 소진된다는 보장은 없습니다. 이는 반복"
"자가 (더 제한적인) [`FusedIterator`](https://doc.rust-lang.org/std/iter/trait."
"FusedIterator.html) 트레잇을 구현하는 경우에만 보장됩니다."

#: src/06_ticket_management/04_iterators.md:63
msgid "`IntoIterator` trait"
msgstr "`IntoIterator` 트레잇"

#: src/06_ticket_management/04_iterators.md:65
msgid ""
"Not all types implement `Iterator`, but many can be converted into a type "
"that does.  \n"
"That's where the `IntoIterator` trait comes in:"
msgstr ""
"모든 타입이 `Iterator`를 구현하는 것은 아니지만 많은 타입이 이를 구현하는 타입"
"으로 변환될 수 있습니다.  \n"
"여기가 `IntoIterator` 트레잇이 필요한 시점입니다:"

#: src/06_ticket_management/04_iterators.md:76
msgid ""
"The `into_iter` method consumes the original value and returns an iterator "
"over its elements.  \n"
"A type can only have one implementation of `IntoIterator`: there can be no "
"ambiguity as to what `for` should desugar to."
msgstr ""
"`into_iter` 메서드는 원래 값을 사용하고 해당 요소에 대한 반복자를 반환합니"
"다.  \n"
"타입은 `IntoIterator`의 구현을 하나만 가질 수 있습니다. `for`가 무엇을 디슈가"
"링 하는지에 대한 모호성은 없습니다."

#: src/06_ticket_management/04_iterators.md:79
msgid ""
"One detail: every type that implements `Iterator` automatically implements "
"`IntoIterator` as well. They just return themselves from `into_iter`!"
msgstr ""
"한 가지 세부 사항: `Iterator`를 구현하는 모든 타입은 자동으로 `IntoIterator`"
"도 구현합니다. 그들은 단지 `into_iter`에서 스스로 돌아옵니다!"

#: src/06_ticket_management/04_iterators.md:82
msgid "Bounds checks"
msgstr "경계 확인"

#: src/06_ticket_management/04_iterators.md:84
msgid ""
"Iterating over iterators has a nice side effect: you can't go out of bounds, "
"by design.  \n"
"This allows Rust to remove bounds checks from the generated machine code, "
"making iteration faster."
msgstr ""
"반복자를 반복하면 좋은 부작용이 있습니다. 설계상 범위를 벗어날 수 없습니"
"다.  \n"
"이를 통해 Rust는 생성된 기계어 코드에서 경계 검사를 제거하여 반복 작업을 더 빠"
"르게 할 수 있습니다."

#: src/06_ticket_management/04_iterators.md:87
msgid "In other words,"
msgstr "다시 말해서,"

#: src/06_ticket_management/04_iterators.md:96
msgid "is usually faster than"
msgstr "위 코드가 일반적으로 다음보다 빠릅니다"

#: src/06_ticket_management/04_iterators.md:105
msgid ""
"There are exceptions to this rule: the compiler can sometimes prove that "
"you're not going out of bounds even with manual indexing, thus removing the "
"bounds checks anyway. But in general, prefer iteration to indexing where "
"possible."
msgstr ""
"이 규칙에는 예외가 있습니다. 컴파일러는 때때로 수동 인덱싱을 사용해도 범위를 "
"벗어나지 않는다는 것을 증명하여 어쨌든 범위 검사를 제거할 수 있습니다. 그러나 "
"일반적으로 가능한 경우 인덱싱보다 반복을 선호합니다."

#: src/06_ticket_management/04_iterators.md:111
msgid ""
"The exercise for this section is located in "
"[`06_ticket_management/04_iterators`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/06_ticket_management/04_iterators)"
msgstr ""
"이 섹션의 예제는 [`06_ticket_management/04_iterators`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/04_iterators)에 있습니다"

#: src/06_ticket_management/05_iter.md:1
msgid "`.iter()`"
msgstr "`.iter()`"

#: src/06_ticket_management/05_iter.md:3
msgid "`IntoIterator` **consumes** `self` to create an iterator."
msgstr "`IntoIterator` **는 `self`를 사용하여 반복자를 생성합니다."

#: src/06_ticket_management/05_iter.md:5
msgid ""
"This has its benefits: you get **owned** values from the iterator. For "
"example: if you call `.into_iter()` on a `Vec<Ticket>` you'll get an iterator "
"that returns `Ticket` values."
msgstr ""
"여기에는 장점이 있습니다. 반복자에서 **소유** 값을 얻습니다. 예를 들어, "
"`Vec<Ticket>`에서 `.into_iter()`를 호출하면 `Ticket` 값을 반환하는 반복자를 얻"
"게 됩니다."

#: src/06_ticket_management/05_iter.md:8
msgid ""
"That's also its downside: you can no longer use the original collection after "
"calling `.into_iter()` on it. Quite often you want to iterate over a "
"collection without consuming it, looking at **references** to the values "
"instead. In the case of `Vec<Ticket>`, you'd want to iterate over `&Ticket` "
"values."
msgstr ""
"그것은 또한 단점이기도 합니다. `.into_iter()`를 호출한 후에는 더 이상 원본 컬"
"렉션을 사용할 수 없습니다. 컬렉션을 사용하지 않고 컬렉션을 반복하고 대신 값에 "
"대한 **참조**를 살펴보고 싶은 경우가 많습니다. `Vec<Ticket>`의 경우 `&Ticket` "
"값을 반복하고 싶을 것입니다."

#: src/06_ticket_management/05_iter.md:12
msgid ""
"Most collections expose a method called `.iter()` that returns an iterator "
"over references to the collection's elements. For example:"
msgstr ""
"대부분의 컬렉션은 컬렉션 요소에 대한 참조에 대한 반복자를 반환하는 `.iter()`라"
"는 메서드를 노출합니다. 예시:"

#: src/06_ticket_management/05_iter.md:16
msgid "// `n` has type `&u32` here\n"
msgstr "// `n`에는 `&u32` 타입이 있습니다.\n"

#: src/06_ticket_management/05_iter.md:23
msgid ""
"This pattern can be simplified by implementing `IntoIterator` for a "
"**reference to the collection**. In our example above, that would be "
"`&Vec<Ticket>`.  \n"
"The standard library does this, that's why the following code works:"
msgstr ""
"이 패턴은 **컬렉션에 대한 참조**에 대해 `IntoIterator`를 구현하여 단순화할 수 "
"있습니다. 위의 예에서는 `&Vec<Ticket>`이 됩니다.  \n"
"표준 라이브러리가 이를 수행하므로 다음 코드가 작동합니다:"

#: src/06_ticket_management/05_iter.md:28
msgid ""
"// `n` has type `&u32` here\n"
"// We didn't have to call `.iter()` explicitly\n"
"// It was enough to use `&numbers` in the `for` loop\n"
msgstr ""
"// 여기서 `n`에는 `&u32` 타입이 있습니다.\n"
"// 명시적으로 `.iter()`를 호출할 필요는 없습니다\n"
"// `for` 루프에서 `&numbers`를 사용하면 충분합니다\n"

#: src/06_ticket_management/05_iter.md:37
msgid "It's idiomatic to provide both options:"
msgstr "두 가지 옵션을 모두 제공하는 것이 관용적입니다:"

#: src/06_ticket_management/05_iter.md:39
msgid "An implementation of `IntoIterator` for a reference to the collection."
msgstr "컬렉션에 대한 참조를 위한 `IntoIterator` 구현."

#: src/06_ticket_management/05_iter.md:40
msgid ""
"An `.iter()` method that returns an iterator over references to the "
"collection's elements."
msgstr "컬렉션의 요소에 대한 참조에 대한 반복자를 반환하는 `.iter()` 메서드."

#: src/06_ticket_management/05_iter.md:42
msgid ""
"The former is convenient in `for` loops, the latter is more explicit and can "
"be used in other contexts."
msgstr ""
"전자는 `for` 루프에서 편리하고, 후자는 더 명시적이며 다른 컨텍스트에서 사용될 "
"수 있습니다."

#: src/06_ticket_management/05_iter.md:46
msgid ""
"The exercise for this section is located in [`06_ticket_management/05_iter`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/05_iter)"
msgstr ""
"이 섹션의 예제는 [`06_ticket_management/05_iter`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/05_iter)에 있습니다"

#: src/06_ticket_management/06_lifetimes.md:3
msgid ""
"Let's try to complete the previous exercise by adding an implementation of "
"`IntoIterator` for `&TicketStore`, for maximum convenience in `for` loops."
msgstr ""
"`for` 루프의 편의성을 극대화하기 위해 `&TicketStore`에 대한 `IntoIterator` 구"
"현을 추가하여 이전 예제를 완료해 보겠습니다."

#: src/06_ticket_management/06_lifetimes.md:6
msgid ""
"Let's start by filling in the most \"obvious\" parts of the implementation:"
msgstr "구현의 가장 \"명확한\" 부분을 채우는 것부터 시작해 보겠습니다:"

#: src/06_ticket_management/06_lifetimes.md:11
msgid "// What goes here?\n"
msgstr "// 여기에 무엇이 들어갈까요?\n"

#: src/06_ticket_management/06_lifetimes.md:19
msgid ""
"What should `type IntoIter` be set to?  \n"
"Intuitively, it should be the type returned by `self.tickets.iter()`, i.e. "
"the type returned by `Vec::iter()`.  \n"
"If you check the standard library documentation, you'll find that `Vec::"
"iter()` returns an `std::slice::Iter`. The definition of `Iter` is:"
msgstr ""
"`type IntoIter`는 무엇으로 설정되어야 할까요?  \n"
"직관적으로 이것은 `self.tickets.iter()`에 의해 반환된 타입, 즉 `Vec::iter()`"
"에 의해 반환된 타입이어야 합니다.  \n"
"표준 라이브러리 문서를 확인하면 `Vec::iter()`가 `std::slice::Iter`를 반환한다"
"는 것을 알 수 있습니다. Iter의 정의는 다음과 같습니다:"

#: src/06_ticket_management/06_lifetimes.md:25
#: src/06_ticket_management/08_impl_trait.md:25
msgid "/* fields omitted */"
msgstr "/* 필드 생략 */"

#: src/06_ticket_management/06_lifetimes.md:28
msgid "`'a` is a **lifetime parameter**."
msgstr "``a`는 **수명 매개변수**입니다."

#: src/06_ticket_management/06_lifetimes.md:30
msgid "Lifetime parameters"
msgstr "수명 매개변수"

#: src/06_ticket_management/06_lifetimes.md:32
msgid ""
"Lifetimes are **labels** used by the Rust compiler to keep track of how long "
"a reference (either mutable or immutable) is valid.  \n"
"The lifetime of a reference is constrained by the scope of the value it "
"refers to. Rust always makes sure, at compile-time, that references are not "
"used after the value they refer to has been dropped, to avoid dangling "
"pointers and use-after-free bugs."
msgstr ""
"수명은 참조(변경 가능 또는 불변)가 얼마나 오랫동안 유효한지 추적하기 위해 "
"Rust 컴파일러에서 사용하는 **레이블**입니다.  \n"
"참조의 수명은 참조하는 값의 범위에 따라 제한됩니다. Rust는 댕글링 포인터와 "
"use-after-free 버그를 피하기 위해 컴파일 타임에 참조가 참조하는 값이 삭제된 후"
"에 참조가 사용되지 않도록 항상 확인합니다."

#: src/06_ticket_management/06_lifetimes.md:37
msgid ""
"This should sound familiar: we've already seen these concepts in action when "
"we discussed ownership and borrowing. Lifetimes are just a way to **name** "
"how long a specific reference is valid."
msgstr ""
"이는 친숙하게 들릴 것입니다. 우리는 소유권과 차용에 대해 논의할 때 이미 이러"
"한 개념이 실제로 실행되는 것을 보았습니다. 수명은 특정 참조가 유효한 기간을 **"
"명칭**하는 방법일 뿐입니다."

#: src/06_ticket_management/06_lifetimes.md:40
msgid ""
"Naming becomes important when you have multiple references and you need to "
"clarify how they **relate to each other**. Let's look at the signature of "
"`Vec::iter()`:"
msgstr ""
"여러 참조가 있고 해당 참조가 **서로 관련**되는 방식을 명확히 해야 할 때 이름 "
"지정이 중요해집니다. `Vec::iter()`의 시그니처를 살펴보겠습니다:"

#: src/06_ticket_management/06_lifetimes.md:45
#: src/06_ticket_management/13_index.md:20
#: src/06_ticket_management/14_index_mut.md:11
#: src/06_ticket_management/15_hashmap.md:34
msgid "// Slightly simplified\n"
msgstr "// 약간 단순화됨\n"

#: src/06_ticket_management/06_lifetimes.md:52
msgid ""
"`Vec::iter()` is generic over a lifetime parameter, named `'a`.  \n"
"`'a` is used to **tie together** the lifetime of the `Vec` and the lifetime "
"of the `Iter` returned by `iter()`. In plain English: the `Iter` returned by "
"`iter()` cannot outlive the `Vec` reference (`&self`) it was created from."
msgstr ""
"`Vec::iter()`는 `'a`라는 이름의 수명 매개변수로 일반화됩니다.  \n"
"`'a`는 `Vec`의 수명과 `iter()`에 의해 반환된 `Iter`의 수명을 **연결**하는 데 "
"사용됩니다. 사람 말로 말하면, `iter()`에 의해 반환된 `Iter`는 그것이 생성된 "
"`Vec` 참조(`&self`)보다 오래 살아있을 수 없습니다."

#: src/06_ticket_management/06_lifetimes.md:56
msgid ""
"This is important because `Vec::iter`, as we discussed, returns an iterator "
"over **references** to the `Vec`'s elements. If the `Vec` is dropped, the "
"references returned by the iterator would be invalid. Rust must make sure "
"this doesn't happen, and lifetimes are the tool it uses to enforce this rule."
msgstr ""
"이는 우리가 논의한 것처럼 `Vec::iter`가 `Vec` 요소에 대한 **참조**에 대한 반복"
"자를 반환하기 때문에 중요합니다. `Vec`가 삭제되면 반복자가 반환한 참조가 유효"
"하지 않게 됩니다. Rust는 이런 일이 발생하지 않도록 해야 하며 수명은 이 규칙을 "
"시행하는 데 사용하는 도구입니다."

#: src/06_ticket_management/06_lifetimes.md:60
msgid "Lifetime elision"
msgstr "수명 제거"

#: src/06_ticket_management/06_lifetimes.md:62
msgid ""
"Rust has a set of rules, called **lifetime elision rules**, that allow you to "
"omit explicit lifetime annotations in many cases. For example, `Vec::iter`'s "
"definition looks like this in `std`'s source code:"
msgstr ""
"Rust에는 **수명 제거 규칙**이라는 일련의 규칙이 있는데, 이를 통해 많은 경우에 "
"명시적인 수명 어노테이션을 생략할 수 있습니다. 예를 들어, `Vec::iter`의 정의"
"는 `std`의 소스 코드에서 다음과 같습니다:"

#: src/06_ticket_management/06_lifetimes.md:73
msgid ""
"No explicit lifetime parameter is present in the signature of `Vec::iter()`. "
"Elision rules imply that the lifetime of the `Iter` returned by `iter()` is "
"tied to the lifetime of the `&self` reference. You can think of `'_` as a "
"**placeholder** for the lifetime of the `&self` reference."
msgstr ""
"`Vec::iter()`의 시그니처에는 명시적인 수명 매개변수가 없습니다. 제거 규칙은 "
"`iter()`에 의해 반환된 `Iter`의 수명이 `&self` 참조의 수명과 연결되어 있음을 "
"의미합니다. `'_`는 `&self` 참조의 수명 동안 **플레이스 홀더**로 생각하면 됩니"
"다."

#: src/06_ticket_management/06_lifetimes.md:77
msgid ""
"See the [References](#references) section for a link to the official "
"documentation on lifetime elision.  \n"
"In most cases, you can rely on the compiler telling you when you need to add "
"explicit lifetime annotations."
msgstr ""
"수명 제거에 대한 공식 문서 링크는 [참조](#참조) 섹션을 참조하세요.  \n"
"대부분의 경우 컴파일러가 명시적인 수명 어노테이션을 추가해야 할 때를 알려주기"
"때문에 컴파일러를 믿으면 됩니다."

#: src/06_ticket_management/06_lifetimes.md:82
msgid ""
"[std::vec::Vec::iter](https://doc.rust-lang.org/std/vec/struct.Vec."
"html#method.iter)"
msgstr ""
"[std::vec::Vec::iter](https://doc.rust-lang.org/std/vec/struct.Vec."
"html#method.iter)"

#: src/06_ticket_management/06_lifetimes.md:83
msgid "[std::slice::Iter](https://doc.rust-lang.org/std/slice/struct.Iter.html)"
msgstr ""
"[std::slice::Iter](https://doc.rust-lang.org/std/slice/struct.Iter.html)"

#: src/06_ticket_management/06_lifetimes.md:84
msgid ""
"[Lifetime elision rules](https://doc.rust-lang.org/reference/lifetime-elision."
"html)"
msgstr ""
"[Lifetime elision rules](https://doc.rust-lang.org/reference/lifetime-elision."
"html)"

#: src/06_ticket_management/06_lifetimes.md:88
msgid ""
"The exercise for this section is located in "
"[`06_ticket_management/06_lifetimes`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/06_ticket_management/06_lifetimes)"
msgstr ""
"이 섹션의 예제는 [`06_ticket_management/06_lifetimes`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/06_lifetimes)에 있습니다"

#: src/06_ticket_management/07_combinators.md:3
msgid ""
"Iterators can do so much more than `for` loops!  \n"
"If you look at the documentation for the `Iterator` trait, you'll find a "
"**vast** collections of methods that you can leverage to transform, filter, "
"and combine iterators in various ways."
msgstr ""
"반복자는 `for` 루프보다 훨씬 더 많은 일을 할 수 있습니다!  \n"
"`Iterator` 트레잇에 대한 문서를 보면 다양한 방법으로 반복자를 변환, 필터링 및 "
"결합하는 데 활용할 수 있는 **광범위한** 메서드 컬렉션을 찾을 수 있습니다."

#: src/06_ticket_management/07_combinators.md:7
msgid "Let's mention the most common ones:"
msgstr "가장 일반적인 것을 언급 해 보겠습니다:"

#: src/06_ticket_management/07_combinators.md:9
msgid "`map` applies a function to each element of the iterator."
msgstr "`map`은 반복자의 각 요소에 함수를 적용합니다."

#: src/06_ticket_management/07_combinators.md:10
msgid "`filter` keeps only the elements that satisfy a predicate."
msgstr "`filter`는 조건자를 만족하는 요소만 유지합니다."

#: src/06_ticket_management/07_combinators.md:11
msgid "`filter_map` combines `filter` and `map` in one step."
msgstr "`filter_map`은 `filter`와 `map`을 한 단계로 결합합니다."

#: src/06_ticket_management/07_combinators.md:12
msgid ""
"`cloned` converts an iterator of references into an iterator of values, "
"cloning each element."
msgstr "'cloned'는 참조 반복자를 값 반복자로 변환하여 각 요소를 복제합니다."

#: src/06_ticket_management/07_combinators.md:13
msgid "`enumerate` returns a new iterator that yields `(index, value)` pairs."
msgstr ""
"`enumerate`는 `(index, value)` 쌍을 생성하는 새로운 반복자를 반환합니다."

#: src/06_ticket_management/07_combinators.md:14
msgid "`skip` skips the first `n` elements of the iterator."
msgstr "`skip`은 반복자의 처음 `n`개의 요소를 건너뜁니다."

#: src/06_ticket_management/07_combinators.md:15
msgid "`take` stops the iterator after `n` elements."
msgstr "`take`는 `n`개의 요소 다음에 반복자를 중지시킵니다."

#: src/06_ticket_management/07_combinators.md:16
msgid "`chain` combines two iterators into one."
msgstr "`chain`은 두 개의 반복자를 하나로 결합합니다."

#: src/06_ticket_management/07_combinators.md:18
msgid ""
"These methods are called **combinators**.  \n"
"They are usually **chained** together to create complex transformations in a "
"concise and readable way:"
msgstr ""
"이러한 메서드를 **결합자**라고 합니다.  \n"
"일반적으로 간결하고 읽기 쉬운 방식으로 복잡한 변환을 생성하기 위해 함께 **체인"
"**됩니다:"

#: src/06_ticket_management/07_combinators.md:22
msgid "// The sum of the squares of the even numbers\n"
msgstr "// 짝수의 제곱의 합\n"

#: src/06_ticket_management/07_combinators.md:30
msgid "Closures"
msgstr "클로저"

#: src/06_ticket_management/07_combinators.md:32
msgid ""
"What's going on with the `filter` and `map` methods above?  \n"
"They take **closures** as arguments."
msgstr ""
"위의 `filter` 및 `map` 메소드에서는 무슨 일이 일어나고 있을까요?  \n"
"그들은 **클로저**를 인수로 사용합니다."

#: src/06_ticket_management/07_combinators.md:35
msgid ""
"Closures are **anonymous functions**, i.e. functions that are not defined "
"using the `fn` syntax we are used to.  \n"
"They are defined using the `|args| body` syntax, where `args` are the "
"arguments and `body` is the function body. `body` can be a block of code or a "
"single expression. For example:"
msgstr ""
"클로저는 **익명 함수**, 즉 우리에게 익숙한 `fn` 구문을 사용하여 정의되지 않은 "
"함수입니다.  \n"
"`|args| body`를 사용하여 정의됩니다. 여기서 `args`는 인수이고 `body`는 함수 본"
"문입니다. `body`는 코드 블록이거나 단일 표현식일 수 있습니다. 예시:"

#: src/06_ticket_management/07_combinators.md:41
msgid "// An anonymous function that adds 1 to its argument\n"
msgstr "// 인수에 1을 더하는 익명 함수\n"

#: src/06_ticket_management/07_combinators.md:42
msgid "// Could be written with a block too:\n"
msgstr "// 블록으로도 작성할 수 있습니다:\n"

#: src/06_ticket_management/07_combinators.md:47
msgid "Closures can take more than one argument:"
msgstr "클로저는 하나 이상의 인수를 취할 수 있습니다:"

#: src/06_ticket_management/07_combinators.md:54
msgid "They can also capture variables from their environment:"
msgstr "또한 변수를 캡처할 수도 있습니다:"

#: src/06_ticket_management/07_combinators.md:62
msgid ""
"If necessary, you can specify the types of the arguments and/or the return "
"type:"
msgstr "필요한 경우 인수 타입이나 반환 타입을 지정할 수 있습니다:"

#: src/06_ticket_management/07_combinators.md:65
msgid "// Just the input type\n"
msgstr "// 입력 타입만\n"

#: src/06_ticket_management/07_combinators.md:66
msgid "// Or both input and output types, using the `fn` syntax\n"
msgstr "// 또는 `fn` 구문을 사용하여 입력 및 출력 타입 모두\n"

#: src/06_ticket_management/07_combinators.md:71
msgid "`collect`"
msgstr "`collect`"

#: src/06_ticket_management/07_combinators.md:73
msgid ""
"What happens when you're done transforming an iterator using combinators?  \n"
"You either iterate over the transformed values using a `for` loop, or you "
"collect them into a collection."
msgstr ""
"결합자를 사용하여 반복자 변환을 완료하면 이제 뭘 해야 할까요?  \n"
"`for` 루프를 사용하여 변환된 값을 반복하거나 컬렉션으로 수집해야합니다."

#: src/06_ticket_management/07_combinators.md:76
msgid ""
"The latter is done using the `collect` method.  \n"
"`collect` consumes the iterator and collects its elements into a collection "
"of your choice."
msgstr ""
"후자는 `collect` 메소드를 사용하여 수행됩니다.  \n"
"`collect`는 반복자를 사용하고 해당 요소를 선택한 컬렉션으로 수집합니다."

#: src/06_ticket_management/07_combinators.md:79
msgid ""
"For example, you can collect the squares of the even numbers into a `Vec`:"
msgstr "예를 들어 짝수의 제곱을 `Vec`으로 수집할 수 있습니다:"

#: src/06_ticket_management/07_combinators.md:89
msgid ""
"`collect` is generic over its **return type**.  \n"
"Therefore you usually need to provide a type hint to help the compiler infer "
"the correct type. In the example above, we annotated the type of "
"`squares_of_evens` to be `Vec<u32>`. Alternatively, you can use the "
"**turbofish syntax** to specify the type:"
msgstr ""
"`collect`는 **반환 타입**에 일반화됩니다.  \n"
"따라서 일반적으로 컴파일러가 올바른 타입을 유추하는 데 도움이 되는 유형 힌트"
"를 제공해야 합니다. 위의 예에서는 `squares_of_evens` 타입을 `Vec<u32>`로 어노"
"테이션했습니다. 또는 **turbofish 구문**을 사용하여 타입을 지정할 수 있습니다:"

#: src/06_ticket_management/07_combinators.md:98
msgid ""
"// Turbofish syntax: `<method_name>::<type>()`\n"
"    // It's called turbofish because `::<>` looks like a fish\n"
msgstr ""
"// Turbofish 구문: `<method_name>::<type>()`\n"
"    // `::<>`이 물고기처럼 보이기 때문에 터보피시라고 합니다\n"

#: src/06_ticket_management/07_combinators.md:105
msgid ""
"[`Iterator`'s documentation](https://doc.rust-lang.org/std/iter/trait."
"Iterator.html) gives you an overview of the methods available for iterators "
"in `std`."
msgstr ""
"[`Iterator` 문서](https://doc.rust-lang.org/std/iter/trait.Iterator.html)는 "
"`std`의 반복자에 사용할 수 있는 메서드에 대한 개요를 제공합니다."

#: src/06_ticket_management/07_combinators.md:107
msgid ""
"[The `itertools` crate](https://docs.rs/itertools/) defines even **more** "
"combinators for iterators."
msgstr "`itertools` 크레이트는 반복자를 위한 **더 많은** 결합자를 정의합니다."

#: src/06_ticket_management/07_combinators.md:111
msgid ""
"The exercise for this section is located in "
"[`06_ticket_management/07_combinators`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/07_combinators)"
msgstr ""
"이 섹션의 예제는 [`06_ticket_management/07_combinators`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/07_combinators)에 있습니다"

#: src/06_ticket_management/08_impl_trait.md:3
msgid ""
"`TicketStore::to_dos` returns a `Vec<&Ticket>`.  \n"
"That signature introduces a new heap allocation every time `to_dos` is "
"called, which may be unnecessary depending on what the caller needs to do "
"with the result. It'd be better if `to_dos` returned an iterator instead of a "
"`Vec`, thus empowering the caller to decide whether to collect the results "
"into a `Vec` or just iterate over them."
msgstr ""
"`TicketStore::to_dos`는 `Vec<&Ticket>`을 반환합니다.  \n"
"해당 시그니처는 `to_dos`가 호출될 때마다 새로운 힙 할당을 시행하는데, 이는 호"
"출자가 출력값으로 수행해야 하는 작업에 따라 불필요할 수 있습니다. `to_dos`가 "
"`Vec` 대신 반복자를 반환하여 호출자가 결과를 `Vec`로 수집할지 아니면 그냥 반복"
"할지 결정할 수 있도록 하는 것이 더 좋습니다."

#: src/06_ticket_management/08_impl_trait.md:9
msgid ""
"That's tricky though! What's the return type of `to_dos`, as implemented "
"below?"
msgstr "그래도 까다롭습니다! 아래에 구현된 `to_dos`의 반환 타입은 무엇일까요?"

#: src/06_ticket_management/08_impl_trait.md:20
msgid "Unnameable types"
msgstr "이름을 지정할 수 없는 타입"

#: src/06_ticket_management/08_impl_trait.md:22
msgid ""
"The `filter` method returns an instance of `std::iter::Filter`, which has the "
"following definition:"
msgstr ""
"`filter` 메소드는 다음과 같은 정의를 갖는 `std::iter::Filter`의 인스턴스를 반"
"환합니다:"

#: src/06_ticket_management/08_impl_trait.md:28
msgid ""
"where `I` is the type of the iterator being filtered on and `P` is the "
"predicate used to filter the elements.  \n"
"We know that `I` is `std::slice::Iter<'_, Ticket>` in this case, but what "
"about `P`?  \n"
"`P` is a closure, an **anonymous function**. As the name suggests, closures "
"don't have a name, so we can't write them down in our code."
msgstr ""
"여기서 `I`는 필터링되는 반복자의 타입이고 `P`는 요소를 필터링하는 데 사용되는 "
"조건자입니다.  \n"
"이 경우 `I`는 `std::slice::Iter<'_, Ticket>`이라는 것을 알고 있지만 `P`는 어떤"
"가요?  \n"
"`P`는 클로저, **익명 함수**입니다. 이름에서 알 수 있듯이 클로저에는 이름이 없"
"으므로 코드에 적을 수 없습니다."

#: src/06_ticket_management/08_impl_trait.md:33
msgid "Rust has a solution for this: **impl Trait**."
msgstr "Rust에는 이에 대한 해결책이 있습니다: **impl Trait**."

#: src/06_ticket_management/08_impl_trait.md:37
msgid ""
"`impl Trait` is a feature that allows you to return a type without specifying "
"its name. You just declare what trait(s) the type implements, and Rust "
"figures out the rest."
msgstr ""
"`impl Trait`은 이름을 지정하지 않고 타입을 반환할 수 있는 기능입니다. 해당 타"
"입이 구현하는 트래잇(들)을 선언하면 Rust가 나머지를 알아냅니다."

#: src/06_ticket_management/08_impl_trait.md:40
msgid "In this case, we want to return an iterator of references to `Ticket`s:"
msgstr "이 경우 `Ticket`에 대한 참조의 반복자를 반환하려고 합니다:"

#: src/06_ticket_management/08_impl_trait.md:50
msgid "That's it!"
msgstr "이게 전부입니다!"

#: src/06_ticket_management/08_impl_trait.md:52
msgid "Generic?"
msgstr "제네릭?"

#: src/06_ticket_management/08_impl_trait.md:54
msgid "`impl Trait` in return position is **not** a generic parameter."
msgstr "반환 위치의 `impl Trait`은 일반 매개변수가 **아닙니다**."

#: src/06_ticket_management/08_impl_trait.md:56
msgid ""
"Generics are placeholders for types that are filled in by the caller of the "
"function. A function with a generic parameter is **polymorphic**: it can be "
"called with different types, and the compiler will generate a different "
"implementation for each type."
msgstr ""
"제네릭은 함수 호출자가 채우는 타입에 대한 플레이스 홀더입니다. 일반 매개변수"
"가 있는 함수는 **다형성**입니다. 즉, 다양한 타입으로 호출될 수 있으며 컴파일러"
"는 각 타입에 대해 다른 구현을 생성합니다."

#: src/06_ticket_management/08_impl_trait.md:60
msgid ""
"That's not the case with `impl Trait`. The return type of a function with "
"`impl Trait` is **fixed** at compile time, and the compiler will generate a "
"single implementation for it. This is why `impl Trait` is also called "
"**opaque return type**: the caller doesn't know the exact type of the return "
"value, only that it implements the specified trait(s). But the compiler knows "
"the exact type, there is no polymorphism involved."
msgstr ""
"`impl Trait`의 경우는 그렇지 않습니다. `impl Trait`이 있는 함수의 반환 타입은 "
"컴파일 타임에 **고정**되며, 컴파일러는 이에 대한 단일 구현을 생성합니다. 이것"
"이 `impl Trait`을 **불투명 반환 타입**이라고도 부르는 이유입니다. 호출자는 반"
"환 값의 정확한 타입을 모르고 지정된 트레잇을 구현한다는 것만 알 수 있습니다. "
"그러나 컴파일러는 정확한 타입을 알고 있으므로 다형성이 관련되지 않습니다."

#: src/06_ticket_management/08_impl_trait.md:66
msgid "RPIT"
msgstr "RPIT"

#: src/06_ticket_management/08_impl_trait.md:68
msgid ""
"If you read RFCs or deep-dives about Rust, you might come across the acronym "
"**RPIT**.  \n"
"It stands for **\"Return Position Impl Trait\"** and refers to the use of "
"`impl Trait` in return position."
msgstr ""
"Rust에 대한 RFC나 심층 분석을 읽으면 **RPIT**라는 약어를 접하게 될 것입니"
"다.  \n"
"**\"Return Position Impl Trait\"**의 약자로 리턴 포지션에서 `impl Trait`을 사"
"용하는 것을 말합니다."

#: src/06_ticket_management/08_impl_trait.md:73
msgid ""
"The exercise for this section is located in "
"[`06_ticket_management/08_impl_trait`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/08_impl_trait)"
msgstr ""
"이 섹션의 예제는 [`06_ticket_management/08_impl_trait`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/08_impl_trait)에 있습니다"

#: src/06_ticket_management/09_impl_trait_2.md:1
msgid "`impl Trait` in argument position"
msgstr "인수 위치의 `impl Trait`"

#: src/06_ticket_management/09_impl_trait_2.md:3
msgid ""
"In the previous section, we saw how `impl Trait` can be used to return a type "
"without specifying its name.  \n"
"The same syntax can also be used in **argument position**:"
msgstr ""
"이전 섹션에서 `impl Trait`을 사용하여 이름을 지정하지 않고 타입을 반환하는 방"
"법을 살펴보았습니다.  \n"
"**인수 위치**에도 동일한 구문을 사용할 수 있습니다."

#: src/06_ticket_management/09_impl_trait_2.md:14
msgid ""
"`print_iter` takes an iterator of `i32`s and prints each element.  \n"
"When used in **argument position**, `impl Trait` is equivalent to a generic "
"parameter with a trait bound:"
msgstr ""
"`print_iter`는 `i32`의 반복자를 가져와 각 요소를 프린트합니다.  \n"
"**인수 위치**에서 사용될 때 `impl Trait`은 트레잇 바운드가 있는 일반 매개변수"
"와 동일합니다:"

#: src/06_ticket_management/09_impl_trait_2.md:28
#: src/08_futures/06_async_aware_primitives.md:115
msgid "Downsides"
msgstr "단점"

#: src/06_ticket_management/09_impl_trait_2.md:30
msgid ""
"As a rule of thumb, prefer generics over `impl Trait` in argument "
"position.  \n"
"Generics allow the caller to explicitly specify the type of the argument, "
"using the turbofish syntax (`::<>`), which can be useful for disambiguation. "
"That's not the case with `impl Trait`."
msgstr ""
"경험상 인수 위치에서는 `impl Trait`보다 제네릭을 선호합니다.  \n"
"제네릭을 사용하면 호출자가 명확성에 유용할 수 있는 터보피시 구문(`::<>`)을 사"
"용하여 인수 타입을 명시적으로 지정할 수 있습니다. `impl Trait`의 경우는 그렇"
"지 않습니다."

#: src/06_ticket_management/09_impl_trait_2.md:36
msgid ""
"The exercise for this section is located in "
"[`06_ticket_management/09_impl_trait_2`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/09_impl_trait_2)"
msgstr ""
"이 섹션의 예제는 [`06_ticket_management/09_impl_trait_2`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/09_impl_trait_2)에 있습니다"

#: src/06_ticket_management/10_slices.md:3
msgid "Let's go back to the memory layout of a `Vec`:"
msgstr "`Vec`의 메모리 레이아웃으로 돌아가 보겠습니다:"

#: src/06_ticket_management/10_slices.md:24
msgid ""
"We already remarked how `String` is just a `Vec<u8>` in disguise.  \n"
"The similarity should prompt you to ask: \"What's the equivalent of `&str` "
"for `Vec`?\""
msgstr ""
"우리는 `String`이 어떻게 위장된 `Vec<u8>`인지 이미 언급했습니다.  \n"
"이 유사성을 보면 아마 이런 질문이 떠오를겁니다: \"`Vec`버전의 `&str`는 뭐지?\""

#: src/06_ticket_management/10_slices.md:27
msgid "`&[T]`"
msgstr "`&[T]`"

#: src/06_ticket_management/10_slices.md:29
msgid ""
"`[T]` is a **slice** of a contiguous sequence of elements of type `T`.  \n"
"It's most commonly used in its borrowed form, `&[T]`."
msgstr ""
"`[T]`는 `T` 타입의 연속된 요소 시퀀스의 **슬라이스**입니다.  \n"
"보통 참조 형태인 `&[T]`로 사용합니다."

#: src/06_ticket_management/10_slices.md:32
msgid "There are various ways to create a slice reference from a `Vec`:"
msgstr "`Vec`에서 슬라이스 참조를 생성하는 방법에는 여러 가지가 있습니다:"

#: src/06_ticket_management/10_slices.md:35
msgid "// Via index syntax\n"
msgstr "// 인덱스 구문을 통해\n"

#: src/06_ticket_management/10_slices.md:37
msgid "// Via a method\n"
msgstr "// 메소드를 통해\n"

#: src/06_ticket_management/10_slices.md:39
msgid "// Or for a subset of the elements\n"
msgstr "// 또는 요소의 하위 집합에 대해\n"

#: src/06_ticket_management/10_slices.md:44
msgid ""
"`Vec` implements the `Deref` trait using `[T]` as the target type, so you can "
"use slice methods on a `Vec` directly thanks to deref coercion:"
msgstr ""
"`Vec`은 `[T]`를 대상 타입으로 사용하여 `Deref` 트레잇을 구현하므로 deref "
"coercion 덕분에 `Vec`에서 직접 슬라이스 메서드를 사용할 수 있습니다:"

#: src/06_ticket_management/10_slices.md:48
msgid ""
"// Surprise, surprise: `iter` is not a method on `Vec`!\n"
"// It's a method on `&[T]`, but you can call it on a `Vec` \n"
"// thanks to deref coercion.\n"
msgstr ""
"// 놀라운 사실: `iter`는 `Vec`의 메서드가 아닙니다!\n"
"// `&[T]`의 메서드이지만 deref coercion 덕분에\n"
"// `Vec`에서 호출할 수 있습니다.\n"

#: src/06_ticket_management/10_slices.md:57
msgid ""
"A `&[T]` is a **fat pointer**, just like `&str`.  \n"
"It consists of a pointer to the first element of the slice and the length of "
"the slice."
msgstr ""
"`&[T]`는 `&str`과 마찬가지로 **팻 포인터**입니다.  \n"
"이는 슬라이스의 첫 번째 요소에 대한 포인터와 슬라이스의 길이로 구성됩니다."

#: src/06_ticket_management/10_slices.md:60
msgid "If you have a `Vec` with three elements:"
msgstr "세 가지 요소를 포함하는 `Vec`이 있는 경우:"

#: src/06_ticket_management/10_slices.md:66
msgid "and then create a slice reference:"
msgstr "그런 다음 슬라이스 참조를 만듭니다:"

#: src/06_ticket_management/10_slices.md:72
msgid "you'll get this memory layout:"
msgstr "다음과 같은 메모리 레이아웃을 얻게 됩니다:"

#: src/06_ticket_management/10_slices.md:91
msgid "`&Vec<T>` vs `&[T]`"
msgstr "`&Vec<T>` vs `&[T]`"

#: src/06_ticket_management/10_slices.md:93
msgid ""
"When you need to pass an immutable reference to a `Vec` to a function, prefer "
"`&[T]` over `&Vec<T>`.  \n"
"This allows the function to accept any kind of slice, not necessarily one "
"backed by a `Vec`."
msgstr ""
"`Vec`에 대한 불변 참조를 함수에 전달해야 하는 경우 `&Vec<T>`보다 `&[T]`를 사용"
"하세요.  \n"
"이를 통해 함수는 반드시 `Vec`에 의해 지원되는 슬라이스가 아닌 모든 종류의 슬라"
"이스를 허용할 수 있습니다."

#: src/06_ticket_management/10_slices.md:96
msgid ""
"For example, you can then pass a subset of the elements in a `Vec`. But it "
"goes further than that—you could also pass a **slice of an array**:"
msgstr ""
"예를 들어, `Vec`에 있는 요소의 하위 집합을 전달할 수 있습니다. 하지만 그 이상"
"입니다. **배열의 슬라이스**도 전달할 수도 있습니다."

#: src/06_ticket_management/10_slices.md:104
msgid ""
"Array slices and `Vec` slices are the same type: they're fat pointers to a "
"contiguous sequence of elements. In the case of arrays, the pointer points to "
"the stack rather than the heap, but that doesn't matter when it comes to "
"using the slice."
msgstr ""
"배열 슬라이스와 `Vec` 슬라이스는 동일한 타입입니다. 즉, 연속된 요소 시퀀스에 "
"대한 팻 포인터입니다. 배열의 경우 포인터는 힙이 아닌 스택을 가리키지만 슬라이"
"스를 사용할 때는 중요하지 않습니다."

#: src/06_ticket_management/10_slices.md:110
msgid ""
"The exercise for this section is located in [`06_ticket_management/10_slices`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/10_slices)"
msgstr ""
"이 섹션의 예제는 [`06_ticket_management/10_slices`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/10_slices)에 있습니다"

#: src/06_ticket_management/11_mutable_slices.md:3
msgid ""
"Every time we've talked about slice types (like `str` and `[T]`), we've used "
"their immutable borrow form (`&str` and `&[T]`).  \n"
"But slices can also be mutable!"
msgstr ""
"우리는 슬라이스 타입(예: `str`와 `[T]`)에 대해 이야기할 때마다 불변 참조 형식"
"(`&str` 및 `&[T]`)을 사용했습니다.  \n"
"하지만 슬라이스도 변경할 수 있습니다!"

#: src/06_ticket_management/11_mutable_slices.md:6
msgid "Here's how you create a mutable slice:"
msgstr "변경 가능한 슬라이스를 만드는 방법은 다음과 같습니다:"

#: src/06_ticket_management/11_mutable_slices.md:13
msgid "You can then modify the elements in the slice:"
msgstr "그런 다음 슬라이스의 요소를 수정할 수 있습니다:"

#: src/06_ticket_management/11_mutable_slices.md:19
msgid "This will change the first element of the `Vec` to `42`."
msgstr "그러면 `Vec`의 첫 번째 요소가 `42`로 변경됩니다."

#: src/06_ticket_management/11_mutable_slices.md:23
msgid ""
"When working with immutable borrows, the recommendation was clear: prefer "
"slice references over references to the owned type (e.g. `&[T]` over "
"`&Vec<T>`).  \n"
"That's **not** the case with mutable borrows."
msgstr ""
"불변 참조로 작업할 때 권장 사항은 명확했습니다. 소유한 타입에 대한 참조보다 슬"
"라이스 참조를 선호합니다(예: `&Vec<T>`보다 `&[T]`).  \n"
"변경 가능한 빌림의 경우는 **그렇지** 않습니다."

#: src/06_ticket_management/11_mutable_slices.md:27
msgid "Consider this scenario:"
msgstr "다음 시나리오를 생각해보세요:"

#: src/06_ticket_management/11_mutable_slices.md:35
msgid ""
"It won't compile!  \n"
"`push` is a method on `Vec`, not on slices. This is the manifestation of a "
"more general principle: Rust won't allow you to add or remove elements from a "
"slice. You will only be able to modify/replace the elements that are already "
"there."
msgstr ""
"컴파일되지 않습니다!  \n"
"`push`는 슬라이스가 아닌 `Vec`에 대한 메서드입니다. 이는 보다 일반적인 원칙의 "
"표현입니다. Rust는 슬라이스에서 요소를 추가하거나 제거하는 것을 허용하지 않습"
"니다. 이미 존재하는 요소를 수정/교체만 할 수 있습니다."

#: src/06_ticket_management/11_mutable_slices.md:40
msgid ""
"In this regard, a `&mut Vec` or a `&mut String` are strictly more powerful "
"than a `&mut [T]` or a `&mut str`.  \n"
"Choose the type that best fits based on the operations you need to perform."
msgstr ""
"이와 관련하여 `&mut Vec` 또는 `&mut String`은 `&mut [T]` 또는 `&mut str`보다 "
"엄격하게 더 강력합니다.  \n"
"수행해야 하는 작업에 따라 가장 적합한 타입을 선택하십시오."

#: src/06_ticket_management/11_mutable_slices.md:45
msgid ""
"The exercise for this section is located in "
"[`06_ticket_management/11_mutable_slices`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/11_mutable_slices)"
msgstr ""
"이 섹션의 예제는 [`06_ticket_management/11_mutable_slices`](https://github."
"com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/11_mutable_slices)에 있습니다"

#: src/06_ticket_management/12_two_states.md:1
msgid "Ticket ids"
msgstr "티켓 ID"

#: src/06_ticket_management/12_two_states.md:3
msgid ""
"Let's think again about our ticket management system.  \n"
"Our ticket model right now looks like this:"
msgstr ""
"우리의 티켓 관리 시스템에 대해 다시 생각해 봅시다.  \n"
"현재 우리의 티켓 모델은 다음과 같습니다:"

#: src/06_ticket_management/12_two_states.md:14
msgid ""
"One thing is missing here: an **identifier** to uniquely identify a "
"ticket.  \n"
"That identifier should be unique for each ticket. That can be guaranteed by "
"generating it automatically when a new ticket is created."
msgstr ""
"여기서는 티켓을 고유하게 식별하는 **식별자**가 누락되었습니다.  \n"
"해당 식별자는 각 티켓마다 고유해야 합니다. 새 티켓이 생성될 때 자동으로 생성하"
"여 이를 보장할 수 있습니다."

#: src/06_ticket_management/12_two_states.md:18
msgid "Refining the model"
msgstr "모델 개선"

#: src/06_ticket_management/12_two_states.md:20
msgid ""
"Where should the id be stored?  \n"
"We could add a new field to the `Ticket` struct:"
msgstr ""
"ID는 어디에 저장해야 하나요?  \n"
"`Ticket` 구조체에 새 필드를 추가할 수 있습니다:"

#: src/06_ticket_management/12_two_states.md:32
msgid ""
"But we don't know the id before creating the ticket. So it can't be there "
"from the get-go.  \n"
"It'd have to be optional:"
msgstr ""
"하지만 티켓을 만들기 전에는 ID를 알 수 없습니다. 그러니 처음부터 있을 수는 없"
"습니다.  \n"
"옵셔널해야 한다는 것입니다."

#: src/06_ticket_management/12_two_states.md:44
msgid ""
"That's also not ideal—we'd have to handle the `None` case every single time "
"we retrieve a ticket from the store, even though we know that the id should "
"always be there once the ticket has been created."
msgstr ""
"그것은 또한 이상적이지 않습니다. 티켓이 생성되면 ID가 항상 거기에 있어야 한다"
"는 것을 알고 있더라도 상점에서 티켓을 검색할 때마다 `None` 케이스를 처리해야 "
"합니다."

#: src/06_ticket_management/12_two_states.md:47
msgid ""
"The best solution is to have two different ticket **states**, represented by "
"two separate types: a `TicketDraft` and a `Ticket`:"
msgstr ""
"가장 좋은 해결책은 `TicketDraft`와 `Ticket`이라는 두 가지 별도 타입으로 표시되"
"는 두 개의 서로 다른 티켓 **상태**만드는 것입니다."

#: src/06_ticket_management/12_two_states.md:64
msgid ""
"A `TicketDraft` is a ticket that hasn't been created yet. It doesn't have an "
"id, and it doesn't have a status.  \n"
"A `Ticket` is a ticket that has been created. It has an id and a status.  \n"
"Since each field in `TicketDraft` and `Ticket` embeds its own constraints, we "
"don't have to duplicate logic across the two types."
msgstr ""
"`TicketDraft`는 아직 생성되지 않은 티켓입니다. ID도 없고 상태도 없습니다.  \n"
"`Ticket`은 생성된 티켓입니다. ID와 상태가 있습니다.  \n"
"`TicketDraft`와 `Ticket`의 각 필드에는 자체 제약 조건이 포함되어 있으므로 두 "
"타입에 로직을 중복할 필요가 없습니다."

#: src/06_ticket_management/12_two_states.md:71
msgid ""
"The exercise for this section is located in "
"[`06_ticket_management/12_two_states`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/12_two_states)"
msgstr ""
"이 섹션의 예제는 [`06_ticket_management/12_two_states`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/12_two_states)에 있습니다"

#: src/06_ticket_management/13_index.md:1
msgid "Indexing"
msgstr "인덱싱"

#: src/06_ticket_management/13_index.md:3
msgid ""
"`TicketStore::get` returns an `Option<&Ticket>` for a given `TicketId`.  \n"
"We've seen before how to access elements of arrays and vectors using Rust's "
"indexing syntax:"
msgstr ""
"`TicketStore::get`은 주어진 `TicketId`에 대해 `Option<&Ticket>`을 반환합니"
"다.  \n"
"우리는 이전에 Rust의 인덱싱 구문을 사용하여 배열과 벡터의 요소에 액세스하는 방"
"법을 살펴보았습니다:"

#: src/06_ticket_management/13_index.md:12
msgid ""
"How can we provide the same experience for `TicketStore`?  \n"
"You guessed right: we need to implement a trait, `Index`!"
msgstr ""
"어떻게 `TicketStore`에 대해서도 동일한 경험을 제공할 수 있을까요?  \n"
"당신이 생각하고 있는 그게 맞습니다: `Index` 트레잇을 구현해야 합니다!"

#: src/06_ticket_management/13_index.md:15
msgid "`Index`"
msgstr "`Index`"

#: src/06_ticket_management/13_index.md:17
msgid "The `Index` trait is defined in Rust's standard library:"
msgstr "`Index` 트레잇은 Rust의 표준 라이브러리에 정의되어 있습니다:"

#: src/06_ticket_management/13_index.md:25
#: src/06_ticket_management/14_index_mut.md:14
#: src/06_ticket_management/15_hashmap.md:63
msgid "// Required method\n"
msgstr "// 필수 메서드\n"

#: src/06_ticket_management/13_index.md:30
msgid "It has:"
msgstr "`Index` 트레잇은 아래의 것들을 가집니다:"

#: src/06_ticket_management/13_index.md:32
msgid "One generic parameter, `Idx`, to represent the index type"
msgstr "인덱스 타입을 나타내는 하나의 제네릭 매개변수 `Idx`"

#: src/06_ticket_management/13_index.md:33
msgid ""
"One associated type, `Output`, to represent the type we retrieved using the "
"index"
msgstr "인덱스를 사용하여 검색한 타입을 나타내는 하나의 연관 타입 `Output`"

#: src/06_ticket_management/13_index.md:35
msgid ""
"Notice how the `index` method doesn't return an `Option`. The assumption is "
"that `index` will panic if you try to access an element that's not there, as "
"it happens for array and vec indexing."
msgstr ""
"`index` 메서드가 어떻게 `Option`을 반환하지 않는지 확인하세요. 배열 및 vec 인"
"덱싱에서 발생하는 것처럼 `index`가 존재하지 않는 요소에 액세스하려고 하면 패닉"
"이 발생할 것이라고 가정합니다."

#: src/06_ticket_management/13_index.md:41
msgid ""
"The exercise for this section is located in [`06_ticket_management/13_index`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/13_index)"
msgstr ""
"이 섹션의 예제는 [`06_ticket_management/13_index`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/13_index)에 있습니다"

#: src/06_ticket_management/14_index_mut.md:1
msgid "Mutable indexing"
msgstr "변경 가능한 인덱싱"

#: src/06_ticket_management/14_index_mut.md:3
msgid ""
"`Index` allows read-only access. It doesn't let you mutate the value you "
"retrieved."
msgstr ""
"`Index`는 읽기 전용 액세스를 허용합니다. 검색한 값을 변경할 수 없습니다."

#: src/06_ticket_management/14_index_mut.md:6
msgid "`IndexMut`"
msgstr "`IndexMut`"

#: src/06_ticket_management/14_index_mut.md:8
msgid ""
"If you want to allow mutability, you need to implement the `IndexMut` trait."
msgstr "가변성을 허용하려면 `IndexMut` 트레잇을 구현해야 합니다."

#: src/06_ticket_management/14_index_mut.md:19
msgid ""
"`IndexMut` can only be implemented if the type already implements `Index`, "
"since it unlocks an _additional_ capability."
msgstr ""
"`IndexMut`는 타입이 이미 `Index`를 구현한 경우에만 구현할 수 있습니다. _추가_ "
"기능을 잠금 해제하기 때문입니다."

#: src/06_ticket_management/14_index_mut.md:24
msgid ""
"The exercise for this section is located in "
"[`06_ticket_management/14_index_mut`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/06_ticket_management/14_index_mut)"
msgstr ""
"이 섹션의 예제는 [`06_ticket_management/14_index_mut`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/14_index_mut)에 있습니다"

#: src/06_ticket_management/15_hashmap.md:3
msgid ""
"Our implementation of `Index`/`IndexMut` is not ideal: we need to iterate "
"over the entire `Vec` to retrieve a ticket by id; the algorithmic complexity "
"is `O(n)`, where `n` is the number of tickets in the store."
msgstr ""
"우리의 `Index`/`IndexMut` 구현은 최적이 아닙니다: 티켓을 ID로 검색하기 위해 전"
"체 `Vec`을 반복해야 하며, 알고리즘 복잡도는 티켓 스토어 내의 티켓 수를 나타내"
"는 `n`에 비례하여 `O(n)`입니다."

#: src/06_ticket_management/15_hashmap.md:7
msgid ""
"We can do better by using a different data structure for storing tickets: a "
"`HashMap<K, V>`."
msgstr ""
"티켓 저장을 위해 `HashMap<K, V>`라는 다른 데이터 구조를 사용하면 더 나은 결과"
"를 얻을 수 있습니다."

#: src/06_ticket_management/15_hashmap.md:11
msgid ""
"// Type inference lets us omit an explicit type signature (which\n"
"// would be `HashMap<String, String>` in this example).\n"
msgstr ""
"// 타입 추론을 통해 명시적인 타입 시그니처(이 예에서는\n"
"// HashMap<String, String>`이 됨)을 생략할 수 있습니다.\n"

#: src/06_ticket_management/15_hashmap.md:17
msgid "\"Adventures of Huckleberry Finn\""
msgstr "\"Adventures of Huckleberry Finn\""

#: src/06_ticket_management/15_hashmap.md:18
msgid "\"My favorite book.\""
msgstr "\"My favorite book.\""

#: src/06_ticket_management/15_hashmap.md:22
msgid ""
"`HashMap` works with key-value pairs. It's generic over both: `K` is the "
"generic parameter for the key type, while `V` is the one for the value type."
msgstr ""
"`HashMap`은 키-값 쌍으로 작동합니다. 두 가지 모두에 대해 일반화됩니다. `K`는 "
"키 타입에 대한 일반 매개변수이고 `V`는 값 타입에 대한 매개변수입니다."

#: src/06_ticket_management/15_hashmap.md:25
msgid ""
"The expected cost of insertions, retrievals and removals is **constant**, "
"`O(1)`. That sounds perfect for our usecase, doesn't it?"
msgstr ""
"삽입, 검색 및 제거의 예상 비용은 **상수**, `O(1)`입니다. 우리의 사용 사례에 "
"딱 맞는 것 같지 않나요?"

#: src/06_ticket_management/15_hashmap.md:28
msgid "Key requirements"
msgstr "주요 요구 사항"

#: src/06_ticket_management/15_hashmap.md:30
msgid ""
"There are no trait bounds on `HashMap`'s struct definition, but you'll find "
"some on its methods. Let's look at `insert`, for example:"
msgstr ""
"`HashMap`의 구조체 정의에는 트레잇 바운드가 없지만 해당 메서드에서 일부를 찾"
"을 수 있습니다. 예를 들어 `insert`를 살펴보겠습니다:"

#: src/06_ticket_management/15_hashmap.md:45
msgid ""
"The key type must implement the `Eq` and `Hash` traits.  \n"
"Let's dig into those two."
msgstr ""
"키 타입은 `Eq` 및 `Hash` 트레잇을 구현해야 합니다.  \n"
"그 두 가지를 파헤쳐 보겠습니다."

#: src/06_ticket_management/15_hashmap.md:48
msgid "`Hash`"
msgstr "`Hash`"

#: src/06_ticket_management/15_hashmap.md:50
msgid ""
"A hashing function (or hasher) maps a potentially infinite set of a values (e."
"g. all possible strings) to a bounded range (e.g. a `u64` value).  \n"
"There are many different hashing functions around, each with different "
"properties (speed, collision risk, reversibility, etc.)."
msgstr ""
"해싱 함수(또는 해셔)는 잠재적으로 무한한 값 집합(예: 가능한 모든 문자열)을 제"
"한된 범위(예: `u64` 값)에 매핑합니다.  \n"
"찾아보면 서로 다른 속성(속도, 충돌 위험, 가역성 등)을 가진 다양한 해싱 함수가 "
"있습니다."

#: src/06_ticket_management/15_hashmap.md:55
msgid ""
"A `HashMap`, as the name suggests, uses a hashing function behind the scene. "
"It hashes your key and then uses that hash to store/retrieve the associated "
"value. This strategy requires the key type must be hashable, hence the `Hash` "
"trait bound on `K`."
msgstr ""
"이름에서 알 수 있듯이 `HashMap`은 뒤에서 해싱 함수를 사용합니다. 키를 해시한 "
"다음 해당 해시를 사용하여 관련 값을 저장/검색합니다. 이 전략에서는 키 타입이 "
"해시 가능해야 하므로 `K`에 `Hash` 트레잇이 바인딩됩니다."

#: src/06_ticket_management/15_hashmap.md:59
msgid "You can find the `Hash` trait in the `std::hash` module:"
msgstr "`std::hash` 모듈에서 `Hash` 트레잇을 찾을 수 있습니다:"

#: src/06_ticket_management/15_hashmap.md:69
msgid ""
"You will rarely implement `Hash` manually. Most of the times you'll derive it:"
msgstr ""
"`Hash`를 수동으로 구현하는 경우는 거의 없습니다. 대부분의 경우 다음과 같이 파"
"생됩니다:"

#: src/06_ticket_management/15_hashmap.md:79
msgid "`Eq`"
msgstr "`Eq`"

#: src/06_ticket_management/15_hashmap.md:81
msgid ""
"`HashMap` must be able to compare keys for equality. This is particularly "
"important when dealing with hash collisions—i.e. when two different keys hash "
"to the same value."
msgstr ""
"`HashMap`은 키가 동일한지 비교할 수 있어야 합니다. 이는 해시 충돌을 처리할 때 "
"특히 중요합니다. 즉 두 개의 서로 다른 키가 동일한 값으로 해시되는 경우 말입니"
"다."

#: src/06_ticket_management/15_hashmap.md:84
msgid ""
"You may wonder: isn't that what the `PartialEq` trait is for? Almost!  \n"
"`PartialEq` is not enough for `HashMap` because it doesn't guarantee "
"reflexivity, i.e. `a == a` is always `true`.  \n"
"For example, floating point numbers (`f32` and `f64`) implement `PartialEq`, "
"but they don't satisfy the reflexivity property: `f32::NAN == f32::NAN` is "
"`false`.  \n"
"Reflexivity is crucial for `HashMap` to work correctly: without it, you "
"wouldn't be able to retrieve a value from the map using the same key you used "
"to insert it."
msgstr ""
"아마 당신은 궁금할 것입니다: 이게 바로 `PartialEq` 트레잇이 하는 일 아닌가요? "
"거의 맞았습니다!  \n"
"`PartialEq`는 반사성(reflexivity)을 보장하지 않기 때문에 `HashMap`에 적합하지 "
"않습니다. 즉 `a == a`는 항상 `true`입니다.  \n"
"예를 들어 부동 소수점 숫자(`f32` 및 `f64`)는 `PartialEq`를 구현하지만 반사성 "
"속성을 충족하지 않습니다. `f32::NAN == f32::NAN`은 `false`입니다.  \n"
"재귀성은 `HashMap`이 올바르게 작동하는 데 매우 중요합니다. 재귀성이 없으면 이"
"를 삽입하는 데 사용한 것과 동일한 키를 사용하여 맵에서 값을 검색할 수 없습니"
"다."

#: src/06_ticket_management/15_hashmap.md:91
msgid "The `Eq` trait extends `PartialEq` with the reflexivity property:"
msgstr "`Eq` 트레잇은 반사성 속성을 사용하여 `PartialEq`를 확장합니다:"

#: src/06_ticket_management/15_hashmap.md:95
msgid "// No additional methods\n"
msgstr "// 추가 메서드 없음\n"

#: src/06_ticket_management/15_hashmap.md:99
msgid ""
"It's a marker trait: it doesn't add any new methods, it's just a way for you "
"to say to the compiler that the equality logic implemented in `PartialEq` is "
"reflexive."
msgstr ""
"이는 마커 특성입니다. 새로운 메서드를 추가하지 않고 `PartialEq`에 구현된 동등 "
"논리가 반사적임을 컴파일러에 알리는 방법일 뿐입니다."

#: src/06_ticket_management/15_hashmap.md:102
msgid "You can derive `Eq` automatically when you derive `PartialEq`:"
msgstr "`PartialEq`를 파생시키면 `Eq`가 자동으로 파생될 수 있습니다:"

#: src/06_ticket_management/15_hashmap.md:112
msgid "`Eq` and `Hash` are linked"
msgstr "`Eq`와 `Hash`는 연관되어있습니다"

#: src/06_ticket_management/15_hashmap.md:114
msgid ""
"There is an implicit contract between `Eq` and `Hash`: if two keys are equal, "
"their hashes must be equal too. This is crucial for `HashMap` to work "
"correctly. If you break this contract, you'll get nonsensical results when "
"using `HashMap`."
msgstr ""
"`Eq`와 `Hash` 사이에는 암묵적인 약속이 있습니다. 두 키가 동일하면 해당 해시도 "
"동일해야 합니다. 이는 `HashMap`이 올바르게 작동하는 데 중요합니다. 이 약속을 "
"어기면 `HashMap`을 사용할 때 의미 없는 결과를 얻게 됩니다."

#: src/06_ticket_management/15_hashmap.md:120
msgid ""
"The exercise for this section is located in "
"[`06_ticket_management/15_hashmap`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/06_ticket_management/15_hashmap)"
msgstr ""
"이 섹션의 예제는 [`06_ticket_management/15_hashmap`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/15_hashmap)에 있습니다"

#: src/06_ticket_management/16_btreemap.md:1
msgid "Ordering"
msgstr "순서"

#: src/06_ticket_management/16_btreemap.md:3
msgid ""
"By moving from a `Vec` to a `HashMap` we have improved the performance of our "
"ticket management system, and simplified our code in the process.  \n"
"It's not all roses, though. When iterating over a `Vec`\\-backed store, we "
"could be sure that the tickets would be returned in the order they were "
"added.  \n"
"That's not the case with a `HashMap`: you can iterate over the tickets, but "
"the order is random."
msgstr ""
"`Vec`에서 `HashMap`으로 이동하여 티켓 관리 시스템의 성능을 개선하고 그 과정에"
"서 코드를 단순화했습니다.  \n"
"하지만 아직 모든 것이 완벽하지는 않습니다. `Vec` 지원 스토어를 반복할 때 티켓"
"이 추가된 순서대로 반환된다는 것을 확신할 수 있었습니다.  \n"
"`HashMap`의 경우는 그렇지 않습니다. 티켓을 반복할 수 있지만 순서는 무작위입니"
"다."

#: src/06_ticket_management/16_btreemap.md:9
msgid ""
"We can recover a consistent ordering by switching from a `HashMap` to a "
"`BTreeMap`."
msgstr ""
"`HashMap`에서 `BTreeMap`으로 전환하면 다시 일관된 순서를 보장할 수 있습니다."

#: src/06_ticket_management/16_btreemap.md:13
msgid ""
"A `BTreeMap` guarantees that entries are sorted by their keys.  \n"
"This is useful when you need to iterate over the entries in a specific order, "
"or if you need to perform range queries (e.g. \"give me all tickets with an "
"id between 10 and 20\")."
msgstr ""
"`BTreeMap`은 항목이 키를 기준으로 정렬되도록 보장합니다.  \n"
"이는 특정 순서로 항목을 반복해야 하거나 범위 쿼리를 수행해야 하는 경우(예: "
"\"ID가 10에서 20 사이인 모든 티켓을 주세요\") 유용합니다."

#: src/06_ticket_management/16_btreemap.md:17
msgid ""
"Just like `HashMap`, you won't find trait bounds on the definition of "
"`BTreeMap`. But you'll find trait bounds on its methods. Let's look at "
"`insert`:"
msgstr ""
"`HashMap`과 마찬가지로 `BTreeMap` 정의에서는 트레잇 바운드를 찾을 수 없습니"
"다. 그러나 해당 메서드에서 트레잇 바운드를 찾을 수 있습니다. `insert`를 살펴보"
"겠습니다:"

#: src/06_ticket_management/16_btreemap.md:21
msgid ""
"// `K` and `V` stand for the key and value types, respectively,\n"
"// just like in `HashMap`.\n"
msgstr ""
"// `K`와 `V`는 각각 `HashMap`에서와 마찬가지로 // 키와 값 타입을 나타냅니다.\n"

#: src/06_ticket_management/16_btreemap.md:28
msgid "// implementation\n"
msgstr "// 구현\n"

#: src/06_ticket_management/16_btreemap.md:33
msgid ""
"`Hash` is no longer required. Instead, the key type must implement the `Ord` "
"trait."
msgstr ""
"`Hash`는 더 이상 필요하지 않습니다. 대신, 키 유형은 'Ord' 트레잇을 구현해야 합"
"니다."

#: src/06_ticket_management/16_btreemap.md:35
msgid "`Ord`"
msgstr "`Ord`"

#: src/06_ticket_management/16_btreemap.md:37
msgid ""
"The `Ord` trait is used to compare values.  \n"
"While `PartialEq` is used to compare for equality, `Ord` is used to compare "
"for ordering."
msgstr ""
"`Ord` 트레잇은 값을 비교하는 데 사용됩니다.  \n"
"`PartialEq`는 동등성을 비교하는 데 사용되는 반면, `Ord`는 순서를 비교하는 데 "
"사용됩니다."

#: src/06_ticket_management/16_btreemap.md:40
msgid "It's defined in `std::cmp`:"
msgstr "이는 `std::cmp`에 정의되어 있습니다:"

#: src/06_ticket_management/16_btreemap.md:48
msgid ""
"The `cmp` method returns an `Ordering` enum, which can be one of `Less`, "
"`Equal`, or `Greater`.  \n"
"`Ord` requires that two other traits are implemented: `Eq` and `PartialOrd`."
msgstr ""
"`cmp` 메소드는 `Less`, `Equal` 또는 `Greater` 중 하나일 수 있는 `Ordering` 열"
"거형을 반환합니다.  \n"
"`Ord`를 사용하려면 `Eq`와 `PartialOrd`라는 두 가지 다른 트레잇이 구현되어야 합"
"니다."

#: src/06_ticket_management/16_btreemap.md:52
msgid "`PartialOrd`"
msgstr "`PartialOrd`"

#: src/06_ticket_management/16_btreemap.md:54
msgid ""
"`PartialOrd` is a weaker version of `Ord`, just like `PartialEq` is a weaker "
"version of `Eq`. You can see why by looking at its definition:"
msgstr ""
"`PartialOrd`는 `Ord`의 약한 버전입니다. 마치 `PartialEq`가 `Eq`의 약한 버전인 "
"것과 같습니다. 정의를 보면 그 이유를 알 수 있습니다:"

#: src/06_ticket_management/16_btreemap.md:63
msgid ""
"`PartialOrd::partial_cmp` returns an `Option`—it is not guaranteed that two "
"values can be compared.  \n"
"For example, `f32` doesn't implement `Ord` because `NaN` values are not "
"comparable, the same reason why `f32` doesn't implement `Eq`."
msgstr ""
"`PartialOrd::partial_cmp`는 `Option`을 반환합니다. 두 값을 비교할 수 있다는 보"
"장은 없습니다.  \n"
"예를 들어, `f32`는 `NaN` 값을 비교할 수 없기 때문에 `Ord`를 구현하지 않습니"
"다. 이는 `f32`가 `Eq`를 구현하지 않는 것과 같은 이유입니다."

#: src/06_ticket_management/16_btreemap.md:68
msgid "Implementing `Ord` and `PartialOrd`"
msgstr "`Ord`와 `PartialOrd` 구현"

#: src/06_ticket_management/16_btreemap.md:70
msgid "Both `Ord` and `PartialOrd` can be derived for your types:"
msgstr "타입에 `Ord`와 `PartialOrd`를 모두 파생할 수 있습니다:"

#: src/06_ticket_management/16_btreemap.md:73
msgid ""
"// You need to add `Eq` and `PartialEq` too,\n"
"// since `Ord` requires them.\n"
msgstr ""
"// `Eq`와 `PartialEq`도 추가해야 합니다.\n"
"// `Ord`가 필요로 하기 때문입니다.\n"

#: src/06_ticket_management/16_btreemap.md:79
msgid "If you choose (or need) to implement them manually, be careful:"
msgstr "수동으로 구현하기로 선택하거나 필요한 경우 다음 사항에 주의하세요:"

#: src/06_ticket_management/16_btreemap.md:81
msgid "`Ord` and `PartialOrd` must be consistent with `Eq` and `PartialEq`."
msgstr "`Ord`와 `PartialOrd`는 `Eq`와 `PartialEq`와 일관되어야 합니다."

#: src/06_ticket_management/16_btreemap.md:82
msgid "`Ord` and `PartialOrd` must be consistent with each other."
msgstr "`Ord`와 `PartialOrd`는 서로 일관되어야 합니다."

#: src/06_ticket_management/16_btreemap.md:86
msgid ""
"The exercise for this section is located in "
"[`06_ticket_management/16_btreemap`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/06_ticket_management/16_btreemap)"
msgstr ""
"이 섹션의 예제는 [`06_ticket_management/16_btreemap`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/06_ticket_management/16_btreemap)에 있습니다"

#: src/07_threads/00_intro.md:3
msgid ""
"One of Rust's big promises is _fearless concurrency_: making it easier to "
"write safe, concurrent programs. We haven't seen much of that yet. All the "
"work we've done so far has been single-threaded. Time to change that!"
msgstr ""
"Rust의 가장 큰 약속 중 하나는 _두려움 없는 동시성_입니다. 즉, 안전한 동시성 프"
"로그램 작성을 더 쉽게 만드는 것입니다. 우리는 아직 그런 것을 많이 보지 못했습"
"니다. 지금까지 우리가 수행한 모든 작업은 단일 스레드였습니다. 이제 바뀔 시간입"
"니다!"

#: src/07_threads/00_intro.md:7
msgid ""
"In this chapter we'll make our ticket store multithreaded.  \n"
"We'll have the opportunity to touch most of Rust's core concurrency features, "
"including:"
msgstr ""
"이번 장에서는 티켓 스토어를 멀티스레드로 만들겠습니다.  \n"
"우리는 다음을 포함해 Rust의 핵심 동시성 기능 대부분을 다룰 기회를 갖게 될 것입"
"니다:"

#: src/07_threads/00_intro.md:10
msgid "Threads, using the `std::thread` module"
msgstr "스레드, `std::thread` 모듈를 사용"

#: src/07_threads/00_intro.md:11
msgid "Message passing, using channels"
msgstr "메시지 전달, 채널 사용"

#: src/07_threads/00_intro.md:12
msgid "Shared state, using `Arc`, `Mutex` and `RwLock`"
msgstr "공유 상태, `Arc`, `Mutex`그리고 `RwLock`을 사용"

#: src/07_threads/00_intro.md:13
msgid "`Send` and `Sync`, the traits that encode Rust's concurrency guarantees"
msgstr "`Send`와 `Sync`, Rust의 동시성을 보장하는 트레잇"

#: src/07_threads/00_intro.md:15
msgid ""
"We'll also discuss various design patterns for multithreaded systems and some "
"of their trade-offs."
msgstr ""
"또한 멀티 스레드 시스템의 다양한 디자인 패턴과 그 장단점에 대해서도 논의할 것"
"입니다."

#: src/07_threads/00_intro.md:19
msgid ""
"The exercise for this section is located in [`07_threads/00_intro`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/00_intro)"
msgstr ""
"이 섹션의 예제는 [`07_threads/00_intro`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/00_intro)에 있습니다"

#: src/07_threads/01_threads.md:3
msgid ""
"Before we start writing multithreaded code, let's take a step back and talk "
"about what threads are and why we might want to use them."
msgstr ""
"멀티스레드 코드 작성을 시작하기 전에 한발 물러서서 스레드가 무엇인지, 왜 스레"
"드를 사용하려는지에 대해 이야기해 보겠습니다."

#: src/07_threads/01_threads.md:6
msgid "What is a thread?"
msgstr "스레드란 무엇일까요?"

#: src/07_threads/01_threads.md:8
msgid ""
"A **thread** is an execution context managed by the underlying operating "
"system.  \n"
"Each thread has its own stack, instruction pointer, and program counter."
msgstr ""
"**스레드**는 기본 운영 체제에서 관리하는 실행 컨텍스트입니다.  \n"
"각 스레드에는 자체 스택, 명령 포인터 및 프로그램 카운터가 있습니다."

#: src/07_threads/01_threads.md:11
msgid ""
"A single **process** can manage multiple threads. These threads share the "
"same memory space, which means they can access the same data."
msgstr ""
"단일 **프로세스**는 여러 스레드를 관리할 수 있습니다. 이러한 스레드는 동일한 "
"메모리 공간을 공유하므로 동일한 데이터에 액세스할 수 있습니다."

#: src/07_threads/01_threads.md:14
msgid ""
"Threads are a **logical** construct. In the end, you can only run one set of "
"instructions at a time on a CPU core, the **physical** execution unit.  \n"
"Since there can be many more threads than there are CPU cores, the operating "
"system's **scheduler** is in charge of deciding which thread to run at any "
"given time, partitioning CPU time among them to maximize throughput and "
"responsiveness."
msgstr ""
"스레드는 **논리적** 구조입니다. 결국 CPU 코어, 즉 **물리적** 실행 단위에서는 "
"한 번에 하나의 명령어 세트만 실행할 수 있습니다.  \n"
"CPU 코어보다 더 많은 스레드가 있을 수 있으므로 운영 체제의 **스케줄러**는 주어"
"진 시간에 실행할 스레드를 결정하고 처리량과 응답성을 최대화하기 위해 스레드 간"
"에 CPU 시간을 분할하는 일을 담당합니다."

#: src/07_threads/01_threads.md:20
msgid "`main`"
msgstr "`main`"

#: src/07_threads/01_threads.md:22
msgid ""
"When a Rust program starts, it runs on a single thread, the **main "
"thread**.  \n"
"This thread is created by the operating system and is responsible for running "
"the `main` function."
msgstr ""
"Rust 프로그램이 시작되면 단일 스레드인 **메인 스레드**에서 실행됩니다.  \n"
"이 스레드는 운영 체제에 의해 생성되며 `main` 함수 실행을 담당합니다."

#: src/07_threads/01_threads.md:33 src/07_threads/01_threads.md:63
msgid "\"Hello from the main thread!\""
msgstr "\"Hello from the main thread!\""

#: src/07_threads/01_threads.md:38
msgid "`std::thread`"
msgstr "`std::thread`"

#: src/07_threads/01_threads.md:40
msgid ""
"Rust's standard library provides a module, `std::thread`, that allows you to "
"create and manage threads."
msgstr ""
"Rust의 표준 라이브러리는 스레드를 생성하고 관리할 수 있는 `std::thread` 모듈"
"을 제공합니다."

#: src/07_threads/01_threads.md:43
msgid "`spawn`"
msgstr "`spawn`"

#: src/07_threads/01_threads.md:45
msgid ""
"You can use `std::thread::spawn` to create new threads and execute code on "
"them."
msgstr ""
"`std::thread::spawn`을 사용하여 새 스레드를 생성하고 해당 스레드에서 코드를 실"
"행할 수 있습니다."

#: src/07_threads/01_threads.md:57 src/07_threads/01_threads.md:85
#: src/07_threads/01_threads.md:105
msgid "\"Hello from a thread!\""
msgstr "\"Hello from a thread!\""

#: src/07_threads/01_threads.md:68
msgid ""
"If you execute this program on the [Rust playground](https://play.rust-lang."
"org/?"
"version=stable&mode=debug&edition=2021&gist=afedf7062298ca8f5a248bc551062eaa) "
"you'll see that the main thread and the spawned thread run concurrently.  \n"
"Each thread makes progress independently of the other."
msgstr ""
"[Rust playground](https://play.rust-lang.org/?"
"version=stable&mode=debug&edition=2021&gist=afedf7062298ca8f5a248bc551062eaa)"
"에서 이 프로그램을 실행하면 메인 스레드와 생성된 스레드가 동시에 실행되는 것"
"을 볼 수 있습니다.  \n"
"각 스레드는 서로 독립적으로 진행됩니다."

#: src/07_threads/01_threads.md:72
msgid "Process termination"
msgstr "프로세스 종료"

#: src/07_threads/01_threads.md:74
msgid ""
"When the main thread finishes, the overall process will exit.  \n"
"A spawned thread will continue running until it finishes or the main thread "
"finishes."
msgstr ""
"메인 스레드가 완료되면 전체 프로세스가 종료됩니다.  \n"
"생성된 스레드는 완료되거나 메인 스레드가 종료될 때까지 계속 실행됩니다."

#: src/07_threads/01_threads.md:93
msgid ""
"In the example above, you can expect to see the message \"Hello from a thread!"
"\" printed roughly five times.  \n"
"Then the main thread will finish (when the `sleep` call returns), and the "
"spawned thread will be terminated since the overall process exits."
msgstr ""
"위의 예에서는 \"Hello from a thread!\"라는 메시지가 표시될 것으로 예상할 수 있"
"습니다. 대략 5번 정도 프린트되었습니다.  \n"
"그런 다음 메인 스레드가 종료되고(`sleep` 호출이 반환될 때) 전체 프로세스가 종"
"료되므로 생성된 스레드가 종료됩니다."

#: src/07_threads/01_threads.md:97
msgid "`join`"
msgstr "`join`"

#: src/07_threads/01_threads.md:99
msgid ""
"You can also wait for a spawned thread to finish by calling the `join` method "
"on the `JoinHandle` that `spawn` returns."
msgstr ""
"또한 `spawn`이 반환하는 `JoinHandle`에서 `join` 메서드를 호출하여 생성된 스레"
"드가 완료될 때까지 기다릴 수도 있습니다."

#: src/07_threads/01_threads.md:112
msgid ""
"In this example, the main thread will wait for the spawned thread to finish "
"before exiting.  \n"
"This introduces a form of **synchronization** between the two threads: you're "
"guaranteed to see the message \"Hello from a thread!\" printed before the "
"program exits, because the main thread won't exit until the spawned thread "
"has finished."
msgstr ""
"이 예에서 기본 스레드는 종료되기 전에 생성된 스레드가 완료될 때까지 기다립니"
"다.  \n"
"이렇게 하면 두 스레드 간에 일종의 **동기화**가 도입됩니다. 즉, \"Hello from a "
"thread!\"라는 메시지가 표시됩니다. 생성된 스레드가 완료될 때까지 메인 스레드"
"가 종료되지 않기 때문에 프로그램이 종료되기 전에 프린트됩니다."

#: src/07_threads/01_threads.md:119
msgid ""
"The exercise for this section is located in [`07_threads/01_threads`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/01_threads)"
msgstr ""
"이 섹션의 예제는 [`07_threads/01_threads`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/01_threads)에 있습니다"

#: src/07_threads/02_static.md:1
msgid "`'static`"
msgstr "`'static`"

#: src/07_threads/02_static.md:3
msgid ""
"If you tried to borrow a slice from the vector in the previous exercise, you "
"probably got a compiler error that looks something like this:"
msgstr ""
"이전 연습에서 벡터의 슬라이스를 차용하려고 시도했다면 아마도 다음과 같은 컴파"
"일러 오류가 발생했을 것입니다:"

#: src/07_threads/02_static.md:21
msgid "`argument requires that v is borrowed for 'static`, what does that mean?"
msgstr "`argument requires that v is borrowed for 'static`. 이게 무슨 말일까요?"

#: src/07_threads/02_static.md:23
msgid ""
"The `'static` lifetime is a special lifetime in Rust.  \n"
"It means that the value will be valid for the entire duration of the program."
msgstr ""
"`'static` 수명은 Rust에서 특별한 수명입니다.  \n"
"이는 해당 값이 프로그램 전체 기간 동안 유효함을 의미합니다."

#: src/07_threads/02_static.md:26
msgid "Detached threads"
msgstr "분리된 스레드"

#: src/07_threads/02_static.md:28
msgid ""
"A thread launched via `thread::spawn` can **outlive** the thread that spawned "
"it.  \n"
"For example:"
msgstr ""
"`thread::spawn`을 통해 시작된 스레드는 이를 생성한 스레드보다 **오래 살아**있"
"을 수 있습니다.  \n"
"예시:"

#: src/07_threads/02_static.md:39
msgid "\"Hello from the detached thread!\""
msgstr "\"Hello from the detached thread!\""

#: src/07_threads/02_static.md:46
msgid ""
"In this example, the first spawned thread will in turn spawn a child thread "
"that prints a message every second.  \n"
"The first thread will then finish and exit. When that happens, its child "
"thread will **continue running** for as long as the overall process is "
"running.  \n"
"In Rust's lingo, we say that the child thread has **outlived** its parent."
msgstr ""
"이 예시에서 첫 번째 생성된 스레드는 매초 메시지를 프린트하는 하위 스레드를 생"
"성합니다.  \n"
"그러면 첫 번째 스레드가 완료되고 종료됩니다. 그런 일이 발생하면 해당 하위 스레"
"드는 전체 프로세스가 실행되는 동안 **계속 실행**됩니다.  \n"
"Rust의 용어에서는 하위 스레드가 상위 스레드보다 **오래 살았다(outlived)**고 말"
"합니다."

#: src/07_threads/02_static.md:56
msgid "Since a spawned thread can:"
msgstr "생성된 스레드는 다음과 같은 것이 가능하기때문에:"

#: src/07_threads/02_static.md:58
msgid "outlive the thread that spawned it (its parent thread)"
msgstr "자신을 생성한 스레드(상위 스레드)보다 오래 살 수 있음"

#: src/07_threads/02_static.md:59
msgid "run until the program exits"
msgstr "프로그램이 종료될 때까지 실행됨"

#: src/07_threads/02_static.md:61
msgid ""
"it must not borrow any values that might be dropped before the program exits; "
"violating this constraint would expose us to a use-after-free bug.  \n"
"That's why `std::thread::spawn`'s signature requires that the closure passed "
"to it has the `'static` lifetime:"
msgstr ""
"그 함수가 종료되기 전에 삭제될 수 있는 어떤 값도 차용할 수 없습니다. 이 제약"
"을 위반하면 사용 후 메모리 해제 후에도 사용할 수 있는 버그가 발생할 수 있습니"
"다.\n"
"그것이 `std::thread::spawn`의 시그니처가 전달된 클로저가 `'static` 수명을 가져"
"야 한다고 요구하는 이유입니다:"

#: src/07_threads/02_static.md:72
msgid "// [..]\n"
msgstr "// [..]\n"

#: src/07_threads/02_static.md:76
msgid "`'static` is not (just) about references"
msgstr "``static'은 (그냥) 참조에 관한 것이 아닙니다"

#: src/07_threads/02_static.md:78
msgid "All values in Rust have a lifetime, not just references."
msgstr "Rust의 모든 값에는 참조뿐만 아니라 수명이 있습니다."

#: src/07_threads/02_static.md:80
msgid ""
"In particular, a type that owns its data (like a `Vec` or a `String`) "
"satisfies the `'static` constraint: if you own it, you can keep working with "
"it for as long as you want, even after the function that originally created "
"it has returned."
msgstr ""
"특히, 데이터를 소유한 타입(예: `Vec` 또는 `String`)은 `'static` 제약 조건을 충"
"족합니다. 이를 소유하고 있으면 원하는 만큼 계속 작업할 수 있습니다. 원래 생성"
"한 함수가 반환되더라도 말입니다."

#: src/07_threads/02_static.md:85
msgid "You can thus interpret `'static` as a way to say:"
msgstr "따라서 `'static`을 다음과 같이 해석할 수 있습니다:"

#: src/07_threads/02_static.md:87
msgid "Give me an owned value"
msgstr "나에게 소유권이 있는 값을 주세요"

#: src/07_threads/02_static.md:88
msgid "Give me a reference that's valid for the entire duration of the program"
msgstr "프로그램 전체 기간 동안 유효한 참조를 제공해 주세요"

#: src/07_threads/02_static.md:90
msgid ""
"The first approach is how you solved the issue in the previous exercise: by "
"allocating new vectors to hold the left and right parts of the original "
"vector, which were then moved into the spawned threads."
msgstr ""
"첫 번째 접근 방식은 이전 연습에서 문제를 해결한 방법입니다. 즉, 원래 벡터의 왼"
"쪽과 오른쪽 부분을 유지하기 위해 새 벡터를 할당한 다음 생성된 스레드로 보내 "
"준 것입니다."

#: src/07_threads/02_static.md:94
msgid "`'static` references"
msgstr "`'static` 참조"

#: src/07_threads/02_static.md:96
msgid ""
"Let's talk about the second case, references that are valid for the entire "
"duration of the program."
msgstr ""
"프로그램 전체 기간 동안 유효한 참조인 두 번째 케이스에 대해 이야기해 보겠습니"
"다."

#: src/07_threads/02_static.md:99
msgid "Static data"
msgstr "정적 데이터"

#: src/07_threads/02_static.md:101
msgid ""
"The most common case is a reference to **static data**, such as string "
"literals:"
msgstr ""
"가장 일반적인 경우는 문자열 리터럴과 같은 **정적 데이터**에 대한 참조입니다:"

#: src/07_threads/02_static.md:104
msgid "\"Hello world!\""
msgstr "\"Hello world!\""

#: src/07_threads/02_static.md:107
msgid ""
"Since string literals are known at compile-time, Rust stores them _inside_ "
"your executable, in a region known as **read-only data segment**. All "
"references pointing to that region will therefore be valid for as long as the "
"program runs; they satisfy the `'static` contract."
msgstr ""
"문자열 리터럴은 컴파일 시점에서 알려져 있기 때문에, Rust는 이들을 실행파일 _내"
"부의_ **읽기 전용 데이터 세그먼트**에 저장합니다. 따라서 그 영역을 가리키는 모"
"든 참조는 프로그램이 실행되는 동안 유효할 것입니다. 이는 `'static` 조건을 만족"
"시킵니다."

#: src/07_threads/02_static.md:114
msgid "[The data segment](https://en.wikipedia.org/wiki/Data_segment)"
msgstr "[The data segment](https://en.wikipedia.org/wiki/Data_segment)"

#: src/07_threads/02_static.md:118
msgid ""
"The exercise for this section is located in [`07_threads/02_static`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/02_static)"
msgstr ""
"이 섹션의 예제는 [`07_threads/02_static`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/02_static)에 있습니다"

#: src/07_threads/03_leak.md:1
msgid "Leaking data"
msgstr "데이터 유출"

#: src/07_threads/03_leak.md:3
msgid ""
"The main concern around passing references to spawned threads is use-after-"
"free bugs: accessing data using a pointer to a memory region that's already "
"been freed/de-allocated.  \n"
"If you're working with heap-allocated data, you can avoid the issue by "
"telling Rust that you'll never reclaim that memory: you choose to **leak "
"memory**, intentionally."
msgstr ""
"생성된 스레드에 대한 참조 전달과 관련된 주요 관심사는 use-after-free 버그입니"
"다. 즉, 이미 해제/할당 해제된 메모리 영역에 대한 포인터를 사용하여 데이터에 액"
"세스하는 것입니다.  \n"
"힙 할당 데이터로 작업하는 경우 Rust에 해당 메모리를 절대 회수하지 않을 것이라"
"고 알려줌으로써 문제를 피할 수 있습니다. 의도적으로 **메모리 누수**를 발생시키"
"는겁니다."

#: src/07_threads/03_leak.md:9
msgid ""
"This can be done, for example, using the `Box::leak` method from Rust's "
"standard library:"
msgstr ""
"예를 들어 Rust의 표준 라이브러리에 있는 `Box::leak` 메서드를 사용하면 이 작업"
"을 수행할 수 있습니다:"

#: src/07_threads/03_leak.md:12
msgid "// Allocate a `u32` on the heap, by wrapping it in a `Box`.\n"
msgstr "// `u32`를 `Box`로 감싸서 힙에 할당합니다.\n"

#: src/07_threads/03_leak.md:13
msgid ""
"// Tell Rust that you'll never free that heap allocation\n"
"// using `Box::leak`. You can thus get back a 'static reference.\n"
msgstr ""
"// `Box::leak`을 사용하여 해당 힙 할당을 해제하지 않을 것이라고\n"
"// Rust에 알립니다. 따라서 'static 참조를 얻을 수 있습니다.\n"

#: src/07_threads/03_leak.md:19
msgid "Data leakage is process-scoped"
msgstr "데이터 유출은 프로세스 스코프에 속합니다."

#: src/07_threads/03_leak.md:21
msgid ""
"Leaking data is dangerous: if you keep leaking memory, you'll eventually run "
"out and crash with an out-of-memory error."
msgstr ""
"데이터 누출은 위험합니다. 메모리 누출이 계속되면 결국 메모리 부족 오류로 인해 "
"메모리가 부족해지고 크래시가 발생하게됩니다."

#: src/07_threads/03_leak.md:25
msgid ""
"// If you leave this running for a while, \n"
"// it'll eventually use all the available memory.\n"
msgstr ""
"// 한동안 실행 상태로 놔두면\n"
"// 결국 사용 가능한 메모리를 모두 사용하게 됩니다.\n"

#: src/07_threads/03_leak.md:35
msgid ""
"At the same time, memory leaked via `Box::leak` is not truly forgotten.  \n"
"The operating system can map each memory region to the process responsible "
"for it. When the process exits, the operating system will reclaim that memory."
msgstr ""
"동시에 `Box::leak`을 통해 유출된 메모리는 완전히 잊혀지지 않습니다.  \n"
"운영 체제는 각 메모리 영역을 해당 영역을 담당하는 프로세스에 매핑할 수 있습니"
"다. 프로세스가 종료되면 운영 체제는 해당 메모리를 회수합니다."

#: src/07_threads/03_leak.md:39
msgid "Keeping this in mind, it can be OK to leak memory when:"
msgstr "이 점을 염두에 두고 다음과 같은 경우 메모리 누수가 허용될 수 있습니다:"

#: src/07_threads/03_leak.md:41
msgid "The amount of memory you need to leak is not unbounded/known upfront, or"
msgstr "누수해야 하는 메모리 양이 유한하거나/양을 알고있을 때, 혹은"

#: src/07_threads/03_leak.md:42
msgid ""
"Your process is short-lived and you're confident you won't exhaust all the "
"available memory before it exits"
msgstr ""
"프로세스의 수명이 짧고 종료되기 전에 사용 가능한 메모리가 모두 소진되지 않을 "
"것이라고 확신할 때"

#: src/07_threads/03_leak.md:45
msgid ""
"\"Let the OS deal with it\" is a perfectly valid memory management strategy "
"if your usecase allows for it."
msgstr ""
"\"OS가 처리하게 하라\"는 사용 사례가 허용하는 경우 완벽하게 유효한 메모리 관"
"리 전략입니다."

#: src/07_threads/03_leak.md:50
msgid ""
"The exercise for this section is located in [`07_threads/03_leak`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/03_leak)"
msgstr ""
"이 섹션의 예제는 [`07_threads/03_leak`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/03_leak)에 있습니다"

#: src/07_threads/04_scoped_threads.md:3
msgid ""
"All the lifetime issues we discussed so far have a common source: the spawned "
"thread can outlive its parent.  \n"
"We can sidestep this issue by using **scoped threads**."
msgstr ""
"지금까지 논의한 모든 수명 문제에는 공통된 원인이 있습니다. 즉, 생성된 스레드"
"가 상위 스레드보다 오래 지속될 수 있다는 것입니다.  \n"
"**범위 스레드**를 사용하면 이 문제를 피할 수 있습니다."

#: src/07_threads/04_scoped_threads.md:14 src/07_threads/04_scoped_threads.md:47
msgid "\"Here's the first half of v: {first:?}\""
msgstr "\"Here's the first half of v: {first:?}\""

#: src/07_threads/04_scoped_threads.md:18 src/07_threads/04_scoped_threads.md:51
msgid "\"Here's the second half of v: {second:?}\""
msgstr "\"Here's the second half of v: {second:?}\""

#: src/07_threads/04_scoped_threads.md:22 src/07_threads/04_scoped_threads.md:57
msgid "\"Here's v: {v:?}\""
msgstr "\"Here's v: {v:?}\""

#: src/07_threads/04_scoped_threads.md:25
msgid "Let's unpack what's happening."
msgstr "무슨 일이 일어나고 있는지 파헤쳐봅시다."

#: src/07_threads/04_scoped_threads.md:27
msgid "`scope`"
msgstr "`scope`"

#: src/07_threads/04_scoped_threads.md:29
msgid ""
"The `std::thread::scope` function creates a new **scope**.  \n"
"`std::thread::scope` takes as input a closure, with a single argument: a "
"`Scope` instance."
msgstr ""
"`std::thread::scope` 함수는 새로운 **스코프**를 생성합니다.  \n"
"`std::thread::scope`는 단일 인수인 `Scope` 인스턴스와 함께 클로저를 인풋으로 "
"사용합니다."

#: src/07_threads/04_scoped_threads.md:32
msgid "Scoped spawns"
msgstr "Scoped spawns"

#: src/07_threads/04_scoped_threads.md:34
msgid ""
"`Scope` exposes a `spawn` method.  \n"
"Unlike `std::thread::spawn`, all threads spawned using a `Scope` will be "
"**automatically joined** when the scope ends."
msgstr ""
"`Scope`는 `spawn` 메서드를 제공합니다.  \n"
"`std::thread::spawn`과 달리 `Scope`를 사용하여 생성된 모든 스레드는 범위가 끝"
"나면 **자동으로 조인**됩니다."

#: src/07_threads/04_scoped_threads.md:38
msgid ""
"If we were to \"translate\" the previous example to `std::thread::spawn`, "
"it'd look like this:"
msgstr ""
"이전 예제를 `std::thread::spawn`으로 \"번역\"한다면 다음과 같을 것입니다:"

#: src/07_threads/04_scoped_threads.md:60
msgid "Borrowing from the environment"
msgstr "환경에서 차용하기"

#: src/07_threads/04_scoped_threads.md:62
msgid ""
"The translated example wouldn't compile, though: the compiler would complain "
"that `&v` can't be used from our spawned threads since its lifetime isn't "
"`'static`."
msgstr ""
"하지만 번역된 예제는 컴파일되지 않습니다. 컴파일러는 수명이 `'static`이 아니"
"기 때문에 생성된 스레드에서 `&v`를 사용할 수 없다고 불평합니다."

#: src/07_threads/04_scoped_threads.md:66
msgid ""
"That's not an issue with `std::thread::scope`—you can **safely borrow from "
"the environment**."
msgstr ""
"이는 `std::thread::scope`에서는 문제가 되지 않습니다. **환경에서 안전하게 빌"
"릴 수 있습니다**."

#: src/07_threads/04_scoped_threads.md:68
msgid ""
"In our example, `v` is created before the spawning points. It will only be "
"dropped _after_ `scope` returns. At the same time, all threads spawned inside "
"`scope` are guaranteed to finish _before_ `scope` returns, therefore there is "
"no risk of having dangling references."
msgstr ""
"이 예에서는 `v`가 생성 지점 앞에 생성됩니다. `scope`가 반환된 _이후_에만 삭제"
"됩니다. 동시에 `scope` 내부에 생성된 모든 스레드는 `scope`가 반환되기 _전에_ "
"완료가 보장되므로 댕글링 포인터가 생길 위험이 없습니다."

#: src/07_threads/04_scoped_threads.md:73
msgid "The compiler won't complain!"
msgstr "컴파일러는 불평하지 않을 것입니다!"

#: src/07_threads/04_scoped_threads.md:77
msgid ""
"The exercise for this section is located in [`07_threads/04_scoped_threads`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/04_scoped_threads)"
msgstr ""
"이 섹션의 예제는 [`07_threads/04_scoped_threads`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/04_scoped_threads)에 있습니다"

#: src/07_threads/05_channels.md:3
msgid ""
"All our spawned threads have been fairly short-lived so far.  \n"
"Get some input, run a computation, return the result, shut down."
msgstr ""
"우리가 생성한 모든 스레드는 지금까지 상당히 수명이 짧았습니다.  \n"
"입력을 받고, 계산을 실행하고, 결과를 반환하고, 종료합니다."

#: src/07_threads/05_channels.md:6
msgid ""
"For our ticket management system, we want to do something different: a client-"
"server architecture."
msgstr ""
"티켓 관리 시스템의 경우 클라이언트-서버 아키텍처라는 다른 작업을 수행하려고 합"
"니다."

#: src/07_threads/05_channels.md:9
msgid ""
"We will have **one long-running server thread**, responsible for managing our "
"state, the stored tickets."
msgstr ""
"우리는 상태, 저장된 티켓 관리를 담당하는 **하나의 장기 실행 서버 스레드**를 갖"
"게 됩니다."

#: src/07_threads/05_channels.md:12
msgid ""
"We will then have **multiple client threads**.  \n"
"Each client will be able to send **commands** and **queries** to the stateful "
"thread, in order to change its state (e.g. add a new ticket) or retrieve "
"information (e.g. get the status of a ticket).  \n"
"Client threads will run concurrently."
msgstr ""
"그러면 **여러 클라이언트 스레드**가 생성됩니다.  \n"
"각 클라이언트는 상태를 변경(예: 새 티켓 추가)하거나 정보를 검색(예: 티켓 상태 "
"가져오기)하기 위해 상태 저장 스레드에 **명령** 및 **쿼리**를 보낼 수 있습니"
"다.  \n"
"클라이언트 스레드들은 동시에 실행될겁니다."

#: src/07_threads/05_channels.md:18
msgid "Communication"
msgstr "커뮤니케이션"

#: src/07_threads/05_channels.md:20
msgid "So far we've only had very limited parent-child communication:"
msgstr "지금까지 우리는 부모-자식 커뮤니케이션이 매우 제한적이었습니다:"

#: src/07_threads/05_channels.md:22
msgid "The spawned thread borrowed/consumed data from the parent context"
msgstr "생성된 스레드는 상위 컨텍스트에서 데이터를 차용/소비했습니다"

#: src/07_threads/05_channels.md:23
msgid "The spawned thread returned data to the parent when joined"
msgstr "생성된 스레드는 조인 시 상위 스레드에 데이터를 반환했습니다"

#: src/07_threads/05_channels.md:25
msgid ""
"This isn't enough for a client-server design.  \n"
"Clients need to be able to send and receive data from the server thread "
"_after_ it has been launched."
msgstr ""
"클라이언트-서버 설계에는 이것만으로는 충분하지 않습니다.  \n"
"클라이언트는 서버 스레드가 시작된 _후_ 서버 스레드에 데이터를 보내고 받을 수 "
"있어야 합니다."

#: src/07_threads/05_channels.md:29
msgid "We can solve the issue using **channels**."
msgstr "**채널**을 사용하여 문제를 해결할 수 있습니다."

#: src/07_threads/05_channels.md:33
msgid ""
"Rust's standard library provides **multi-producer, single-consumer** (mpsc) "
"channels in its `std::sync::mpsc` module.  \n"
"There are two channel flavours: bounded and unbounded. We'll stick to the "
"unbounded version for now, but we'll discuss the pros and cons later on."
msgstr ""
"Rust의 표준 라이브러리는 `std::sync::mpsc` 모듈에서 **다중 생산자, 단일 소비자"
"**(mpsc) 채널을 제공합니다.  \n"
"채널에는 제한된 채널과 무제한 채널의 두 가지 타입이 있습니다. 지금은 무제한 버"
"전을 고수하겠지만 장단점에 대해서는 나중에 논의하겠습니다."

#: src/07_threads/05_channels.md:38
msgid "Channel creation looks like this:"
msgstr "채널 생성은 다음과 같습니다:"

#: src/07_threads/05_channels.md:46
msgid ""
"You get a sender and a receiver.  \n"
"You call `send` on the sender to push data into the channel.  \n"
"You call `recv` on the receiver to pull data from the channel."
msgstr ""
"발신자와 수신자를 얻습니다.  \n"
"데이터를 채널에 푸시하려면 발신자에서 `send`를 호출합니다.  \n"
"채널에서 데이터를 가져오려면 수신기에서 `recv`를 호출합니다."

#: src/07_threads/05_channels.md:50
msgid "Multiple senders"
msgstr "여러 발신자"

#: src/07_threads/05_channels.md:52
msgid ""
"`Sender` is clonable: we can create multiple senders (e.g. one for each "
"client thread) and they will all push data into the same channel."
msgstr ""
"`Sender`는 복제 가능합니다. 여러 개의 발신자를 생성할 수 있으며(예: 각 클라이"
"언트 스레드에 대해 하나씩) 모두 동일한 채널에 데이터를 푸시합니다."

#: src/07_threads/05_channels.md:55
msgid ""
"`Receiver`, instead, is not clonable: there can only be a single receiver for "
"a given channel."
msgstr ""
"대신 `수신기`는 복제할 수 없습니다. 특정 채널에 대해 단일 수신기만 있을 수 있"
"습니다."

#: src/07_threads/05_channels.md:58
msgid "That's what **mpsc** (multi-producer single-consumer) stands for!"
msgstr "이것이 **mpsc**(다중 생산자 단일 소비자)가 의미하는 것입니다!"

#: src/07_threads/05_channels.md:60
msgid "Message type"
msgstr "메시지 타입"

#: src/07_threads/05_channels.md:62
msgid ""
"Both `Sender` and `Receiver` are generic over a type parameter `T`.  \n"
"That's the type of the _messages_ that can travel on our channel."
msgstr ""
"`Sender`와 `Receiver`는 모두 타입 매개변수 `T`로 일반화됩니다.  \n"
"이것이 바로 우리 채널을 통해 전달될 수 있는 _메시지_ 타입입니다."

#: src/07_threads/05_channels.md:65
msgid "It could be a `u64`, a struct, an enum, etc."
msgstr "`u64`, 구조체, 열거형 등이 될 수 있습니다."

#: src/07_threads/05_channels.md:67
msgid "Errors"
msgstr "에러"

#: src/07_threads/05_channels.md:69
msgid ""
"Both `send` and `recv` can fail.  \n"
"`send` returns an error if the receiver has been dropped.  \n"
"`recv` returns an error if all senders have been dropped and the channel is "
"empty."
msgstr ""
"`send`와 `recv` 모두 실패할 수 있습니다.  \n"
"`send`는 수신자가 삭제된 경우 오류를 반환합니다.  \n"
"모든 발신자가 삭제되고 채널이 비어 있으면 `recv`는 오류를 반환합니다."

#: src/07_threads/05_channels.md:73
msgid ""
"In other words, `send` and `recv` error when the channel is effectively "
"closed."
msgstr "즉, 사실상 채널이 닫힐 때 `send`와 `recv`는 오류를 발생시킵니다."

#: src/07_threads/05_channels.md:77
msgid ""
"The exercise for this section is located in [`07_threads/05_channels`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/05_channels)"
msgstr ""
"이 섹션의 예제는 [`07_threads/05_channels`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/05_channels)에 있습니다"

#: src/07_threads/06_interior_mutability.md:3
msgid "Let's take a moment to reason about the signature of `Sender`'s `send`:"
msgstr "`Sender`의 `send` 시그니처에 대해 잠시 생각해 봅시다:"

#: src/07_threads/06_interior_mutability.md:13
msgid ""
"`send` takes `&self` as its argument.  \n"
"But it's clearly causing a mutation: it's adding a new message to the "
"channel. What's even more interesting is that `Sender` is cloneable: we can "
"have multiple instances of `Sender` trying to modify the channel state **at "
"the same time**, from different threads."
msgstr ""
"`send`는 `&self`를 인수로 사용합니다.  \n"
"그러나 이는 분명히 변형을 일으키고 있습니다. 즉, 채널에 새 메시지를 추가하는 "
"것입니다. 더욱 흥미로운 점은 `Sender`가 복제 가능하다는 것입니다. 서로 다른 스"
"레드에서 **동시에** 채널 상태를 수정하려고 시도하는 `Sender`의 여러 인스턴스"
"가 있을 수 있습니다."

#: src/07_threads/06_interior_mutability.md:18
msgid ""
"That's the key property we are using to build this client-server "
"architecture. But why does it work? Doesn't it violate Rust's rules about "
"borrowing? How are we performing mutations via an _immutable_ reference?"
msgstr ""
"이것이 바로 우리가 클라이언트-서버 아키텍처를 구축하는 데 사용하는 핵심 속성입"
"니다. 그런데 왜 이게 가능할까요? 차용에 관한 Rust의 규칙을 위반하지 않나요? _"
"불변_ 참조를 통해 변형을 일으킬 수 있을까요?"

#: src/07_threads/06_interior_mutability.md:21
msgid "Shared rather than immutable references"
msgstr "불변 참조가 아닌 공유 참조"

#: src/07_threads/06_interior_mutability.md:23
msgid ""
"When we introduced the borrow-checker, we named the two types of references "
"we can have in Rust:"
msgstr ""
"차용 검사기를 도입했을 때 우리는 Rust에서 가질 수 있는 참조 타입을 두 가지로 "
"명명했습니다:"

#: src/07_threads/06_interior_mutability.md:25
msgid "immutable references (`&T`)"
msgstr "불변 참조 (`&T`)"

#: src/07_threads/06_interior_mutability.md:26
msgid "mutable references (`&mut T`)"
msgstr "변경 가능한 참조 (`&mut T`)"

#: src/07_threads/06_interior_mutability.md:28
msgid "It would have been more accurate to name them:"
msgstr "이런 이름을 지어주는 것이 더 정확할겁니다:"

#: src/07_threads/06_interior_mutability.md:30
msgid "shared references (`&T`)"
msgstr "공유 참조 (`&T`)"

#: src/07_threads/06_interior_mutability.md:31
msgid "exclusive references (`&mut T`)"
msgstr "독점 참조 (`&mut T`)"

#: src/07_threads/06_interior_mutability.md:33
msgid ""
"Immutable/mutable is a mental model that works for the vast majority of "
"cases, and it's a great one to get started with Rust. But it's not the whole "
"story, as you've just seen: `&T` doesn't actually guarantee that the data it "
"points to is immutable.  \n"
"Don't worry, though: Rust is still keeping its promises. It's just that the "
"terms are a bit more nuanced than they might seem at first."
msgstr ""
"불변/변경 가능은 대부분의 경우에 작동하는 정신 모델이며 Rust를 시작하기에 좋"
"은 모델입니다. 하지만 방금 본 것처럼 이것이 전부는 아닙니다. `&T`는 실제로 가"
"리키는 데이터가 불변임을 보장하지 않습니다.  \n"
"하지만 걱정하지 마십시오. Rust는 여전히 약속을 지키고 있습니다. 단지 용어가 처"
"음에 보이는 것보다 조금 더 미묘하다는 것뿐입니다."

#: src/07_threads/06_interior_mutability.md:39
msgid "`UnsafeCell`"
msgstr "`UnsafeCell`"

#: src/07_threads/06_interior_mutability.md:41
msgid ""
"Whenever a type allows you to mutate data through a shared reference, you're "
"dealing with **interior mutability**."
msgstr ""
"타입이 공유 참조를 통해 데이터를 변경할 수 있도록 허용할 때마다 **내부 변경 가"
"능성**을 다루고 있는 것입니다."

#: src/07_threads/06_interior_mutability.md:43
msgid ""
"By default, the Rust compiler assumes that shared references are immutable. "
"It **optimises your code** based on that assumption.  \n"
"The compiler can reorder operations, cache values, and do all sorts of magic "
"to make your code faster."
msgstr ""
"기본적으로 Rust 컴파일러는 공유 참조가 불변이라고 가정합니다. 해당 가정을 기반"
"으로 **코드를 최적화**합니다.  \n"
"컴파일러는 작업 순서를 변경하고 값을 캐시하며 모든 종류의 마법을 수행하여 코드"
"를 더 빠르게 만들 수 있습니다."

#: src/07_threads/06_interior_mutability.md:46
msgid ""
"You can tell the compiler \"No, this shared reference is actually mutable\" "
"by wrapping the data in an `UnsafeCell`.  \n"
"Every time you see a type that allows interior mutability, you can be certain "
"that `UnsafeCell` is involved, either directly or indirectly.  \n"
"Using `UnsafeCell`, raw pointers and `unsafe` code, you can mutate data "
"through shared references."
msgstr ""
"데이터를 `UnsafeCell`로 래핑하여 \"아니요, 이 공유 참조는 실제로 변경 가능합니"
"다\"라고 컴파일러에 알릴 수 있습니다.  \n"
"내부 가변성을 허용하는 유형을 볼 때마다 `UnsafeCell`이 직접적으로든 간접적으로"
"든 관련되어 있음을 확신할 수 있습니다.  \n"
"`UnsafeCell`, 원시 포인터 및 `unsafe` 코드를 사용하면 공유 참조를 통해 데이터"
"를 변경할 수 있습니다."

#: src/07_threads/06_interior_mutability.md:51
msgid ""
"Let's be clear, though: `UnsafeCell` isn't a magic wand that allows you to "
"ignore the borrow-checker!  \n"
"`unsafe` code is still subject to Rust's rules about borrowing and aliasing. "
"It's an (advanced) tool that you can leverage to build **safe abstractions** "
"whose safety can't be directly expressed in Rust's type system. Whenever you "
"use the `unsafe` keyword you're telling the compiler: \"I know what I'm "
"doing, I won't violate your invariants, trust me.\""
msgstr ""
"하지만 분명히 해두자면 `UnsafeCell`은 차용 검사기를 무시할 수 있게 해주는 마"
"술 지팡이가 아닙니다!  \n"
"`unsafe` 코드에는 여전히 차용 및 별칭에 대한 Rust의 규칙이 적용됩니다. 이는 "
"Rust의 타입 시스템에서 안전성을 직접 표현할 수 없는 **안전한 추상화**를 구축하"
"는 데 활용할 수 있는 (고급) 도구입니다. `unsafe` 키워드를 사용할 때마다 컴파일"
"러에게 다음과 같이 말하는 것입니다. \"나는 내가 무엇을 하는지 알고 있습니다. "
"나는 당신의 불변성을 위반하지 않을 것입니다. 나를 믿으십시오.\""

#: src/07_threads/06_interior_mutability.md:57
msgid ""
"Every time you call an `unsafe` function, there will be documentation "
"explaining its **safety preconditions**: under what circumstances it's safe "
"to execute its `unsafe` block. You can find the ones for `UnsafeCell` [in "
"`std`'s documentation](https://doc.rust-lang.org/std/cell/struct.UnsafeCell."
"html)."
msgstr ""
"`unsafe` 함수를 호출할 때마다 **안전 전제 조건**을 설명하는 문서가 있을겁니"
"다. 어떤 상황에서 `unsafe` 블록을 실행하는 것이 안전한지 설명합니다. [`std` 문"
"서에서](https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html) "
"`UnsafeCell`에 대한 내용을 찾을 수 있습니다."

#: src/07_threads/06_interior_mutability.md:61
msgid ""
"We won't be using `UnsafeCell` directly in this course, nor will we be "
"writing `unsafe` code. But it's important to know that it's there, why it "
"exists and how it relates to the types you use every day in Rust."
msgstr ""
"이 과정에서는 `UnsafeCell`을 직접 사용하지 않을 것이며 `unsafe` 코드를 작성하"
"지도 않을 것입니다. 하지만 그것이 존재하는지, 그것이 왜 존재하는지, 그리고 그"
"것이 Rust에서 매일 사용하는 타입과 어떻게 관련되는지를 아는 것이 중요합니다."

#: src/07_threads/06_interior_mutability.md:65
msgid "Key examples"
msgstr "주요 사례"

#: src/07_threads/06_interior_mutability.md:67
msgid ""
"Let's go through a couple of important `std` types that leverage interior "
"mutability.  \n"
"These are types that you'll encounter somewhat often in Rust code, especially "
"if you peek under the hood of some the libraries you use."
msgstr ""
"내부 가변성을 활용하는 몇 가지 중요한 `std` 타입을 살펴보겠습니다.  \n"
"이는 Rust 코드에서 다소 자주 접하게 될 유형입니다. 특히 사용하는 일부 라이브러"
"리의 내부를 들여다보면 더욱 그렇습니다."

#: src/07_threads/06_interior_mutability.md:71
msgid "Reference counting"
msgstr "참조 카운팅"

#: src/07_threads/06_interior_mutability.md:73
msgid ""
"`Rc` is a reference-counted pointer.  \n"
"It wraps around a value and keeps track of how many references to the value "
"exist. When the last reference is dropped, the value is deallocated.  \n"
"The value wrapped in an `Rc` is immutable: you can only get shared references "
"to it."
msgstr ""
"`Rc`는 참조 카운트 포인터입니다.  \n"
"이는 값을 둘러싸며 해당 값에 대한 참조 수를 추적합니다. 마지막 참조가 삭제되"
"면 값의 할당이 취소됩니다.  \n"
"`Rc`에 포함된 값은 변경할 수 없습니다: 값에 대한 공유 참조만 얻을 수 있습니다."

#: src/07_threads/06_interior_mutability.md:81
msgid "\"My string\""
msgstr "\"My string\""

#: src/07_threads/06_interior_mutability.md:81
msgid "// Only one reference to the string data exists.\n"
msgstr "// 문자열 데이터에 대한 참조는 하나만 존재합니다.\n"

#: src/07_threads/06_interior_mutability.md:84
msgid ""
"// When we call `clone`, the string data is not copied!\n"
"// Instead, the reference count for `Rc` is incremented.\n"
msgstr ""
"// `clone`을 호출하면 문자열 데이터가 복사되지 않습니다!\n"
"// 대신 `Rc`에 대한 참조 횟수가 증가합니다.\n"

#: src/07_threads/06_interior_mutability.md:89
msgid ""
"// ^ Both `a` and `b` point to the same string data\n"
"//   and share the same reference counter.\n"
msgstr ""
"// ^ `a`와 `b`는 모두 동일한 문자열 데이터를 가리키며\n"
"//   동일한 참조 카운터를 공유합니다.\n"

#: src/07_threads/06_interior_mutability.md:94
msgid ""
"`Rc` uses `UnsafeCell` internally to allow shared references to increment and "
"decrement the reference count."
msgstr ""
"`Rc`는 내부적으로 `UnsafeCell`을 사용하여 공유 참조가 참조 카운트를 늘리거나 "
"줄일 수 있도록 합니다."

#: src/07_threads/06_interior_mutability.md:96
msgid "`RefCell`"
msgstr "`RefCell`"

#: src/07_threads/06_interior_mutability.md:98
msgid ""
"`RefCell` is one of the most common examples of interior mutability in Rust. "
"It allows you to mutate the value wrapped in a `RefCell` even if you only "
"have an immutable reference to the `RefCell` itself."
msgstr ""
"RefCell은 Rust의 내부 가변성의 가장 일반적인 예 중 하나입니다. `RefCell` 자체"
"에 대한 불변 참조만 있는 경우에도 `RefCell`에 래핑된 값을 변경할 수 있습니다."

#: src/07_threads/06_interior_mutability.md:102
msgid ""
"This is done via **runtime borrow checking**. The `RefCell` keeps track of "
"the number (and type) of references to the value it contains at runtime. If "
"you try to borrow the value mutably while it's already borrowed immutably, "
"the program will panic, ensuring that Rust's borrowing rules are always "
"enforced."
msgstr ""
"이는 **런타임 차용 검사**를 통해 수행됩니다. `RefCell`은 런타임에 포함된 값에 "
"대한 참조 수(및 타입)를 추적합니다. 이미 불변적으로 빌린 값을 변경 가능하게 빌"
"리려고 하면 프로그램은 패닉 상태가 되어 Rust의 차용 규칙이 항상 시행되도록 합"
"니다."

#: src/07_threads/06_interior_mutability.md:112
msgid "// Immutable borrow\n"
msgstr "// 불변 차용\n"

#: src/07_threads/06_interior_mutability.md:113
msgid "// Panics! There is an active immutable borrow.\n"
msgstr "// 패닉! 이미 불변 차용이 존재합니다.\n"

#: src/07_threads/06_interior_mutability.md:118
msgid ""
"The exercise for this section is located in "
"[`07_threads/06_interior_mutability`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/06_interior_mutability)"
msgstr ""
"이 섹션의 예제는 [`07_threads/06_interior_mutability`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/06_interior_mutability)에 있습니다"

#: src/07_threads/07_ack.md:1
msgid "Two-way communication"
msgstr "양방향 통신"

#: src/07_threads/07_ack.md:3
msgid ""
"In our current client-server implementation, communication flows in one "
"direction: from the client to the server.  \n"
"The client has no way of knowing if the server received the message, executed "
"it successfully, or failed. That's not ideal."
msgstr ""
"현재 클라이언트-서버 구현에서 통신은 클라이언트에서 서버로 한 방향으로 흐릅니"
"다.  \n"
"클라이언트는 서버가 메시지를 받았는지, 성공적으로 실행했는지, 실패했는지 알 "
"수 없습니다. 그것은 이상적이지 않습니다."

#: src/07_threads/07_ack.md:7
msgid "To solve this issue, we can introduce a two-way communication system."
msgstr "이 문제를 해결하기 위해 양방향 통신 시스템을 도입할 수 있습니다."

#: src/07_threads/07_ack.md:9
msgid "Response channel"
msgstr "응답 채널"

#: src/07_threads/07_ack.md:11
msgid ""
"We need a way for the server to send a response back to the client.  \n"
"There are various ways to do this, but the simplest option is to include a "
"`Sender` channel in the message that the client sends to the server. After "
"processing the message, the server can use this channel to send a response "
"back to the client."
msgstr ""
"서버가 클라이언트에 응답을 다시 보낼 수 있는 방법이 필요합니다.  \n"
"이를 수행하는 방법은 다양하지만 가장 간단한 옵션은 클라이언트가 서버에 보내는 "
"메시지에 `Sender` 채널을 포함시키는 것입니다. 메시지를 처리한 후 서버는 이 채"
"널을 사용하여 클라이언트에 응답을 다시 보낼 수 있습니다."

#: src/07_threads/07_ack.md:16
msgid ""
"This is a fairly common pattern in Rust applications built on top of message-"
"passing primitives."
msgstr ""
"이는 메시지 전달 기본 요소를 기반으로 구축된 Rust 애플리케이션에서 상당히 일반"
"적인 패턴입니다."

#: src/07_threads/07_ack.md:20
msgid ""
"The exercise for this section is located in [`07_threads/07_ack`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/07_ack)"
msgstr ""
"이 섹션의 예제는 [`07_threads/07_ack`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/07_ack)에 있습니다"

#: src/07_threads/08_client.md:1
msgid "A dedicated `Client` type"
msgstr "전용 `클라이언트` 타입"

#: src/07_threads/08_client.md:3
msgid ""
"All the interactions from the client side have been fairly low-level: you "
"have to manually create a response channel, build the command, send it to the "
"server, and then call `recv` on the response channel to get the response."
msgstr ""
"클라이언트 측의 모든 상호 작용은 상당히 낮은 수준이었습니다. 수동으로 응답 채"
"널을 만들고, 명령을 빌드하고, 이를 서버로 보낸 다음 응답 채널에서 `recv`를 호"
"출하여 응답을 받아야 합니다."

#: src/07_threads/08_client.md:7
msgid ""
"This is a lot of boilerplate code that could be abstracted away, and that's "
"exactly what we're going to do in this exercise."
msgstr ""
"이것은 추상화할 수 있는 많은 상용구 코드이며 이것이 바로 우리가 이 예제에서 수"
"행할 작업입니다."

#: src/07_threads/08_client.md:12
msgid ""
"The exercise for this section is located in [`07_threads/08_client`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/08_client)"
msgstr ""
"이 섹션의 예제는 [`07_threads/08_client`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/08_client)에 있습니다"

#: src/07_threads/09_bounded.md:1
msgid "Bounded vs unbounded channels"
msgstr "제한된 채널과 무제한 채널"

#: src/07_threads/09_bounded.md:3
msgid ""
"So far we've been using unbounded channels.  \n"
"You can send as many messages as you want, and the channel will grow to "
"accommodate them.  \n"
"In a multi-producer single-consumer scenario, this can be problematic: if the "
"producers enqueues messages at a faster rate than the consumer can process "
"them, the channel will keep growing, potentially consuming all available "
"memory."
msgstr ""
"지금까지 우리는 무제한 채널을 사용해 왔습니다.  \n"
"원하는 만큼 많은 메시지를 보낼 수 있으며 채널은 메시지를 수용할 수 있도록 커집"
"니다.  \n"
"다중 생산자 단일 소비자 시나리오에서 이는 문제가 될 수 있습니다. 생산자가 소비"
"자가 처리할 수 있는 것보다 더 빠른 속도로 메시지를 대기열에 넣으면 채널이 계"
"속 성장하여 잠재적으로 사용 가능한 모든 메모리를 소비하게 됩니다."

#: src/07_threads/09_bounded.md:9
msgid ""
"Our recommendation is to **never** use an unbounded channel in a production "
"system.  \n"
"You should always enforce an upper limit on the number of messages that can "
"be enqueued using a **bounded channel**."
msgstr ""
"우리의 권장 사항은 프로덕션 시스템에서 무제한 채널을 **절대로** 사용하지 않는 "
"것입니다.  \n"
"**바운드 채널**을 사용하여 대기열에 추가할 수 있는 메시지 수에 대한 상한을 항"
"상 적용해야 합니다."

#: src/07_threads/09_bounded.md:15
msgid ""
"A bounded channel has a fixed capacity.  \n"
"You can create one by calling `sync_channel` with a capacity greater than "
"zero:"
msgstr ""
"제한된 채널에는 고정된 용량이 있습니다.  \n"
"0보다 큰 용량으로 `sync_channel`을 호출하여 채널을 생성할 수 있습니다:"

#: src/07_threads/09_bounded.md:24
msgid ""
"`receiver` has the same type as before, `Receiver<T>`.  \n"
"`sender`, instead, is an instance of `SyncSender<T>`."
msgstr ""
"`receiver`는 이전과 동일한 타입인 `Receiver<T>`를 갖습니다.  \n"
"대신 `sender`는 `SyncSender<T>`의 인스턴스입니다."

#: src/07_threads/09_bounded.md:27
msgid "Sending messages"
msgstr "메시지 보내기"

#: src/07_threads/09_bounded.md:29
msgid "You have two different methods to send messages through a `SyncSender`:"
msgstr "`SyncSender`를 통해 메시지를 보내는 방법에는 두 가지가 있습니다:"

#: src/07_threads/09_bounded.md:31
msgid ""
"`send`: if there is space in the channel, it will enqueue the message and "
"return `Ok(())`.  \n"
"If the channel is full, it will block and wait until there is space available."
msgstr ""
"`send`: 채널에 공간이 있으면 메시지를 대기열에 추가하고 `Ok(())`를 반환합니"
"다.  \n"
"채널이 가득 차면 사용 가능한 공간이 생길 때까지 차단하고 기다립니다."

#: src/07_threads/09_bounded.md:33
msgid ""
"`try_send`: if there is space in the channel, it will enqueue the message and "
"return `Ok(())`.  \n"
"If the channel is full, it will return `Err(TrySendError::Full(value))`, "
"where `value` is the message that couldn't be sent."
msgstr ""
"`try_send`: 채널에 공간이 있으면 메시지를 대기열에 추가하고 `Ok(())`를 반환합"
"니다.  \n"
"채널이 꽉 차면 `Err(TrySendError::Full(value))`를 반환합니다. 여기서 `value`"
"는 전송할 수 없는 메시지입니다."

#: src/07_threads/09_bounded.md:36
msgid "Depending on your use case, you might want to use one or the other."
msgstr "케이스에 따라 둘 중 하나를 골라 사용하면 됩니다."

#: src/07_threads/09_bounded.md:38
msgid "Backpressure"
msgstr "배압"

#: src/07_threads/09_bounded.md:40
msgid ""
"The main advantage of using bounded channels is that they provide a form of "
"**backpressure**.  \n"
"They force the producers to slow down if the consumer can't keep up. The "
"backpressure can then propagate through the system, potentially affecting the "
"whole architecture and preventing end users from overwhelming the system with "
"requests."
msgstr ""
"제한된 채널을 사용하는 주요 이점은 **배압** 형태를 제공한다는 것입니다.  \n"
"소비자가 따라잡을 수 없으면 생산자가 속도를 늦추도록 강요합니다. 그런 다음 배"
"압이 시스템을 통해 전파되어 잠재적으로 전체 아키텍처에 영향을 미치고 최종 사용"
"자가 요청으로 시스템을 압박하는 것을 방지할 수 있습니다."

#: src/07_threads/09_bounded.md:47
msgid ""
"The exercise for this section is located in [`07_threads/09_bounded`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/09_bounded)"
msgstr ""
"이 섹션의 예제는 [`07_threads/09_bounded`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/09_bounded)에 있습니다"

#: src/07_threads/10_patch.md:1
msgid "Update operations"
msgstr "업데이트 작업"

#: src/07_threads/10_patch.md:3
msgid ""
"So far we've implemented only insertion and retrieval operations.  \n"
"Let's see how we can expand the system to provide an update operation."
msgstr ""
"지금까지 우리는 삽입 및 검색 작업만 구현했습니다.  \n"
"업데이트 작업을 제공하기 위해 시스템을 어떻게 확장할 수 있는지 살펴보겠습니다."

#: src/07_threads/10_patch.md:6
msgid "Legacy updates"
msgstr "레거시 업데이트"

#: src/07_threads/10_patch.md:8
msgid ""
"In the non-threaded version of the system, updates were fairly "
"straightforward: `TicketStore` exposed a `get_mut` method that allowed the "
"caller to obtain a mutable reference to a ticket, and then modify it."
msgstr ""
"스레드되지 않은 시스템 버전에서는 업데이트가 매우 간단했습니다. `TicketStore`"
"는 호출자가 티켓에 대한 변경 가능한 참조를 얻은 다음 이를 수정할 수 있도록 하"
"는 `get_mut` 메서드를 제공했습니다."

#: src/07_threads/10_patch.md:11
msgid "Multithreaded updates"
msgstr "멀티스레드 업데이트"

#: src/07_threads/10_patch.md:13
msgid ""
"The same strategy won't work in the current multi-threaded version, because "
"the mutable reference would have to be sent over a channel. The borrow "
"checker would stop us, because `&mut Ticket` doesn't satisfy the `'static` "
"lifetime requirement of `SyncSender::send`."
msgstr ""
"변경 가능한 참조를 채널을 통해 전송해야 하기 때문에 현재 멀티 스레드 버전에서"
"는 동일한 전략이 작동하지 않습니다. 차용 검사기는 `&mut Ticket`이 "
"`SyncSender::send`의 `'static` 수명 요구 사항을 충족하지 않기 때문에 우리를 막"
"을 것입니다."

#: src/07_threads/10_patch.md:17
msgid ""
"There are a few ways to work around this limitation. We'll explore a few of "
"them in the following exercises."
msgstr ""
"이 제한 사항을 해결하는 방법에는 몇 가지가 있습니다. 다음 연습에서는 그 중 몇 "
"가지를 살펴보겠습니다."

#: src/07_threads/10_patch.md:21
msgid ""
"We can't send a `&mut Ticket` over a channel, therefore we can't mutate on "
"the client-side.  \n"
"Can we mutate on the server-side?"
msgstr ""
"채널을 통해 `&mut Ticket`을 보낼 수 없으므로 클라이언트 측에서 변경할 수 없습"
"니다.  \n"
"서버 측에서 변경할 순 없을까요?"

#: src/07_threads/10_patch.md:24
msgid ""
"We can, if we tell the server what needs to be changed. In other words, if we "
"send a **patch** to the server:"
msgstr ""
"변경해야 할 사항을 서버에 알리면 가능합니다. 즉, 서버에 **패치**를 보내는 경"
"우:"

#: src/07_threads/10_patch.md:35
msgid ""
"The `id` field is mandatory, since it's required to identify the ticket that "
"needs to be updated.  \n"
"All other fields are optional:"
msgstr ""
"`id` 필드는 업데이트해야 하는 티켓을 식별하는 데 필요하므로 필수입니다.  \n"
"다른 모든 필드는 선택사항입니다:"

#: src/07_threads/10_patch.md:38
msgid "If a field is `None`, it means that the field should not be changed."
msgstr "필드가 `None`인 경우 해당 필드를 변경해서는 안 된다는 의미입니다."

#: src/07_threads/10_patch.md:39
msgid ""
"If a field is `Some(value)`, it means that the field should be changed to "
"`value`."
msgstr ""
"필드가 `Some(value)`인 경우 해당 필드가 `value`로 변경되어야 함을 의미합니다."

#: src/07_threads/10_patch.md:43
msgid ""
"The exercise for this section is located in [`07_threads/10_patch`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/10_patch)"
msgstr ""
"이 섹션의 예제는 [`07_threads/10_patch`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/10_patch)에 있습니다"

#: src/07_threads/11_locks.md:1
msgid "Locks, `Send` and `Arc`"
msgstr "Locks, `Send` 그리고 `Arc`"

#: src/07_threads/11_locks.md:3
msgid ""
"The patching strategy you just implemented has a major drawback: it's "
"racy.  \n"
"If two clients send patches for the same ticket roughly at same time, the "
"server will apply them in an arbitrary order. Whoever enqueues their patch "
"last will overwrite the changes made by the other client."
msgstr ""
"방금 구현한 패치 전략에는 큰 단점이 있습니다. 바로 경쟁 조건이 발생할 수 있다"
"는 것입니다.  \n"
"두 클라이언트가 거의 동시에 동일한 티켓에 대한 패치를 보내는 경우 서버는 이를 "
"임의의 순서로 적용합니다. 패치를 마지막으로 대기열에 추가하는 사람은 다른 클라"
"이언트의 변경 사항을 덮어쓰게 됩니다."

#: src/07_threads/11_locks.md:7
msgid "Version numbers"
msgstr "버전 번호"

#: src/07_threads/11_locks.md:9
msgid ""
"We could try to fix this by using a **version number**.  \n"
"Each ticket gets assigned a version number upon creation, set to `0`.  \n"
"Whenever a client sends a patch, they must include the current version number "
"of the ticket alongside the desired changes. The server will only apply the "
"patch if the version number matches the one it has stored."
msgstr ""
"**버전 번호**를 사용하여 이 문제를 해결할 수 있습니다.  \n"
"각 티켓에는 생성 시 `0`으로 설정된 버전 번호가 할당됩니다.  \n"
"클라이언트가 패치를 보낼 때마다 원하는 변경 사항과 함께 티켓의 현재 버전 번호"
"를 포함해야 합니다. 서버는 버전 번호가 저장된 버전 번호와 일치하는 경우에만 패"
"치를 적용합니다."

#: src/07_threads/11_locks.md:14
msgid ""
"In the scenario described above, the server would reject the second patch, "
"because the version number would have been incremented by the first patch and "
"thus wouldn't match the one sent by the second client."
msgstr ""
"위에 설명된 시나리오에서 서버는 두 번째 패치를 거부합니다. 버전 번호가 첫 번"
"째 패치에 의해 증가되어 두 번째 클라이언트가 보낸 버전 번호와 일치하지 않기 때"
"문입니다."

#: src/07_threads/11_locks.md:17
msgid ""
"This approach is fairly common in distributed systems (e.g. when client and "
"servers don't share memory), and it is known as **optimistic concurrency "
"control**.  \n"
"The idea is that most of the time, conflicts won't happen, so we can optimize "
"for the common case. You know enough about Rust by now to implement this "
"strategy on your own as a bonus exercise, if you want to."
msgstr ""
"이 접근 방식은 분산 시스템(예: 클라이언트와 서버가 메모리를 공유하지 않는 경"
"우)에서 매우 일반적이며 **낙관적 동시성 제어**라고 알려져 있습니다.  \n"
"대부분의 경우 충돌이 발생하지 않으므로 일반적인 경우에 맞게 최적화할 수 있다"
"는 아이디어입니다. 당신은 원한다면 보너스 연습으로 이 전략을 스스로 구현할 수 "
"있을 만큼 Rust에 대해 충분히 알고 있습니다."

#: src/07_threads/11_locks.md:22
msgid "Locking"
msgstr "잠금"

#: src/07_threads/11_locks.md:24
msgid ""
"We can also fix the race condition by introducing a **lock**.  \n"
"Whenever a client wants to update a ticket, they must first acquire a lock on "
"it. While the lock is active, no other client can modify the ticket."
msgstr ""
"**잠금**을 도입하여 경쟁 조건을 수정할 수도 있습니다.  \n"
"클라이언트가 티켓을 업데이트하려고 할 때마다 먼저 티켓에 대한 잠금을 획득해야 "
"합니다. 잠금이 활성화되어 있는 동안에는 다른 클라이언트가 티켓을 수정할 수 없"
"습니다."

#: src/07_threads/11_locks.md:28
msgid ""
"Rust's standard library provides two different locking primitives: `Mutex<T>` "
"and `RwLock<T>`.  \n"
"Let's start with `Mutex<T>`. It stands for **mut**ual **ex**clusion, and it's "
"the simplest kind of lock: it allows only one thread to access the data, no "
"matter if it's for reading or writing."
msgstr ""
"Rust의 표준 라이브러리는 `Mutex<T>`와 `RwLock<T>`라는 두 가지 잠금 기본 요소"
"를 제공합니다.  \n"
"`Mutex<T>`부터 시작해 보겠습니다. 이는 **mut**ual **ex**clusion(상호 배제)을 "
"의미하며 가장 간단한 종류의 잠금입니다. 읽기용이든 쓰기용이든 관계없이 하나의 "
"스레드만 데이터에 액세스할 수 있도록 허용합니다."

#: src/07_threads/11_locks.md:32
msgid ""
"`Mutex<T>` wraps the data it protects, and it's therefore generic over the "
"type of the data.  \n"
"You can't access the data directly: the type system forces you to acquire a "
"lock first using either `Mutex::lock` or `Mutex::try_lock`. The former blocks "
"until the lock is acquired, the latter returns immediately with an error if "
"the lock can't be acquired.  \n"
"Both methods return a guard object that dereferences to the data, allowing "
"you to modify it. The lock is released when the guard is dropped."
msgstr ""
"`Mutex<T>`는 보호하는 데이터를 래핑하므로 데이터 타입으로 일반화됩니다.  \n"
"데이터에 직접 액세스할 수는 없습니다. 타입 시스템은 `Mutex::lock` 또는 "
"`Mutex::try_lock`을 사용하여 먼저 잠금을 획득하도록 강제합니다. 전자는 잠금을 "
"획득할 때까지 차단하고 후자는 잠금을 획득할 수 없는 경우 오류와 함께 즉시 반환"
"합니다.  \n"
"두 메서드 모두 데이터를 역참조하는 가드 개체를 반환하므로 데이터를 수정할 수 "
"있습니다. 가드를 삭제하면 잠금이 해제됩니다."

#: src/07_threads/11_locks.md:41
msgid "// An integer protected by a mutex lock\n"
msgstr "// 뮤텍스 잠금으로 보호되는 정수\n"

#: src/07_threads/11_locks.md:44
msgid "// Acquire a lock on the mutex\n"
msgstr "// 뮤텍스에 대한 잠금을 획득합니다\n"

#: src/07_threads/11_locks.md:47
msgid ""
"// Modify the data through the guard,\n"
"// leveraging its `Deref` implementation\n"
msgstr ""
"// `Deref` 구현을 활용하여 가드를\n"
"// 통해 데이터를 수정합니다\n"

#: src/07_threads/11_locks.md:51
msgid ""
"// The lock is released when `data` goes out of scope\n"
"// This can be done explicitly by dropping the guard\n"
"// or happen implicitly when the guard goes out of scope\n"
msgstr ""
"// `data`가 스코프를 벗어날 때 잠금이 해제됩니다\n"
"// 이는 가드를 삭제하여 명시적으로 수행할 수도 있고\n"
"// 가드가 스코프를 벗어날 때 암시적으로 발생할 수 있습니다\n"

#: src/07_threads/11_locks.md:58
msgid "Locking granularity"
msgstr "잠금 세분성"

#: src/07_threads/11_locks.md:60
msgid ""
"What should our `Mutex` wrap?  \n"
"The simplest option would be the wrap the entire `TicketStore` in a single "
"`Mutex`.  \n"
"This would work, but it would severely limit the system's performance: you "
"wouldn't be able to read tickets in parallel, because every read would have "
"to wait for the lock to be released.  \n"
"This is known as **coarse-grained locking**."
msgstr ""
"`Mutex`는 무엇을 감싸야 할까요?  \n"
"가장 간단한 옵션은 전체 `TicketStore`를 하나의 `Mutex`로 묶는 것입니다.  \n"
"이는 작동하지만 시스템 성능을 심각하게 제한합니다. 모든 읽기는 잠금이 해제될 "
"때까지 기다려야 하기 때문에 티켓을 병렬로 읽을 수 없습니다.  \n"
"이를 **대략적인 잠금**이라고 합니다."

#: src/07_threads/11_locks.md:66
msgid ""
"It would be better to use **fine-grained locking**, where each ticket is "
"protected by its own lock. This way, clients can keep working with tickets in "
"parallel, as long as they aren't trying to access the same ticket."
msgstr ""
"각 티켓이 자체 잠금으로 보호되는 **세밀한 잠금**을 사용하는 것이 더 좋습니다. "
"이렇게 하면 클라이언트는 동일한 티켓에 액세스하려고 시도하지 않는 한 티켓 작업"
"을 계속해서 병렬로 수행할 수 있습니다."

#: src/07_threads/11_locks.md:70
msgid "// The new structure, with a lock for each ticket\n"
msgstr "// 각 티켓에 대한 잠금 장치가 있는 새로운 구조\n"

#: src/07_threads/11_locks.md:76
msgid ""
"This approach is more efficient, but it has a downside: `TicketStore` has to "
"become **aware** of the multithreaded nature of the system; up until now, "
"`TicketStore` has been blissfully ignoring the existence of threads.  \n"
"Let's go for it anyway."
msgstr ""
"이 접근 방식은 더 효율적이지만 단점도 있습니다: `TicketStore`가 시스템의 멀티"
"스레드 특성을 **인지**해야 합니다. 지금까지 `TicketStore`는 스레드의 존재를 신"
"경 쓰지 않고 있었습니다.\n"
"일단 한번 해봅시다."

#: src/07_threads/11_locks.md:80
msgid "Who holds the lock?"
msgstr "누가 lock을 걸고있나요?"

#: src/07_threads/11_locks.md:82
msgid ""
"For the whole scheme to work, the lock must be passed to the client that "
"wants to modify the ticket.  \n"
"The client can then directly modify the ticket (as if they had a `&mut "
"Ticket`) and release the lock when they're done."
msgstr ""
"전체 체계가 작동하려면 티켓을 수정하려는 클라이언트에 잠금을 전달해야 합니"
"다.  \n"
"그런 다음 클라이언트는 티켓을 직접 수정하고(`&mut 티켓`이 있는 것처럼) 작업이 "
"완료되면 잠금을 해제할 수 있습니다."

#: src/07_threads/11_locks.md:85
msgid ""
"This is a bit tricky.  \n"
"We can't send a `Mutex<Ticket>` over a channel, because `Mutex` is not "
"`Clone` and we can't move it out of the `TicketStore`. Could we send the "
"`MutexGuard` instead?"
msgstr ""
"이것은 약간 까다롭습니다.  \n"
"`Mutex`는 `Clone`이 아니고 `TicketStore` 밖으로 이동할 수 없기 때문에 채널을 "
"통해 `Mutex<Ticket>`을 보낼 수 없습니다. 대신 `MutexGuard`를 보낼 수 있나요?"

#: src/07_threads/11_locks.md:89
msgid "Let's test the idea with a small example:"
msgstr "작은 예를 통해 아이디어를 테스트해 보겠습니다:"

#: src/07_threads/11_locks.md:105
msgid ""
"// Try to send the guard over the channel\n"
"    // to another thread\n"
msgstr ""
"// 채널을 통해 가드를\n"
"    // 다른 스레드로 보내려고 합니다\n"

#: src/07_threads/11_locks.md:111
msgid "The compiler is not happy with this code:"
msgstr "컴파일러는 이 코드에 만족하지 않습니다:"

#: src/07_threads/11_locks.md:130
msgid "`MutexGuard<'_, i32>` is not `Send`: what does it mean?"
msgstr "`MutexGuard<'_, i32>`는 `Send`가 아니랍니다. 무슨 뜻일까요?"

#: src/07_threads/11_locks.md:132
msgid "`Send`"
msgstr "`Send`"

#: src/07_threads/11_locks.md:134
msgid ""
"`Send` is a marker trait that indicates that a type can be safely transferred "
"from one thread to another.  \n"
"`Send` is also an auto-trait, just like `Sized`; it's automatically "
"implemented (or not implemented) for your type by the compiler, based on its "
"definition.  \n"
"You can also implement `Send` manually for your types, but it requires "
"`unsafe` since you have to guarantee that the type is indeed safe to send "
"between threads for reasons that the compiler can't automatically verify."
msgstr ""
"`Send`는 타입이 한 스레드에서 다른 스레드로 안전하게 전송될 수 있음을 나타내"
"는 마커 트레잇입니다.\n"
"`Send`는 `Sized`처럼 자동 트레잇이기도 합니다. 컴파일러가 타입의 정의를 기반으"
"로 자동으로 구현하거나 구현하지 않기도 합니다.\n"
"`Send`를 직접 구현할 수도 있지만, 이 경우 `unsafe`가 필요합니다. 이는 컴파일러"
"가 자동으로 확인할 수 없는 이유로 타입이 스레드 간에 안전하게 전송될 수 있음"
"을 보장해야 하기 때문입니다."

#: src/07_threads/11_locks.md:140
msgid "Channel requirements"
msgstr "채널 요구 사항"

#: src/07_threads/11_locks.md:142
msgid ""
"`Sender<T>`, `SyncSender<T>` and `Receiver<T>` are `Send` if and only if `T` "
"is `Send`.  \n"
"That's because they are used to send values between threads, and if the value "
"itself is not `Send`, it would be unsafe to send it between threads."
msgstr ""
"`Sender<T>`, `SyncSender<T>` 및 `Receiver<T>`는 `T`가 `Send`인 경우에만 `Send`"
"입니다.  \n"
"스레드 간에 값을 보내는 데 사용되며, 값 자체가 `Send`가 아닌 경우 스레드 간에 "
"전송하는 것이 안전하지 않기 때문입니다."

#: src/07_threads/11_locks.md:146
msgid "`MutexGuard`"
msgstr "`MutexGuard`"

#: src/07_threads/11_locks.md:148
msgid ""
"`MutexGuard` is not `Send` because the underlying operating system primitives "
"that `Mutex` uses to implement the lock require (on some platforms) that the "
"lock must be released by the same thread that acquired it.  \n"
"If we were to send a `MutexGuard` to another thread, the lock would be "
"released by a different thread, which would lead to undefined behavior."
msgstr ""
"`MutexGuard`는 `Mutex`가 잠금을 구현하는 데 사용하는 기본 운영 체제 프리미티브"
"가 (일부 플랫폼에서) 잠금을 획득한 동일한 스레드에 의해 잠금을 해제해야 하기 "
"때문에 `Send`가 아닙니다.  \n"
"다른 스레드에 `MutexGuard`를 보내면 다른 스레드에 의해 잠금이 해제되어 정의되"
"지 않은 동작이 발생하게 됩니다."

#: src/07_threads/11_locks.md:153
msgid "Our challenges"
msgstr "도전과제"

#: src/07_threads/11_locks.md:155
msgid "Summing it up:"
msgstr "요약하면 다음과 같습니다:"

#: src/07_threads/11_locks.md:157
msgid ""
"We can't send a `MutexGuard` over a channel. So we can't lock on the server-"
"side and then modify the ticket on the client-side."
msgstr ""
"채널을 통해 `MutexGuard`를 보낼 수 없습니다. 따라서 서버 측을 잠근 다음 클라이"
"언트 측에서 티켓을 수정할 수 없습니다."

#: src/07_threads/11_locks.md:159
msgid ""
"We can send a `Mutex` over a channel because it's `Send` as long as the data "
"it protects is `Send`, which is the case for `Ticket`. At the same time, we "
"can't move the `Mutex` out of the `TicketStore` nor clone it."
msgstr ""
"보호하는 데이터가 `Send`인 한 `Send`이기 때문에 채널을 통해 `Mutex`를 보낼 수 "
"있습니다. 이는 `Ticket`의 경우입니다. 동시에 `TicketStore`에서 `Mutex`를 이동"
"하거나 복제할 수 없습니다."

#: src/07_threads/11_locks.md:163
msgid ""
"How can we solve this conundrum?  \n"
"We need to look at the problem from a different angle. To lock a `Mutex`, we "
"don't need an owned value. A shared reference is enough, since `Mutex` uses "
"internal mutability:"
msgstr ""
"이 수수께끼를 어떻게 해결할 수 있을까요?  \n"
"우리는 다른 각도에서 문제를 볼 필요가 있습니다. `Mutex`를 잠글 때 값을 소유 "
"할 필요가 없습니다. `Mutex`는 내부 가변성을 사용하므로 공유 참조로 충분합니다."

#: src/07_threads/11_locks.md:169
msgid "// `&self`, not `self`!\n"
msgstr "// `self`가 아니라 `&self`!\n"

#: src/07_threads/11_locks.md:171
msgid "// Implementation details\n"
msgstr "// 세부 구현\n"

#: src/07_threads/11_locks.md:176
msgid ""
"It is therefore enough to send a shared reference to the client.  \n"
"We can't do that directly, though, because the reference would have to be "
"`'static` and that's not the case.  \n"
"In a way, we need an \"owned shared reference\". It turns out that Rust has a "
"type that fits the bill: `Arc`."
msgstr ""
"따라서 클라이언트에 공유 참조를 보내는 것으로 충분합니다.  \n"
"하지만 참조는 `'static`이어야 하는데 그렇지 않기 때문에 직접적으로 그렇게 할 "
"수는 없습니다.  \n"
"어떤 면에서는 \"소유된 공유 참조\"가 필요합니다. Rust에는 `Arc`라는 우리 목적"
"에 맞는 타입이 있습니다."

#: src/07_threads/11_locks.md:180
msgid "`Arc` to the rescue"
msgstr "우리를 구원해줄 `Arc`"

#: src/07_threads/11_locks.md:182
msgid ""
"`Arc` stands for **atomic reference counting**.  \n"
"`Arc` wraps around a value and keeps track of how many references to the "
"value exist. When the last reference is dropped, the value is deallocated.  \n"
"The value wrapped in an `Arc` is immutable: you can only get shared "
"references to it."
msgstr ""
"`Arc`는 **원자 참조 카운팅**을 의미합니다.  \n"
"`Arc`는 값을 감싸고 해당 값에 대한 참조가 얼마나 많이 존재하는지 추적합니다. "
"마지막 참조가 삭제되면 값의 할당이 취소됩니다.  \n"
"`Arc`에 포함된 값은 변경할 수 없습니다. 이에 대한 공유 참조만 얻을 수 있습니"
"다."

#: src/07_threads/11_locks.md:192
msgid ""
"// `Arc<T>` implements `Deref<T>`, so can convert \n"
"// a `&Arc<T>` to a `&T` using deref coercion\n"
msgstr ""
"// `Arc<T>`는 `Deref<T>`를 구현하므로\n"
"// deref coercion을 사용하여 `&Arc<T>`를 `&T`로 변환할 수 있습니다\n"

#: src/07_threads/11_locks.md:198
msgid ""
"If you're having a déjà vu moment, you're right: `Arc` sounds very similar to "
"`Rc`, the reference-counted pointer we introduced when talking about interior "
"mutability. The difference is thread-safety: `Rc` is not `Send`, while `Arc` "
"is. It boils down to the way the reference count is implemented: `Rc` uses a "
"\"normal\" integer, while `Arc` uses an **atomic** integer, which can be "
"safely shared and modified across threads."
msgstr ""
"데자뷰를 겪고 계시다면 맞습니다. `Arc`는 내부 가변성에 대해 이야기할 때 소개"
"한 참조 카운트 포인터인 `Rc`와 매우 유사해 보입니다. 차이점은 스레드 안전성입"
"니다. `Rc`는 `Send`가 아니지만 `Arc`는 그렇습니다. 이는 참조 카운트가 구현되"
"는 방식으로 요약됩니다. `Rc`는 \"일반\" 정수를 사용하는 반면, `Arc`는 스레드 "
"간에 안전하게 공유되고 수정될 수 있는 **원자** 정수를 사용합니다."

#: src/07_threads/11_locks.md:203
msgid "`Arc<Mutex<T>>`"
msgstr "`Arc<Mutex<T>>`"

#: src/07_threads/11_locks.md:205
msgid "If we pair `Arc` with `Mutex`, we finally get a type that:"
msgstr ""
"`Arc`와 `Mutex`를 쌍으로 사용하면 마침내 다음과 같은 타입을 얻게 됩니다."

#: src/07_threads/11_locks.md:207
msgid "Can be sent between threads, because:"
msgstr "다음과 같은 이유로 스레드 간에 전송될 수 있습니다:"

#: src/07_threads/11_locks.md:208
msgid "`Arc` is `Send` if `T` is `Send`, and"
msgstr "`T`가 `Send`이면 `Arc`는 `Send`이고"

#: src/07_threads/11_locks.md:209
msgid "`Mutex` is `Send` if `T` is `Send`."
msgstr "`T`가 `Send`이면 `Mutex`는 `Send`입니다."

#: src/07_threads/11_locks.md:210
msgid "`T` is `Ticket`, which is `Send`."
msgstr "`T`는 `Ticket`, 즉 `Send`입니다."

#: src/07_threads/11_locks.md:211
msgid ""
"Can be cloned, because `Arc` is `Clone` no matter what `T` is. Cloning an "
"`Arc` increments the reference count, the data is not copied."
msgstr ""
"`T`가 무엇이든 `Arc`는 `Clone`이기 때문에 복제될 수 있습니다. `Arc`를 복제하"
"면 참조 카운트가 증가하지만 데이터는 복사되지 않습니다."

#: src/07_threads/11_locks.md:213
msgid ""
"Can be used to modify the data it wraps, because `Arc` lets you get a shared "
"reference to `Mutex<T>` which can in turn be used to acquire a lock."
msgstr ""
"`Arc`를 사용하면 잠금을 획득하는 데 사용할 수 있는 `Mutex<T>`에 대한 공유 참조"
"를 얻을 수 있으므로 래핑된 데이터를 수정하는 데 사용할 수 있습니다."

#: src/07_threads/11_locks.md:216
msgid ""
"We have all the pieces we need to implement the locking strategy for our "
"ticket store."
msgstr ""
"우리는 티켓 스토어의 잠금 전략을 구현하는 데 필요한 모든 요소를 ​​갖추고 있습니"
"다."

#: src/07_threads/11_locks.md:220
msgid ""
"We won't be covering the details of atomic operations in this course, but you "
"can find more information [in the `std` documentation](https://doc.rust-lang."
"org/std/sync/atomic/index.html) as well as in the [\"Rust atomics and locks\" "
"book](https://marabos.nl/atomics/)."
msgstr ""
"이 과정에서는 원자 연산에 대한 세부 사항을 다루지 않지만 [`std` 문서](https://"
"doc.rust-lang.org/std/sync/atomic/index.html)와 [\"Rust atomics and locks\" "
"book](https://marabos.nl/atomics/) 책에서 더 많은 정보를 찾을 수 있습니다."

#: src/07_threads/11_locks.md:226
msgid ""
"The exercise for this section is located in [`07_threads/11_locks`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/11_locks)"
msgstr ""
"이 섹션의 예제는 [`07_threads/11_locks`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/11_locks)에 있습니다"

#: src/07_threads/12_rw_lock.md:1
msgid "Readers and writers"
msgstr "Readers와 writers"

#: src/07_threads/12_rw_lock.md:3
msgid ""
"Our new `TicketStore` works, but its read performance is not great: there can "
"only be one client at a time reading a specific ticket, because `Mutex<T>` "
"doesn't distinguish between readers and writers."
msgstr ""
"새로운 `TicketStore`는 작동하지만 읽기 성능은 좋지 않습니다. `Mutex<T>`는 리더"
"와 라이터를 구별하지 않기 때문에 특정 티켓을 한 번에 하나의 클라이언트만 읽을 "
"수 있습니다."

#: src/07_threads/12_rw_lock.md:6
msgid ""
"We can solve the issue by using a different locking primitive: "
"`RwLock<T>`.  \n"
"`RwLock<T>` stands for **read-write lock**. It allows **multiple readers** to "
"access the data simultaneously, but only one writer at a time."
msgstr ""
"다른 잠금 기본 요소인 `RwLock<T>`를 사용하여 문제를 해결할 수 있습니다.  \n"
"`RwLock<T>`는 **읽기-쓰기 잠금**을 나타냅니다. **여러 리더**가 동시에 데이터"
"에 액세스할 수 있지만 한 번에 한 명의 라이터만 액세스할 수 있습니다."

#: src/07_threads/12_rw_lock.md:10
msgid ""
"`RwLock<T>` has two methods to acquire a lock: `read` and `write`.  \n"
"`read` returns a guard that allows you to read the data, while `write` "
"returns a guard that allows you to modify it."
msgstr ""
"`RwLock<T>`에는 잠금을 획득하는 두 가지 방법, `읽기`와 `쓰기`가 있습니다.  \n"
"`read`는 데이터를 읽을 수 있는 가드를 반환하고, `write`는 데이터를 수정할 수 "
"있는 가드를 반환합니다."

#: src/07_threads/12_rw_lock.md:15
msgid "// An integer protected by a read-write lock\n"
msgstr "// 읽기-쓰기 잠금으로 보호되는 정수\n"

#: src/07_threads/12_rw_lock.md:18
msgid "// Acquire a read lock on the RwLock\n"
msgstr "// RwLock에 대한 읽기 잠금을 획득합니다\n"

#: src/07_threads/12_rw_lock.md:21
msgid ""
"// Acquire a **second** read lock\n"
"// while the first one is still active\n"
msgstr ""
"// 첫 번째 읽기 잠금이 아직 활성화되어 있는 동안\n"
"// **두 번째** 읽기 잠금을 획득합니다\n"

#: src/07_threads/12_rw_lock.md:27
msgid "Trade-offs"
msgstr "장단점"

#: src/07_threads/12_rw_lock.md:29
msgid ""
"On the surface, `RwLock<T>` seems like a no-brainer: it provides a superset "
"of the functionality of `Mutex<T>`. Why would you ever use `Mutex<T>` if you "
"can use `RwLock<T>` instead?"
msgstr ""
"표면적으로 `RwLock<T>`는 당연한 것처럼 보입니다. 이는 `Mutex<T>` 기능의 상위 "
"집합을 제공합니다. `RwLock<T>`를 사용할 수 있는데 왜 `Mutex<T>`를 사용할까요?"

#: src/07_threads/12_rw_lock.md:32
msgid "There are two key reasons:"
msgstr "두 가지 주요 이유가 있습니다:"

#: src/07_threads/12_rw_lock.md:34
msgid ""
"Locking a `RwLock<T>` is more expensive than locking a `Mutex<T>`.  \n"
"This is because `RwLock<T>` has to keep track of the number of active readers "
"and writers, while `Mutex<T>` only has to keep track of whether the lock is "
"held or not. This performance overhead is not an issue if there are more "
"readers than writers, but if the workload is write-heavy `Mutex<T>` might be "
"a better choice."
msgstr ""
"`RwLock<T>`을 잠그는 것은 `Mutex<T>`를 잠그는 것보다 비용이 더 많이 듭니"
"다.  \n"
"이는 `RwLock<T>`이 활성 판독기와 기록기의 수를 추적해야 하는 반면 `Mutex<T>`"
"는 잠금이 유지되는지 여부만 추적하면 되기 때문입니다. 이 성능 오버헤드는 작성"
"기보다 판독기가 더 많은 경우 문제가 되지 않지만 작업 부하가 쓰기가 많은 경우 "
"`Mutex<T>`가 더 나은 선택일 수 있습니다."

#: src/07_threads/12_rw_lock.md:39
msgid ""
"`RwLock<T>` can cause **writer starvation**.  \n"
"If there are always readers waiting to acquire the lock, writers might never "
"get a chance to run.  \n"
"`RwLock<T>` doesn't provide any guarantees about the order in which readers "
"and writers are granted access to the lock. It depends on the policy "
"implemented by the underlying OS, which might not be fair to writers."
msgstr ""
"`RwLock<T>`는 **작성기 기아**를 유발할 수 있습니다.  \n"
"잠금을 획득하기 위해 대기하는 판독기가 항상 있는 경우 작성자는 실행할 기회를 "
"얻지 못할 수도 있습니다.  \n"
"`RwLock<T>`는 판독기와 기록기에게 잠금에 대한 액세스 권한이 부여되는 순서에 대"
"해 어떠한 보장도 제공하지 않습니다. 이는 기본 OS에서 구현하는 정책에 따라 달라"
"지며, 이는 작성자에게 공평하지 않을 수 있습니다."

#: src/07_threads/12_rw_lock.md:44
msgid ""
"In our case, we can expect the workload to be read-heavy (since most clients "
"will be reading tickets, not modifying them), so `RwLock<T>` is a good choice."
msgstr ""
"우리의 경우 작업량이 읽기 중심일 것으로 예상할 수 있으므로(대부분의 클라이언트"
"는 티켓을 수정하지 않고 읽기 때문에) `RwLock<T>`을 선택하는 것이 좋습니다."

#: src/07_threads/12_rw_lock.md:49
msgid ""
"The exercise for this section is located in [`07_threads/12_rw_lock`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/12_rw_lock)"
msgstr ""
"이 섹션의 예제는 [`07_threads/12_rw_lock`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/12_rw_lock)에 있습니다"

#: src/07_threads/13_without_channels.md:1
msgid "Design review"
msgstr "디자인 리뷰"

#: src/07_threads/13_without_channels.md:3
msgid "Let's take a moment to review the journey we've been through."
msgstr "잠시 우리가 겪어온 여정을 되돌아보겠습니다."

#: src/07_threads/13_without_channels.md:5
msgid "Lockless with channel serialization"
msgstr "채널 직렬화를 통한 잠금 없음"

#: src/07_threads/13_without_channels.md:7
msgid "Our first implementation of a multithreaded ticket store used:"
msgstr "사용된 멀티스레드 티켓 저장소의 첫 번째 구현은 다음과 같습니다:"

#: src/07_threads/13_without_channels.md:9
msgid "a single long-lived thread (server), to hold the shared state"
msgstr "공유 상태를 유지하기 위한 단일 수명이 긴 스레드(서버)"

#: src/07_threads/13_without_channels.md:10
msgid ""
"multiple clients sending requests to it via channels from their own threads."
msgstr "여러 클라이언트가 자체 스레드의 채널을 통해 요청을 보냅니다."

#: src/07_threads/13_without_channels.md:12
msgid ""
"No locking of the state was necessary, since the server was the only one "
"modifying the state. That's because the \"inbox\" channel naturally "
"**serialized** incoming requests: the server would process them one by "
"one.  \n"
"We've already discussed the limitations of this approach when it comes to "
"patching behaviour, but we didn't discuss the performance implications of the "
"original design: the server could only process one request at a time, "
"including reads."
msgstr ""
"서버가 상태를 수정하는 유일한 서버였으므로 상태 잠금이 필요하지 않았습니다. "
"그 이유는 \"받은 편지함\" 채널이 들어오는 요청을 자연스럽게 **직렬화**했기 때"
"문입니다. 서버는 요청을 하나씩 처리합니다.  \n"
"패치 동작과 관련하여 이 접근 방식의 한계에 대해 이미 논의했지만 원래 설계의 성"
"능 영향에 대해서는 논의하지 않았습니다. 서버는 읽기를 포함하여 한 번에 하나의 "
"요청만 처리할 수 있었습니다."

#: src/07_threads/13_without_channels.md:18
msgid "Fine-grained locking"
msgstr "세분화된 잠금"

#: src/07_threads/13_without_channels.md:20
msgid ""
"We then moved to a more sophisticated design, where each ticket was protected "
"by its own lock and clients could independently decide if they wanted to read "
"or atomically modify a ticket, acquiring the appropriate lock."
msgstr ""
"그런 다음 각 티켓이 자체 잠금으로 보호되고 클라이언트가 티켓을 읽을지 또는 원"
"자적으로 수정할지 여부를 독립적으로 결정하여 적절한 잠금을 획득할 수 있는 보"
"다 정교한 디자인으로 전환했습니다."

#: src/07_threads/13_without_channels.md:23
msgid ""
"This design allows for better parallelism (i.e. multiple clients can read "
"tickets at the same time), but it is still fundamentally **serial**: the "
"server processes commands one by one. In particular, it hands out locks to "
"clients one by one."
msgstr ""
"이 디자인은 더 나은 병렬 처리를 허용하지만(즉, 여러 클라이언트가 동시에 티켓"
"을 읽을 수 있음) 기본적으로는 여전히 **직렬**입니다. 즉, 서버가 명령을 하나씩 "
"처리합니다. 특히 클라이언트에게 하나씩 잠금을 전달합니다."

#: src/07_threads/13_without_channels.md:27
msgid ""
"Could we remove the channels entirely and allow clients to directly access "
"the `TicketStore`, relying exclusively on locks to synchronize access?"
msgstr ""
"채널을 완전히 제거하고 클라이언트가 액세스를 동기화하기 위해 잠금에만 의존하"
"여 `TicketStore`에 직접 액세스할 수 있도록 허용할 수 있습니까?"

#: src/07_threads/13_without_channels.md:30
msgid "Removing channels"
msgstr "채널 삭제"

#: src/07_threads/13_without_channels.md:32
msgid "We have two problems to solve:"
msgstr "해결해야 할 두 가지 문제가 있습니다:"

#: src/07_threads/13_without_channels.md:34
#: src/07_threads/13_without_channels.md:37
msgid "Sharing `TicketStore` across threads"
msgstr "스레드 간에 `TicketStore` 공유"

#: src/07_threads/13_without_channels.md:35
#: src/07_threads/13_without_channels.md:43
msgid "Synchronizing access to the store"
msgstr "스토어에 대한 액세스 동기화"

#: src/07_threads/13_without_channels.md:39
msgid ""
"We want all threads to refer to the same state, otherwise we don't really "
"have a multithreaded system—we're just running multiple single-threaded "
"systems in parallel.  \n"
"We've already encountered this problem when we tried to share a lock across "
"threads: we can use an `Arc`."
msgstr ""
"우리는 모든 스레드가 동일한 상태를 참조하기를 원합니다. 그렇지 않으면 실제로"
"는 멀티스레드 시스템이 아닙니다. 단지 여러 단일 스레드 시스템을 병렬로 실행하"
"는 것뿐입니다.  \n"
"스레드 간에 잠금을 공유하려고 할 때 이미 이 문제에 직면했습니다. `Arc`를 사용"
"하면 됩니다."

#: src/07_threads/13_without_channels.md:45
msgid ""
"There is one interaction that's still lockless thanks to the serialization "
"provided by the channels: inserting (or removing) a ticket from the store.  \n"
"If we remove the channels, we need to introduce (another) lock to synchronize "
"access to the `TicketStore` itself."
msgstr ""
"채널에서 제공하는 직렬화 덕분에 여전히 잠금이 해제된 상호 작용이 하나 있습니"
"다. 바로 매장에서 티켓을 삽입(또는 제거)하는 것입니다.  \n"
"채널을 제거하는 경우 `TicketStore` 자체에 대한 액세스를 동기화하기 위해 (또 다"
"른) 잠금이 필요합니다."

#: src/07_threads/13_without_channels.md:49
msgid ""
"If we use a `Mutex`, then it makes no sense to use an additional `RwLock` for "
"each ticket: the `Mutex` will already serialize access to the entire store, "
"so we wouldn't be able to read tickets in parallel anyway.  \n"
"If we use a `RwLock`, instead, we can read tickets in parallel. We just need "
"to pause all reads while inserting or removing a ticket."
msgstr ""
"`Mutex`를 사용하는 경우 각 티켓에 추가 `RwLock`을 사용하는 것은 의미가 없습니"
"다. `Mutex`는 이미 전체 매장에 대한 액세스를 직렬화하므로 어쨌든 티켓을 병렬"
"로 읽을 수 없습니다. .  \n"
"대신 `RwLock`을 사용하면 티켓을 병렬로 읽을 수 있습니다. 티켓을 삽입하거나 제"
"거하는 동안 모든 읽기를 일시 중지하면 됩니다."

#: src/07_threads/13_without_channels.md:54
msgid "Let's go down this path and see where it leads us."
msgstr "이 접근 방식을 따라가봅시다."

#: src/07_threads/13_without_channels.md:58
msgid ""
"The exercise for this section is located in [`07_threads/13_without_channels`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/13_without_channels)"
msgstr ""
"이 섹션의 예제는 [`07_threads/13_without_channels`](https://github.com/"
"mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/13_without_channels)에 있습니다"

#: src/07_threads/14_sync.md:1
msgid "`Sync`"
msgstr "`Sync`"

#: src/07_threads/14_sync.md:3
msgid ""
"Before we wrap up this chapter, let's talk about another key trait in Rust's "
"standard library: `Sync`."
msgstr ""
"이 장을 마무리하기 전에 Rust 표준 라이브러리의 또 다른 핵심 트레잇인 `Sync`에 "
"대해 이야기해 보겠습니다."

#: src/07_threads/14_sync.md:5
msgid ""
"`Sync` is an auto trait, just like `Send`.  \n"
"It is automatically implemented by all types that can be safely **shared** "
"between threads."
msgstr ""
"`Sync`는 `Send`와 마찬가지로 오토 트레잇입니다.  \n"
"스레드 간에 안전하게 **공유**할 수 있는 모든 타입에 대해 자동으로 구현됩니다."

#: src/07_threads/14_sync.md:8
msgid "In order words: `T: Sync` means that `&T` is `Send`."
msgstr "즉, `T: Sync`는 `&T`가 `Send`임을 의미합니다."

#: src/07_threads/14_sync.md:10
msgid "`Sync` doesn't imply `Send`"
msgstr "`Sync`는 `Send`를 뜻하는게 아닙니다"

#: src/07_threads/14_sync.md:12
msgid ""
"It's important to note that `Sync` doesn't imply `Send`.  \n"
"For example: `MutexGuard` is not `Send`, but it is `Sync`."
msgstr ""
"`Sync`는 `Send`를 의미하지 않는다는 점에 유의하는 것이 중요합니다.  \n"
"예를 들어 `MutexGuard`는 `Send`가 아니지만 `Sync`입니다."

#: src/07_threads/14_sync.md:15
msgid ""
"It isn't `Send` because the lock must be released on the same thread that "
"acquired it, therefore we don't want `MutexGuard` to be dropped on a "
"different thread.  \n"
"But it is `Sync`, because giving a `&MutexGuard` to another thread has no "
"impact on where the lock is released."
msgstr ""
"잠금을 획득한 동일한 스레드에서 잠금을 해제해야 하기 때문에 `Send`가 아닙니"
"다. 따라서 `MutexGuard`가 다른 스레드에서 삭제되는 것을 원하지 않습니다.  \n"
"그러나 다른 스레드에 `&MutexGuard`를 제공해도 잠금이 해제되는 위치에는 영향을 "
"미치지 않기 때문에 이는 `Sync`입니다."

#: src/07_threads/14_sync.md:19
msgid "`Send` doesn't imply `Sync`"
msgstr "`Send`는 `Sync`를 뜻하지 않습니다."

#: src/07_threads/14_sync.md:21
msgid ""
"The opposite is also true: `Send` doesn't imply `Sync`.  \n"
"For example: `RefCell<T>` is `Send` (if `T` is `Send`), but it is not `Sync`."
msgstr ""
"그 반대도 마찬가지입니다. `Send`는 `Sync`를 뜻하지 않습니다.  \n"
"예를 들어 `RefCell<T>`는 `Send`(`T`가 `Send`인 경우)이지만 `Sync`는 아닙니다."

#: src/07_threads/14_sync.md:24
msgid ""
"`RefCell<T>` performs runtime borrow checking, but the counters it uses to "
"track borrows are not thread-safe. Therefore, having multiple threads holding "
"a `&RefCell` would lead to a data race, with potentially multiple threads "
"obtaining mutable references to the same data. Hence `RefCell` is not "
"`Sync`.  \n"
"`Send` is fine, instead, because when we send a `RefCell` to another thread "
"we're not leaving behind any references to the data it contains, hence no "
"risk of concurrent mutable access."
msgstr ""
"`RefCell<T>`는 런타임 차용 검사를 수행하지만 차용을 추적하는 데 사용하는 카운"
"터는 스레드로부터 안전하지 않습니다. 따라서 `&RefCell`을 보유하는 여러 스레드"
"가 있으면 데이터 경쟁이 발생하고 잠재적으로 여러 스레드가 동일한 데이터에 대"
"한 변경 가능한 참조를 얻게 됩니다. 따라서 `RefCell`은 `Sync`가 아닙니다.  \n"
"대신 `Send` 맞습니다. 왜냐하면 `RefCell`을 다른 스레드로 보낼 때 포함된 데이터"
"에 대한 참조를 남기지 않고 동시에 변경 가능한 액세스가 발생할 위험이 없기 때문"
"입니다."

#: src/07_threads/14_sync.md:32
msgid ""
"The exercise for this section is located in [`07_threads/14_sync`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/07_threads/14_sync)"
msgstr ""
"이 섹션의 예제는 [`07_threads/14_sync`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/exercises/07_threads/14_sync)에 있습니다"

#: src/08_futures/00_intro.md:1
#, fuzzy
msgid "Async Rust"
msgstr "비동기 러스트"

#: src/08_futures/00_intro.md:3
#, fuzzy
msgid ""
"Threads are not the only way to write concurrent programs in Rust.  \n"
"In this chapter we'll explore another approach: **asynchronous programming**."
msgstr ""
"스레드는 Rust에서 동시성 프로그램을 작성하는 유일한 방법은 아닙니다.  \n"
"이번 장에서는 **비동기 프로그래밍**이라는 또 다른 접근 방식을 살펴보겠습니다."

#: src/08_futures/00_intro.md:6
#, fuzzy
msgid "In particular, you'll get an introduction to:"
msgstr "특히 다음 내용을 소개하게 됩니다."

#: src/08_futures/00_intro.md:8
#, fuzzy
msgid "The `async`/`.await` keywords, to write asynchronous code effortlessly"
msgstr "비동기 코드를 쉽게 작성하기 위한 `async`/`.await` 키워드"

#: src/08_futures/00_intro.md:9
#, fuzzy
msgid ""
"The `Future` trait, to represent computations that may not be complete yet"
msgstr "아직 완료되지 않은 계산을 나타내는 `Future` 특성"

#: src/08_futures/00_intro.md:10
#, fuzzy
msgid "`tokio`, the most popular runtime for running asynchronous code"
msgstr "비동기 코드 실행을 위한 가장 인기 있는 런타임인 'tokio'"

#: src/08_futures/00_intro.md:11
#, fuzzy
msgid ""
"The cooperative nature of Rust asynchronous model, and how this affects your "
"code"
msgstr "Rust 비동기 모델의 협력적 특성과 이것이 코드에 미치는 영향"

#: src/08_futures/00_intro.md:15
msgid ""
"The exercise for this section is located in [`08_futures/00_intro`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/08_futures/00_intro)"
msgstr ""

#: src/08_futures/01_async_fn.md:3
#, fuzzy
msgid ""
"All the functions and methods you've written so far were eager.  \n"
"Nothing happened until you invoked them. But once you did, they ran to "
"completion: they did **all** their work, and then returned their output."
msgstr ""
"지금까지 작성한 모든 함수와 메소드는 열망적이었습니다.  \n"
"당신이 그들을 호출할 때까지 아무 일도 일어나지 않았습니다. 하지만 한 번 수행하"
"면 완료될 때까지 달렸습니다. **모든** 작업을 수행한 다음 출력물을 반환했습니"
"다."

#: src/08_futures/01_async_fn.md:7
#, fuzzy
msgid ""
"Sometimes that's undesirable.  \n"
"For example, if you're writing an HTTP server, there might be a lot of "
"**waiting**: waiting for the request body to arrive, waiting for the database "
"to respond, waiting for a downstream service to reply, etc."
msgstr ""
"때때로 그것은 바람직하지 않습니다.  \n"
"예를 들어, HTTP 서버를 작성하는 경우 요청 본문이 도착하기를 기다리기, 데이터베"
"이스가 응답하기를 기다리기, 다운스트림 서비스가 응답하기를 기다리는 등 많은 **"
"대기**가 있을 수 있습니다."

#: src/08_futures/01_async_fn.md:12
#, fuzzy
msgid ""
"What if you could do something else while you're waiting?  \n"
"What if you could choose to give up midway through a computation?  \n"
"What if you could choose to prioritise another task over the current one?"
msgstr ""
"기다리는 동안 다른 일을 할 수 있다면 어떨까요?  \n"
"계산 도중에 포기할 수 있다면 어떨까요?  \n"
"현재 작업보다 다른 작업의 우선순위를 선택할 수 있다면 어떨까요?"

#: src/08_futures/01_async_fn.md:16
#, fuzzy
msgid "That's where **asynchronous functions** come in."
msgstr "이것이 바로 **비동기 함수**가 등장하는 곳입니다."

#: src/08_futures/01_async_fn.md:18
#, fuzzy
msgid "`async fn`"
msgstr "`비동기 fn`"

#: src/08_futures/01_async_fn.md:20
#, fuzzy
msgid "You use the `async` keyword to define an asynchronous function:"
msgstr "비동기 함수를 정의하려면 `async` 키워드를 사용합니다."

#: src/08_futures/01_async_fn.md:24
#, fuzzy
msgid "// This function is asynchronous\n"
msgstr "// 이 함수는 비동기식입니다."

#: src/08_futures/01_async_fn.md:31
#, fuzzy
msgid "What happens if you call `bind_random` as you would a regular function?"
msgstr "일반 함수처럼 `bind_random`을 호출하면 어떻게 되나요?"

#: src/08_futures/01_async_fn.md:35
#, fuzzy
msgid "// Invoke `bind_random`\n"
msgstr "// `bind_random` 호출"

#: src/08_futures/01_async_fn.md:37
#, fuzzy
msgid "// Now what?\n"
msgstr "// 이제 뭐?"

#: src/08_futures/01_async_fn.md:41
#, fuzzy
msgid ""
"Nothing happens!  \n"
"Rust doesn't start executing `bind_random` when you call it, not even as a "
"background task (as you might expect based on your experience with other "
"languages). Asynchronous functions in Rust are **lazy**: they don't do any "
"work until you explicitly ask them to. Using Rust's terminology, we say that "
"`bind_random` returns a **future**, a type that represents a computation that "
"may complete later. They're called futures because they implement the "
"`Future` trait, an interface that we'll examine in detail later on in this "
"chapter."
msgstr ""
"아무 반응이 없습니다!  \n"
"Rust는 호출할 때 `bind_random` 실행을 시작하지 않습니다. (다른 언어 사용 경험"
"을 바탕으로 예상할 수 있듯이) 백그라운드 작업으로도 실행하지 않습니다. Rust의 "
"비동기 함수는 **게으르다**: 명시적으로 요청하기 전까지는 어떤 작업도 수행하지 "
"않습니다. Rust의 용어를 사용하면 'bind_random'이 나중에 완료될 수 있는 계산을 "
"나타내는 유형인 **future**를 반환한다고 말합니다. 이것들은 이 장의 뒷부분에서 "
"자세히 살펴볼 인터페이스인 `Future` 특성을 구현하기 때문에 미래라고 불립니다."

#: src/08_futures/01_async_fn.md:52
#, fuzzy
msgid "`.await`"
msgstr "`.기다려`"

#: src/08_futures/01_async_fn.md:54
#, fuzzy
msgid ""
"The most common way to ask an asynchronous function to do some work is to use "
"the `.await` keyword:"
msgstr ""
"비동기 함수에 작업을 요청하는 가장 일반적인 방법은 `.await` 키워드를 사용하는 "
"것입니다."

#: src/08_futures/01_async_fn.md:65
#, fuzzy
msgid "// Invoke `bind_random` and wait for it to complete\n"
msgstr "// `bind_random`을 호출하고 완료될 때까지 기다립니다."

#: src/08_futures/01_async_fn.md:67
#, fuzzy
msgid "// Now `listener` is ready\n"
msgstr "// 이제 `listener`가 준비되었습니다."

#: src/08_futures/01_async_fn.md:71
#, fuzzy
msgid ""
"`.await` doesn't return control to the caller until the asynchronous function "
"has run to completion—e.g. until the `TcpListener` has been created in the "
"example above."
msgstr ""
"`.await`는 비동기 함수 실행이 완료될 때까지 호출자에게 제어권을 반환하지 않습"
"니다. 위의 예에서 `TcpListener`가 생성될 때까지."

#: src/08_futures/01_async_fn.md:74
#, fuzzy
msgid "Runtimes"
msgstr "런타임"

#: src/08_futures/01_async_fn.md:76
#, fuzzy
msgid ""
"If you're puzzled, you're right to be!  \n"
"We've just said that the perk of asynchronous functions is that they don't do "
"**all** their work at once. We then introduced `.await`, which doesn't return "
"until the asynchronous function has run to completion. Haven't we just re-"
"introduced the problem we were trying to solve? What's the point?"
msgstr ""
"당신이 의아해한다면, 당신이 옳습니다!  \n"
"비동기 함수의 장점은 **모든** 작업을 한 번에 수행하지 않는다는 것입니다. 그런 "
"다음 비동기 함수 실행이 완료될 때까지 반환되지 않는 `.await`를 도입했습니다. "
"우리가 해결하려고 했던 문제를 다시 도입하지 않았나요? 점은 무엇인가?"

#: src/08_futures/01_async_fn.md:82
#, fuzzy
msgid ""
"Not quite! A lot happens behind the scenes when you call `.await`!  \n"
"You're yielding control to an **async runtime**, also known as an **async "
"executor**. Executors are where the magic happens: they are in charge of "
"managing all your ongoing asynchronous **tasks**. In particular, they balance "
"two different goals:"
msgstr ""
"좀 빠지는! `.await`를 호출하면 뒤에서 많은 일이 일어납니다!  \n"
"**비동기 실행기**라고도 알려진 **비동기 런타임**에 제어권을 양보하고 있습니"
"다. 실행자는 마법이 일어나는 곳입니다. 실행 중인 모든 비동기 **작업**을 관리하"
"는 역할을 담당합니다. 특히 두 가지 목표의 균형을 유지합니다."

#: src/08_futures/01_async_fn.md:87
#, fuzzy
msgid "**Progress**: they make sure that tasks make progress whenever they can."
msgstr "**진행**: 가능할 때마다 작업이 진행되도록 합니다."

#: src/08_futures/01_async_fn.md:88
#, fuzzy
msgid ""
"**Efficiency**: if a task is waiting for something, they try to make sure "
"that another task can run in the meantime, fully utilising the available "
"resources."
msgstr ""
"**효율성**: 작업이 무언가를 기다리고 있는 경우 사용 가능한 리소스를 최대한 활"
"용하여 그 동안 다른 작업이 실행될 수 있는지 확인하려고 합니다."

#: src/08_futures/01_async_fn.md:91
#, fuzzy
msgid "No default runtime"
msgstr "기본 런타임 없음"

#: src/08_futures/01_async_fn.md:93
#, fuzzy
msgid ""
"Rust is fairly unique in its approach to asynchronous programing: there is no "
"default runtime. The standard library doesn't ship with one. You need to "
"bring your own!"
msgstr ""
"Rust는 비동기 프로그래밍에 대한 접근 방식이 매우 독특합니다. 기본 런타임이 없"
"습니다. 표준 라이브러리는 함께 제공되지 않습니다. 직접 가져와야합니다!"

#: src/08_futures/01_async_fn.md:97
#, fuzzy
msgid ""
"In most cases, you'll choose one of the options available in the ecosystem. "
"Some runtimes are designed to be broadly applicable, a solid option for most "
"applications. `tokio` and `async-std` belong to this category. Other runtimes "
"are optimised for specific use cases—e.g. `embassy` for embedded systems."
msgstr ""
"대부분의 경우 생태계에서 사용 가능한 옵션 중 하나를 선택하게 됩니다. 일부 런타"
"임은 광범위하게 적용 가능하도록 설계되어 대부분의 애플리케이션에 확실한 옵션입"
"니다. `tokio`와 `async-std`가 이 범주에 속합니다. 다른 런타임은 특정 사용 사례"
"에 최적화되어 있습니다. 임베디드 시스템을 위한 `대사관`."

#: src/08_futures/01_async_fn.md:102
#, fuzzy
msgid ""
"Throughout this course we'll rely on `tokio`, the most popular runtime for "
"general-purpose asynchronous programming in Rust."
msgstr ""
"이 과정 전체에서 우리는 Rust의 범용 비동기 프로그래밍을 위한 가장 인기 있는 런"
"타임인 'tokio'를 사용하게 됩니다."

#: src/08_futures/01_async_fn.md:105
#, fuzzy
msgid "`#[tokio::main]`"
msgstr "`#[토키오::메인]`"

#: src/08_futures/01_async_fn.md:107
#, fuzzy
msgid ""
"The entrypoint of your executable, the `main` function, must be a synchronous "
"function. That's where you're supposed to set up and launch your chosen async "
"runtime."
msgstr ""
"실행 파일의 진입점인 'main' 함수는 동기 함수여야 합니다. 여기에서 선택한 비동"
"기 런타임을 설정하고 실행해야 합니다."

#: src/08_futures/01_async_fn.md:110
#, fuzzy
msgid ""
"Most runtimes provides a macro to make this easier. For `tokio`, it's `tokio::"
"main`:"
msgstr ""
"대부분의 런타임은 이를 더 쉽게 하기 위해 매크로를 제공합니다. `tokio`의 경우 "
"`tokio::main`입니다."

#: src/08_futures/01_async_fn.md:115
#, fuzzy
msgid "// Your async code goes here\n"
msgstr "// 비동기 코드가 여기에 들어갑니다."

#: src/08_futures/01_async_fn.md:119
#, fuzzy
msgid "which expands to:"
msgstr "이는 다음으로 확장됩니다."

#: src/08_futures/01_async_fn.md:125
#, fuzzy
msgid ""
"// Your async function goes here\n"
"        // [...]\n"
msgstr "// 비동기 함수가 여기에 위치합니다. // \\[...\\]"

#: src/08_futures/01_async_fn.md:131
#, fuzzy
msgid "`#[tokio::test]`"
msgstr "`#[tokio::테스트]`"

#: src/08_futures/01_async_fn.md:133
#, fuzzy
msgid ""
"The same goes for tests: they must be synchronous functions.  \n"
"Each test function is run in its own thread, and you're responsible for "
"setting up and launching an async runtime if you need to run async code in "
"your tests.  \n"
"`tokio` provides a `#[tokio::test]` macro to make this easier:"
msgstr ""
"테스트도 마찬가지입니다. 동기식 함수여야 합니다.  \n"
"각 테스트 함수는 자체 스레드에서 실행되며, 테스트에서 비동기 코드를 실행해야 "
"하는 경우 비동기 런타임을 설정하고 시작하는 책임은 사용자에게 있습니다.  \n"
"`tokio`는 이 작업을 더 쉽게 하기 위해 `#[tokio::test]` 매크로를 제공합니다:"

#: src/08_futures/01_async_fn.md:142
#, fuzzy
msgid "// Your async test code goes here\n"
msgstr "// 비동기 테스트 코드가 여기에 들어갑니다."

#: src/08_futures/01_async_fn.md:148
msgid ""
"The exercise for this section is located in [`08_futures/01_async_fn`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/08_futures/01_async_fn)"
msgstr ""

#: src/08_futures/02_spawn.md:3
#, fuzzy
msgid "Your solution to the previous exercise should look something like this:"
msgstr "이전 연습에 대한 솔루션은 다음과 같습니다."

#: src/08_futures/02_spawn.md:15
#, fuzzy
msgid ""
"This is not bad!  \n"
"If a long time passes between two incoming connections, the `echo` function "
"will be idle (since `TcpListener::accept` is an asynchronous function), thus "
"allowing the executor to run other tasks in the meantime."
msgstr ""
"이것은 나쁘지 않습니다!  \n"
"두 개의 들어오는 연결 사이에 오랜 시간이 지나면 `echo` 함수는 유휴 상태가 되며"
"(`TcpListener::accept`는 비동기 함수이므로) 실행기가 그 동안 다른 작업을 실행"
"할 수 있습니다."

#: src/08_futures/02_spawn.md:20
#, fuzzy
msgid ""
"But how can we actually have multiple tasks running concurrently?  \n"
"If we always run our asynchronous functions until completion (by using `."
"await`), we'll never have more than one task running at a time."
msgstr ""
"하지만 실제로 여러 작업을 동시에 실행하려면 어떻게 해야 할까요?  \n"
"완료될 때까지 항상 비동기 함수를 실행한다면(`.await`를 사용하여) 한 번에 두 "
"개 이상의 작업이 실행되지 않습니다."

#: src/08_futures/02_spawn.md:24
#, fuzzy
msgid "This is where the `tokio::spawn` function comes in."
msgstr "이것이 `tokio::spawn` 함수가 들어오는 곳입니다."

#: src/08_futures/02_spawn.md:26
#, fuzzy
msgid "`tokio::spawn`"
msgstr "`tokio::spawn`"

#: src/08_futures/02_spawn.md:28
#, fuzzy
msgid ""
"`tokio::spawn` allows you to hand off a task to the executor, **without "
"waiting for it to complete**.  \n"
"Whenever you invoke `tokio::spawn`, you're telling `tokio` to continue "
"running the spawned task, in the background, **concurrently** with the task "
"that spawned it."
msgstr ""
"`tokio::spawn`을 사용하면 **완료될 때까지 기다리지 않고** 작업을 실행자에게 전"
"달할 수 있습니다.  \n"
"`tokio::spawn`을 호출할 때마다 `tokio`에게 생성된 작업을 백그라운드에서 생성"
"된 작업과 **동시에** 계속 실행하라고 지시하는 것입니다."

#: src/08_futures/02_spawn.md:32
#, fuzzy
msgid "Here's how you can use it to process multiple connections concurrently:"
msgstr "이를 사용하여 여러 연결을 동시에 처리하는 방법은 다음과 같습니다."

#: src/08_futures/02_spawn.md:40
#, fuzzy
msgid ""
"// Spawn a background task to handle the connection\n"
"        // thus allowing the main task to immediately start \n"
"        // accepting new connections\n"
msgstr ""
"// 연결을 처리하기 위해 백그라운드 작업을 생성합니다. // 따라서 기본 작업이 즉"
"시 시작될 수 있습니다. // 새 연결을 수락합니다."

#: src/08_futures/02_spawn.md:51
#, fuzzy
msgid "Asynchronous blocks"
msgstr "비동기 블록"

#: src/08_futures/02_spawn.md:53
#, fuzzy
msgid ""
"In this example, we've passed an **asynchronous block** to `tokio::spawn`: "
"`async move { /* */ }` Asynchronous blocks are a quick way to mark a region "
"of code as asynchronous without having to define a separate async function."
msgstr ""
"이 예에서는 **비동기 블록**을 `tokio::spawn`에 전달했습니다. `async move { /* "
"*/ }` 비동기 블록은 코드 영역을 비동기로 표시할 수 있는 빠른 방법입니다. 별도"
"의 비동기 함수를 정의합니다."

#: src/08_futures/02_spawn.md:57
#, fuzzy
msgid "`JoinHandle`"
msgstr "'조인핸들'"

#: src/08_futures/02_spawn.md:59
#, fuzzy
msgid ""
"`tokio::spawn` returns a `JoinHandle`.  \n"
"You can use `JoinHandle` to `.await` the background task, in the same way we "
"used `join` for spawned threads."
msgstr ""
"`tokio::spawn`은 `JoinHandle`을 반환합니다.  \n"
"생성된 스레드에 대해 'join'을 사용한 것과 같은 방식으로 'JoinHandle'을 사용하"
"여 백그라운드 작업을 '.await'할 수 있습니다."

#: src/08_futures/02_spawn.md:65
#, fuzzy
msgid ""
"// Spawn a background task to ship telemetry data\n"
"    // to a remote server\n"
msgstr ""
"// 원격 서버에 원격 측정 데이터를 전송하기 위한 백그라운드 작업을 생성합니다."

#: src/08_futures/02_spawn.md:68
#, fuzzy
msgid "// In the meantime, do some other useful work\n"
msgstr "// 그동안 다른 유용한 작업을 수행합니다."

#: src/08_futures/02_spawn.md:70
#, fuzzy
msgid ""
"// But don't return to the caller until \n"
"    // the telemetry data has been successfully delivered\n"
msgstr ""
"// 하지만 원격 측정 데이터가 성공적으로 전달될 때까지 // 호출자에게 반환하지 "
"마세요."

#: src/08_futures/02_spawn.md:84
#, fuzzy
msgid "Panic boundary"
msgstr "패닉 경계"

#: src/08_futures/02_spawn.md:86
#, fuzzy
msgid ""
"If a task spawned with `tokio::spawn` panics, the panic will be caught by the "
"executor.  \n"
"If you don't `.await` the corresponding `JoinHandle`, the panic won't be "
"propagated to the spawner. Even if you do `.await` the `JoinHandle`, the "
"panic won't be propagated automatically. Awaiting a `JoinHandle` returns a "
"`Result`, with [`JoinError`](https://docs.rs/tokio/latest/tokio/task/struct."
"JoinError.html) as its error type. You can then check if the task panicked by "
"calling `JoinError::is_panic` and choose what to do with the panic—either log "
"it, ignore it, or propagate it."
msgstr ""
"`tokio::spawn`으로 생성된 작업에 패닉이 발생하면 실행 프로그램이 패닉을 포착합"
"니다.  \n"
"해당하는 `JoinHandle`을 `.await`하지 않으면 패닉이 생성자에게 전파되지 않습니"
"다. `JoinHandle`을 `.await`하더라도 패닉이 자동으로 전파되지 않습니다. "
"'JoinHandle'을 기다리면 오류 유형이 'JoinError'인 '결과'가 반환됩니다. 그런 다"
"음 `JoinError::is_panic`을 호출하여 작업에 패닉이 발생했는지 확인하고 패닉 처"
"리 방법(기록, 무시 또는 전파)을 선택할 수 있습니다."

#: src/08_futures/02_spawn.md:100
#, fuzzy
msgid ""
"// The task has panicked\n"
"            // We resume unwinding the panic,\n"
"            // thus propagating it to the current task\n"
msgstr ""
"// 작업에 패닉이 발생했습니다. // 패닉 해제를 재개하여 // 이를 현재 작업에 전"
"파합니다."

#: src/08_futures/02_spawn.md:113
#, fuzzy
msgid "`std::thread::spawn` vs `tokio::spawn`"
msgstr "`std::thread::spawn` 대 `tokio::spawn`"

#: src/08_futures/02_spawn.md:115
#, fuzzy
msgid ""
"You can think of `tokio::spawn` as the asynchronous sibling of `std::spawn::"
"thread`."
msgstr ""
"`tokio::spawn`을 `std::spawn::thread`의 비동기 형제로 생각할 수 있습니다."

#: src/08_futures/02_spawn.md:117
#, fuzzy
msgid ""
"Notice a key difference: with `std::thread::spawn`, you're delegating control "
"to the OS scheduler. You're not in control of how threads are scheduled."
msgstr ""
"주요 차이점에 주목하세요. `std::thread::spawn`을 사용하면 제어권을 OS 스케줄러"
"에 위임합니다. 스레드 예약 방법을 제어할 수 없습니다."

#: src/08_futures/02_spawn.md:120
#, fuzzy
msgid ""
"With `tokio::spawn`, you're delegating to an async executor that runs "
"entirely in user space. The underlying OS scheduler is not involved in the "
"decision of which task to run next. We're in charge of that decision now, via "
"the executor we chose to use."
msgstr ""
"`tokio::spawn`을 사용하면 전적으로 사용자 공간에서 실행되는 비동기 실행기에 위"
"임하게 됩니다. 기본 OS 스케줄러는 다음에 실행할 작업을 결정하는 데 관여하지 않"
"습니다. 우리는 이제 우리가 사용하기로 선택한 실행자를 통해 그 결정을 담당하고 "
"있습니다."

#: src/08_futures/02_spawn.md:126
msgid ""
"The exercise for this section is located in [`08_futures/02_spawn`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/08_futures/02_spawn)"
msgstr ""

#: src/08_futures/03_runtime.md:1
#, fuzzy
msgid "Runtime architecture"
msgstr "런타임 아키텍처"

#: src/08_futures/03_runtime.md:3
#, fuzzy
msgid ""
"So far we've been talking about async runtimes as an abstract concept. Let's "
"dig a bit deeper into the way they are implemented—as you'll see soon enough, "
"it has an impact on our code."
msgstr ""
"지금까지 우리는 추상적인 개념으로 비동기 런타임에 대해 이야기해왔습니다. 구현 "
"방식에 대해 좀 더 자세히 살펴보겠습니다. 곧 알게 되겠지만 이는 코드에 영향을 "
"미칩니다."

#: src/08_futures/03_runtime.md:7
#, fuzzy
msgid "Flavors"
msgstr "맛"

#: src/08_futures/03_runtime.md:9
#, fuzzy
msgid "`tokio` ships two different runtime _flavors_."
msgstr "`tokio`는 두 가지 다른 런타임 _flavors_를 제공합니다."

#: src/08_futures/03_runtime.md:11
#, fuzzy
msgid "You can configure your runtime via `tokio::runtime::Builder`:"
msgstr "`tokio::runtime::Builder`를 통해 런타임을 구성할 수 있습니다."

#: src/08_futures/03_runtime.md:13
#, fuzzy
msgid ""
"`Builder::new_multi_thread` gives you a **multithreaded `tokio` runtime**"
msgstr ""
"`Builder::new_multi_thread`는 **멀티스레드 `tokio` 런타임**을 제공합니다."

#: src/08_futures/03_runtime.md:14
#, fuzzy
msgid ""
"`Builder::new_current_thread` will instead rely on the **current thread** for "
"execution."
msgstr ""
"대신 `Builder::new_current_thread`는 실행을 위해 **현재 스레드**에 의존합니다."

#: src/08_futures/03_runtime.md:16
#, fuzzy
msgid ""
"`#[tokio::main]` returns a multithreaded runtime by default, while `#[tokio::"
"test]` uses a current thread runtime out of the box."
msgstr ""
"`#[tokio::main]`은 기본적으로 다중 스레드 런타임을 반환하는 반면 `#[tokio::"
"test]`는 기본적으로 현재 스레드 런타임을 사용합니다."

#: src/08_futures/03_runtime.md:19
#, fuzzy
msgid "Current thread runtime"
msgstr "현재 스레드 런타임"

#: src/08_futures/03_runtime.md:21
#, fuzzy
msgid ""
"The current-thread runtime, as the name implies, relies exclusively on the OS "
"thread it was launched on to schedule and execute tasks.  \n"
"When using the current-thread runtime, you have **concurrency** but no "
"**parallelism**: asynchronous tasks will be interleaved, but there will "
"always be at most one task running at any given time."
msgstr ""
"현재 스레드 런타임은 이름에서 알 수 있듯이 작업을 예약하고 실행하기 위해 시작"
"된 OS 스레드에만 의존합니다.  \n"
"현재 스레드 런타임을 사용하는 경우 **동시성**은 있지만 **병렬성**은 없습니다. "
"비동기 작업은 인터리브되지만 주어진 시간에 항상 최대 하나의 작업이 실행됩니다."

#: src/08_futures/03_runtime.md:27
#, fuzzy
msgid "Multithreaded runtime"
msgstr "멀티스레드 런타임"

#: src/08_futures/03_runtime.md:29
#, fuzzy
msgid ""
"When using the multithreaded runtime, instead, there can up to `N` tasks "
"running _in parallel_ at any given time, where `N` is the number of threads "
"used by the runtime. By default, `N` matches the number of available CPU "
"cores."
msgstr ""
"대신 멀티스레드 런타임을 사용하는 경우 주어진 시간에 최대 'N'개의 작업을 _병렬"
"_로 실행할 수 있습니다. 여기서 'N'은 런타임에서 사용하는 스레드 수입니다. 기본"
"적으로 'N'은 사용 가능한 CPU 코어 수와 일치합니다."

#: src/08_futures/03_runtime.md:33
#, fuzzy
msgid ""
"There's more: `tokio` performs **work-stealing**.  \n"
"If a thread is idle, it won't wait around: it'll try to find a new task "
"that's ready for execution, either from a global queue or by stealing it from "
"the local queue of another thread.  \n"
"Work-stealing can have significant performance benefits, especially on tail "
"latencies, whenever your application is dealing with workloads that are not "
"perfectly balanced across threads."
msgstr ""
"더 많은 것이 있습니다: `tokio`는 **작업 훔치기**를 수행합니다.  \n"
"스레드가 유휴 상태이면 기다리지 않고 전역 대기열에서 또는 다른 스레드의 로컬 "
"대기열에서 이를 훔쳐 실행할 준비가 된 새 작업을 찾으려고 시도합니다.  \n"
"작업 가로채기는 애플리케이션이 스레드 간에 완벽하게 균형을 이루지 못한 작업 부"
"하를 처리할 때마다 특히 꼬리 지연 시간에 상당한 성능 이점을 제공할 수 있습니"
"다."

#: src/08_futures/03_runtime.md:41
#, fuzzy
msgid "Implications"
msgstr "시사점"

#: src/08_futures/03_runtime.md:43
#, fuzzy
msgid ""
"`tokio::spawn` is flavor-agnostic: it'll work no matter if you're running on "
"the multithreaded or current-thread runtime. The downside is that the "
"signature assume the worst case (i.e. multithreaded) and is constrained "
"accordingly:"
msgstr ""
"`tokio::spawn`은 버전에 구애받지 않습니다. 다중 스레드 런타임이나 현재 스레드 "
"런타임에서 실행 중인지 상관없이 작동합니다. 단점은 서명이 최악의 경우(예: 다"
"중 스레드)를 가정하고 이에 따라 제한된다는 것입니다."

#: src/08_futures/03_runtime.md:55
#, fuzzy
msgid ""
"Let's ignore the `Future` trait for now to focus on the rest.  \n"
"`spawn` is asking all its inputs to be `Send` and have a `'static` lifetime."
msgstr ""
"지금은 '미래' 특성을 무시하고 나머지 부분에 집중하겠습니다.  \n"
"`spawn`은 모든 입력이 `Send`이고 `정적` 수명을 갖도록 요청합니다."

#: src/08_futures/03_runtime.md:58
#, fuzzy
msgid ""
"The `'static` constraint follows the same rationale of the `'static` "
"constraint on `std::thread::spawn`: the spawned task may outlive the context "
"it was spawned from, therefore it shouldn't depend on any local data that may "
"be de-allocated after the spawning context is destroyed."
msgstr ""
"`정적` 제약 조건은 `std::thread::spawn`에 대한 `정적` 제약 조건과 동일한 근거"
"를 따릅니다. 생성된 작업은 생성된 컨텍스트보다 오래 지속될 수 있으므로 로컬 데"
"이터에 의존해서는 안 됩니다. 생성 컨텍스트가 삭제된 후 할당이 취소될 수 있습니"
"다."

#: src/08_futures/03_runtime.md:66
#, fuzzy
msgid ""
"// This won't work, since `&v` doesn't\n"
"    // live long enough.\n"
msgstr "// `&v`는 // 충분히 오래 지속되지 않기 때문에 작동하지 않습니다."

#: src/08_futures/03_runtime.md:70
#, fuzzy
msgid "\"{x}\""
msgstr "\"{엑스}\""

#: src/08_futures/03_runtime.md:76
#, fuzzy
msgid ""
"`Send`, on the other hand, is a direct consequence of `tokio`'s work-stealing "
"strategy: a task that was spawned on thread `A` may end up being moved to "
"thread `B` if that's idle, thus requiring a `Send` bound since we're crossing "
"thread boundaries."
msgstr ""
"반면에 `Send`는 `tokio`의 작업 도용 전략의 직접적인 결과입니다. 스레드 `A`에"
"서 생성된 작업은 스레드 `B`가 유휴 상태인 경우 결국 스레드 `B`로 이동될 수 있"
"습니다. 스레드 경계를 넘었기 때문에 `Send` 경계입니다."

#: src/08_futures/03_runtime.md:82
#, fuzzy
msgid ""
"// This won't work either, because\n"
"    // `Rc` isn't `Send`.\n"
msgstr ""
"// 이 역시 작동하지 않습니다. 왜냐하면 // `Rc`는 `Send`가 아니기 때문입니다."

#: src/08_futures/03_runtime.md:92
msgid ""
"The exercise for this section is located in [`08_futures/03_runtime`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/08_futures/03_runtime)"
msgstr ""

#: src/08_futures/04_future.md:1 src/08_futures/04_future.md:71
#, fuzzy
msgid "The `Future` trait"
msgstr "'미래' 특성"

#: src/08_futures/04_future.md:3
#, fuzzy
msgid "The local `Rc` problem"
msgstr "지역 `Rc` 문제"

#: src/08_futures/04_future.md:5
#, fuzzy
msgid "Let's go back to `tokio::spawn`'s signature:"
msgstr "`tokio::spawn`의 서명으로 돌아가 보겠습니다."

#: src/08_futures/04_future.md:15
#, fuzzy
msgid ""
"What does it _actually_ mean for `F` to be `Send`?  \n"
"It implies, as we saw in the previous section, that whatever value it "
"captures from the spawning environment has to be `Send`. But it goes further "
"than that."
msgstr ""
"`F`가 `보내기`라는 것이 _실제로_ 무엇을 의미하나요?  \n"
"이는 이전 섹션에서 본 것처럼 생성 환경에서 캡처하는 값이 무엇이든 'Send'여야 "
"함을 의미합니다. 그러나 그것은 그 이상입니다."

#: src/08_futures/04_future.md:19
#, fuzzy
msgid ""
"Any value that's _held across a .await point_ has to be `Send`.  \n"
"Let's look at an example:"
msgstr ""
".await 지점 전체에 걸쳐 _보유된_ 모든 값은 `Send`여야 합니다.  \n"
"예를 살펴보겠습니다:"

#: src/08_futures/04_future.md:31
#, fuzzy
msgid ""
"// A value that's not `Send`,\n"
"    // created _inside_ the async function\n"
msgstr "// `Send`가 아닌 값, // 비동기 함수 _내부_에서 생성됨"

#: src/08_futures/04_future.md:35
#, fuzzy
msgid "// A `.await` point that does nothing\n"
msgstr "// 아무것도 하지 않는 `.await` 지점"

#: src/08_futures/04_future.md:38
#, fuzzy
msgid ""
"// The local non-`Send` value is still needed\n"
"    // after the `.await`\n"
msgstr "// `.await` 뒤에는 `Send`가 아닌 로컬 값이 여전히 필요합니다."

#: src/08_futures/04_future.md:44
#, fuzzy
msgid "The compiler will reject this code:"
msgstr "컴파일러는 다음 코드를 거부합니다."

#: src/08_futures/04_future.md:46
msgid ""
"```text\n"
"error: future cannot be sent between threads safely\n"
"    |\n"
"5   |     tokio::spawn(example());\n"
"    |                  ^^^^^^^^^ future returned by `example` is not `Send`\n"
"    |\n"
"note: future is not `Send` as this value is used across an await\n"
"    |\n"
"11  |     let non_send = Rc::new(1);\n"
"    |         -------- has type `Rc<i32>` which is not `Send`\n"
"12  |     // A `.await` point\n"
"13  |     yield_now().await;\n"
"    |                 ^^^^^ await occurs here, with `non_send` maybe used "
"later\n"
"note: required by a bound in `tokio::spawn`\n"
"    |\n"
"164 |     pub fn spawn<F>(future: F) -> JoinHandle<F::Output>\n"
"    |            ----- required by a bound in this function\n"
"165 |     where\n"
"166 |         F: Future + Send + 'static,\n"
"    |                     ^^^^ required by this bound in `spawn`\n"
"```"
msgstr ""

#: src/08_futures/04_future.md:68
#, fuzzy
msgid ""
"To understand why that's the case, we need to refine our understanding of "
"Rust's asynchronous model."
msgstr ""
"왜 그런 경우인지 이해하려면 Rust의 비동기 모델에 대한 이해를 개선해야 합니다."

#: src/08_futures/04_future.md:73
#, fuzzy
msgid ""
"We stated early on that `async` functions return **futures**, types that "
"implement the `Future` trait. You can think of a future as a **state "
"machine**. It's in one of two states:"
msgstr ""
"우리는 `async` 함수가 `Future` 특성을 구현하는 유형인 **futures**를 반환한다"
"고 일찍 밝혔습니다. 미래를 **상태 머신**으로 생각할 수 있습니다. 다음 두 가지 "
"상태 중 하나입니다."

#: src/08_futures/04_future.md:77
#, fuzzy
msgid "**pending**: the computation has not finished yet."
msgstr "**보류 중**: 계산이 아직 완료되지 않았습니다."

#: src/08_futures/04_future.md:78
#, fuzzy
msgid "**ready**: the computation has finished, here's the output."
msgstr "**준비**: 계산이 완료되었습니다. 출력은 다음과 같습니다."

#: src/08_futures/04_future.md:80
#, fuzzy
msgid "This is encoded in the trait definition:"
msgstr "이는 특성 정의에 인코딩되어 있습니다."

#: src/08_futures/04_future.md:86
#, fuzzy
msgid "// Ignore `Pin` and `Context` for now\n"
msgstr "// 지금은 `Pin`과 `Context`를 무시합니다."

#: src/08_futures/04_future.md:91
#, fuzzy
msgid "`poll`"
msgstr "'설문조사'"

#: src/08_futures/04_future.md:93
#, fuzzy
msgid ""
"The `poll` method is the heart of the `Future` trait.  \n"
"A future on its own doesn't do anything. It needs to be **polled** to make "
"progress.  \n"
"When you call `poll`, you're asking the future to do some work. `poll` tries "
"to make progress, and then returns one of the following:"
msgstr ""
"'Poll' 방법은 'Future' 특성의 핵심입니다.  \n"
"미래 그 자체로는 아무것도 할 수 없습니다. 진행하려면 **폴링**이 필요합니"
"다.  \n"
"'poll'을 호출하면 미래에 작업을 요청하는 것입니다. `poll`은 진행을 시도한 후 "
"다음 중 하나를 반환합니다."

#: src/08_futures/04_future.md:98
#, fuzzy
msgid ""
"`Poll::Pending`: the future is not ready yet. You need to call `poll` again "
"later."
msgstr ""
"`Poll::Pending`: 미래는 아직 준비되지 않았습니다. 나중에 'poll'을 다시 호출해"
"야 합니다."

#: src/08_futures/04_future.md:99
#, fuzzy
msgid ""
"`Poll::Ready(value)`: the future has finished. `value` is the result of the "
"computation, of type `Self::Output`."
msgstr ""
"`Poll::Ready(value)`: future가 완료되었습니다. 'value'는 'Self::Output' 유형"
"의 계산 결과입니다."

#: src/08_futures/04_future.md:102
#, fuzzy
msgid ""
"Once `Future::poll` returns `Poll::Ready`, it should not be polled again: the "
"future has completed, there's nothing left to do."
msgstr ""
"`Future::poll`이 `Poll::Ready`를 반환하면 다시 폴링해서는 안 됩니다. future가 "
"완료되었으므로 더 이상 할 일이 없습니다."

#: src/08_futures/04_future.md:105
#, fuzzy
msgid "The role of the runtime"
msgstr "런타임의 역할"

#: src/08_futures/04_future.md:107
#, fuzzy
msgid ""
"You'll rarely, if ever, be calling poll directly.  \n"
"That's the job of your async runtime: it has all the required information "
"(the `Context` in `poll`'s signature) to ensure that your futures are making "
"progress whenever they can."
msgstr ""
"설문 조사를 직접 호출하는 경우는 거의 없습니다.  \n"
"이것이 비동기 런타임의 임무입니다. 미래가 가능할 때마다 진행되고 있는지 확인하"
"는 데 필요한 모든 정보(`poll` 서명의 `Context`)가 있습니다."

#: src/08_futures/04_future.md:111
#, fuzzy
msgid "`async fn` and futures"
msgstr "`async fn`과 미래"

#: src/08_futures/04_future.md:113
#, fuzzy
msgid ""
"We've worked with the high-level interface, asynchronous functions.  \n"
"We've now looked at the low-level primitive, the `Future trait`."
msgstr ""
"우리는 높은 수준의 인터페이스인 비동기 기능을 사용해 작업했습니다.  \n"
"우리는 이제 저수준 프리미티브인 '미래 특성'을 살펴보았습니다."

#: src/08_futures/04_future.md:116
#, fuzzy
msgid "How are they related?"
msgstr "그들은 어떻게 관련되어 있습니까?"

#: src/08_futures/04_future.md:118
#, fuzzy
msgid ""
"Every time you mark a function as asynchronous, that function will return a "
"future. The compiler will transform the body of your asynchronous function "
"into a **state machine**: one state for each `.await` point."
msgstr ""
"함수를 비동기로 표시할 때마다 해당 함수는 future를 반환합니다. 컴파일러는 비동"
"기 함수의 본문을 **상태 머신**으로 변환합니다. 각 `.await` 지점에 대해 하나의 "
"상태입니다."

#: src/08_futures/04_future.md:122
#, fuzzy
msgid "Going back to our `Rc` example:"
msgstr "`Rc` 예제로 돌아가면:"

#: src/08_futures/04_future.md:135
#, fuzzy
msgid ""
"The compiler would transform it into an enum that looks somewhat like this:"
msgstr "컴파일러는 이를 다음과 같은 열거형으로 변환합니다."

#: src/08_futures/04_future.md:145
#, fuzzy
msgid ""
"When `example` is called, it returns `ExampleFuture::NotStarted`. The future "
"has never been polled yet, so nothing has happened.  \n"
"When the runtime polls it the first time, `ExampleFuture` will advance until "
"the next `.await` point: it'll stop at the `ExampleFuture::YieldNow(Rc<i32>)` "
"stage of the state machine, returning `Poll::Pending`.  \n"
"When it's polled again, it'll execute the remaining code (`println!`) and "
"return `Poll::Ready(())`."
msgstr ""
"`example`이 호출되면 `ExampleFuture::NotStarted`를 반환합니다. 미래는 아직 폴"
"링된 적이 없으므로 아무 일도 일어나지 않았습니다.  \n"
"런타임이 처음으로 폴링하면 `ExampleFuture`는 다음 `.await` 지점까지 진행됩니"
"다. 상태 시스템의 `ExampleFuture::YieldNow(Rc<i32>)` 단계에서 멈추고 `Poll'을 "
"반환합니다. ::보류중`.  \n"
"다시 폴링되면 나머지 코드(`println!`)를 실행하고 `Poll::Ready(())`를 반환합니"
"다."

#: src/08_futures/04_future.md:153
#, fuzzy
msgid ""
"When you look at its state machine representation, `ExampleFuture`, it is now "
"clear why `example` is not `Send`: it holds an `Rc`, therefore it cannot be "
"`Send`."
msgstr ""
"상태 머신 표현인 `ExampleFuture`를 보면 이제 `example`이 `Send`가 아닌 이유가 "
"분명해졌습니다. 여기에는 `Rc`가 있으므로 `Send`가 될 수 없습니다."

#: src/08_futures/04_future.md:157
#, fuzzy
msgid "Yield points"
msgstr "항복점"

#: src/08_futures/04_future.md:159
#, fuzzy
msgid ""
"As you've just seen with `example`, every `.await` point creates a new "
"intermediate state in the lifecycle of a future.  \n"
"That's why `.await` points are also known as **yield points**: your future "
"_yields control_ back to the runtime that was polling it, allowing the "
"runtime to pause it and (if necessary) schedule another task for execution, "
"thus making progress on multiple fronts concurrently."
msgstr ""
"방금 `example`에서 본 것처럼 모든 `.await` 지점은 future의 수명 주기에서 새로"
"운 중간 상태를 생성합니다.  \n"
"그렇기 때문에 `.await` 포인트는 **수율 포인트**라고도 알려져 있습니다. 미래의 "
"_수율 제어_는 이를 폴링한 런타임으로 돌아가서 런타임이 이를 일시 중지하고 (필"
"요한 경우) 실행을 위해 다른 작업을 예약할 수 있도록 합니다. 여러 분야에서 동시"
"에 진행됩니다."

#: src/08_futures/04_future.md:165
#, fuzzy
msgid "We'll come back to the importance of yielding in a later section."
msgstr "우리는 나중 섹션에서 양보의 중요성으로 다시 돌아오겠습니다."

#: src/08_futures/04_future.md:169
msgid ""
"The exercise for this section is located in [`08_futures/04_future`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/08_futures/04_future)"
msgstr ""

#: src/08_futures/05_blocking.md:1
#, fuzzy
msgid "Don't block the runtime"
msgstr "런타임을 차단하지 마세요"

#: src/08_futures/05_blocking.md:3
#, fuzzy
msgid ""
"Let's circle back to yield points.  \n"
"Unlike threads, **Rust tasks cannot be preempted**."
msgstr ""
"항복점으로 다시 돌아갑시다.  \n"
"스레드와 달리 **Rust 작업은 선점될 수 없습니다**."

#: src/08_futures/05_blocking.md:6
#, fuzzy
msgid ""
"`tokio` cannot, on its own, decide to pause a task and run another one in its "
"place. The control goes back to the executor **exclusively** when the task "
"yields—i.e. when `Future::poll` returns `Poll::Pending` or, in the case of "
"`async fn`, when you `.await` a future."
msgstr ""
"'tokio'는 자체적으로 작업을 일시 중지하고 그 자리에서 다른 작업을 실행하기로 "
"결정할 수 없습니다. 작업이 양보되면 제어권은 **독점적으로** 실행자에게 돌아갑"
"니다. 즉, `Future::poll`이 `Poll::Pending`을 반환할 때 또는 `async fn`의 경우 "
"미래를 `.await`할 때."

#: src/08_futures/05_blocking.md:11
#, fuzzy
msgid ""
"This exposes the runtime to a risk: if a task never yields, the runtime will "
"never be able to run another task. This is called **blocking the runtime**."
msgstr ""
"이로 인해 런타임이 위험에 노출됩니다. 작업이 결코 양보되지 않으면 런타임은 다"
"른 작업을 실행할 수 없습니다. 이를 **런타임 차단**이라고 합니다."

#: src/08_futures/05_blocking.md:14
#, fuzzy
msgid "What is blocking?"
msgstr "차단이란 무엇입니까?"

#: src/08_futures/05_blocking.md:16
#, fuzzy
msgid ""
"How long is too long? How much time can a task spend without yielding before "
"it becomes a problem?"
msgstr ""
"얼마나 긴가요? 작업이 문제가 되기 전에 양보하지 않고 얼마나 많은 시간을 보낼 "
"수 있습니까?"

#: src/08_futures/05_blocking.md:19
#, fuzzy
msgid ""
"It depends on the runtime, the application, the number of in-flight tasks, "
"and many other factors. But, as a general rule of thumb, try to spend less "
"than 100 microseconds between yield points."
msgstr ""
"런타임, 애플리케이션, 진행 중인 작업 수 및 기타 여러 요인에 따라 달라집니다. "
"그러나 일반적으로 항복점 사이에 100마이크로초 미만의 시간을 소비하도록 노력하"
"십시오."

#: src/08_futures/05_blocking.md:23
#, fuzzy
msgid "Consequences"
msgstr "결과"

#: src/08_futures/05_blocking.md:25
#, fuzzy
msgid "Blocking the runtime can lead to:"
msgstr "런타임을 차단하면 다음과 같은 결과가 발생할 수 있습니다."

#: src/08_futures/05_blocking.md:27
#, fuzzy
msgid ""
"**Deadlocks**: if the task that's not yielding is waiting for another task to "
"complete, and that task is waiting for the first one to yield, you have a "
"deadlock. No progress can be made, unless the runtime is able to schedule the "
"other task on a different thread."
msgstr ""
"**교착 상태**: 양보하지 않는 작업이 다른 작업이 완료되기를 기다리고 있고 해당 "
"작업이 첫 번째 작업이 양보되기를 기다리고 있다면 교착 상태가 발생한 것입니다. "
"런타임이 다른 스레드에서 다른 작업을 예약할 수 없으면 진행이 불가능합니다."

#: src/08_futures/05_blocking.md:31
#, fuzzy
msgid ""
"**Starvation**: other tasks might not be able to run, or might run after a "
"long delay, which can lead to poor performances (e.g. high tail latencies)."
msgstr ""
"**기아**: 다른 작업을 실행할 수 없거나 오랜 지연 후에 실행될 수 있으며, 이로 "
"인해 성능이 저하될 수 있습니다(예: 긴 꼬리 지연 시간)."

#: src/08_futures/05_blocking.md:34
#, fuzzy
msgid "Blocking is not always obvious"
msgstr "차단이 항상 명확한 것은 아닙니다."

#: src/08_futures/05_blocking.md:36
#, fuzzy
msgid ""
"Some types of operations should generally be avoided in async code, like:"
msgstr ""
"다음과 같은 일부 유형의 작업은 일반적으로 비동기 코드에서 피해야 합니다."

#: src/08_futures/05_blocking.md:38
#, fuzzy
msgid ""
"Synchronous I/O. You can't predict how long it will take, and it's likely to "
"be longer than 100 microseconds."
msgstr ""
"동기식 I/O. 시간이 얼마나 걸릴지 예측할 수 없으며 100마이크로초보다 길어질 가"
"능성이 높습니다."

#: src/08_futures/05_blocking.md:40
#, fuzzy
msgid "Expensive CPU-bound computations."
msgstr "CPU 바인딩된 계산 비용이 많이 듭니다."

#: src/08_futures/05_blocking.md:42
msgid ""
"The latter category is not always obvious though. For example, sorting a "
"vector with a few elements is not a problem; that evaluation changes if the "
"vector has billions of entries."
msgstr ""

#: src/08_futures/05_blocking.md:46
#, fuzzy
msgid "How to avoid blocking"
msgstr "차단을 피하는 방법"

#: src/08_futures/05_blocking.md:48
#, fuzzy
msgid ""
"OK, so how do you avoid blocking the runtime assuming you _must_ perform an "
"operation that qualifies or risks qualifying as blocking?  \n"
"You need to move the work to a different thread. You don't want to use the so-"
"called runtime threads, the ones used by `tokio` to run tasks."
msgstr ""
"그렇다면 차단 자격을 갖추거나 차단 자격을 얻을 위험이 있는 작업을 _반드시_ 수"
"행해야 한다고 가정할 때 런타임 차단을 어떻게 방지할 수 있을까요?  \n"
"작업을 다른 스레드로 이동해야 합니다. 작업을 실행하기 위해 `tokio`에서 사용하"
"는 소위 런타임 스레드를 사용하고 싶지 않습니다."

#: src/08_futures/05_blocking.md:53
#, fuzzy
msgid ""
"`tokio` provides a dedicated threadpool for this purpose, called the "
"**blocking pool**. You can spawn a synchronous operation on the blocking pool "
"using the `tokio::task::spawn_blocking` function. `spawn_blocking` returns a "
"future that resolves to the result of the operation when it completes."
msgstr ""
"`tokio`는 이 목적을 위해 **차단 풀**이라고 불리는 전용 스레드 풀을 제공합니"
"다. `tokio::task::spawn_blocking` 함수를 사용하여 차단 풀에서 동기 작업을 생성"
"할 수 있습니다. `spawn_blocking`은 작업이 완료되면 작업 결과로 확인되는 future"
"를 반환합니다."

#: src/08_futures/05_blocking.md:67
#, fuzzy
msgid "// Do other stuff in the meantime\n"
msgstr "// 그동안 다른 일을 하세요"

#: src/08_futures/05_blocking.md:72
#, fuzzy
msgid ""
"The blocking pool is long-lived. `spawn_blocking` should be faster than "
"creating a new thread directly via `std::thread::spawn` because the cost of "
"thread initialization is amortized over multiple calls."
msgstr ""
"차단 풀은 수명이 길다. 스레드 초기화 비용은 여러 호출을 통해 분할되므로 "
"`spawn_blocking`은 `std::thread::spawn`을 통해 직접 새 스레드를 생성하는 것보"
"다 더 빠릅니다."

#: src/08_futures/05_blocking.md:78
#, fuzzy
msgid ""
"Check out [Alice Ryhl's blog post](https://ryhl.io/blog/async-what-is-"
"blocking/) on the topic."
msgstr "해당 주제에 대한 Alice Ryhl의 블로그 게시물을 확인하세요."

#: src/08_futures/05_blocking.md:83
msgid ""
"The exercise for this section is located in [`08_futures/05_blocking`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/08_futures/05_blocking)"
msgstr ""

#: src/08_futures/06_async_aware_primitives.md:3
#, fuzzy
msgid ""
"If you browse `tokio`'s documentation, you'll notice that it provides a lot "
"of types that \"mirror\" the ones in the standard library, but with an "
"asynchronous twist: locks, channels, timers, and more."
msgstr ""
"`tokio`의 문서를 찾아보면 표준 라이브러리의 유형을 \"미러링\"하지만 잠금, 채"
"널, 타이머 등 비동기식 변형이 포함된 많은 유형을 제공한다는 것을 알 수 있습니"
"다."

#: src/08_futures/06_async_aware_primitives.md:7
#, fuzzy
msgid ""
"When working in an asynchronous context, you should prefer these asynchronous "
"alternatives to their synchronous counterparts."
msgstr ""
"비동기식 컨텍스트에서 작업할 때는 동기식 컨텍스트보다 이러한 비동기식 대안을 "
"선호해야 합니다."

#: src/08_futures/06_async_aware_primitives.md:10
#, fuzzy
msgid ""
"To understand why, let's take a look at `Mutex`, the mutually exclusive lock "
"we explored in the previous chapter."
msgstr ""
"그 이유를 이해하기 위해 이전 장에서 살펴본 상호 배타적 잠금 장치인 'Mutex'를 "
"살펴보겠습니다."

#: src/08_futures/06_async_aware_primitives.md:13
#, fuzzy
msgid "Case study: `Mutex`"
msgstr "사례 연구: '뮤텍스'"

#: src/08_futures/06_async_aware_primitives.md:15
#, fuzzy
msgid "Let's look at a simple example:"
msgstr "간단한 예를 살펴보겠습니다."

#: src/08_futures/06_async_aware_primitives.md:23
#: src/08_futures/06_async_aware_primitives.md:70
#, fuzzy
msgid "\"Sent {:?} to the server\""
msgstr "\"{:?}을(를) 서버로 보냈습니다.\""

#: src/08_futures/06_async_aware_primitives.md:24
#: src/08_futures/06_async_aware_primitives.md:71
#, fuzzy
msgid "// `guard` is dropped here\n"
msgstr "// `guard`가 여기에 삭제되었습니다."

#: src/08_futures/06_async_aware_primitives.md:26
#, fuzzy
msgid "/// Use `v` as the body of an HTTP call.\n"
msgstr "/// `v`를 HTTP 호출의 본문으로 사용합니다."

#: src/08_futures/06_async_aware_primitives.md:33
#, fuzzy
msgid "`std::sync::MutexGuard` and yield points"
msgstr "`std::sync::MutexGuard` 및 항복점"

#: src/08_futures/06_async_aware_primitives.md:35
#, fuzzy
msgid "This code will compile, but it's dangerous."
msgstr "이 코드는 컴파일되지만 위험합니다."

#: src/08_futures/06_async_aware_primitives.md:37
#, fuzzy
msgid ""
"We try to acquire a lock over a `Mutex` from `std` in an asynchronous "
"context. We then hold on to the resulting `MutexGuard` across a yield point "
"(the `.await` on `http_call`)."
msgstr ""
"비동기 컨텍스트의 `std`에서 `Mutex`에 대한 잠금을 획득하려고 합니다. 그런 다"
"음 항복 지점(`http_call`의 `.await`)에서 결과 `MutexGuard`를 유지합니다."

#: src/08_futures/06_async_aware_primitives.md:41
#, fuzzy
msgid ""
"Let's imagine that there are two tasks executing `run`, concurrently, on a "
"single-threaded runtime. We observe the following sequence of scheduling "
"events:"
msgstr ""
"단일 스레드 런타임에서 'run'을 동시에 실행하는 두 가지 작업이 있다고 가정해 보"
"겠습니다. 우리는 다음과 같은 일정 이벤트 순서를 관찰합니다."

#: src/08_futures/06_async_aware_primitives.md:55
#, fuzzy
msgid ""
"We have a deadlock. Task B we'll never manage to acquire the lock, because "
"the lock is currently held by task A, which has yielded to the runtime before "
"releasing the lock and won't be scheduled again because the runtime cannot "
"preempt task B."
msgstr ""
"교착상태에 빠졌습니다. 작업 B는 잠금을 획득하지 못할 것입니다. 현재 작업 A가 "
"잠금을 보유하고 있기 때문입니다. 작업 A는 잠금을 해제하기 전에 런타임에 양보했"
"으며 런타임이 작업 B를 선점할 수 없기 때문에 다시 예약되지 않습니다."

#: src/08_futures/06_async_aware_primitives.md:59
#, fuzzy
msgid "`tokio::sync::Mutex`"
msgstr "`tokio::sync::뮤텍스`"

#: src/08_futures/06_async_aware_primitives.md:61
#, fuzzy
msgid "You can solve the issue by switching to `tokio::sync::Mutex`:"
msgstr "`tokio::sync::Mutex`로 전환하면 문제를 해결할 수 있습니다."

#: src/08_futures/06_async_aware_primitives.md:75
#, fuzzy
msgid ""
"Acquiring the lock is now an asynchronous operation, which yields back to the "
"runtime if it can't make progress.  \n"
"Going back to the previous scenario, the following would happen:"
msgstr ""
"잠금 획득은 이제 비동기식 작업으로 진행되지 않으면 런타임으로 반환됩니다.  \n"
"이전 시나리오로 돌아가면 다음과 같은 일이 발생합니다."

#: src/08_futures/06_async_aware_primitives.md:104
#, fuzzy
msgid "All good!"
msgstr "문제 없다!"

#: src/08_futures/06_async_aware_primitives.md:106
#, fuzzy
msgid "Multithreaded won't save you"
msgstr "멀티스레드로는 당신을 구할 수 없습니다"

#: src/08_futures/06_async_aware_primitives.md:108
msgid ""
"We've used a single-threaded runtime as the execution context in our previous "
"example, but the same risk persists even when using a multithreaded "
"runtime.  \n"
"The only difference is in the number of concurrent tasks required to create "
"the deadlock: in a single-threaded runtime, 2 are enough; in a multithreaded "
"runtime, we would need `N+1` tasks, where `N` is the number of runtime "
"threads."
msgstr ""

#: src/08_futures/06_async_aware_primitives.md:117
#, fuzzy
msgid ""
"Having an async-aware `Mutex` comes with a performance penalty.  \n"
"If you're confident that the lock isn't under significant contention _and_ "
"you're careful to never hold it across a yield point, you can still use `std::"
"sync::Mutex` in an asynchronous context."
msgstr ""
"비동기 인식 `Mutex`를 사용하면 성능이 저하됩니다.  \n"
"잠금이 심각한 경합 상태에 있지 않다고 확신하고 _그리고_ 양보 지점을 넘어 잠금"
"을 유지하지 않도록 주의한다면 여전히 비동기 컨텍스트에서 `std::sync::Mutex`를 "
"사용할 수 있습니다."

#: src/08_futures/06_async_aware_primitives.md:122
#, fuzzy
msgid ""
"But weigh the performance benefit against the liveness risk you will incur."
msgstr "하지만 발생할 수 있는 활성 위험과 성능상의 이점을 비교해보세요."

#: src/08_futures/06_async_aware_primitives.md:125
#, fuzzy
msgid "Other primitives"
msgstr "기타 프리미티브"

#: src/08_futures/06_async_aware_primitives.md:127
#, fuzzy
msgid ""
"We used `Mutex` as an example, but the same applies to `RwLock`, semaphores, "
"etc.  \n"
"Prefer async-aware versions when working in an asynchronous context to "
"minimise the risk of issues."
msgstr ""
"예시로 `Mutex`를 사용했지만 `RwLock`, 세마포어 등에도 동일하게 적용됩니다.  \n"
"문제 위험을 최소화하려면 비동기 컨텍스트에서 작업할 때 비동기 인식 버전을 선호"
"하세요."

#: src/08_futures/06_async_aware_primitives.md:133
msgid ""
"The exercise for this section is located in "
"[`08_futures/06_async_aware_primitives`](https://github.com/mainmatter/100-"
"exercises-to-learn-rust/tree/main/"
"exercises/08_futures/06_async_aware_primitives)"
msgstr ""

#: src/08_futures/07_cancellation.md:3
#, fuzzy
msgid ""
"What happens when a pending future is dropped?  \n"
"The runtime will no longer poll it, therefore it won't make any further "
"progress. In other words, its execution has been **cancelled**."
msgstr ""
"보류 중인 미래가 삭제되면 어떻게 되나요?  \n"
"런타임은 더 이상 폴링하지 않으므로 더 이상 진행되지 않습니다. 즉, 실행이 **취"
"소**되었습니다."

#: src/08_futures/07_cancellation.md:7
#, fuzzy
msgid "In the wild, this often happens when working with timeouts. For example:"
msgstr "실제로는 시간 초과 작업을 할 때 이런 일이 자주 발생합니다. 예를 들어:"

#: src/08_futures/07_cancellation.md:20
#, fuzzy
msgid "// Wrap the future with a `Timeout` set to expire in 10 milliseconds.\n"
msgstr "// 10밀리초 후에 만료되도록 설정된 'Timeout'으로 future를 래핑합니다."

#: src/08_futures/07_cancellation.md:23
#, fuzzy
msgid "\"Didn't receive a value within 10 ms\""
msgstr "\"10ms 이내에 값을 받지 못했습니다.\""

#: src/08_futures/07_cancellation.md:28
#, fuzzy
msgid ""
"When the timeout expires, the future returned by `http_call` will be "
"cancelled. Let's imagine that this is `http_call`'s body:"
msgstr ""
"제한 시간이 만료되면 `http_call`에 의해 반환된 future가 취소됩니다. 이것이 "
"`http_call`의 본문이라고 상상해 봅시다:"

#: src/08_futures/07_cancellation.md:41
#, fuzzy
msgid ""
"Each yield point becomes a **cancellation point**.  \n"
"`http_call` can't be preempted by the runtime, so it can only be discarded "
"after it has yielded control back to the executor via `.await`. This applies "
"recursively—e.g. `stream.write_all(&request)` is likely to have multiple "
"yield points in its implementation. It is perfectly possible to see "
"`http_call` pushing a _partial_ request before being cancelled, thus dropping "
"the connection and never finishing transmitting the body."
msgstr ""
"각 항복 지점은 **취소 지점**이 됩니다.  \n"
"`http_call`은 런타임에 의해 선점될 수 없으므로 `.await`를 통해 실행자에게 제어"
"권을 다시 넘겨준 후에만 폐기될 수 있습니다. 이는 재귀적으로 적용됩니다. "
"`stream.write_all(&request)`는 구현 시 여러 항복 지점을 가질 가능성이 높습니"
"다. `http_call`이 취소되기 전에 _partial_ 요청을 푸시하여 연결이 끊어지고 본"
"문 전송이 완료되지 않는 것을 볼 수 있습니다."

#: src/08_futures/07_cancellation.md:49
#, fuzzy
msgid "Clean up"
msgstr "정리하다"

#: src/08_futures/07_cancellation.md:51
#, fuzzy
msgid ""
"Rust's cancellation mechanism is quite powerful—it allows the caller to "
"cancel an ongoing task without needing any form of cooperation from the task "
"itself.  \n"
"At the same time, this can be quite dangerous. It may be desirable to perform "
"a **graceful cancellation**, to ensure that some clean-up tasks are performed "
"before aborting the operation."
msgstr ""
"Rust의 취소 메커니즘은 매우 강력합니다. 이를 통해 호출자는 작업 자체에서 어떤 "
"형태의 협력도 필요 없이 진행 중인 작업을 취소할 수 있습니다.  \n"
"동시에 이는 매우 위험할 수 있다. 작업을 중단하기 전에 일부 정리 작업이 수행되"
"도록 **정상적인 취소**를 수행하는 것이 바람직할 수 있습니다."

#: src/08_futures/07_cancellation.md:57
#, fuzzy
msgid "For example, consider this fictional API for a SQL transaction:"
msgstr "예를 들어 SQL 트랜잭션에 대한 다음 가상 API를 생각해 보세요."

#: src/08_futures/07_cancellation.md:73
#, fuzzy
msgid ""
"On cancellation, it'd be ideal to explicitly abort the pending transaction "
"rather than leaving it hanging. Rust, unfortunately, doesn't provide a bullet-"
"proof mechanism for this kind of **asynchronous** clean up operations."
msgstr ""
"취소 시 보류 중인 트랜잭션을 그대로 두는 것보다 명시적으로 중단하는 것이 이상"
"적입니다. 안타깝게도 Rust는 이러한 종류의 **비동기** 정리 작업에 대한 완벽한 "
"메커니즘을 제공하지 않습니다."

#: src/08_futures/07_cancellation.md:78
#, fuzzy
msgid ""
"The most common strategy is to rely on the `Drop` trait to schedule the "
"required clean-up work. This can be by:"
msgstr ""
"가장 일반적인 전략은 'Drop' 특성을 사용하여 필요한 정리 작업을 예약하는 것입니"
"다. 이는 다음과 같이 할 수 있습니다."

#: src/08_futures/07_cancellation.md:81
#, fuzzy
msgid "Spawning a new task on the runtime"
msgstr "런타임에 새 작업 생성"

#: src/08_futures/07_cancellation.md:82
#, fuzzy
msgid "Enqueueing a message on a channel"
msgstr "채널의 대기열에 메시지 추가"

#: src/08_futures/07_cancellation.md:83
#, fuzzy
msgid "Spawning a background thread"
msgstr "백그라운드 스레드 생성"

#: src/08_futures/07_cancellation.md:85
#, fuzzy
msgid "The optimal choice is contextual."
msgstr "최적의 선택은 상황에 따라 다릅니다."

#: src/08_futures/07_cancellation.md:87
#, fuzzy
msgid "Cancelling spawned tasks"
msgstr "생성된 작업 취소"

#: src/08_futures/07_cancellation.md:89
msgid ""
"When you spawn a task using `tokio::spawn`, you can no longer drop it; it "
"belongs to the runtime.  \n"
"Nonetheless, you can use its `JoinHandle` to cancel it if needed:"
msgstr ""

#: src/08_futures/07_cancellation.md:95
#, fuzzy
msgid "/* some async task */"
msgstr "/\\* 일부 비동기 작업 \\*/"

#: src/08_futures/07_cancellation.md:96
#, fuzzy
msgid "// Cancel the spawned task\n"
msgstr "// 생성된 작업 취소"

#: src/08_futures/07_cancellation.md:103
#, fuzzy
msgid ""
"Be extremely careful when using `tokio`'s `select!` macro to \"race\" two "
"different futures. Retrying the same task in a loop is dangerous unless you "
"can ensure **cancellation safety**. Check out [`select!`'s documentation]"
"(https://tokio.rs/tokio/tutorial/select) for more details.  \n"
"If you need to interleave two asynchronous streams of data (e.g. a socket and "
"a channel), prefer using [`StreamExt::merge`](https://docs.rs/tokio-stream/"
"latest/tokio_stream/trait.StreamExt.html#method.merge) instead."
msgstr ""
"두 개의 서로 다른 미래를 \"경쟁\"하기 위해 `tokio`의 `select!` 매크로를 사용"
"할 때는 매우 주의하십시오. **취소 안전**을 보장할 수 없다면 루프에서 동일한 작"
"업을 다시 시도하는 것은 위험합니다. 자세한 내용은 `select!`의 문서를 확인하세"
"요.  \n"
"두 개의 비동기 데이터 스트림(예: 소켓 및 채널)을 인터리브해야 하는 경우 "
"`StreamExt::merge`를 대신 사용하는 것이 좋습니다."

#: src/08_futures/07_cancellation.md:108
#, fuzzy
msgid ""
"Rather than \"abrupt\" cancellation, it can be preferable to rely on "
"[`CancellationToken`](https://docs.rs/tokio-util/latest/tokio_util/sync/"
"struct.CancellationToken.html)."
msgstr ""
"\"갑작스러운\" 취소보다는 'CancellationToken'을 사용하는 것이 더 나을 수 있습"
"니다."

#: src/08_futures/07_cancellation.md:113
msgid ""
"The exercise for this section is located in [`08_futures/07_cancellation`]"
"(https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/08_futures/07_cancellation)"
msgstr ""

#: src/08_futures/08_outro.md:3
#, fuzzy
msgid ""
"Rust's asynchronous model is quite powerful, but it does introduce additional "
"complexity. Take time to know your tools: dive deep into `tokio`'s "
"documentation and get familiar with its primitives to make the most out of it."
msgstr ""
"Rust의 비동기 모델은 매우 강력하지만 추가적인 복잡성을 초래합니다. 도구를 알아"
"가는 데 시간을 투자하세요. 'tokio'의 문서를 자세히 살펴보고 문서를 최대한 활용"
"하기 위해 기본 요소에 익숙해지세요."

#: src/08_futures/08_outro.md:7
#, fuzzy
msgid ""
"Keep in mind, as well, that there is ongoing work at the language and `std` "
"level to streamline and \"complete\" Rust's asynchronous story. You may "
"experience some rough edges in your day-to-day work due to some of these "
"missing pieces."
msgstr ""
"또한 Rust의 비동기 스토리를 간소화하고 \"완성\"하기 위해 언어 및 'std' 수준에"
"서 지속적인 작업이 진행 중이라는 점을 명심하세요. 이러한 누락된 부분으로 인해 "
"일상적인 작업에서 약간의 거친 부분이 발생할 수 있습니다."

#: src/08_futures/08_outro.md:11
#, fuzzy
msgid "A few recommendations for a mostly-pain-free async experience:"
msgstr "거의 고통 없는 비동기 환경을 위한 몇 가지 권장 사항:"

#: src/08_futures/08_outro.md:13
#, fuzzy
msgid ""
"**Pick a runtime and stick to it.**  \n"
"Some primitives (e.g. timers, I/O) are not portable across runtimes. Trying "
"to mix runtimes is likely to cause you pain. Trying to write code that's "
"runtime agnostic can significantly increase the complexity of your codebase. "
"Avoid it if you can."
msgstr ""
"**런타임을 선택하고 이를 고수하세요.**  \n"
"일부 기본 요소(예: 타이머, I/O)는 런타임 전반에 걸쳐 이식 가능하지 않습니다. "
"런타임을 혼합하려고 하면 문제가 발생할 수 있습니다. 런타임에 구애받지 않는 코"
"드를 작성하려고 하면 코드베이스의 복잡성이 크게 증가할 수 있습니다. 가능하다"
"면 피하세요."

#: src/08_futures/08_outro.md:18
#, fuzzy
msgid ""
"**There is no stable `Stream`/`AsyncIterator` interface yet.**  \n"
"An `AsyncIterator` is, conceptually, an iterator that yields new items "
"asynchronously. There is ongoing design work, but no consensus (yet). If "
"you're using `tokio`, refer to [`tokio_stream`](https://docs.rs/tokio-stream/"
"latest/tokio_stream/) as your go-to interface."
msgstr ""
"**안정적인 `Stream`/`AsyncIterator` 인터페이스는 아직 없습니다.**  \n"
"'AsyncIterator'는 개념적으로 새 항목을 비동기적으로 생성하는 반복자입니다. 디"
"자인 작업이 진행 중이지만 (아직) 합의가 이루어지지 않았습니다. `tokio`를 사용"
"하는 경우 이동 인터페이스로 `tokio_stream`을 참조하세요."

#: src/08_futures/08_outro.md:23
#, fuzzy
msgid ""
"**Be careful with buffering.**  \n"
"It is often the cause of subtle bugs. Check out [\"Barbara battles buffered "
"streams\"](https://rust-lang.github.io/wg-async/vision/submitted_stories/"
"status_quo/barbara_battles_buffered_streams.html) for more details."
msgstr ""
"**버퍼링에 주의하세요.**  \n"
"미묘한 버그의 원인이 되는 경우가 많습니다. 자세한 내용은 \"Barbara 전투 버퍼"
"링 스트림\"을 확인하세요."

#: src/08_futures/08_outro.md:27
#, fuzzy
msgid ""
"**There is no equivalent of scoped threads for asynchronous tasks**.  \n"
"Check out [\"The scoped task trilemma\"](https://without.boats/blog/the-"
"scoped-task-trilemma/) for more details."
msgstr ""
"**비동기 작업에는 범위가 지정된 스레드와 동등한 것이 없습니다**.  \n"
"자세한 내용은 \"범위가 지정된 작업 트릴레마\"를 확인하세요."

#: src/08_futures/08_outro.md:31
#, fuzzy
msgid ""
"Don't let these caveats scare you: asynchronous Rust is being used "
"effectively at _massive_ scale (e.g. AWS, Meta) to power foundational "
"services.  \n"
"You will have to master it if you're planning building networked applications "
"in Rust."
msgstr ""
"이러한 주의 사항에 겁먹지 마세요. 비동기식 Rust는 기본 서비스를 강화하기 위해 "
"_대규모_ 규모(예: AWS, Meta)에서 효과적으로 사용되고 있습니다.  \n"
"Rust로 네트워크 애플리케이션을 구축할 계획이라면 이를 마스터해야 합니다."

#: src/08_futures/08_outro.md:38
msgid ""
"The exercise for this section is located in [`08_futures/08_outro`](https://"
"github.com/mainmatter/100-exercises-to-learn-rust/tree/main/"
"exercises/08_futures/08_outro)"
msgstr ""

#: src/going_further.md:1
#, fuzzy
msgid "Epilogue"
msgstr "발문"

#: src/going_further.md:3
#, fuzzy
msgid ""
"Our tour of Rust ends here.  \n"
"It has been quite extensive, but by no means exhaustive: Rust is a language "
"with a large surface area, and an even larger ecosystem!  \n"
"Don't let this scare you, though: there's **no need to learn everything**. "
"You'll pick up whatever is necessary to be effective in the domain (backend, "
"embedded, CLIs, GUIs, etc.) **while working on your projects**."
msgstr ""
"Rust 투어는 여기서 끝납니다.  \n"
"상당히 광범위했지만 결코 철저하지는 않았습니다. Rust는 표면적이 넓고 생태계도 "
"훨씬 더 큰 언어입니다!  \n"
"하지만 겁먹지 마세요. **모든 것을 배울 필요는 없습니다**. **프로젝트 작업** 중"
"에 도메인(백엔드, 임베디드, CLI, GUI 등)에서 효율성을 높이는 데 필요한 모든 것"
"을 선택하게 됩니다."

#: src/going_further.md:10
#, fuzzy
msgid ""
"In the end, there are no shortcuts: if you want to get good at something, you "
"need to do it, over and over again. Throughout this course you wrote a fair "
"amount of Rust, enough to get the language and its syntax flowing under your "
"fingers. It'll take many more lines of code to feel it \"yours\", but that "
"moment will come without a doubt if you keep practicing."
msgstr ""
"결국 지름길은 없습니다. 어떤 일을 잘하고 싶다면 계속해서 그 일을 해야 합니다. "
"이 코스 전반에 걸쳐 여러분은 언어와 그 구문을 손가락으로 짚어볼 수 있을 만큼 "
"충분한 양의 Rust를 작성했습니다. \"자신의 것\"이라고 느끼려면 훨씬 더 많은 코"
"드 라인이 필요하지만, 계속 연습하면 그 순간은 의심할 여지 없이 찾아올 것입니"
"다."

#: src/going_further.md:18
#, fuzzy
msgid ""
"Let's close with some pointers to additional resources that you might find "
"useful as you move forward in your journey with Rust."
msgstr ""
"Rust와 함께하는 여정에서 앞으로 나아갈 때 유용할 수 있는 추가 리소스에 대한 "
"몇 가지 지침으로 마무리하겠습니다."

#: src/going_further.md:21
#, fuzzy
msgid "Exercises"
msgstr "수업 과정"

#: src/going_further.md:23
#, fuzzy
msgid ""
"You can find more exercises to practice Rust in the [`rustlings`](https://"
"github.com/rust-lang/rustlings) project and on [exercism.io](https://exercism."
"io)'s Rust track."
msgstr ""
"Rust를 연습하기 위한 더 많은 연습문제는 `rustlings` 프로젝트와 exercism.io의 "
"Rust 트랙에서 찾을 수 있습니다."

#: src/going_further.md:26
#, fuzzy
msgid "Introductory material"
msgstr "입문 자료"

#: src/going_further.md:28
msgid ""
"Check out [the Rust book](https://doc.rust-lang.org/book/title-page.html) and "
"[\"Programming Rust\"](https://www.oreilly.com/library/view/programming-"
"rust-2nd/9781492052586/) if you're looking for a different perspective on the "
"same concepts we covered throughout this course. You'll certainly learn "
"something new since they don't cover exactly the same topics; Rust has a lot "
"of surface area!"
msgstr ""

#: src/going_further.md:33
#, fuzzy
msgid "Advanced material"
msgstr "고급 소재"

#: src/going_further.md:35
#, fuzzy
msgid ""
"If you want to dive deeper into the language, refer to the [Rustonomicon]"
"(https://doc.rust-lang.org/nomicon/) and [\"Rust for Rustaceans\"](https://"
"nostarch.com/rust-rustaceans).  \n"
"The [\"Decrusted\" series](https://www.youtube.com/playlist?"
"list=PLqbS7AVVErFirH9armw8yXlE6dacF-A6z) is another excellent resource to "
"learn more about the internals of many of the most popular Rust libraries."
msgstr ""
"언어에 대해 더 깊이 알고 싶다면 Rustonomicon과 \"Rust for Rustaceans\"를 참조"
"하세요.  \n"
"\"Decrusted\" 시리즈는 가장 인기 있는 Rust 라이브러리의 내부에 대해 자세히 알"
"아볼 수 있는 또 다른 훌륭한 리소스입니다."

#: src/going_further.md:40
#, fuzzy
msgid "Domain-specific material"
msgstr "도메인별 자료"

#: src/going_further.md:42
#, fuzzy
msgid ""
"If you want to use Rust for backend development, check out [\"Zero to "
"Production in Rust\"](https://zero2prod.com).  \n"
"If you want to use Rust for embedded development, check out the [Embedded "
"Rust book](https://docs.rust-embedded.org/book/)."
msgstr ""
"백엔드 개발에 Rust를 사용하고 싶다면 \"Zero to Production in Rust\"를 확인하세"
"요.  \n"
"임베디드 개발에 Rust를 사용하고 싶다면 Embedded Rust 책을 확인해 보세요."

#: src/going_further.md:47
#, fuzzy
msgid "Masterclasses"
msgstr "마스터클래스"

#: src/going_further.md:49
#, fuzzy
msgid ""
"You can then find resources on key topics that cut across domains.  \n"
"For testing, check out [\"Advanced testing, going beyond the basics\"]"
"(https://github.com/mainmatter/rust-advanced-testing-workshop).  \n"
"For telemetry, check out [\"You can't fix what you can't see\"](https://"
"github.com/mainmatter/rust-telemetry-workshop)."
msgstr ""
"그런 다음 도메인 전반에 걸친 주요 주제에 대한 리소스를 찾을 수 있습니다.  \n"
"테스트에 대해서는 \"기본을 넘어서는 고급 테스트\"를 참고하세요.  \n"
"원격 측정의 경우 \"볼 수 없는 것은 고칠 수 없습니다\"를 확인하세요."

#~ msgid "The exercise for this section is located in `01_intro/00_welcome`"
#~ msgstr "이 섹션의 예제는 `01_intro/00_welcome`에 있습니다."

#~ msgid "The exercise for this section is located in `01_intro/01_syntax`"
#~ msgstr "이 섹션의 예제는 `01_intro/01_syntax`에 있습니다"

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `02_basic_calculator/00_intro`"
#~ msgstr "이 섹션의 연습은 `02_basic_calculator/00_intro`에 있습니다."

#, fuzzy
#~ msgid "The integer types section in the official Rust book"
#~ msgstr "공식 Rust 책의 정수 유형 섹션"

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`02_basic_calculator/01_integers`"
#~ msgstr "이 섹션의 연습은 `02_basic_calculator/01_integers`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`02_basic_calculator/02_variables`"
#~ msgstr "이 섹션의 연습은 `02_basic_calculator/02_variables`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`02_basic_calculator/03_if_else`"
#~ msgstr "이 섹션의 연습은 `02_basic_calculator/03_if_else`에 있습니다."

#, fuzzy
#~ msgid "The panic! macro documentation"
#~ msgstr "공황! 매크로 문서"

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `02_basic_calculator/04_panics`"
#~ msgstr "이 섹션의 연습은 `02_basic_calculator/04_panics`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`02_basic_calculator/05_factorial`"
#~ msgstr "이 섹션의 연습은 `02_basic_calculator/05_factorial`에 있습니다."

#, fuzzy
#~ msgid "`while` loop documentation"
#~ msgstr "`while` 루프 문서"

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `02_basic_calculator/06_while`"
#~ msgstr "이 섹션의 연습은 `02_basic_calculator/06_while`에 있습니다."

#, fuzzy
#~ msgid "`for` loop documentation"
#~ msgstr "`for` 루프 문서"

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `02_basic_calculator/07_for`"
#~ msgstr "이 섹션의 연습은 `02_basic_calculator/07_for`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`02_basic_calculator/08_overflow`"
#~ msgstr "이 섹션의 연습은 `02_basic_calculator/08_overflow`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`02_basic_calculator/09_saturating`"
#~ msgstr "이 섹션의 연습은 `02_basic_calculator/09_saturating`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`02_basic_calculator/10_as_casting`"
#~ msgstr "이 섹션의 연습은 `02_basic_calculator/10_as_casting`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `03_ticket_v1/00_intro`"
#~ msgstr "이 섹션의 연습은 `03_ticket_v1/00_intro`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `03_ticket_v1/01_struct`"
#~ msgstr "이 섹션의 연습은 `03_ticket_v1/01_struct`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `03_ticket_v1/02_validation`"
#~ msgstr "이 섹션의 연습은 `03_ticket_v1/02_validation`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `03_ticket_v1/03_modules`"
#~ msgstr "이 섹션의 연습은 `03_ticket_v1/03_modules`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `03_ticket_v1/04_visibility`"
#~ msgstr "이 섹션의 연습은 `03_ticket_v1/04_visibility`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `03_ticket_v1/05_encapsulation`"
#~ msgstr "이 섹션의 연습은 `03_ticket_v1/05_encapsulation`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `03_ticket_v1/06_ownership`"
#~ msgstr "이 섹션의 연습은 `03_ticket_v1/06_ownership`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `03_ticket_v1/07_setters`"
#~ msgstr "이 섹션의 연습은 `03_ticket_v1/07_setters`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `03_ticket_v1/08_stack`"
#~ msgstr "이 섹션의 연습은 `03_ticket_v1/08_stack`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `03_ticket_v1/09_heap`"
#~ msgstr "이 섹션의 연습은 `03_ticket_v1/09_heap`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`03_ticket_v1/10_references_in_memory`"
#~ msgstr "이 섹션의 연습은 `03_ticket_v1/10_references_in_memory`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `03_ticket_v1/11_destructor`"
#~ msgstr "이 섹션의 연습은 `03_ticket_v1/11_destructor`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `03_ticket_v1/12_outro`"
#~ msgstr "이 섹션의 연습은 `03_ticket_v1/12_outro`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `04_traits/00_intro`"
#~ msgstr "이 섹션의 연습은 `04_traits/00_intro`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `04_traits/01_trait`"
#~ msgstr "이 섹션의 연습은 `04_traits/01_trait`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `04_traits/02_orphan_rule`"
#~ msgstr "이 섹션의 연습은 `04_traits/02_orphan_rule`에 있습니다."

#, fuzzy
#~ msgid "`Add`"
#~ msgstr "`추가`"

#, fuzzy
#~ msgid "`Sub`"
#~ msgstr "`서브`"

#, fuzzy
#~ msgid "`Mul`"
#~ msgstr "'물'"

#, fuzzy
#~ msgid "`Div`"
#~ msgstr "`디브`"

#, fuzzy
#~ msgid "`Rem`"
#~ msgstr "'렘'"

#, fuzzy
#~ msgid "`PartialEq`"
#~ msgstr "`부분 방정식`"

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`04_traits/03_operator_overloading`"
#~ msgstr "이 섹션의 연습은 `04_traits/03_operator_overloading`에 있습니다."

#, fuzzy
#~ msgid "Proc macro workshop"
#~ msgstr "Proc 매크로 워크숍"

#, fuzzy
#~ msgid "The exercise for this section is located in `04_traits/04_derive`"
#~ msgstr "이 섹션의 연습은 `04_traits/04_derive`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `04_traits/05_trait_bounds`"
#~ msgstr "이 섹션의 연습은 `04_traits/05_trait_bounds`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `04_traits/06_str_slice`"
#~ msgstr "이 섹션의 연습은 `04_traits/06_str_slice`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `04_traits/07_deref`"
#~ msgstr "이 섹션의 연습은 `04_traits/07_deref`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `04_traits/08_sized`"
#~ msgstr "이 섹션의 연습은 `04_traits/08_size`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `04_traits/09_from`"
#~ msgstr "이 섹션의 연습은 `04_traits/09_from`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `04_traits/10_assoc_vs_generic`"
#~ msgstr "이 섹션의 연습은 `04_traits/10_assoc_vs_generic`에 있습니다."

#, fuzzy
#~ msgid "/\\* \\*/"
#~ msgstr "/\\* \\*/"

#, fuzzy
#~ msgid "The exercise for this section is located in `04_traits/11_clone`"
#~ msgstr "이 섹션의 연습은 `04_traits/11_clone`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `04_traits/12_copy`"
#~ msgstr "이 섹션의 연습은 `04_traits/12_copy`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `04_traits/13_drop`"
#~ msgstr "이 섹션의 연습은 `04_traits/13_drop`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `04_traits/14_outro`"
#~ msgstr "이 섹션의 연습은 `04_traits/14_outro`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `05_ticket_v2/00_intro`"
#~ msgstr "이 섹션의 연습은 `05_ticket_v2/00_intro`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `05_ticket_v2/01_enum`"
#~ msgstr "이 섹션의 연습은 `05_ticket_v2/01_enum`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `05_ticket_v2/02_match`"
#~ msgstr "이 섹션의 연습은 `05_ticket_v2/02_match`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`05_ticket_v2/03_variants_with_data`"
#~ msgstr "이 섹션의 연습은 `05_ticket_v2/03_variants_with_data`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `05_ticket_v2/04_if_let`"
#~ msgstr "이 섹션의 연습은 `05_ticket_v2/04_if_let`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `05_ticket_v2/05_nullability`"
#~ msgstr "이 섹션의 연습은 `05_ticket_v2/05_nullability`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `05_ticket_v2/06_fallibility`"
#~ msgstr "이 섹션의 연습은 `05_ticket_v2/06_fallibility`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `05_ticket_v2/07_unwrap`"
#~ msgstr "이 섹션의 연습은 `05_ticket_v2/07_unwrap`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `05_ticket_v2/08_error_enums`"
#~ msgstr "이 섹션의 연습은 `05_ticket_v2/08_error_enums`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `05_ticket_v2/09_error_trait`"
#~ msgstr "이 섹션의 연습은 `05_ticket_v2/09_error_trait`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `05_ticket_v2/10_packages`"
#~ msgstr "이 섹션의 연습은 `05_ticket_v2/10_packages`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `05_ticket_v2/11_dependencies`"
#~ msgstr "이 섹션의 연습은 `05_ticket_v2/11_dependent`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `05_ticket_v2/12_thiserror`"
#~ msgstr "이 섹션의 연습은 `05_ticket_v2/12_thiserror`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `05_ticket_v2/13_try_from`"
#~ msgstr "이 섹션의 연습은 `05_ticket_v2/13_try_from`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `05_ticket_v2/14_source`"
#~ msgstr "이 섹션의 연습은 `05_ticket_v2/14_source`에 있습니다."

#, fuzzy
#~ msgid "Parse, don't validate"
#~ msgstr "구문 분석하고 유효성을 검사하지 않음"

#, fuzzy
#~ msgid "Using types to guarantee domain invariants"
#~ msgstr "유형을 사용하여 도메인 불변성 보장"

#, fuzzy
#~ msgid "The exercise for this section is located in `05_ticket_v2/15_outro`"
#~ msgstr "이 섹션의 연습은 `05_ticket_v2/15_outro`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `06_ticket_management/00_intro`"
#~ msgstr "이 섹션의 연습은 `06_ticket_management/00_intro`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/01_arrays`"
#~ msgstr "이 섹션의 연습은 `06_ticket_management/01_arrays`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `06_ticket_management/02_vec`"
#~ msgstr "이 섹션의 연습은 `06_ticket_management/02_vec`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/03_resizing`"
#~ msgstr "이 섹션의 연습은 `06_ticket_management/03_resizing`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/04_iterators`"
#~ msgstr "이 섹션의 연습은 `06_ticket_management/04_iterators`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `06_ticket_management/05_iter`"
#~ msgstr "이 섹션의 연습은 `06_ticket_management/05_iter`에 있습니다."

#, fuzzy
#~ msgid "std::vec::Vec::iter"
#~ msgstr "표준::vec::Vec::iter"

#, fuzzy
#~ msgid "std::slice::Iter"
#~ msgstr "표준::슬라이스::Iter"

#, fuzzy
#~ msgid "Lifetime elision rules"
#~ msgstr "평생 제거 규칙"

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/06_lifetimes`"
#~ msgstr "이 섹션의 연습은 `06_ticket_management/06_lifetimes`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/07_combinators`"
#~ msgstr "이 섹션의 연습은 `06_ticket_management/07_combinators`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/08_impl_trait`"
#~ msgstr "이 섹션의 연습은 `06_ticket_management/08_impl_trait`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/09_impl_trait_2`"
#~ msgstr "이 섹션의 연습은 `06_ticket_management/09_impl_trait_2`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/10_slices`"
#~ msgstr "이 섹션의 연습은 `06_ticket_management/10_slices`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/11_mutable_slices`"
#~ msgstr ""
#~ "이 섹션의 연습은 `06_ticket_management/11_mutable_slices`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/12_two_states`"
#~ msgstr "이 섹션의 연습은 `06_ticket_management/12_two_states`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `06_ticket_management/13_index`"
#~ msgstr "이 섹션의 연습은 `06_ticket_management/13_index`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/14_index_mut`"
#~ msgstr "이 섹션의 연습은 `06_ticket_management/14_index_mut`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/15_hashmap`"
#~ msgstr "이 섹션의 연습은 `06_ticket_management/15_hashmap`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`06_ticket_management/16_btreemap`"
#~ msgstr "이 섹션의 연습은 `06_ticket_management/16_btreemap`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `07_threads/00_intro`"
#~ msgstr "이 섹션의 연습은 `07_threads/00_intro`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `07_threads/01_threads`"
#~ msgstr "이 섹션의 연습은 `07_threads/01_threads`에 있습니다."

#, fuzzy
#~ msgid "// \\[..\\]"
#~ msgstr "// \\[..\\]"

#, fuzzy
#~ msgid "The data segment"
#~ msgstr "데이터 세그먼트"

#, fuzzy
#~ msgid "The exercise for this section is located in `07_threads/02_static`"
#~ msgstr "이 섹션의 연습은 `07_threads/02_static`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `07_threads/03_leak`"
#~ msgstr "이 섹션의 연습은 `07_threads/03_leak`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `07_threads/04_scoped_threads`"
#~ msgstr "이 섹션의 연습은 `07_threads/04_scoped_threads`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `07_threads/05_channels`"
#~ msgstr "이 섹션의 연습은 `07_threads/05_channels`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`07_threads/06_interior_mutability`"
#~ msgstr "이 섹션의 연습은 `07_threads/06_interior_mutability`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `07_threads/07_ack`"
#~ msgstr "이 섹션의 연습은 `07_threads/07_ack`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `07_threads/08_client`"
#~ msgstr "이 섹션의 연습은 `07_threads/08_client`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `07_threads/09_bounded`"
#~ msgstr "이 섹션의 연습은 `07_threads/09_bounded`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `07_threads/10_patch`"
#~ msgstr "이 섹션의 연습은 `07_threads/10_patch`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `07_threads/11_locks`"
#~ msgstr "이 섹션의 연습은 `07_threads/11_locks`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `07_threads/12_rw_lock`"
#~ msgstr "이 섹션의 연습은 `07_threads/12_rw_lock`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`07_threads/13_without_channels`"
#~ msgstr "이 섹션의 연습은 `07_threads/13_without_channels`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `07_threads/14_sync`"
#~ msgstr "이 섹션의 연습은 `07_threads/14_sync`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `08_futures/00_intro`"
#~ msgstr "이 섹션의 연습은 `08_futures/00_intro`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `08_futures/01_async_fn`"
#~ msgstr "이 섹션의 연습은 `08_futures/01_async_fn`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `08_futures/02_spawn`"
#~ msgstr "이 섹션의 연습은 `08_futures/02_spawn`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `08_futures/03_runtime`"
#~ msgstr "이 섹션의 연습은 `08_futures/03_runtime`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `08_futures/04_future`"
#~ msgstr "이 섹션의 연습은 `08_futures/04_future`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `08_futures/05_blocking`"
#~ msgstr "이 섹션의 연습은 `08_futures/05_blocking`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in "
#~ "`08_futures/06_async_aware_primitives`"
#~ msgstr "이 섹션의 연습은 `08_futures/06_async_aware_primitives`에 있습니다."

#, fuzzy
#~ msgid ""
#~ "The exercise for this section is located in `08_futures/07_cancellation`"
#~ msgstr "이 섹션의 연습은 `08_futures/07_cancellation`에 있습니다."

#, fuzzy
#~ msgid "The exercise for this section is located in `08_futures/08_outro`"
#~ msgstr "이 섹션의 연습은 `08_futures/08_outro`에 있습니다."
